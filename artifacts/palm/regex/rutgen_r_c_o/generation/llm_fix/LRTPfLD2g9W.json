{
  "name": "regex_syntax::hir::translate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre",
  "name_with_impl": "regex_syntax::hir::translate::{impl#4}::visit_pre",
  "mod_info": {
    "name": "hir::translate",
    "loc": "regex-syntax/src/hir/mod.rs:29:1:29:19"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/translate.rs:253:5:281:6",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Concat(ref x) or Ast::Concat(_) is true\n",
        "// constraint: *ast matches Ast::Concat(ref x) is true\n",
        "// constraint: x.asts.is_empty() is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Concat(ref x) where x.asts is an empty vector: []\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let concat_ast = ast::Concat {",
                "        span: Span::new(0, 0),",
                "        asts: vec![],",
                "    };",
                "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                "    let result = translator.visit_pre(&Ast::Concat(concat_ast));",
                "}"
              ],
              "oracles": [
                [
                  "    let concat_ast = ast::Concat { span: Span::new(0, 0), asts: vec![] };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Concat(concat_ast));",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let concat_ast = ast::Concat {",
                  "        span: Span::new(0, 0),",
                  "        asts: vec![],",
                  "    };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast = ast::Concat { span: Span::new(0, 0), asts: vec![] };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Concat(concat_ast));",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         span: Span::new(0, 0),\n     |               ^^^^^^^^^ -  - expected `Position`, found integer\n     |                         |\n     |                         expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2547 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2549:42\n     |\n2549 |     let concat_ast = ast::Concat { span: Span::new(0, 0), asts: vec![] };\n     |                                          ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                                    |\n     |                                                    expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2550 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alternation_ast = ast::Alternation {",
                "        span: Span::new(0, 0),",
                "        asts: vec![],",
                "    };",
                "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                "    let result = translator.visit_pre(&Ast::Alternation(alternation_ast));",
                "}"
              ],
              "oracles": [
                [
                  "    let alternation_ast = ast::Alternation { span: Span::new(0, 0), asts: vec![] };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alternation_ast = ast::Alternation {",
                  "        span: Span::new(0, 0),",
                  "        asts: vec![],",
                  "    };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    let alternation_ast = ast::Alternation { span: Span::new(0, 0), asts: vec![] };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         span: Span::new(0, 0),\n     |               ^^^^^^^^^ -  - expected `Position`, found integer\n     |                         |\n     |                         expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2547 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let alternation_ast = ast::Alternation { span: Span::new(0, 0), asts: vec![] };\n     |                                                    ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                                              |\n     |                                                              expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2550 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let group_ast = ast::Group {",
                "        span: Span::new(0, 0),",
                "        kind: GroupKind::NonCapturing(Flags::default()),",
                "        ast: Box::new(Ast::Empty(Span::new(0, 0))),",
                "    };",
                "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                "    let result = translator.visit_pre(&Ast::Group(group_ast));",
                "}"
              ],
              "oracles": [
                [
                  "    let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::new(0, 0))), };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Group(group_ast));",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::new(0, 0))), };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Group(group_ast));",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::new(0, 0))), };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Group(group_ast));",
                  "    assert!(matches!(translator.trans().stack.borrow()[0], HirFrame::Group { old_flags: Some(_) }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let group_ast = ast::Group {",
                  "        span: Span::new(0, 0),",
                  "        kind: GroupKind::NonCapturing(Flags::default()),",
                  "        ast: Box::new(Ast::Empty(Span::new(0, 0))),",
                  "    };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Group(group_ast));",
                  "    let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::new(0, 0))), };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Group(group_ast));",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let group_ast = ast::Group {",
                  "        span: Span::new(0, 0),",
                  "        kind: GroupKind::NonCapturing(Flags::default()),",
                  "        ast: Box::new(Ast::Empty(Span::new(0, 0))),",
                  "    };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Group(group_ast));",
                  "    let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::new(0, 0))), };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Group(group_ast));",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let group_ast = ast::Group {",
                  "        span: Span::new(0, 0),",
                  "        kind: GroupKind::NonCapturing(Flags::default()),",
                  "        ast: Box::new(Ast::Empty(Span::new(0, 0))),",
                  "    };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Group(group_ast));",
                  "    let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::new(0, 0))), };",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result = translator.visit_pre(&Ast::Group(group_ast));",
                  "    assert!(matches!(translator.trans().stack.borrow()[0], HirFrame::Group { old_flags: Some(_) }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2545:15\n     |\n2545 |         kind: GroupKind::NonCapturing(Flags::default()),\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2550:63\n     |\n2550 |     let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::n...\n     |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         span: Span::new(0, 0),\n     |               ^^^^^^^^^ -  - expected `Position`, found integer\n     |                         |\n     |                         expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2546:34\n     |\n2546 |         ast: Box::new(Ast::Empty(Span::new(0, 0))),\n     |                                  ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                            |\n     |                                            expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2550:40\n     |\n2550 |     let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::n...\n     |                                        ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                                  |\n     |                                                  expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2550:131\n     |\n2550 | ...ags::default()), ast: Box::new(Ast::Empty(Span::new(0, 0))), };\n     |                                              ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                                        |\n     |                                                        expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2545:15\n     |\n2545 |         kind: GroupKind::NonCapturing(Flags::default()),\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2550:63\n     |\n2550 |     let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::n...\n     |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         span: Span::new(0, 0),\n     |               ^^^^^^^^^ -  - expected `Position`, found integer\n     |                         |\n     |                         expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2546:34\n     |\n2546 |         ast: Box::new(Ast::Empty(Span::new(0, 0))),\n     |                                  ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                            |\n     |                                            expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2550:40\n     |\n2550 |     let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::n...\n     |                                        ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                                  |\n     |                                                  expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2550:131\n     |\n2550 | ...ags::default()), ast: Box::new(Ast::Empty(Span::new(0, 0))), };\n     |                                              ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                                        |\n     |                                                        expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2545:15\n     |\n2545 |         kind: GroupKind::NonCapturing(Flags::default()),\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2550:63\n     |\n2550 |     let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::n...\n     |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         span: Span::new(0, 0),\n     |               ^^^^^^^^^ -  - expected `Position`, found integer\n     |                         |\n     |                         expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2546:34\n     |\n2546 |         ast: Box::new(Ast::Empty(Span::new(0, 0))),\n     |                                  ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                            |\n     |                                            expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2550:40\n     |\n2550 |     let group_ast = ast::Group { span: Span::new(0, 0), kind: GroupKind::NonCapturing(Flags::default()), ast: Box::new(Ast::Empty(Span::n...\n     |                                        ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                                  |\n     |                                                  expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0308]: arguments to this function are incorrect\n    --> regex-syntax/src/hir/translate.rs:2550:131\n     |\n2550 | ...ags::default()), ast: Box::new(Ast::Empty(Span::new(0, 0))), };\n     |                                              ^^^^^^^^^ -  - expected `Position`, found integer\n     |                                                        |\n     |                                                        expected `Position`, found integer\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:396:12\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |            ^^^ ---------------  -------------\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                "    let class_ast = ast::Class(bracketed_class_ast);",
                "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                "    // Set flags to unicode before visiting",
                "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                "}"
              ],
              "oracles": [
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    assert_eq!(translator.trans.stack.borrow().len(), 1);"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    assert!(matches!(translator.trans.stack.borrow()[0], HirFrame::ClassUnicode(_)));"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    assert!(result2.is_ok());"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    assert_eq!(translator2.trans.stack.borrow().len(), 1);"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    assert!(matches!(translator2.trans.stack.borrow()[0], HirFrame::ClassBytes(_)));"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    assert!(result3.is_ok());"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    assert_eq!(translator3.trans.stack.borrow().len(), 1);"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    assert!(matches!(translator3.trans.stack.borrow()[0], HirFrame::Group { .. }));"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    assert!(result4.is_ok());"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    assert_eq!(translator4.trans.stack.borrow().len(), 0);  // should not push anything"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    assert!(result5.is_ok());"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    assert_eq!(translator5.trans.stack.borrow().len(), 1);"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    assert!(matches!(translator5.trans.stack.borrow()[0], HirFrame::Concat));"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    let alternation_ast = ast::Alternation { asts: vec![] };  // empty case",
                  "    let mut translator6 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result6 = translator6.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    assert!(result6.is_ok());"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    let alternation_ast = ast::Alternation { asts: vec![] };  // empty case",
                  "    let mut translator6 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result6 = translator6.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    assert_eq!(translator6.trans.stack.borrow().len(), 0);  // should not push anything"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    let alternation_ast = ast::Alternation { asts: vec![] };  // empty case",
                  "    let mut translator6 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result6 = translator6.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    let alternation_ast_non_empty = ast::Alternation { asts: vec![/* some other ast */] };",
                  "    let mut translator7 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result7 = translator7.visit_pre(&Ast::Alternation(alternation_ast_non_empty));",
                  "    assert!(result7.is_ok());"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    let alternation_ast = ast::Alternation { asts: vec![] };  // empty case",
                  "    let mut translator6 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result6 = translator6.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    let alternation_ast_non_empty = ast::Alternation { asts: vec![/* some other ast */] };",
                  "    let mut translator7 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result7 = translator7.visit_pre(&Ast::Alternation(alternation_ast_non_empty));",
                  "    assert_eq!(translator7.trans.stack.borrow().len(), 1);"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    let alternation_ast = ast::Alternation { asts: vec![] };  // empty case",
                  "    let mut translator6 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result6 = translator6.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    let alternation_ast_non_empty = ast::Alternation { asts: vec![/* some other ast */] };",
                  "    let mut translator7 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result7 = translator7.visit_pre(&Ast::Alternation(alternation_ast_non_empty));",
                  "    assert!(matches!(translator7.trans.stack.borrow()[0], HirFrame::Alternation));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    assert_eq!(translator.trans.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    assert!(matches!(translator.trans.stack.borrow()[0], HirFrame::ClassUnicode(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    assert!(result2.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    assert_eq!(translator2.trans.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    assert!(matches!(translator2.trans.stack.borrow()[0], HirFrame::ClassBytes(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::new(), \"\");  ",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    assert!(result3.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    assert_eq!(translator3.trans.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::new(), \"\");  ",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    assert!(matches!(translator3.trans.stack.borrow()[0], HirFrame::Group { .. }));",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::new(), \"\");  ",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    assert!(result4.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::new(), \"\");  ",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "        let mut translator4 = TranslatorI::new(&Translator::new(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    assert_eq!(translator4.trans.stack.borrow().len(), 0);  // should not push anything",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    assert!(result5.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::new(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::new(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    assert_eq!(translator5.trans.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::new(), \"\");  ",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::new(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    assert!(matches!(translator5.trans.stack.borrow()[0], HirFrame::Concat));",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::new(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::new(), \"\");  ",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    let alternation_ast = ast::Alternation { asts: vec![] };  // empty case",
                  "    let mut translator6 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result6 = translator6.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    assert!(result6.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    let alternation_ast = ast::Alternation { asts: vec![] };  // empty case",
                  "    let mut translator6 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result6 = translator6.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    assert_eq!(translator6.trans.stack.borrow().len(), 0);  // should not push anything",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    let alternation_ast = ast::Alternation { asts: vec![] };  // empty case",
                  "    let mut translator6 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result6 = translator6.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    let alternation_ast_non_empty = ast::Alternation { asts: vec![/* some other ast */] };",
                  "    let mut translator7 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result7 = translator7.visit_pre(&Ast::Alternation(alternation_ast_non_empty));",
                  "    assert!(result7.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    let alternation_ast = ast::Alternation { asts: vec![] };  // empty case",
                  "    let mut translator6 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result6 = translator6.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    let alternation_ast_non_empty = ast::Alternation { asts: vec![/* some other ast */] };",
                  "    let mut translator7 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result7 = translator7.visit_pre(&Ast::Alternation(alternation_ast_non_empty));",
                  "    assert_eq!(translator7.trans.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast2 = ast::Class(bracketed_class_ast2);",
                  "    let mut translator2 = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator2.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result2 = translator2.visit_pre(&Ast::Class(class_ast2));",
                  "    let group_ast = ast::Group { /* initialize as required */ };",
                  "    let mut translator3 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result3 = translator3.visit_pre(&Ast::Group(group_ast));",
                  "    let concat_ast = ast::Concat { asts: vec![] };  // empty case",
                  "    let mut translator4 = TranslatorI::new(&Translator::new(), \"\");",
                  "    let result4 = translator4.visit_pre(&Ast::Concat(concat_ast));",
                  "    let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };",
                  "    let mut translator5 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result5 = translator5.visit_pre(&Ast::Concat(concat_ast_non_empty));",
                  "    let alternation_ast = ast::Alternation { asts: vec![] };  // empty case",
                  "    let mut translator6 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result6 = translator6.visit_pre(&Ast::Alternation(alternation_ast));",
                  "    let alternation_ast_non_empty = ast::Alternation { asts: vec![/* some other ast */] };",
                  "    let mut translator7 = TranslatorI::new(&Translator::default(), \"\");",
                  "    let result7 = translator7.visit_pre(&Ast::Alternation(alternation_ast_non_empty));",
                  "    assert!(matches!(translator7.trans.stack.borrow()[0], HirFrame::Alternation));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2562:22\n     |\n2562 |     let concat_ast = ast::Concat { asts: vec![] };  // empty case\n     |                      ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2563 |     let mut translator4 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2562:22\n     |\n2562 |     let concat_ast = ast::Concat { asts: vec![] };  // empty case\n     |                      ^^^^^^^^^^^ missing `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2562:22\n     |\n2562 |     let concat_ast = ast::Concat { asts: vec![] };  // empty case\n     |                      ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2563 |     let mut translator4 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };\n     |                                ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2566 |     let mut translator5 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2562:22\n     |\n2562 |     let concat_ast = ast::Concat { asts: vec![] };  // empty case\n     |                      ^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };\n     |                                ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2566 |     let mut translator5 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2562:22\n     |\n2562 |     let concat_ast = ast::Concat { asts: vec![] };  // empty case\n     |                      ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2563 |     let mut translator4 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };\n     |                                ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2566 |     let mut translator5 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2562:22\n     |\n2562 |     let concat_ast = ast::Concat { asts: vec![] };  // empty case\n     |                      ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2563 |     let mut translator4 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };\n     |                                ^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `span` in initializer of `ast::Alternation`\n    --> regex-syntax/src/hir/translate.rs:2568:27\n     |\n2568 |     let alternation_ast = ast::Alternation { asts: vec![] };  // empty case\n     |                           ^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2569 |     let mut translator6 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2562:22\n     |\n2562 |     let concat_ast = ast::Concat { asts: vec![] };  // empty case\n     |                      ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2563 |     let mut translator4 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };\n     |                                ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2566 |     let mut translator5 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Alternation`\n    --> regex-syntax/src/hir/translate.rs:2568:27\n     |\n2568 |     let alternation_ast = ast::Alternation { asts: vec![] };  // empty case\n     |                           ^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2569 |     let mut translator6 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2562:22\n     |\n2562 |     let concat_ast = ast::Concat { asts: vec![] };  // empty case\n     |                      ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2563 |     let mut translator4 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };\n     |                                ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2566 |     let mut translator5 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Alternation`\n    --> regex-syntax/src/hir/translate.rs:2568:27\n     |\n2568 |     let alternation_ast = ast::Alternation { asts: vec![] };  // empty case\n     |                           ^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2569 |     let mut translator6 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Alternation`\n    --> regex-syntax/src/hir/translate.rs:2571:37\n     |\n2571 |     let alternation_ast_non_empty = ast::Alternation { asts: vec![/* some other ast */] };\n     |                                     ^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2572 |     let mut translator7 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2562:22\n     |\n2562 |     let concat_ast = ast::Concat { asts: vec![] };  // empty case\n     |                      ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2563 |     let mut translator4 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };\n     |                                ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2566 |     let mut translator5 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Alternation`\n    --> regex-syntax/src/hir/translate.rs:2568:27\n     |\n2568 |     let alternation_ast = ast::Alternation { asts: vec![] };  // empty case\n     |                           ^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2569 |     let mut translator6 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Alternation`\n    --> regex-syntax/src/hir/translate.rs:2571:37\n     |\n2571 |     let alternation_ast_non_empty = ast::Alternation { asts: vec![/* some other ast */] };\n     |                                     ^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2572 |     let mut translator7 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2555:22\n     |\n2555 |     let class_ast2 = ast::Class(bracketed_class_ast2);\n     |                      ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2555 |     let class_ast2 = ast::Class::Bracketed(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Perl(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~\n2555 |     let class_ast2 = ast::Class::Unicode(bracketed_class_ast2);\n     |                      ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2555 -     let class_ast2 = ast::Class(bracketed_class_ast2);\n2555 +     let class_ast2 = Class(bracketed_class_ast2);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:54\n     |\n2554 |     let bracketed_class_ast2 = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2556 |     let mut translator2 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let group_ast = ast::Group { /* initialize as required */ };\n     |                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator3 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2562:22\n     |\n2562 |     let concat_ast = ast::Concat { asts: vec![] };  // empty case\n     |                      ^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `span` in initializer of `ast::Concat`\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let concat_ast_non_empty = ast::Concat { asts: vec![/* some other ast */] };\n     |                                ^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2566 |     let mut translator5 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Alternation`\n    --> regex-syntax/src/hir/translate.rs:2568:27\n     |\n2568 |     let alternation_ast = ast::Alternation { asts: vec![] };  // empty case\n     |                           ^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2569 |     let mut translator6 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing field `span` in initializer of `ast::Alternation`\n    --> regex-syntax/src/hir/translate.rs:2571:37\n     |\n2571 |     let alternation_ast_non_empty = ast::Alternation { asts: vec![/* some other ast */] };\n     |                                     ^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:57\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2572 |     let mut translator7 = TranslatorI::new(&Translator::default(), \"\");\n     |                                                         ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                "    let class_ast = ast::Class(bracketed_class_ast);",
                "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                "    // Set flags to not unicode before visiting",
                "    translator.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                "}"
              ],
              "oracles": [
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    assert_eq!(translator.trans.stack.borrow().last(), Some(&HirFrame::ClassBytes(ClassBytes::empty())));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::new(), \"\");",
                  "    // Set flags to not unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    // Set flags to not unicode before visiting",
                  "    translator.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });",
                  "    let class_ast = ast::Class(bracketed_class_ast);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.trans.flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let result = translator.visit_pre(&Ast::Class(class_ast));",
                  "    assert_eq!(translator.trans.stack.borrow().last(), Some(&HirFrame::ClassBytes(ClassBytes::empty())));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2544 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2544 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2544 -     let class_ast = ast::Class(bracketed_class_ast);\n2544 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found enum `ast::Class`\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |     let class_ast = ast::Class(bracketed_class_ast);\n     |                     ^^^^^^^^^^\n     |\nnote: the enum is defined here\n    --> regex-syntax/src/ast/mod.rs:715:1\n     |\n715  | / pub enum Class {\n716  | |     /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n717  | |     Unicode(ClassUnicode),\n718  | |     /// A perl character class, e.g., `\\d` or `\\W`.\n...    |\n723  | |     Bracketed(ClassBracketed),\n724  | | }\n     | |_^\nhelp: try to construct one of the enum's variants\n     |\n2550 |     let class_ast = ast::Class::Bracketed(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Perl(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~\n2550 |     let class_ast = ast::Class::Unicode(bracketed_class_ast);\n     |                     ~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n2535 +    use hir::HirKind::Class;\n     |\n2535 +    use hir::translate::Ast::Class;\n     |\nhelp: if you import `Class`, refer to it directly\n     |\n2550 -     let class_ast = ast::Class(bracketed_class_ast);\n2550 +     let class_ast = Class(bracketed_class_ast);\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2554:83\n     |\n2554 |     assert_eq!(translator.trans.stack.borrow().last(), Some(&HirFrame::ClassBytes(ClassBytes::empty())));\n     |                                                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2543:53\n     |\n2543 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     let bracketed_class_ast = ast::Class::Bracketed(ast::ClassBracketed { /* initialize as required */ });\n     |                                                     ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<&translate::HirFrame>`\n    --> regex-syntax/src/hir/translate.rs:2554:5\n     |\n2554 |     assert_eq!(translator.trans.stack.borrow().last(), Some(&HirFrame::ClassBytes(ClassBytes::empty())));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     Option<&translate::HirFrame>\n     |     Option<&translate::HirFrame>\n     |\nnote: an implementation of `PartialEq` might be missing for `translate::HirFrame`\n    --> regex-syntax/src/hir/translate.rs:154:1\n     |\n154  | enum HirFrame {\n     | ^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `translate::HirFrame` with `#[derive(PartialEq)]`\n     |\n154  + #[derive(PartialEq)]\n155  | enum HirFrame {\n     |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0369, E0423, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Concat(ref x) or Ast::Concat(_) is true\n",
        "// constraint: *ast matches Ast::Concat(ref x) is true\n",
        "// constraint: x.asts.is_empty() is false\n",
        "// constraint: *ast matches Ast::Concat(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Concat(ref x) where x.asts has a non-empty vector of length 1 to N\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span::default(),",
                "        asts: vec![Ast::Literal(Literal::default())],",
                "    });",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "    translator_i.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert_eq!(trans.stack.borrow().len(), 1);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert!(matches!(trans.stack.borrow()[0], HirFrame::Concat));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::default())],",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert_eq!(trans.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::default())],",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert!(matches!(trans.stack.borrow()[0], HirFrame::Concat));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:27\n     |\n2549 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |         asts: vec![Ast::Literal(Literal::default())],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:27\n     |\n2561 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2563:29\n     |\n2563 |     asts: vec![Ast::Literal(Literal::default())],\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:17\n     |\n2562 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:27\n     |\n2549 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |         asts: vec![Ast::Literal(Literal::default())],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:27\n     |\n2561 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2563:29\n     |\n2563 |     asts: vec![Ast::Literal(Literal::default())],\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:17\n     |\n2562 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span::default(),",
                "        asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())],",
                "    });",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "    translator_i.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert_eq!(trans.stack.borrow().len(), 1);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert!(matches!(trans.stack.borrow().last(), Some(HirFrame::Concat)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())],",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert_eq!(trans.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())],",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert!(matches!(trans.stack.borrow().last(), Some(HirFrame::Concat)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:27\n     |\n2549 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |         asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2557:83\n     |\n2557 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });\n     |                                                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:69\n     |\n2551 |         asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())],\n     |                                                                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });\n     |                                                ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:119\n     |\n2557 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });\n     |                                                                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:27\n     |\n2549 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |         asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2557:83\n     |\n2557 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });\n     |                                                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:69\n     |\n2551 |         asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())],\n     |                                                                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });\n     |                                                ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:119\n     |\n2557 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Dot(Span::default())] });\n     |                                                                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span::default(),",
                "        asts: vec![",
                "            Ast::Literal(Literal::default()),",
                "            Ast::Dot(Span::default()),",
                "            Ast::Class(Class::Bracketed(ClassBracketed::default())),",
                "        ],",
                "    });",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "    translator_i.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::default()),",
                  "    Ast::Dot(Span::default()),",
                  "    Ast::Class(Class::Bracketed(ClassBracketed::default())),",
                  "    ],",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::default()),",
                  "    Ast::Dot(Span::default()),",
                  "    Ast::Class(Class::Bracketed(ClassBracketed::default())),",
                  "    ],",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert!(matches!(translator_i.trans().stack.borrow()[0], HirFrame::Concat));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::default()),",
                  "            Ast::Dot(Span::default()),",
                  "            Ast::Class(Class::Bracketed(ClassBracketed::default())),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::default()),",
                  "    Ast::Dot(Span::default()),",
                  "    Ast::Class(Class::Bracketed(ClassBracketed::default())),",
                  "    ],",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            use ast::Literal;  ",
                  "            Ast::Dot(Span::default()),",
                  "            Ast::Class(Class::Bracketed(ClassBracketed::default())),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::default()),",
                  "    Ast::Dot(Span::default()),",
                  "    Ast::Class(Class::Bracketed(ClassBracketed::default())),",
                  "    ],",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert!(matches!(translator_i.trans().stack.borrow()[0], HirFrame::Concat));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:27\n     |\n2549 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2552:26\n     |\n2552 |             Ast::Literal(Literal::default()),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2554:24\n     |\n2554 |             Ast::Class(Class::Bracketed(ClassBracketed::default())),\n     |                        ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |             Ast::Class(Class::Bracketed(ClassBracketed::default())),\n     |                                         ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:27\n     |\n2565 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2568:18\n     |\n2568 |     Ast::Literal(Literal::default()),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2570:16\n     |\n2570 |     Ast::Class(Class::Bracketed(ClassBracketed::default())),\n     |                ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2570:33\n     |\n2570 |     Ast::Class(Class::Bracketed(ClassBracketed::default())),\n     |                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:28\n     |\n2553 |             Ast::Dot(Span::default()),\n     |                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:17\n     |\n2566 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:20\n     |\n2569 |     Ast::Dot(Span::default()),\n     |                    ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: no rules expected the token `use`\n    --> regex-syntax/src/hir/translate.rs:2552:13\n     |\n2552 |             use ast::Literal;  \n     |             ^^^ no rules expected this token in macro call\n     |\n     = note: while trying to match end of macro\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:27\n     |\n2549 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:27\n     |\n2565 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2568:18\n     |\n2568 |     Ast::Literal(Literal::default()),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2570:16\n     |\n2570 |     Ast::Class(Class::Bracketed(ClassBracketed::default())),\n     |                ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2570:33\n     |\n2570 |     Ast::Class(Class::Bracketed(ClassBracketed::default())),\n     |                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:17\n     |\n2566 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:20\n     |\n2569 |     Ast::Dot(Span::default()),\n     |                    ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Alternation(ref x) or Ast::Alternation(_) is true\n",
        "// constraint: *ast matches Ast::Alternation(ref x) is true\n",
        "// constraint: x.asts.is_empty() is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Alternation(Ast::Alternation { span: Span::default(), asts: vec![] })\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test_pattern\";",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    let empty_alternation = Ast::Alternation(Alternation {",
                "        span: Span::default(),",
                "        asts: vec![],",
                "    });",
                "    let result = translator_i.visit_pre(&empty_alternation);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let empty_alternation = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![],",
                  "    });",
                  "    let result = translator_i.visit_pre(&empty_alternation);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let empty_alternation = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![],",
                  "    });",
                  "    let result = translator_i.visit_pre(&empty_alternation);",
                  "    assert!(translator_i.trans().stack.borrow().len() == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let empty_alternation = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![],",
                  "    });",
                  "    let result = translator_i.visit_pre(&empty_alternation);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let empty_alternation = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![],",
                  "    });",
                  "    let result = translator_i.visit_pre(&empty_alternation);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let empty_alternation = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![],",
                  "    });",
                  "    let result = translator_i.visit_pre(&empty_alternation);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let empty_alternation = Ast::Alternation(ast::Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![],",
                  "    });",
                  "    let result = translator_i.visit_pre(&empty_alternation);",
                  "    assert!(translator_i.trans().stack.borrow().len() == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:46\n     |\n2550 |     let empty_alternation = Ast::Alternation(Alternation {\n     |                                              ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:46\n     |\n2562 |     let empty_alternation = Ast::Alternation(Alternation {\n     |                                              ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:21\n     |\n2551 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:17\n     |\n2563 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:46\n     |\n2550 |     let empty_alternation = Ast::Alternation(Alternation {\n     |                                              ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:21\n     |\n2551 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:17\n     |\n2563 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test_pattern\";",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    let non_empty_alternation = Ast::Alternation(Alternation {",
                "        span: Span::default(),",
                "        asts: vec![Ast::Literal(Literal::new('a', Span::default())), Ast::Literal(Literal::new('b', Span::default()))],",
                "    });",
                "    let result = translator_i.visit_pre(&non_empty_alternation);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let non_empty_alternation = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::new('a', Span::default())), Ast::Literal(Literal::new('b', Span::default()))] });",
                  "    let result = translator_i.visit_pre(&non_empty_alternation);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let non_empty_alternation = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        use hir::Literal; // Importing the required Literal type",
                  "        asts: vec![Ast::Literal(Literal::new('a', Span::default())), Ast::Literal(Literal::new('b', Span::default()))],",
                  "    });",
                  "    let result = translator_i.visit_pre(&non_empty_alternation);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let non_empty_alternation = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::new('a', Span::default())), Ast::Literal(Literal::new('b', Span::default()))] });",
                  "    let result = translator_i.visit_pre(&non_empty_alternation);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected identifier, found keyword `use`\n    --> regex-syntax/src/hir/translate.rs:2552:9\n     |\n2550 |     let non_empty_alternation = Ast::Alternation(Alternation {\n     |                                                  ----------- while parsing this struct\n2551 |         span: Span::default(),\n2552 |         use hir::Literal; // Importing the required Literal type\n     |         ^^^ expected identifier, found keyword\n\nerror: expected identifier or integer\n    --> regex-syntax/src/hir/translate.rs:2552:9\n     |\n2552 |         use hir::Literal; // Importing the required Literal type\n     |         ^^^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_pre_16` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_pre_16()\n2542 | | {\n2543 | |     let translator = Translator {\n2544 | |         stack: RefCell::new(vec![]),\n...    |\n2561 | |     assert!(result.is_ok());\n2562 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Alternation(ref x) or Ast::Alternation(_) is true\n",
        "// constraint: *ast matches Ast::Alternation(ref x) is true\n",
        "// constraint: x.asts.is_empty() is false\n",
        "// constraint: *ast matches Ast::Alternation(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Alternation(ref x) with non-empty x.asts where x.asts.length is [1, 10]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alternation = Alternation {",
                "        span: Span::default(),",
                "        asts: vec![Ast::Literal(Literal::new(\"a\", Span::default()))],",
                "    };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                "    let _ = translator_i.visit_pre(&Ast::Alternation(alternation));",
                "}"
              ],
              "oracles": [
                [
                  "    let alternation = Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::new(\"a\", Span::default()))],",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_pre(&Ast::Alternation(alternation));",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alternation = Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"a\", Span::default()))],",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let _ = translator_i.visit_pre(&Ast::Alternation(alternation));",
                  "    let alternation = Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::new(\"a\", Span::default()))],",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_pre(&Ast::Alternation(alternation));",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:23\n     |\n2543 |     let alternation = Alternation {\n     |                       ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2545:33\n     |\n2545 |         asts: vec![Ast::Literal(Literal::new(\"a\", Span::default()))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:23\n     |\n2554 |     let alternation = Alternation {\n     |                       ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2556:29\n     |\n2556 |     asts: vec![Ast::Literal(Literal::new(\"a\", Span::default()))],\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:57\n     |\n2545 |         asts: vec![Ast::Literal(Literal::new(\"a\", Span::default()))],\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:17\n     |\n2555 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:53\n     |\n2556 |     asts: vec![Ast::Literal(Literal::new(\"a\", Span::default()))],\n     |                                                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alternation = Alternation {",
                "        span: Span::default(),",
                "        asts: vec![",
                "            Ast::Literal(Literal::new(\"a\", Span::default())),",
                "            Ast::Literal(Literal::new(\"b\", Span::default())),",
                "            Ast::Literal(Literal::new(\"c\", Span::default())),",
                "            Ast::Literal(Literal::new(\"d\", Span::default())),",
                "            Ast::Literal(Literal::new(\"e\", Span::default())),",
                "        ],",
                "    };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                "    let _ = translator_i.visit_pre(&Ast::Alternation(alternation));",
                "}"
              ],
              "oracles": [
                [
                  "    let alternation = Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::new(\"a\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"b\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"c\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"d\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"e\", Span::default())),",
                  "    ],",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    assert_eq!(translator_i.flags().unicode(), true);"
                ],
                [
                  "    let alternation = Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::new(\"a\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"b\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"c\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"d\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"e\", Span::default())),",
                  "    ],",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    assert!(translator_i.trans().stack.borrow().len() == 0);"
                ],
                [
                  "    let alternation = Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::new(\"a\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"b\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"c\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"d\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"e\", Span::default())),",
                  "    ],",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let _ = translator_i.visit_pre(&Ast::Alternation(alternation));",
                  "    assert!(translator_i.trans().stack.borrow().len() == 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alternation = Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::new(\"a\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"b\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"c\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"d\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"e\", Span::default())),",
                  "        ],",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let _ = translator_i.visit_pre(&Ast::Alternation(alternation));",
                  "    let alternation = Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::new(\"a\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"b\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"c\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"d\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"e\", Span::default())),",
                  "    ],",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    assert_eq!(translator_i.flags().unicode(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let alternation = Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::new(\"a\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"b\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"c\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"d\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"e\", Span::default())),",
                  "        ],",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let _ = translator_i.visit_pre(&Ast::Alternation(alternation));",
                  "    let alternation = Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::new(\"a\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"b\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"c\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"d\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"e\", Span::default())),",
                  "    ],",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    assert!(translator_i.trans().stack.borrow().len() == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let alternation = Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::new(\"a\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"b\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"c\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"d\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"e\", Span::default())),",
                  "        ],",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let _ = translator_i.visit_pre(&Ast::Alternation(alternation));",
                  "    let alternation = Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::new(\"a\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"b\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"c\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"d\", Span::default())),",
                  "    Ast::Literal(Literal::new(\"e\", Span::default())),",
                  "    ],",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let _ = translator_i.visit_pre(&Ast::Alternation(alternation));",
                  "    assert!(translator_i.trans().stack.borrow().len() == 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:23\n     |\n2543 |     let alternation = Alternation {\n     |                       ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:26\n     |\n2546 |             Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2547:26\n     |\n2547 |             Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |             Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:26\n     |\n2549 |             Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |             Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:23\n     |\n2560 |     let alternation = Alternation {\n     |                       ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2563:18\n     |\n2563 |     Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2564:18\n     |\n2564 |     Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:18\n     |\n2565 |     Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2566:18\n     |\n2566 |     Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2567:18\n     |\n2567 |     Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:50\n     |\n2546 |             Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:50\n     |\n2547 |             Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:50\n     |\n2548 |             Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2549:50\n     |\n2549 |             Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |             Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:17\n     |\n2561 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:42\n     |\n2563 |     Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 |     Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:42\n     |\n2565 |     Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 |     Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:42\n     |\n2567 |     Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:23\n     |\n2543 |     let alternation = Alternation {\n     |                       ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:26\n     |\n2546 |             Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2547:26\n     |\n2547 |             Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |             Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:26\n     |\n2549 |             Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |             Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:23\n     |\n2560 |     let alternation = Alternation {\n     |                       ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2563:18\n     |\n2563 |     Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2564:18\n     |\n2564 |     Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:18\n     |\n2565 |     Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2566:18\n     |\n2566 |     Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2567:18\n     |\n2567 |     Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:50\n     |\n2546 |             Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:50\n     |\n2547 |             Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:50\n     |\n2548 |             Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2549:50\n     |\n2549 |             Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |             Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:17\n     |\n2561 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:42\n     |\n2563 |     Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 |     Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:42\n     |\n2565 |     Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 |     Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:42\n     |\n2567 |     Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:23\n     |\n2543 |     let alternation = Alternation {\n     |                       ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:26\n     |\n2546 |             Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2547:26\n     |\n2547 |             Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |             Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:26\n     |\n2549 |             Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |             Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:23\n     |\n2560 |     let alternation = Alternation {\n     |                       ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2563:18\n     |\n2563 |     Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2564:18\n     |\n2564 |     Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:18\n     |\n2565 |     Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2566:18\n     |\n2566 |     Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2567:18\n     |\n2567 |     Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:50\n     |\n2546 |             Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:50\n     |\n2547 |             Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:50\n     |\n2548 |             Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2549:50\n     |\n2549 |             Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |             Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:17\n     |\n2561 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:42\n     |\n2563 |     Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 |     Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:42\n     |\n2565 |     Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 |     Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:42\n     |\n2567 |     Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alternation = Alternation {",
                "        span: Span::default(),",
                "        asts: vec![",
                "            Ast::Literal(Literal::new(\"a\", Span::default())),",
                "            Ast::Literal(Literal::new(\"b\", Span::default())),",
                "            Ast::Literal(Literal::new(\"c\", Span::default())),",
                "            Ast::Literal(Literal::new(\"d\", Span::default())),",
                "            Ast::Literal(Literal::new(\"e\", Span::default())),",
                "            Ast::Literal(Literal::new(\"f\", Span::default())),",
                "            Ast::Literal(Literal::new(\"g\", Span::default())),",
                "            Ast::Literal(Literal::new(\"h\", Span::default())),",
                "            Ast::Literal(Literal::new(\"i\", Span::default())),",
                "            Ast::Literal(Literal::new(\"j\", Span::default())),",
                "        ],",
                "    };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                "    let _ = translator_i.visit_pre(&Ast::Alternation(alternation));",
                "}"
              ],
              "oracles": [
                [
                  "    let alternation = Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::new(\"a\", Span::default())), Ast::Literal(Literal::new(\"b\", Span::default())), Ast::Literal(Literal::new(\"c\", Span::default())), Ast::Literal(Literal::new(\"d\", Span::default())), Ast::Literal(Literal::new(\"e\", Span::default())), Ast::Literal(Literal::new(\"f\", Span::default())), Ast::Literal(Literal::new(\"g\", Span::default())), Ast::Literal(Literal::new(\"h\", Span::default())), Ast::Literal(Literal::new(\"i\", Span::default())), Ast::Literal(Literal::new(\"j\", Span::default())),],};",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false,};",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    assert_eq!(translator_i.visit_pre(&Ast::Alternation(alternation)), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alternation = Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::new(\"a\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"b\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"c\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"d\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"e\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"f\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"g\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"h\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"i\", Span::default())),",
                  "            Ast::Literal(Literal::new(\"j\", Span::default())),",
                  "        ],",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let _ = translator_i.visit_pre(&Ast::Alternation(alternation));",
                  "    let alternation = Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::new(\"a\", Span::default())), Ast::Literal(Literal::new(\"b\", Span::default())), Ast::Literal(Literal::new(\"c\", Span::default())), Ast::Literal(Literal::new(\"d\", Span::default())), Ast::Literal(Literal::new(\"e\", Span::default())), Ast::Literal(Literal::new(\"f\", Span::default())), Ast::Literal(Literal::new(\"g\", Span::default())), Ast::Literal(Literal::new(\"h\", Span::default())), Ast::Literal(Literal::new(\"i\", Span::default())), Ast::Literal(Literal::new(\"j\", Span::default())),],};",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false,};",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    assert_eq!(translator_i.visit_pre(&Ast::Alternation(alternation)), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:23\n     |\n2543 |     let alternation = Alternation {\n     |                       ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:26\n     |\n2546 |             Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2547:26\n     |\n2547 |             Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |             Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:26\n     |\n2549 |             Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |             Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2551:26\n     |\n2551 |             Ast::Literal(Literal::new(\"f\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2552:26\n     |\n2552 |             Ast::Literal(Literal::new(\"g\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2553:26\n     |\n2553 |             Ast::Literal(Literal::new(\"h\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |             Ast::Literal(Literal::new(\"i\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |             Ast::Literal(Literal::new(\"j\", Span::default())),\n     |                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:23\n     |\n2565 |     let alternation = Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::new(\"a\", Span::default())), Ast::Literal(Lite...\n     |                       ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:84\n     |\n2565 |     let alternation = Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::new(\"a\", Span::default())), Ast::Literal(Lite...\n     |                                                                                    ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:134\n     |\n2565 | ...eral::new(\"a\", Span::default())), Ast::Literal(Literal::new(\"b\", Span::default())), Ast::Literal(Literal::new(\"c\", Span::default())), ...\n     |                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:184\n     |\n2565 | ...eral::new(\"b\", Span::default())), Ast::Literal(Literal::new(\"c\", Span::default())), Ast::Literal(Literal::new(\"d\", Span::default())), ...\n     |                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:234\n     |\n2565 | ...eral::new(\"c\", Span::default())), Ast::Literal(Literal::new(\"d\", Span::default())), Ast::Literal(Literal::new(\"e\", Span::default())), ...\n     |                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:284\n     |\n2565 | ...eral::new(\"d\", Span::default())), Ast::Literal(Literal::new(\"e\", Span::default())), Ast::Literal(Literal::new(\"f\", Span::default())), ...\n     |                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:334\n     |\n2565 | ...eral::new(\"e\", Span::default())), Ast::Literal(Literal::new(\"f\", Span::default())), Ast::Literal(Literal::new(\"g\", Span::default())), ...\n     |                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:384\n     |\n2565 | ...eral::new(\"f\", Span::default())), Ast::Literal(Literal::new(\"g\", Span::default())), Ast::Literal(Literal::new(\"h\", Span::default())), ...\n     |                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:434\n     |\n2565 | ...eral::new(\"g\", Span::default())), Ast::Literal(Literal::new(\"h\", Span::default())), Ast::Literal(Literal::new(\"i\", Span::default())), ...\n     |                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:484\n     |\n2565 | ...eral::new(\"h\", Span::default())), Ast::Literal(Literal::new(\"i\", Span::default())), Ast::Literal(Literal::new(\"j\", Span::default())),],};\n     |                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2565:534\n     |\n2565 | ...eral::new(\"i\", Span::default())), Ast::Literal(Literal::new(\"j\", Span::default())),],};\n     |                                                   ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:50\n     |\n2546 |             Ast::Literal(Literal::new(\"a\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:50\n     |\n2547 |             Ast::Literal(Literal::new(\"b\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:50\n     |\n2548 |             Ast::Literal(Literal::new(\"c\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2549:50\n     |\n2549 |             Ast::Literal(Literal::new(\"d\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |             Ast::Literal(Literal::new(\"e\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:50\n     |\n2551 |             Ast::Literal(Literal::new(\"f\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:50\n     |\n2552 |             Ast::Literal(Literal::new(\"g\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:50\n     |\n2553 |             Ast::Literal(Literal::new(\"h\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:50\n     |\n2554 |             Ast::Literal(Literal::new(\"i\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |             Ast::Literal(Literal::new(\"j\", Span::default())),\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:49\n     |\n2565 |     let alternation = Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::new(\"a\", Span::default())), Ast::Literal(Lite...\n     |                                                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:108\n     |\n2565 | ...Ast::Literal(Literal::new(\"a\", Span::default())), Ast::Literal(Literal::new(\"b\", Span::default())), Ast::Literal(Literal::new(\"c\", Spa...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:158\n     |\n2565 | ...Ast::Literal(Literal::new(\"b\", Span::default())), Ast::Literal(Literal::new(\"c\", Span::default())), Ast::Literal(Literal::new(\"d\", Spa...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:208\n     |\n2565 | ...Ast::Literal(Literal::new(\"c\", Span::default())), Ast::Literal(Literal::new(\"d\", Span::default())), Ast::Literal(Literal::new(\"e\", Spa...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:258\n     |\n2565 | ...Ast::Literal(Literal::new(\"d\", Span::default())), Ast::Literal(Literal::new(\"e\", Span::default())), Ast::Literal(Literal::new(\"f\", Spa...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:308\n     |\n2565 | ...Ast::Literal(Literal::new(\"e\", Span::default())), Ast::Literal(Literal::new(\"f\", Span::default())), Ast::Literal(Literal::new(\"g\", Spa...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:358\n     |\n2565 | ...Ast::Literal(Literal::new(\"f\", Span::default())), Ast::Literal(Literal::new(\"g\", Span::default())), Ast::Literal(Literal::new(\"h\", Spa...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:408\n     |\n2565 | ...Ast::Literal(Literal::new(\"g\", Span::default())), Ast::Literal(Literal::new(\"h\", Span::default())), Ast::Literal(Literal::new(\"i\", Spa...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:458\n     |\n2565 | ...Ast::Literal(Literal::new(\"h\", Span::default())), Ast::Literal(Literal::new(\"i\", Span::default())), Ast::Literal(Literal::new(\"j\", Spa...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:508\n     |\n2565 | ...Ast::Literal(Literal::new(\"i\", Span::default())), Ast::Literal(Literal::new(\"j\", Span::default())),],};\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:558\n     |\n2565 | ...Ast::Literal(Literal::new(\"j\", Span::default())),],};\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 44 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Group(ref x) is true\n",
        "// constraint: *ast matches Ast::Group(ref x) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Test input ranges: *ast = Ast::Group(ref x) where x contains a valid representation of the Group structure, with nested structures allowed, and flags either set or unset (i.e., valid non-empty instances of Group and Flags).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags { case_insensitive: Some(true), multi_line: Some(false), ..Flags::default() };",
                "    let span = Span::default(); // Placeholder for a valid Span",
                "    let ast = Ast::Group(Group {",
                "        span,",
                "        kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                "        ast: Box::new(Ast::Empty(span)),",
                "    });",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                "    let _ = translator_i.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let flags = Flags { case_insensitive: Some(true), multi_line: Some(false), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let flags = Flags { case_insensitive: Some(true), multi_line: Some(false), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    let frame = translator_i.pop();",
                  "    assert!(frame.is_some());"
                ],
                [
                  "    let flags = Flags { case_insensitive: Some(true), multi_line: Some(false), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    let frame = translator_i.pop();",
                  "    assert!(matches!(frame.unwrap(), HirFrame::Group { old_flags: Some(_) }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), multi_line: Some(false), ..Flags::default() };",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Group(Group {",
                  "        span,",
                  "        kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "        ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let flags = Flags { case_insensitive: Some(true), multi_line: Some(false), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), multi_line: Some(false), ..Flags::default() };",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Group(Group {",
                  "        span,",
                  "        kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "        ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let flags = Flags { case_insensitive: Some(true), multi_line: Some(false), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    let frame = translator_i.pop();",
                  "    assert!(frame.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), multi_line: Some(false), ..Flags::default() };",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Group(Group {",
                  "        span,",
                  "        kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "        ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let flags = Flags { case_insensitive: Some(true), multi_line: Some(false), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    let frame = translator_i.pop();",
                  "    assert!(matches!(frame.unwrap(), HirFrame::Group { old_flags: Some(_) }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:26\n     |\n2545 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2547:15\n     |\n2547 |         kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:26\n     |\n2561 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:22\n     |\n2544 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:22\n     |\n2560 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:26\n     |\n2545 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2547:15\n     |\n2547 |         kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:26\n     |\n2561 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:22\n     |\n2544 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:22\n     |\n2560 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:26\n     |\n2545 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2547:15\n     |\n2547 |         kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:26\n     |\n2561 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:22\n     |\n2544 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:22\n     |\n2560 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::default(); // Placeholder for a valid Span",
                "    let ast = Ast::Group(Group {",
                "        span,",
                "        kind: GroupKind::Capturing { flags: None },",
                "        ast: Box::new(Ast::Empty(span)),",
                "    });",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let mut translator_i = TranslatorI::new(&translator, \"another_test_pattern\");",
                "    let _ = translator_i.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: None },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"another_test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: None },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"another_test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.stack.borrow().len(), 1);"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: None },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"another_test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(matches!(translator_i.stack.borrow().last(), Some(HirFrame::Group { old_flags: None })));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Group(Group {",
                  "        span,",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"another_test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: None },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"another_test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Group(Group {",
                  "        span,",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"another_test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: None },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"another_test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Group(Group {",
                  "        span,",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"another_test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: None },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"another_test_pattern\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(matches!(translator_i.stack.borrow().last(), Some(HirFrame::Group { old_flags: None })));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:26\n     |\n2544 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |         kind: GroupKind::Capturing { flags: None },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:26\n     |\n2559 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2561:11\n     |\n2561 |     kind: GroupKind::Capturing { flags: None },\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:26\n     |\n2544 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |         kind: GroupKind::Capturing { flags: None },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:26\n     |\n2559 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2561:11\n     |\n2561 |     kind: GroupKind::Capturing { flags: None },\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2571:29\n     |\n2571 |     assert_eq!(translator_i.stack.borrow().len(), 1);\n     |                             ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2571 |     assert_eq!(translator_i.trans.stack.borrow().len(), 1);\n     |                             ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:26\n     |\n2544 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |         kind: GroupKind::Capturing { flags: None },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:26\n     |\n2559 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2561:11\n     |\n2561 |     kind: GroupKind::Capturing { flags: None },\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2571:35\n     |\n2571 |     assert!(matches!(translator_i.stack.borrow().last(), Some(HirFrame::Group { old_flags: None })));\n     |                                   ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2571 |     assert!(matches!(translator_i.trans.stack.borrow().last(), Some(HirFrame::Group { old_flags: None })));\n     |                                   ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let inner_group = Ast::Group(Group {",
                "        span: Span::default(),",
                "        kind: GroupKind::Capturing { flags: None },",
                "        ast: Box::new(Ast::Empty(Span::default())),",
                "    });",
                "    ",
                "    let outer_group = Ast::Group(Group {",
                "        span: Span::default(),",
                "        kind: GroupKind::Capturing { flags: None },",
                "        ast: Box::new(inner_group),",
                "    });",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                "    let _ = translator_i.visit_pre(&outer_group);",
                "}"
              ],
              "oracles": [
                [
                  "    let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let result = translator_i.visit_pre(&outer_group);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let result = translator_i.visit_pre(&outer_group);",
                  "    assert_eq!(translator_i.stack.borrow().len(), 1);"
                ],
                [
                  "    let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let result = translator_i.visit_pre(&outer_group);",
                  "    if let HirFrame::Group { old_flags } = &translator_i.stack.borrow()[0] {",
                  "    assert!(old_flags.is_none());"
                ],
                [
                  "    let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let result = translator_i.visit_pre(&outer_group);",
                  "    if let HirFrame::Group { old_flags } = &translator_i.stack.borrow()[0] {",
                  "    } else {",
                  "    assert!(false, \"Expected a HirFrame::Group frame\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let inner_group = Ast::Group(Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(Ast::Empty(Span::default())),",
                  "    });",
                  "    ",
                  "    let outer_group = Ast::Group(Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(inner_group),",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let _ = translator_i.visit_pre(&outer_group);",
                  "    let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let result = translator_i.visit_pre(&outer_group);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let inner_group = Ast::Group(Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(Ast::Empty(Span::default())),",
                  "    });",
                  "    ",
                  "    let outer_group = Ast::Group(Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(inner_group),",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let _ = translator_i.visit_pre(&outer_group);",
                  "    let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let result = translator_i.visit_pre(&outer_group);",
                  "    assert_eq!(translator_i.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let inner_group = Ast::Group(Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(Ast::Empty(Span::default())),",
                  "    });",
                  "    ",
                  "    let outer_group = Ast::Group(Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(inner_group),",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let _ = translator_i.visit_pre(&outer_group);",
                  "    let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let result = translator_i.visit_pre(&outer_group);",
                  "    if let HirFrame::Group { old_flags } = &translator_i.stack.borrow()[0] {",
                  "    assert!(old_flags.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let inner_group = Ast::Group(Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(Ast::Empty(Span::default())),",
                  "    });",
                  "    ",
                  "    let outer_group = Ast::Group(Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::Capturing { flags: None },",
                  "        ast: Box::new(inner_group),",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let _ = translator_i.visit_pre(&outer_group);",
                  "    let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"nested_group_test\");",
                  "    let result = translator_i.visit_pre(&outer_group);",
                  "    if let HirFrame::Group { old_flags } = &translator_i.stack.borrow()[0] {",
                  "    } else {",
                  "    assert!(false, \"Expected a HirFrame::Group frame\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:34\n     |\n2543 |     let inner_group = Ast::Group(Group {\n     |                                  ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2545:15\n     |\n2545 |         kind: GroupKind::Capturing { flags: None },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:34\n     |\n2549 |     let outer_group = Ast::Group(Group {\n     |                                  ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2551:15\n     |\n2551 |         kind: GroupKind::Capturing { flags: None },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:34\n     |\n2563 |     let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span...\n     |                                  ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2563:71\n     |\n2563 |     let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span...\n     |                                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:34\n     |\n2564 |     let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });\n     |                                  ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2564:71\n     |\n2564 |     let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });\n     |                                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |         ast: Box::new(Ast::Empty(Span::default())),\n     |                                        ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:54\n     |\n2563 |     let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span...\n     |                                                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:140\n     |\n2563 | ...ne }, ast: Box::new(Ast::Empty(Span::default())) });\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });\n     |                                                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:34\n     |\n2543 |     let inner_group = Ast::Group(Group {\n     |                                  ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2545:15\n     |\n2545 |         kind: GroupKind::Capturing { flags: None },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:34\n     |\n2549 |     let outer_group = Ast::Group(Group {\n     |                                  ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2551:15\n     |\n2551 |         kind: GroupKind::Capturing { flags: None },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:34\n     |\n2563 |     let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span...\n     |                                  ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2563:71\n     |\n2563 |     let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span...\n     |                                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:34\n     |\n2564 |     let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });\n     |                                  ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2564:71\n     |\n2564 |     let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });\n     |                                                                       ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |         ast: Box::new(Ast::Empty(Span::default())),\n     |                                        ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:21\n     |\n2550 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:54\n     |\n2563 |     let inner_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(Ast::Empty(Span...\n     |                                                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:140\n     |\n2563 | ...ne }, ast: Box::new(Ast::Empty(Span::default())) });\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let outer_group = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capturing { flags: None }, ast: Box::new(inner_group) });\n     |                                                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     assert_eq!(translator_i.stack.borrow().len(), 1);\n     |                             ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2568 |     assert_eq!(translator_i.trans.stack.borrow().len(), 1);\n     |                             ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2571:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2571 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2572:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2572 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                "    let span = Span::default(); // Placeholder for a valid Span",
                "    let ast = Ast::Group(Group {",
                "        span,",
                "        kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                "        ast: Box::new(Ast::Empty(span)),",
                "    });",
                "",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let mut translator_i = TranslatorI::new(&translator, \"unicode_flags_test\");",
                "    let _ = translator_i.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"unicode_flags_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"unicode_flags_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"unicode_flags_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(matches!(translator_i.trans().stack.borrow()[0], HirFrame::Group { old_flags: Some(_) }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Group(Group {",
                  "        span,",
                  "        kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "        ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"unicode_flags_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"unicode_flags_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Group(Group {",
                  "        span,",
                  "",
                  "        ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"unicode_flags_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"unicode_flags_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Group(Group {",
                  "        span,",
                  "        kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "        ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"unicode_flags_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing { flags: Some(flags.clone()) },",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"unicode_flags_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(matches!(translator_i.trans().stack.borrow()[0], HirFrame::Group { old_flags: Some(_) }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:26\n     |\n2545 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2547:15\n     |\n2547 |         kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:26\n     |\n2561 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:22\n     |\n2544 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:22\n     |\n2560 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:26\n     |\n2545 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:26\n     |\n2561 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:22\n     |\n2544 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:22\n     |\n2560 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:26\n     |\n2545 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2547:15\n     |\n2547 |         kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:26\n     |\n2561 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: GroupKind::Capturing { flags: Some(flags.clone()) },\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:22\n     |\n2544 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:22\n     |\n2560 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::default(); // Placeholder for a valid Span",
                "    let ast = Ast::Concat(Concat {",
                "        span,",
                "        asts: vec![],",
                "    });",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let mut translator_i = TranslatorI::new(&translator, \"concat_test\");",
                "    let _ = translator_i.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"group_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"group_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"group_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::Group { .. })));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Concat(Concat {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"concat_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"group_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Concat(Concat {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"concat_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"group_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Concat(Concat {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"concat_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group {",
                  "    span,",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Empty(span)),",
                  "    });",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"group_test\");",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::Group { .. })));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:27\n     |\n2544 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:26\n     |\n2558 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2560:11\n     |\n2560 |     kind: GroupKind::Capturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:22\n     |\n2557 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:27\n     |\n2544 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:26\n     |\n2558 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2560:11\n     |\n2560 |     kind: GroupKind::Capturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:22\n     |\n2557 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:27\n     |\n2544 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:26\n     |\n2558 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2560:11\n     |\n2560 |     kind: GroupKind::Capturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:22\n     |\n2557 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::default(); // Placeholder for a valid Span",
                "    let ast = Ast::Alternation(Alternation {",
                "        span,",
                "        asts: vec![],",
                "    });",
                "",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                "    let _ = translator_i.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    assert_eq!(translator.stack.borrow().len(), 1);"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    assert_eq!(translator.stack.borrow().len(), 2);"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::ClassBytes(_))));"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    assert_eq!(translator.stack.borrow().len(), 2);"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    assert_eq!(translator.stack.borrow().len(), 2);"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Empty(span)] });",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Empty(span)] });",
                  "    assert_eq!(translator.stack.borrow().len(), 3);"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Empty(span)] });",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::Alternation)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    assert_eq!(translator.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    assert_eq!(translator.stack.borrow().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::ClassBytes(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    assert_eq!(translator.stack.borrow().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    assert_eq!(translator.stack.borrow().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Empty(span)] });",
                  "    assert_eq!(translator_i.visit_pre(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Empty(span)] });",
                  "    assert_eq!(translator.stack.borrow().len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Placeholder for a valid Span",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span,",
                  "        asts: vec![],",
                  "    });",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"alternation_test\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let span = Span::default();",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Flags::default() });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Concat(Concat { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![] });",
                  "    let span = Span::default();",
                  "    let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Empty(span)] });",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::Alternation)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:32\n     |\n2544 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:26\n     |\n2558 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2558:46\n     |\n2558 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:22\n     |\n2557 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:32\n     |\n2544 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:26\n     |\n2558 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2558:46\n     |\n2558 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:22\n     |\n2557 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:22\n     |\n2559 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:32\n     |\n2544 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:26\n     |\n2558 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2558:46\n     |\n2558 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:22\n     |\n2557 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:22\n     |\n2559 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:48\n     |\n2559 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:48\n     |\n2559 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:48\n     |\n2559 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:27\n     |\n2562 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:48\n     |\n2559 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:22\n     |\n2561 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:27\n     |\n2562 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:48\n     |\n2559 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:22\n     |\n2561 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:27\n     |\n2562 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:32\n     |\n2564 |     let ast = Ast::Alternation(Alternation { span, asts: vec![] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:48\n     |\n2559 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:22\n     |\n2561 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:22\n     |\n2563 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:27\n     |\n2562 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:32\n     |\n2564 |     let ast = Ast::Alternation(Alternation { span, asts: vec![] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:48\n     |\n2559 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:22\n     |\n2561 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:22\n     |\n2563 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:27\n     |\n2562 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:32\n     |\n2564 |     let ast = Ast::Alternation(Alternation { span, asts: vec![] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:32\n     |\n2566 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Empty(span)] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:48\n     |\n2559 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:22\n     |\n2561 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:22\n     |\n2563 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:22\n     |\n2565 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:27\n     |\n2562 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:32\n     |\n2564 |     let ast = Ast::Alternation(Alternation { span, asts: vec![] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:32\n     |\n2566 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Empty(span)] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:48\n     |\n2559 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:22\n     |\n2561 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:22\n     |\n2563 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:22\n     |\n2565 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:32\n     |\n2541 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2555:46\n     |\n2555 |     let ast = Ast::Group(Group { span, kind: GroupKind::NonCapturing(vec![]), ast: Box::new(Ast::Empty(span)) });\n     |                                              ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:27\n     |\n2562 |     let ast = Ast::Concat(Concat { span, asts: vec![] });\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:32\n     |\n2564 |     let ast = Ast::Alternation(Alternation { span, asts: vec![] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:32\n     |\n2566 |     let ast = Ast::Alternation(Alternation { span, asts: vec![Ast::Empty(span)] });\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:22\n     |\n2540 |     let span = Span::default(); // Placeholder for a valid Span\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:22\n     |\n2554 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:22\n     |\n2556 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:48\n     |\n2557 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:22\n     |\n2558 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:48\n     |\n2559 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:22\n     |\n2561 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:22\n     |\n2563 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:22\n     |\n2565 |     let span = Span::default();\n     |                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(_)) is true\n",
        "// constraint: *ast matches Ast::Concat(ref x) is false\n",
        "// constraint: *ast matches Ast::Group(ref x) is false\n",
        "// constraint: *ast matches Ast::Alternation(ref x) is false\n",
        "// constraint: *ast matches Ast::Concat(_) is false\n",
        "// constraint: *ast matches Ast::Alternation(_) is false\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(_)) is false\n",
        "// constraint: *ast matches _ is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= *ast <= 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    let ast = Ast::Empty(Span::default());",
                "    translator.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span::default());",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span::default());",
                  "    assert!(translator.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span::default());",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span::default());",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span::default());",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span::default());",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span::default());",
                  "    assert!(translator.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span::default());",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span::default());",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:32\n     |\n2547 |     let ast = Ast::Empty(Span::default());\n     |                                ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:32\n     |\n2552 |     let ast = Ast::Empty(Span::default());\n     |                                ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:32\n     |\n2547 |     let ast = Ast::Empty(Span::default());\n     |                                ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:32\n     |\n2552 |     let ast = Ast::Empty(Span::default());\n     |                                ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:32\n     |\n2547 |     let ast = Ast::Empty(Span::default());\n     |                                ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:32\n     |\n2552 |     let ast = Ast::Empty(Span::default());\n     |                                ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \".\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    let ast = Ast::Dot(Span::default());",
                "    translator.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \".\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span::default());",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \".\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span::default());",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span::default());",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \".\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span::default());",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span::default());",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \".\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span::default());",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let ast = Ast::Dot(Span::default());\n     |                              ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let ast = Ast::Dot(Span::default());\n     |                              ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let ast = Ast::Dot(Span::default());\n     |                              ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let ast = Ast::Dot(Span::default());\n     |                              ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"(?=a)\";",
                "    let assertion = ast::Assertion::default(); // Assuming there's a default implementation",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    let ast = Ast::Assertion(assertion);",
                "    translator.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"(?=a)\";",
                  "    let assertion = ast::Assertion::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"(?=a)\";",
                  "    let assertion = ast::Assertion::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(translator.visit_pre(&ast).is_ok());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"(?=a)\";",
                  "    let assertion = ast::Assertion::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"(?=a)\";",
                  "    let assertion = ast::Assertion::default(); // Assuming there's a default implementation",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Assertion(assertion);",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"(?=a)\";",
                  "    let assertion = ast::Assertion::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"(?=a)\";",
                  "    let assertion = ast::Assertion::default(); // Assuming there's a default implementation",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Assertion(assertion);",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"(?=a)\";",
                  "    let assertion = ast::Assertion::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(translator.visit_pre(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"(?=a)\";",
                  "    let assertion = ast::Assertion::default(); // Assuming there's a default implementation",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Assertion(assertion);",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"(?=a)\";",
                  "    let assertion = ast::Assertion::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Assertion` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |     let assertion = ast::Assertion::default(); // Assuming there's a default implementation\n     |                                     ^^^^^^^ function or associated item not found in `Assertion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1101:1\n     |\n1101 | pub struct Assertion {\n     | -------------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Assertion` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |     let assertion = ast::Assertion::default();\n     |                                     ^^^^^^^ function or associated item not found in `Assertion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1101:1\n     |\n1101 | pub struct Assertion {\n     | -------------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Assertion` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |     let assertion = ast::Assertion::default(); // Assuming there's a default implementation\n     |                                     ^^^^^^^ function or associated item not found in `Assertion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1101:1\n     |\n1101 | pub struct Assertion {\n     | -------------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Assertion` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |     let assertion = ast::Assertion::default();\n     |                                     ^^^^^^^ function or associated item not found in `Assertion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1101:1\n     |\n1101 | pub struct Assertion {\n     | -------------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Assertion` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |     let assertion = ast::Assertion::default(); // Assuming there's a default implementation\n     |                                     ^^^^^^^ function or associated item not found in `Assertion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1101:1\n     |\n1101 | pub struct Assertion {\n     | -------------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Assertion` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |     let assertion = ast::Assertion::default();\n     |                                     ^^^^^^^ function or associated item not found in `Assertion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1101:1\n     |\n1101 | pub struct Assertion {\n     | -------------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"a\";",
                "    let literal = ast::Literal::default(); // Assuming there's a default implementation",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    let ast = Ast::Literal(literal);",
                "    translator.visit_pre(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    assert!(trans.stack.borrow().is_empty());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(translator.visit_pre(&ast).unwrap(), ());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(trans.stack.borrow().len(), 0);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    assert!(matches!(trans.stack.borrow().last(), None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default(); // Assuming there's a default implementation",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    assert!(trans.stack.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default(); // Assuming there's a default implementation",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(translator.visit_pre(&ast).unwrap(), ());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default(); // Assuming there's a default implementation",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(trans.stack.borrow().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default(); // Assuming there's a default implementation",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    translator.visit_pre(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"a\";",
                  "    let literal = ast::Literal::default();",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Literal(literal);",
                  "    assert!(matches!(trans.stack.borrow().last(), None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:33\n     |\n2546 |     let literal = ast::Literal::default(); // Assuming there's a default implementation\n     |                                 ^^^^^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |     let literal = ast::Literal::default();\n     |                                 ^^^^^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:33\n     |\n2546 |     let literal = ast::Literal::default(); // Assuming there's a default implementation\n     |                                 ^^^^^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |     let literal = ast::Literal::default();\n     |                                 ^^^^^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:33\n     |\n2546 |     let literal = ast::Literal::default(); // Assuming there's a default implementation\n     |                                 ^^^^^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |     let literal = ast::Literal::default();\n     |                                 ^^^^^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:33\n     |\n2546 |     let literal = ast::Literal::default(); // Assuming there's a default implementation\n     |                                 ^^^^^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |     let literal = ast::Literal::default();\n     |                                 ^^^^^^^ function or associated item not found in `Literal`\n     |\n    ::: regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(_)) is true\n",
        "// constraint: *ast matches  is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(_)) is true\n",
        "// constraint: self.flags().unicode() is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Class(ast::Class::Bracketed(_)), self.flags().unicode() = true\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {})); // Assuming ClassBracketed has a default implementation",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "    let _ = translator_i.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert!(trans.stack.borrow().is_empty());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {}));",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert_eq!(trans.stack.borrow().len(), 1);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {}));",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert!(matches!(trans.stack.borrow()[0], HirFrame::ClassUnicode(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {})); // Assuming ClassBracketed has a default implementation",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert!(trans.stack.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {})); // Assuming ClassBracketed has a default implementation",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {}));",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert_eq!(trans.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {})); // Assuming ClassBracketed has a default implementation",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {}));",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert!(matches!(trans.stack.borrow()[0], HirFrame::ClassUnicode(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {})); // Assuming ClassBracketed has a default implementation\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {})); // Assuming ClassBracketed has a default implementation\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {}));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {})); // Assuming ClassBracketed has a default implementation\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |     let ast = Ast::Class(ast::Class::Bracketed(ClassBracketed {}));\n     |                                                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()), // Default flags, unicode not set",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let ast = Ast::Group(Group {",
                "        span: Span::default(), ",
                "        kind: GroupKind::Capturing, // Assuming we have some kind of capturing group",
                "        ast: Box::new(Ast::Literal(Literal::new('a'))), // Literal character",
                "    });",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "    let _ = translator_i.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(translator_i.trans().stack.borrow().len() == 1);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags, unicode not set",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span::default(), ",
                  "        kind: GroupKind::Capturing, // Assuming we have some kind of capturing group",
                  "        ast: Box::new(Ast::Literal(Literal::new('a'))), // Literal character",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags, unicode not set",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span::default(), ",
                  "        kind: GroupKind::Capturing, // Assuming we have some kind of capturing group",
                  "        ast: Box::new(Ast::Literal(Literal::new('a'))), // Literal character",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(translator_i.trans().stack.borrow().len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags, unicode not set",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span::default(), ",
                  "        kind: GroupKind::Capturing, // Assuming we have some kind of capturing group",
                  "        ast: Box::new(Ast::Literal(Literal::new('a'))), // Literal character",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    trans.flags.set(Flags { unicode: Some(true), ..Flags::default() });",
                  "    let result = translator_i.visit_pre(&ast);",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:26\n     |\n2546 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: GroupKind::Capturing, // Assuming we have some kind of capturing group\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:36\n     |\n2549 |         ast: Box::new(Ast::Literal(Literal::new('a'))), // Literal character\n     |                                    ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(), \n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:26\n     |\n2546 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: GroupKind::Capturing, // Assuming we have some kind of capturing group\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:36\n     |\n2549 |         ast: Box::new(Ast::Literal(Literal::new('a'))), // Literal character\n     |                                    ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(), \n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:26\n     |\n2546 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: GroupKind::Capturing, // Assuming we have some kind of capturing group\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:36\n     |\n2549 |         ast: Box::new(Ast::Literal(Literal::new('a'))), // Literal character\n     |                                    ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(), \n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |     let ast = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()), // Default flags",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span::default(),",
                "        asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation",
                "    });",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "    let _ = translator_i.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::NonCapturing(Flags::default()),",
                  "    ast: Box::new(ast_class_bracketed.clone()),",
                  "    });",
                  "    let _ = translator_i.visit_pre(&ast_class_bracketed);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::NonCapturing(Flags::default()),",
                  "    ast: Box::new(ast_class_bracketed.clone()),",
                  "    });",
                  "    let _ = translator_i.visit_pre(&ast_class_bracketed);",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));"
                ],
                [
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::NonCapturing(Flags::default()),",
                  "    ast: Box::new(ast_class_bracketed.clone()),",
                  "    });",
                  "    let _ = translator_i.visit_pre(&ast_class_bracketed);",
                  "    let _ = translator_i.visit_pre(&ast_group);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 2);"
                ],
                [
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::NonCapturing(Flags::default()),",
                  "    ast: Box::new(ast_class_bracketed.clone()),",
                  "    });",
                  "    let _ = translator_i.visit_pre(&ast_class_bracketed);",
                  "    let _ = translator_i.visit_pre(&ast_group);",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::Group { old_flags: Some(_), })));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::NonCapturing(Flags::default()),",
                  "    ast: Box::new(ast_class_bracketed.clone()),",
                  "    });",
                  "    let _ = translator_i.visit_pre(&ast_class_bracketed);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::NonCapturing(Flags::default()),",
                  "    ast: Box::new(ast_class_bracketed.clone()),",
                  "    });",
                  "    let _ = translator_i.visit_pre(&ast_class_bracketed);",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::NonCapturing(Flags::default()),",
                  "    ast: Box::new(ast_class_bracketed.clone()),",
                  "    });",
                  "    let _ = translator_i.visit_pre(&ast_class_bracketed);",
                  "    let _ = translator_i.visit_pre(&ast_group);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::NonCapturing(Flags::default()),",
                  "    ast: Box::new(ast_class_bracketed.clone()),",
                  "    });",
                  "    let _ = translator_i.visit_pre(&ast_class_bracketed);",
                  "    let _ = translator_i.visit_pre(&ast_group);",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::Group { old_flags: Some(_), })));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:33\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:66\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:32\n     |\n2555 |     let ast_group = Ast::Group(Group {\n     |                                ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2557:11\n     |\n2557 |     kind: GroupKind::NonCapturing(Flags::default()),\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:64\n     |\n2554 |     let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                                          |\n     |                                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:17\n     |\n2556 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:33\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:66\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:32\n     |\n2555 |     let ast_group = Ast::Group(Group {\n     |                                ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2557:11\n     |\n2557 |     kind: GroupKind::NonCapturing(Flags::default()),\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:64\n     |\n2554 |     let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                                          |\n     |                                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:17\n     |\n2556 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:33\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:66\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:32\n     |\n2555 |     let ast_group = Ast::Group(Group {\n     |                                ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2557:11\n     |\n2557 |     kind: GroupKind::NonCapturing(Flags::default()),\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:64\n     |\n2554 |     let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                                          |\n     |                                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:17\n     |\n2556 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:33\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:66\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple concatenation\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:32\n     |\n2555 |     let ast_group = Ast::Group(Group {\n     |                                ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2557:11\n     |\n2557 |     kind: GroupKind::NonCapturing(Flags::default()),\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:64\n     |\n2554 |     let ast_class_bracketed = Ast::Class(ast::Class::Bracketed(vec![]));\n     |                                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                                          |\n     |                                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:17\n     |\n2556 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()), // Default flags",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let ast = Ast::Alternation(Alternation {",
                "        span: Span::default(),",
                "        asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation",
                "    });",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "    let _ = translator_i.visit_pre(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    match &translator_i.trans().stack.borrow()[0] {",
                  "    HirFrame::ClassUnicode(_) => {},",
                  "    _ => panic!(\"Expected ClassUnicode frame\"),",
                  "    }",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::new('c'))),",
                  "    }); // Matches Ast::Group(ref x)",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    match &translator_i.trans().stack.borrow()[0] {",
                  "    HirFrame::ClassUnicode(_) => {},",
                  "    _ => panic!(\"Expected ClassUnicode frame\"),",
                  "    }",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::new('c'))),",
                  "    }); // Matches Ast::Group(ref x)",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    match &translator_i.trans().stack.borrow()[0] {",
                  "    HirFrame::Group { .. } => {},",
                  "    _ => panic!(\"Expected Group frame\"),",
                  "    }",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![],",
                  "    }); // Matches Ast::Concat(ref x) if x.asts.is_empty()",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 0);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    match &translator_i.trans().stack.borrow()[0] {",
                  "    HirFrame::ClassUnicode(_) => {},",
                  "    _ => panic!(\"Expected ClassUnicode frame\"),",
                  "    }",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::new('c'))),",
                  "    }); // Matches Ast::Group(ref x)",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    match &translator_i.trans().stack.borrow()[0] {",
                  "    HirFrame::Group { .. } => {},",
                  "    _ => panic!(\"Expected Group frame\"),",
                  "    }",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![],",
                  "    }); // Matches Ast::Concat(ref x) if x.asts.is_empty()",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::new('x')), Ast::Literal(Literal::new('y'))],",
                  "    }); // Matches Ast::Alternation(_)",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    match &translator_i.trans().stack.borrow()[0] {",
                  "    HirFrame::ClassUnicode(_) => {},",
                  "    _ => panic!(\"Expected ClassUnicode frame\"),",
                  "    }",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::new('c'))),",
                  "    }); // Matches Ast::Group(ref x)",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    match &translator_i.trans().stack.borrow()[0] {",
                  "    HirFrame::ClassUnicode(_) => {},",
                  "    _ => panic!(\"Expected ClassUnicode frame\"),",
                  "    }",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::new('c'))),",
                  "    }); // Matches Ast::Group(ref x)",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    match &translator_i.trans().stack.borrow()[0] {",
                  "    HirFrame::Group { .. } => {},",
                  "    _ => panic!(\"Expected Group frame\"),",
                  "    }",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![],",
                  "    }); // Matches Ast::Concat(ref x) if x.asts.is_empty()",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()), // Default flags",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    match &translator_i.trans().stack.borrow()[0] {",
                  "    HirFrame::ClassUnicode(_) => {},",
                  "    _ => panic!(\"Expected ClassUnicode frame\"),",
                  "    }",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::new('c'))),",
                  "    }); // Matches Ast::Group(ref x)",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    match &translator_i.trans().stack.borrow()[0] {",
                  "    HirFrame::Group { .. } => {},",
                  "    _ => panic!(\"Expected Group frame\"),",
                  "    }",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![],",
                  "    }); // Matches Ast::Concat(ref x) if x.asts.is_empty()",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::new('x')), Ast::Literal(Literal::new('y'))],",
                  "    }); // Matches Ast::Alternation(_)",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let _ = translator_i.visit_pre(&ast);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:32\n     |\n2546 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:33\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:66\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:32\n     |\n2546 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:33\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:66\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:26\n     |\n2573 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2575:11\n     |\n2575 |     kind: GroupKind::Capturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2576:32\n     |\n2576 |     ast: Box::new(Ast::Literal(Literal::new('c'))),\n     |                                ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2574:17\n     |\n2574 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:32\n     |\n2546 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:33\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:66\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:26\n     |\n2573 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2575:11\n     |\n2575 |     kind: GroupKind::Capturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2576:32\n     |\n2576 |     ast: Box::new(Ast::Literal(Literal::new('c'))),\n     |                                ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2589:27\n     |\n2589 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2574:17\n     |\n2574 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2590:17\n     |\n2590 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:32\n     |\n2546 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:33\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:66\n     |\n2548 |         asts: vec![Ast::Literal(Literal::new('a')), Ast::Literal(Literal::new('b'))], // Simple alternation\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:26\n     |\n2573 |     let ast = Ast::Group(Group {\n     |                          ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2575:11\n     |\n2575 |     kind: GroupKind::Capturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2576:32\n     |\n2576 |     ast: Box::new(Ast::Literal(Literal::new('c'))),\n     |                                ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2589:27\n     |\n2589 |     let ast = Ast::Concat(Concat {\n     |                           ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2600:32\n     |\n2600 |     let ast = Ast::Alternation(Alternation {\n     |                                ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2602:29\n     |\n2602 |     asts: vec![Ast::Literal(Literal::new('x')), Ast::Literal(Literal::new('y'))],\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/hir/translate.rs:2602:62\n     |\n2602 |     asts: vec![Ast::Literal(Literal::new('x')), Ast::Literal(Literal::new('y'))],\n     |                                                              ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:21\n     |\n2547 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let ast = Ast::Class(ast::Class::Bracketed(vec![])); // Matches Ast::Class(ast::Class::Bracketed(_))\n     |                          --------------------- ^^^^^^ expected `ClassBracketed`, found `Vec<_>`\n     |                          |\n     |                          arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ClassBracketed`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:723:5\n     |\n723  |     Bracketed(ClassBracketed),\n     |     ^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2574:17\n     |\n2574 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2590:17\n     |\n2590 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2601:17\n     |\n2601 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(_)) is true\n",
        "// constraint: *ast matches  is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(_)) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Class(ast::Class::Bracketed(a)) where a is any valid instance; self.flags() returns Flags { unicode: Some(false) }\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"[a-z]\";",
                "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));",
                "",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false, };",
                  "    let pattern = \"[a-z]\";",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false, };",
                  "    let pattern = \"[a-z]\";",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::ClassBytes(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[a-z]\";",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false, };",
                  "    let pattern = \"[a-z]\";",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[a-z]\";",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false, };",
                  "    let pattern = \"[a-z]\";",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::ClassBytes(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));\n     |                                                ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2553:48\n     |\n2553 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));\n     |                                                ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));\n     |                                                ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/hir/translate.rs:2553:48\n     |\n2553 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { /* fields initialized here */ }));\n     |                                                ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"(abcd)\";",
                "    let group_ast = ast::Group {",
                "        span: Span::default(), ",
                "        kind: GroupKind::Capturing, // or any valid GroupKind",
                "        ast: Box::new(Ast::Literal(ast::Literal { /* fields initialized here */ })),",
                "    };",
                "    let ast = Ast::Group(group_ast);",
                "",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                "}"
              ],
              "oracles": [
                [
                  "    let cls_unicode = hir::ClassUnicode::empty();",
                  "    let cls_bytes = hir::ClassBytes::empty();",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let cls_unicode = hir::ClassUnicode::empty();",
                  "    let cls_bytes = hir::ClassBytes::empty();",
                  "    assert!(matches!(translator_i.trans().stack.borrow()[0], HirFrame::ClassBytes(_)));"
                ],
                [
                  "    let cls_unicode = hir::ClassUnicode::empty();",
                  "    let cls_bytes = hir::ClassBytes::empty();",
                  "    assert!(translator_i.trans().stack.borrow().is_empty() == false);"
                ],
                [
                  "    let cls_unicode = hir::ClassUnicode::empty();",
                  "    let cls_bytes = hir::ClassBytes::empty();",
                  "    assert_eq!(translator_i.visit_pre(&ast).unwrap(), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"(abcd)\";",
                  "    let group_ast = ast::Group {",
                  "        span: Span::default(), ",
                  "        kind: GroupKind::Capturing, // or any valid GroupKind",
                  "        ast: Box::new(Ast::Literal(ast::Literal { /* fields initialized here */ })),",
                  "    };",
                  "    let ast = Ast::Group(group_ast);",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    let cls_unicode = hir::ClassUnicode::empty();",
                  "    let cls_bytes = hir::ClassBytes::empty();",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"(abcd)\";",
                  "    let group_ast = ast::Group {",
                  "        span: Span::default(), ",
                  "        kind: GroupKind::Capturing, // or any valid GroupKind",
                  "        ast: Box::new(Ast::Literal(ast::Literal { /* fields initialized here */ })),",
                  "    };",
                  "    let ast = Ast::Group(group_ast);",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    let cls_unicode = hir::ClassUnicode::empty();",
                  "    let cls_bytes = hir::ClassBytes::empty();",
                  "    assert!(matches!(translator_i.trans().stack.borrow()[0], HirFrame::ClassBytes(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"(abcd)\";",
                  "    let group_ast = ast::Group {",
                  "        span: Span::default(), ",
                  "        kind: GroupKind::Capturing, // or any valid GroupKind",
                  "        ast: Box::new(Ast::Literal(ast::Literal { /* fields initialized here */ })),",
                  "    };",
                  "    let ast = Ast::Group(group_ast);",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    let cls_unicode = hir::ClassUnicode::empty();",
                  "    let cls_bytes = hir::ClassBytes::empty();",
                  "    assert!(translator_i.trans().stack.borrow().is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"(abcd)\";",
                  "    let group_ast = ast::Group {",
                  "        span: Span::default(), ",
                  "        kind: GroupKind::Capturing, // or any valid GroupKind",
                  "        ast: Box::new(Ast::Literal(ast::Literal { /* fields initialized here */ })),",
                  "    };",
                  "    let ast = Ast::Group(group_ast);",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    let cls_unicode = hir::ClassUnicode::empty();",
                  "    let cls_bytes = hir::ClassBytes::empty();",
                  "    assert_eq!(translator_i.visit_pre(&ast).unwrap(), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: GroupKind::Capturing, // or any valid GroupKind\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:21\n     |\n2548 |         span: Span::default(), \n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:36\n     |\n2550 |         ast: Box::new(Ast::Literal(ast::Literal { /* fields initialized here */ })),\n     |                                    ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: GroupKind::Capturing, // or any valid GroupKind\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:21\n     |\n2548 |         span: Span::default(), \n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:36\n     |\n2550 |         ast: Box::new(Ast::Literal(ast::Literal { /* fields initialized here */ })),\n     |                                    ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: GroupKind::Capturing, // or any valid GroupKind\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:21\n     |\n2548 |         span: Span::default(), \n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:36\n     |\n2550 |         ast: Box::new(Ast::Literal(ast::Literal { /* fields initialized here */ })),\n     |                                    ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: GroupKind::Capturing, // or any valid GroupKind\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:21\n     |\n2548 |         span: Span::default(), \n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:36\n     |\n2550 |         ast: Box::new(Ast::Literal(ast::Literal { /* fields initialized here */ })),\n     |                                    ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:55\n     |\n2558 |     assert_eq!(translator_i.visit_pre(&ast).unwrap(), Ok(()));\n     |                                                       ^^^^^^ expected `()`, found `Result<(), _>`\n     |\n     = note: expected unit type `()`\n                     found enum `std::result::Result<(), _>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"abc\";",
                "    let concat_ast = Concat {",
                "        span: Span::default(),",
                "        asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances",
                "    };",
                "    let ast = Ast::Concat(concat_ast);",
                "",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                "}"
              ],
              "oracles": [
                [
                  "    translator_i.push(HirFrame::Concat);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    translator_i.push(HirFrame::Concat);",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::Concat)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"abc\";",
                  "    let concat_ast = Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances",
                  "    };",
                  "    let ast = Ast::Concat(concat_ast);",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    translator_i.push(HirFrame::Concat);",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"abc\";",
                  "    let concat_ast = Concat {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances",
                  "    };",
                  "    let ast = Ast::Concat(concat_ast);",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    translator_i.push(HirFrame::Concat);",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::Concat)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:22\n     |\n2547 |     let concat_ast = Concat {\n     |                      ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:21\n     |\n2548 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:33\n     |\n2549 |         asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances\n     |                                 ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:22\n     |\n2547 |     let concat_ast = Concat {\n     |                      ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Concat;\n     |\n2535 +    use hir::HirKind::Concat;\n     |\n2535 +    use hir::translate::Ast::Concat;\n     |\n2535 +    use hir::translate::HirFrame::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:21\n     |\n2548 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:33\n     |\n2549 |         asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances\n     |                                 ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"a|b\";",
                "    let alternation_ast = Alternation {",
                "        span: Span::default(),",
                "        asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances",
                "    };",
                "    let ast = Ast::Alternation(alternation_ast);",
                "",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"a|b\";",
                  "    let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };",
                  "    let ast = Ast::Alternation(alternation_ast);",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    assert!(translator_i.trans().stack.borrow().is_empty());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"a|b\";",
                  "    let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };",
                  "    let ast = Ast::Alternation(alternation_ast);",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"a|b\";",
                  "    let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };",
                  "    let ast = Ast::Alternation(alternation_ast);",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::Alternation)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"a|b\";",
                  "    let alternation_ast = Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances",
                  "    };",
                  "    let ast = Ast::Alternation(alternation_ast);",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"a|b\";",
                  "    let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };",
                  "    let ast = Ast::Alternation(alternation_ast);",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    assert!(translator_i.trans().stack.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"a|b\";",
                  "    let alternation_ast = Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances",
                  "    };",
                  "    let ast = Ast::Alternation(alternation_ast);",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"a|b\";",
                  "    let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };",
                  "    let ast = Ast::Alternation(alternation_ast);",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"a|b\";",
                  "    let alternation_ast = Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances",
                  "    };",
                  "    let ast = Ast::Alternation(alternation_ast);",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap(); // Call the function with the test input",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"a|b\";",
                  "    let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };",
                  "    let ast = Ast::Alternation(alternation_ast);",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    translator_i.visit_pre(&ast).unwrap();",
                  "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::Alternation)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let alternation_ast = Alternation {\n     |                           ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };\n     |                           ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:21\n     |\n2548 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:33\n     |\n2549 |         asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances\n     |                                 ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:53\n     |\n2557 |     let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };\n     |                                                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2557:88\n     |\n2557 |     let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };\n     |                                                                                        ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let alternation_ast = Alternation {\n     |                           ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };\n     |                           ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:21\n     |\n2548 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:33\n     |\n2549 |         asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances\n     |                                 ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:53\n     |\n2557 |     let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };\n     |                                                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2557:88\n     |\n2557 |     let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };\n     |                                                                                        ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let alternation_ast = Alternation {\n     |                           ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };\n     |                           ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Alternation;\n     |\n2535 +    use hir::HirKind::Alternation;\n     |\n2535 +    use hir::translate::Ast::Alternation;\n     |\n2535 +    use hir::translate::HirFrame::Alternation;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:21\n     |\n2548 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2549:33\n     |\n2549 |         asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })], // valid Literal instances\n     |                                 ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:53\n     |\n2557 |     let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };\n     |                                                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2557:88\n     |\n2557 |     let alternation_ast = Alternation { span: Span::default(), asts: vec![Ast::Literal(ast::Literal { /* fields initialized here */ })] };\n     |                                                                                        ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}