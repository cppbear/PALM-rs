{
  "name": "regex_syntax::ast::visitor::ast::visitor::HeapVisitor<'a>::pop",
  "name_with_impl": "regex_syntax::ast::visitor::{impl#0}::pop",
  "mod_info": {
    "name": "ast::visitor",
    "loc": "regex-syntax/src/ast/mod.rs:23:1:23:13"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/visitor.rs:303:5:328:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: induct matches Frame::Alternation { tail, .. } is true\n",
        "// constraint: tail.is_empty() is true\n",
        "// expected return value/type: None\n"
      ],
      "input_infer": "pop(Frame::Alternation { tail: &[] })\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let frame = Frame::Alternation {",
                "        head: &Ast::Empty(Span::new(0, 0)), // Dummy head, since it won't be accessed",
                "        tail: &[],",
                "    };",
                "    let visitor = HeapVisitor::new();",
                "    visitor.pop(frame);",
                "}"
              ],
              "oracles": [
                [
                  "    let frame = Frame::Alternation { head: &Ast::Empty(Span::new(0, 0)), tail: &[] };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let frame = Frame::Alternation {",
                  "        head: &Ast::Empty(Span::new(0, 0)), // Dummy head, since it won't be accessed",
                  "        tail: &[],",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.pop(frame);",
                  "    let frame = Frame::Alternation { head: &Ast::Empty(Span::new(0, 0)), tail: &[] };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:27\n    |\n569 |         head: &Ast::Empty(Span::new(0, 0)), // Dummy head, since it won't be accessed\n    |                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:574:56\n    |\n574 |     let frame = Frame::Alternation { head: &Ast::Empty(Span::new(0, 0)), tail: &[] };\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:577:5\n    |\n577 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:577:5\n    |\n577 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let frame = Frame::Alternation {",
                "        head: &Ast::Dot(Span::new(0, 1)), // Another dummy head",
                "        tail: &[],",
                "    };",
                "    let visitor = HeapVisitor::new();",
                "    visitor.pop(frame);",
                "}"
              ],
              "oracles": [
                [
                  "    let frame = Frame::Alternation {",
                  "    head: &Ast::Dot(Span::new(0, 1)),",
                  "    tail: &[],",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let frame = Frame::Alternation {",
                  "        head: &Ast::Dot(Span::new(0, 1)), // Another dummy head",
                  "        tail: &[],",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.pop(frame);",
                  "    let frame = Frame::Alternation {",
                  "    head: &Ast::Dot(Span::new(0, 1)),",
                  "    tail: &[],",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    assert!(result.is_none());  ",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |         head: &Ast::Dot(Span::new(0, 1)), // Another dummy head\n    |                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:21\n    |\n575 |     head: &Ast::Dot(Span::new(0, 1)),\n    |                     ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: induct matches Frame::Alternation { tail, .. } is true\n",
        "// constraint: tail.is_empty() is false\n",
        "// constraint: tail[1..] is \n",
        "// expected return value/type: Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n"
      ],
      "input_infer": "tail length: 1 to 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = HeapVisitor::new();",
                "    let ast = ast::Alternation { /* construct alternation node */ };",
                "    ",
                "    let tail = vec![",
                "        &ast::Literal(Literal::Char('a')),",
                "        &ast::Literal(Literal::Char('b')),",
                "        &ast::Literal(Literal::Char('c')),",
                "    ];",
                "    ",
                "    let induct = Frame::Alternation {",
                "        head: &tail[0],",
                "        tail: &tail[1..],",
                "    };",
                "    ",
                "    let result = visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('a')),",
                  "    &ast::Literal(Literal::Char('b')),",
                  "    &ast::Literal(Literal::Char('c')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('a')),",
                  "    &ast::Literal(Literal::Char('b')),",
                  "    &ast::Literal(Literal::Char('c')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(frame) = result {",
                  "    if let Frame::Alternation { head, tail } = frame {",
                  "    assert_eq!(head, &tail[0]);"
                ],
                [
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('a')),",
                  "    &ast::Literal(Literal::Char('b')),",
                  "    &ast::Literal(Literal::Char('c')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(frame) = result {",
                  "    if let Frame::Alternation { head, tail } = frame {",
                  "    assert_eq!(tail.len(), 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    ",
                  "    let tail = vec![",
                  "        &ast::Literal(Literal::Char('a')),",
                  "        &ast::Literal(Literal::Char('b')),",
                  "        &ast::Literal(Literal::Char('c')),",
                  "    ];",
                  "    ",
                  "    let induct = Frame::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    ",
                  "    let result = visitor.pop(induct);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('a')),",
                  "    use ast::Literal;  ",
                  "    &ast::Literal(Literal::Char('b')),  ",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    ",
                  "    let tail = vec![",
                  "        &ast::Literal(Literal::Char('a')),",
                  "        &ast::Literal(Literal::Char('b')),",
                  "        &ast::Literal(Literal::Char('c')),",
                  "    ];",
                  "    ",
                  "    let induct = Frame::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    ",
                  "    let result = visitor.pop(induct);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('a')),",
                  "    &ast::Literal(Literal::Char('b')),",
                  "    &ast::Literal(Literal::Char('c')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(frame) = result {",
                  "    if let Frame::Alternation { head, tail } = frame {",
                  "    assert_eq!(head, &tail[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    ",
                  "    let tail = vec![",
                  "        &ast::Literal(Literal::Char('a')),",
                  "        &ast::Literal(Literal::Char('b')),",
                  "        &ast::Literal(Literal::Char('c')),",
                  "    ];",
                  "    ",
                  "    let induct = Frame::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    ",
                  "    let result = visitor.pop(induct);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('a')),",
                  "    &ast::Literal(Literal::Char('b')),",
                  "    &ast::Literal(Literal::Char('c')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(frame) = result {",
                  "    if let Frame::Alternation { head, tail } = frame {",
                  "    assert_eq!(tail.len(), 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: no rules expected the token `use`\n   --> regex-syntax/src/ast/visitor.rs:587:5\n    |\n587 |     use ast::Literal;  \n    |     ^^^ no rules expected this token in macro call\n    |\nnote: while trying to match meta-variable `$x:expr`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs:49:8\n    |\n49  |     ($($x:expr),+ $(,)?) => (\n    |        ^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:10\n    |\n572 |           &ast::Literal(Literal::Char('a')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n572 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n572 -         &ast::Literal(Literal::Char('a')),\n572 +         &Literal(Literal::Char('a')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:23\n    |\n572 |         &ast::Literal(Literal::Char('a')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:10\n    |\n573 |           &ast::Literal(Literal::Char('b')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n573 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n573 -         &ast::Literal(Literal::Char('b')),\n573 +         &Literal(Literal::Char('b')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |         &ast::Literal(Literal::Char('b')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:10\n    |\n574 |           &ast::Literal(Literal::Char('c')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n574 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n574 -         &ast::Literal(Literal::Char('c')),\n574 +         &Literal(Literal::Char('c')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |         &ast::Literal(Literal::Char('c')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `asts` and `span` in initializer of `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let ast = ast::Alternation { /* construct alternation node */ };\n    |               ^^^^^^^^^^^^^^^^ missing `asts` and `span`\n\nerror[E0063]: missing fields `asts` and `span` in initializer of `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:584:15\n    |\n584 |     let ast = ast::Alternation { /* construct alternation node */ };\n    |               ^^^^^^^^^^^^^^^^ missing `asts` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:599:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n596 |     if let Frame::Alternation { head, tail } = frame {\n    |                                                      - this delimiter might not be properly closed...\n597 |     assert_eq!(head, &tail[0]);\n598 | }\n    | - ...as it matches this but it has different indentation\n599 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:599:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n596 |     if let Frame::Alternation { head, tail } = frame {\n    |                                                      - this delimiter might not be properly closed...\n597 |     assert_eq!(tail.len(), 2);\n598 | }\n    | - ...as it matches this but it has different indentation\n599 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = HeapVisitor::new();",
                "    let ast = ast::Alternation { /* construct alternation node */ };",
                "    ",
                "    let tail = vec![",
                "        &ast::Literal(Literal::Char('d')),",
                "        &ast::Literal(Literal::Char('e')),",
                "        &ast::Literal(Literal::Char('f')),",
                "        &ast::Literal(Literal::Char('g')),",
                "        &ast::Literal(Literal::Char('h')),",
                "    ];",
                "    ",
                "    let induct = Frame::Alternation {",
                "        head: &tail[0],",
                "        tail: &tail[1..],",
                "    };",
                "    ",
                "    let result = visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('d')),",
                  "    &ast::Literal(Literal::Char('e')),",
                  "    &ast::Literal(Literal::Char('f')),",
                  "    &ast::Literal(Literal::Char('g')),",
                  "    &ast::Literal(Literal::Char('h')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('d')),",
                  "    &ast::Literal(Literal::Char('e')),",
                  "    &ast::Literal(Literal::Char('f')),",
                  "    &ast::Literal(Literal::Char('g')),",
                  "    &ast::Literal(Literal::Char('h')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert_matches!(result, Some(Frame::Alternation { head, tail }) if head == &tail[0] && tail == &tail[1..]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    ",
                  "    let tail = vec![",
                  "        &ast::Literal(Literal::Char('d')),",
                  "        &ast::Literal(Literal::Char('e')),",
                  "        &ast::Literal(Literal::Char('f')),",
                  "        &ast::Literal(Literal::Char('g')),",
                  "        &ast::Literal(Literal::Char('h')),",
                  "    ];",
                  "    ",
                  "    let induct = Frame::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    ",
                  "    let result = visitor.pop(induct);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('d')),",
                  "    &ast::Literal(Literal::Char('e')),",
                  "    &ast::Literal(Literal::Char('f')),",
                  "    &ast::Literal(Literal::Char('g')),",
                  "    &ast::Literal(Literal::Char('h')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    ",
                  "    let tail = vec![",
                  "        &ast::Literal(Literal::Char('d')),",
                  "        &ast::Literal(Literal::Char('e')),",
                  "        &ast::Literal(Literal::Char('f')),",
                  "        &ast::Literal(Literal::Char('g')),",
                  "        &ast::Literal(Literal::Char('h')),",
                  "    ];",
                  "    ",
                  "    let induct = Frame::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    ",
                  "    let result = visitor.pop(induct);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('d')),",
                  "    &ast::Literal(Literal::Char('e')),",
                  "    &ast::Literal(Literal::Char('f')),",
                  "    &ast::Literal(Literal::Char('g')),",
                  "    &ast::Literal(Literal::Char('h')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert_matches!(result, Some(Frame::Alternation { head, tail }) if head == &tail[0] && tail == &tail[1..]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:10\n    |\n572 |           &ast::Literal(Literal::Char('d')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n572 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n572 -         &ast::Literal(Literal::Char('d')),\n572 +         &Literal(Literal::Char('d')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:23\n    |\n572 |         &ast::Literal(Literal::Char('d')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:10\n    |\n573 |           &ast::Literal(Literal::Char('e')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n573 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n573 -         &ast::Literal(Literal::Char('e')),\n573 +         &Literal(Literal::Char('e')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |         &ast::Literal(Literal::Char('e')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:10\n    |\n574 |           &ast::Literal(Literal::Char('f')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n574 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n574 -         &ast::Literal(Literal::Char('f')),\n574 +         &Literal(Literal::Char('f')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |         &ast::Literal(Literal::Char('f')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:575:10\n    |\n575 |           &ast::Literal(Literal::Char('g')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n575 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n575 -         &ast::Literal(Literal::Char('g')),\n575 +         &Literal(Literal::Char('g')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |         &ast::Literal(Literal::Char('g')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:10\n    |\n576 |           &ast::Literal(Literal::Char('h')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n576 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n576 -         &ast::Literal(Literal::Char('h')),\n576 +         &Literal(Literal::Char('h')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |         &ast::Literal(Literal::Char('h')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:6\n    |\n588 |       &ast::Literal(Literal::Char('d')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n588 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n588 -     &ast::Literal(Literal::Char('d')),\n588 +     &Literal(Literal::Char('d')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:19\n    |\n588 |     &ast::Literal(Literal::Char('d')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:6\n    |\n589 |       &ast::Literal(Literal::Char('e')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n589 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n589 -     &ast::Literal(Literal::Char('e')),\n589 +     &Literal(Literal::Char('e')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:19\n    |\n589 |     &ast::Literal(Literal::Char('e')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:590:6\n    |\n590 |       &ast::Literal(Literal::Char('f')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n590 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n590 -     &ast::Literal(Literal::Char('f')),\n590 +     &Literal(Literal::Char('f')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:590:19\n    |\n590 |     &ast::Literal(Literal::Char('f')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:6\n    |\n591 |       &ast::Literal(Literal::Char('g')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n591 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n591 -     &ast::Literal(Literal::Char('g')),\n591 +     &Literal(Literal::Char('g')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |     &ast::Literal(Literal::Char('g')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:6\n    |\n592 |       &ast::Literal(Literal::Char('h')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n592 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n592 -     &ast::Literal(Literal::Char('h')),\n592 +     &Literal(Literal::Char('h')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:19\n    |\n592 |     &ast::Literal(Literal::Char('h')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `asts` and `span` in initializer of `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let ast = ast::Alternation { /* construct alternation node */ };\n    |               ^^^^^^^^^^^^^^^^ missing `asts` and `span`\n\nerror[E0063]: missing fields `asts` and `span` in initializer of `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:586:15\n    |\n586 |     let ast = ast::Alternation { /* construct alternation node */ };\n    |               ^^^^^^^^^^^^^^^^ missing `asts` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: cannot find macro `assert_matches` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:5\n    |\n599 |     assert_matches!(result, Some(Frame::Alternation { head, tail }) if head == &tail[0] && tail == &tail[1..]);\n    |     ^^^^^^^^^^^^^^\n    |\nhelp: consider importing this macro\n    |\n560 +    use std::assert_matches::assert_matches;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:10\n    |\n572 |           &ast::Literal(Literal::Char('d')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n572 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n572 -         &ast::Literal(Literal::Char('d')),\n572 +         &Literal(Literal::Char('d')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:23\n    |\n572 |         &ast::Literal(Literal::Char('d')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:10\n    |\n573 |           &ast::Literal(Literal::Char('e')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n573 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n573 -         &ast::Literal(Literal::Char('e')),\n573 +         &Literal(Literal::Char('e')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |         &ast::Literal(Literal::Char('e')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:10\n    |\n574 |           &ast::Literal(Literal::Char('f')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n574 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n574 -         &ast::Literal(Literal::Char('f')),\n574 +         &Literal(Literal::Char('f')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |         &ast::Literal(Literal::Char('f')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:575:10\n    |\n575 |           &ast::Literal(Literal::Char('g')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n575 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n575 -         &ast::Literal(Literal::Char('g')),\n575 +         &Literal(Literal::Char('g')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |         &ast::Literal(Literal::Char('g')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:10\n    |\n576 |           &ast::Literal(Literal::Char('h')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n576 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n576 -         &ast::Literal(Literal::Char('h')),\n576 +         &Literal(Literal::Char('h')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |         &ast::Literal(Literal::Char('h')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:6\n    |\n588 |       &ast::Literal(Literal::Char('d')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n588 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n588 -     &ast::Literal(Literal::Char('d')),\n588 +     &Literal(Literal::Char('d')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:19\n    |\n588 |     &ast::Literal(Literal::Char('d')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:6\n    |\n589 |       &ast::Literal(Literal::Char('e')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n589 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n589 -     &ast::Literal(Literal::Char('e')),\n589 +     &Literal(Literal::Char('e')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:19\n    |\n589 |     &ast::Literal(Literal::Char('e')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:590:6\n    |\n590 |       &ast::Literal(Literal::Char('f')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n590 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n590 -     &ast::Literal(Literal::Char('f')),\n590 +     &Literal(Literal::Char('f')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:590:19\n    |\n590 |     &ast::Literal(Literal::Char('f')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:6\n    |\n591 |       &ast::Literal(Literal::Char('g')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n591 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n591 -     &ast::Literal(Literal::Char('g')),\n591 +     &Literal(Literal::Char('g')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |     &ast::Literal(Literal::Char('g')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:6\n    |\n592 |       &ast::Literal(Literal::Char('h')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n592 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n592 -     &ast::Literal(Literal::Char('h')),\n592 +     &Literal(Literal::Char('h')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:19\n    |\n592 |     &ast::Literal(Literal::Char('h')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `asts` and `span` in initializer of `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let ast = ast::Alternation { /* construct alternation node */ };\n    |               ^^^^^^^^^^^^^^^^ missing `asts` and `span`\n\nerror[E0063]: missing fields `asts` and `span` in initializer of `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:586:15\n    |\n586 |     let ast = ast::Alternation { /* construct alternation node */ };\n    |               ^^^^^^^^^^^^^^^^ missing `asts` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = HeapVisitor::new();",
                "    let ast = ast::Alternation { /* construct alternation node */ };",
                "    ",
                "    let tail = vec![",
                "        &ast::Literal(Literal::Char('i')),",
                "        &ast::Literal(Literal::Char('j')),",
                "    ];",
                "    ",
                "    let induct = Frame::Alternation {",
                "        head: &tail[0],",
                "        tail: &tail[1..],",
                "    };",
                "    ",
                "    let result = visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('i')),",
                  "    &ast::Literal(Literal::Char('j')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('i')),",
                  "    &ast::Literal(Literal::Char('j')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    Frame::Alternation { head, tail } => {",
                  "    assert_eq!(head, &tail[0]);"
                ],
                [
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('i')),",
                  "    &ast::Literal(Literal::Char('j')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    Frame::Alternation { head, tail } => {",
                  "    assert_eq!(tail.len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    ",
                  "    let tail = vec![",
                  "        &ast::Literal(Literal::Char('i')),",
                  "        &ast::Literal(Literal::Char('j')),",
                  "    ];",
                  "    ",
                  "    let induct = Frame::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    ",
                  "    let result = visitor.pop(induct);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('i')),",
                  "    &ast::Literal(Literal::Char('j')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    ",
                  "    let tail = vec![",
                  "        &ast::Literal(Literal::Char('i')),",
                  "        &ast::Literal(Literal::Char('j')),",
                  "    ];",
                  "    ",
                  "    let induct = Frame::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    ",
                  "    let result = visitor.pop(induct);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('i')),",
                  "    &ast::Literal(Literal::Char('j')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    Frame::Alternation { head, tail } => {",
                  "    assert_eq!(head, &tail[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    ",
                  "    let tail = vec![",
                  "        &ast::Literal(Literal::Char('i')),",
                  "        &ast::Literal(Literal::Char('j')),",
                  "    ];",
                  "    ",
                  "    let induct = Frame::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    ",
                  "    let result = visitor.pop(induct);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('i')),",
                  "    &ast::Literal(Literal::Char('j')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    Frame::Alternation { head, tail } => {",
                  "    assert_eq!(tail.len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:10\n    |\n572 |           &ast::Literal(Literal::Char('i')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n572 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n572 -         &ast::Literal(Literal::Char('i')),\n572 +         &Literal(Literal::Char('i')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:23\n    |\n572 |         &ast::Literal(Literal::Char('i')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:10\n    |\n573 |           &ast::Literal(Literal::Char('j')),\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n573 |         &ast::Literal { span: val, kind: val, c: val },\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n573 -         &ast::Literal(Literal::Char('j')),\n573 +         &Literal(Literal::Char('j')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |         &ast::Literal(Literal::Char('j')),\n    |                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:6\n    |\n585 |       &ast::Literal(Literal::Char('i')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n585 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n585 -     &ast::Literal(Literal::Char('i')),\n585 +     &Literal(Literal::Char('i')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:19\n    |\n585 |     &ast::Literal(Literal::Char('i')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:6\n    |\n586 |       &ast::Literal(Literal::Char('j')),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n586 |     &ast::Literal { span: val, kind: val, c: val },\n    |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n586 -     &ast::Literal(Literal::Char('j')),\n586 +     &Literal(Literal::Char('j')),\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:19\n    |\n586 |     &ast::Literal(Literal::Char('j')),\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `asts` and `span` in initializer of `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let ast = ast::Alternation { /* construct alternation node */ };\n    |               ^^^^^^^^^^^^^^^^ missing `asts` and `span`\n\nerror[E0063]: missing fields `asts` and `span` in initializer of `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:583:15\n    |\n583 |     let ast = ast::Alternation { /* construct alternation node */ };\n    |               ^^^^^^^^^^^^^^^^ missing `asts` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0423, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:598:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n593 |     if let Some(frame) = result {\n    |                                 - unclosed delimiter\n594 |     match frame {\n595 |     Frame::Alternation { head, tail } => {\n    |                                          - this delimiter might not be properly closed...\n596 |     assert_eq!(head, &tail[0]);\n597 | }\n    | - ...as it matches this but it has different indentation\n598 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:598:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n593 |     if let Some(frame) = result {\n    |                                 - unclosed delimiter\n594 |     match frame {\n595 |     Frame::Alternation { head, tail } => {\n    |                                          - this delimiter might not be properly closed...\n596 |     assert_eq!(tail.len(), 1);\n597 | }\n    | - ...as it matches this but it has different indentation\n598 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = HeapVisitor::new();",
                "    let ast = ast::Alternation { /* construct alternation node */ };",
                "    ",
                "    let tail = vec![",
                "        &ast::Literal(Literal::Char('k')),",
                "        &ast::Literal(Literal::Char('l')),",
                "        &ast::Literal(Literal::Char('m')),",
                "        &ast::Literal(Literal::Char('n')),",
                "        &ast::Literal(Literal::Char('o')),",
                "        &ast::Literal(Literal::Char('p')),",
                "        &ast::Literal(Literal::Char('q')),",
                "        &ast::Literal(Literal::Char('r')),",
                "        &ast::Literal(Literal::Char('s')),",
                "        &ast::Literal(Literal::Char('t')),",
                "    ];",
                "    ",
                "    let induct = Frame::Alternation {",
                "        head: &tail[0],",
                "        tail: &tail[1..],",
                "    };",
                "    ",
                "    let result = visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('k')),",
                  "    &ast::Literal(Literal::Char('l')),",
                  "    &ast::Literal(Literal::Char('m')),",
                  "    &ast::Literal(Literal::Char('n')),",
                  "    &ast::Literal(Literal::Char('o')),",
                  "    &ast::Literal(Literal::Char('p')),",
                  "    &ast::Literal(Literal::Char('q')),",
                  "    &ast::Literal(Literal::Char('r')),",
                  "    &ast::Literal(Literal::Char('s')),",
                  "    &ast::Literal(Literal::Char('t')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('k')),",
                  "    &ast::Literal(Literal::Char('l')),",
                  "    &ast::Literal(Literal::Char('m')),",
                  "    &ast::Literal(Literal::Char('n')),",
                  "    &ast::Literal(Literal::Char('o')),",
                  "    &ast::Literal(Literal::Char('p')),",
                  "    &ast::Literal(Literal::Char('q')),",
                  "    &ast::Literal(Literal::Char('r')),",
                  "    &ast::Literal(Literal::Char('s')),",
                  "    &ast::Literal(Literal::Char('t')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert_eq!("
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    ",
                  "    let tail = vec![",
                  "        &ast::Literal(Literal::Char('k')),",
                  "        &ast::Literal(Literal::Char('l')),",
                  "        &ast::Literal(Literal::Char('m')),",
                  "        &ast::Literal(Literal::Char('n')),",
                  "        &ast::Literal(Literal::Char('o')),",
                  "        &ast::Literal(Literal::Char('p')),",
                  "        use ast::Literal; // Importing the type Literal",
                  "        &ast::Literal(Literal::Char('q')),",
                  "        &ast::Literal(Literal::Char('r')),",
                  "        &ast::Literal(Literal::Char('s')),",
                  "        &ast::Literal(Literal::Char('t')),",
                  "    ];",
                  "    ",
                  "    let induct = Frame::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    ",
                  "    let result = visitor.pop(induct);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('k')),",
                  "    &ast::Literal(Literal::Char('l')),",
                  "    &ast::Literal(Literal::Char('m')),",
                  "    &ast::Literal(Literal::Char('n')),",
                  "    &ast::Literal(Literal::Char('o')),",
                  "    &ast::Literal(Literal::Char('p')),",
                  "    use ast::Literal;  ",
                  "    &ast::Literal(Literal::Char('q')),  ",
                  "    &ast::Literal(Literal::Char('r')),  ",
                  "    &ast::Literal(Literal::Char('s')),",
                  "    &ast::Literal(Literal::Char('t')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    ",
                  "    let tail = vec![",
                  "        &ast::Literal(Literal::Char('k')),",
                  "        &ast::Literal(Literal::Char('l')),",
                  "        &ast::Literal(Literal::Char('m')),",
                  "        &ast::Literal(Literal::Char('n')),",
                  "        &ast::Literal(Literal::Char('o')),",
                  "        &ast::Literal(Literal::Char('p')),",
                  "        &ast::Literal(Literal::Char('q')),",
                  "        &ast::Literal(Literal::Char('r')),",
                  "        &ast::Literal(Literal::Char('s')),",
                  "        &ast::Literal(Literal::Char('t')),",
                  "    ];",
                  "    ",
                  "    let induct = Frame::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    ",
                  "    let result = visitor.pop(induct);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let ast = ast::Alternation { /* construct alternation node */ };",
                  "    let tail = vec![",
                  "    &ast::Literal(Literal::Char('k')),",
                  "    &ast::Literal(Literal::Char('l')),",
                  "    &ast::Literal(Literal::Char('m')),",
                  "    &ast::Literal(Literal::Char('n')),",
                  "    &ast::Literal(Literal::Char('o')),",
                  "    &ast::Literal(Literal::Char('p')),",
                  "    &ast::Literal(Literal::Char('q')),",
                  "    &ast::Literal(Literal::Char('r')),",
                  "    &ast::Literal(Literal::Char('s')),",
                  "    &ast::Literal(Literal::Char('t')),",
                  "    ];",
                  "    let induct = Frame::Alternation {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let result = visitor.pop(induct);",
                  "    assert_eq!(",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: no rules expected the token `use`\n   --> regex-syntax/src/ast/visitor.rs:578:9\n    |\n578 |         use ast::Literal; // Importing the type Literal\n    |         ^^^ no rules expected this token in macro call\n    |\nnote: while trying to match meta-variable `$x:expr`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs:49:8\n    |\n49  |     ($($x:expr),+ $(,)?) => (\n    |        ^^^^^^^\n\nerror: no rules expected the token `use`\n   --> regex-syntax/src/ast/visitor.rs:600:5\n    |\n600 |     use ast::Literal;  \n    |     ^^^ no rules expected this token in macro call\n    |\nnote: while trying to match meta-variable `$x:expr`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs:49:8\n    |\n49  |     ($($x:expr),+ $(,)?) => (\n    |        ^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `asts` and `span` in initializer of `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let ast = ast::Alternation { /* construct alternation node */ };\n    |               ^^^^^^^^^^^^^^^^ missing `asts` and `span`\n\nerror[E0063]: missing fields `asts` and `span` in initializer of `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:592:15\n    |\n592 |     let ast = ast::Alternation { /* construct alternation node */ };\n    |               ^^^^^^^^^^^^^^^^ missing `asts` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:609:15\n    |\n567 | {\n    | - closing delimiter possibly meant for this\n...\n609 |     assert_eq!(\n    |               ^ unclosed delimiter\n610 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: induct matches Frame::Concat { tail, .. } is true\n",
        "// constraint: induct matches Frame::Concat { tail, .. } is true\n",
        "// constraint: tail.is_empty() is true\n",
        "// expected return value/type: None\n"
      ],
      "input_infer": "test input ranges: Frame::Concat { tail: &[] }\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MyVisitor;",
                "",
                "    impl Visitor for MyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "",
                "    let tail: Vec<Ast> = Vec::new();",
                "    let frame = Frame::Concat {",
                "        head: &Ast::Empty(Span::new(0, 0)),",
                "        tail: &tail,",
                "    };",
                "",
                "    let visitor = MyVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    let result = heap_visitor.pop(frame);",
                "}"
              ],
              "oracles": [
                [
                  "    let tail: Vec<Ast> = Vec::new();",
                  "    let frame = Frame::Concat {",
                  "    head: &Ast::Empty(Span::new(0, 0)),",
                  "    tail: &tail,",
                  "    };",
                  "    assert_eq!(heap_visitor.pop(frame), None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MyVisitor;",
                  "",
                  "    impl Visitor for MyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let tail: Vec<Ast> = Vec::new();",
                  "    let frame = Frame::Concat {",
                  "        head: &Ast::Empty(Span::new(0, 0)),",
                  "        tail: &tail,",
                  "    };",
                  "",
                  "    let visitor = MyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.pop(frame);",
                  "    let tail: Vec<Ast> = Vec::new();",
                  "    let frame = Frame::Concat {",
                  "    head: &Ast::Empty(Span::new(0, 0)),",
                  "    tail: &tail,",
                  "    };",
                  "    assert_eq!(heap_visitor.pop(frame), None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:27\n    |\n577 |         head: &Ast::Empty(Span::new(0, 0)),\n    |                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     head: &Ast::Empty(Span::new(0, 0)),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for MyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:590:5\n    |\n590 |     assert_eq!(heap_visitor.pop(frame), None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:590:5\n    |\n590 |     assert_eq!(heap_visitor.pop(frame), None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MyVisitor;",
                "",
                "    impl Visitor for MyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "",
                "    let tail: Vec<Ast> = Vec::new();",
                "    let frame = Frame::Alternation {",
                "        head: &Ast::Empty(Span::new(0, 0)),",
                "        tail: &tail,",
                "    };",
                "",
                "    let visitor = MyVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    let result = heap_visitor.pop(frame);",
                "}"
              ],
              "oracles": [
                [
                  "    let tail: Vec<Ast> = Vec::new();",
                  "    let frame = Frame::Concat {",
                  "    head: &Ast::Empty(Span::new(0, 0)),",
                  "    tail: &tail,",
                  "    };",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MyVisitor;",
                  "",
                  "    impl Visitor for MyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let tail: Vec<Ast> = Vec::new();",
                  "    let frame = Frame::Alternation {",
                  "        head: &Ast::Empty(Span::new(0, 0)),",
                  "        tail: &tail,",
                  "    };",
                  "",
                  "    let visitor = MyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.pop(frame);",
                  "    let tail: Vec<Ast> = Vec::new();",
                  "    let frame = Frame::Concat {",
                  "    head: &Ast::Empty(Span::new(0, 0)),",
                  "    tail: &tail,",
                  "    };",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:27\n    |\n577 |         head: &Ast::Empty(Span::new(0, 0)),\n    |                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     head: &Ast::Empty(Span::new(0, 0)),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for MyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:590:5\n    |\n590 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:590:5\n    |\n590 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: induct matches Frame::Concat { tail, .. } is true\n",
        "// constraint: induct matches Frame::Concat { tail, .. } is true\n",
        "// constraint: tail.is_empty() is false\n",
        "// constraint: tail[1..] is \n",
        "// expected return value/type: Some(Frame::Concat {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n"
      ],
      "input_infer": "test input ranges: induct containing at least 2 elements in tail of type Ast, where tail has a length ranging from 2 to N (N being an arbitrary positive integer representing the size of the remaining elements)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast1 = Ast::Literal(Literal(\"a\".into()));",
                "    let ast2 = Ast::Literal(Literal(\"b\".into()));",
                "    let tail: Vec<Ast> = vec![ast1, ast2];",
                "    let induct = Frame::Concat {",
                "        head: &tail[0],",
                "        tail: &tail,",
                "    };",
                "    ",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast1 = Ast::Literal(Literal(\"a\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"b\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2];",
                  "    let induct = Frame::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail,",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let ast1 = Ast::Literal(Literal(\"a\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"b\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2];",
                  "    let induct = Frame::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail,",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(head, &tail[0]);"
                ],
                [
                  "    let ast1 = Ast::Literal(Literal(\"a\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"b\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2];",
                  "    let induct = Frame::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail,",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(tail.len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast1 = Ast::Literal(Literal(\"a\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"b\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2];",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let ast1 = Ast::Literal(Literal(\"a\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"b\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2];",
                  "    let induct = Frame::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail,",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let ast1 = Ast::Literal(Literal(\"a\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"b\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2];",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let ast1 = Ast::Literal(Literal(\"a\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"b\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2];",
                  "    let induct = Frame::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail,",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(head, &tail[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let ast1 = Ast::Literal(Literal(\"a\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"b\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2];",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let ast1 = Ast::Literal(Literal(\"a\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"b\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2];",
                  "    let induct = Frame::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail,",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(tail.len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let ast1 = Ast::Literal(Literal(\"a\".into()));\n    |                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:29\n    |\n569 |     let ast2 = Ast::Literal(Literal(\"b\".into()));\n    |                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:29\n    |\n578 |     let ast1 = Ast::Literal(Literal(\"a\".into()));\n    |                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:29\n    |\n579 |     let ast2 = Ast::Literal(Literal(\"b\".into()));\n    |                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:590:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n590 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:590:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n590 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                "    let induct = Frame::Concat {",
                "        head: &tail[0],",
                "        tail: &tail,",
                "    };",
                "    ",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(head, &tail[0]);"
                ],
                [
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(tail.len(), 3);"
                ],
                [
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(tail[0], ast2);"
                ],
                [
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(tail[1], ast3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(head, &tail[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(tail.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(tail[0], ast2);",
                  "}"
                ],
                [
                  "{",
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let ast1 = Ast::Literal(Literal(\"x\".into()));",
                  "    let ast2 = Ast::Literal(Literal(\"y\".into()));",
                  "    let ast3 = Ast::Literal(Literal(\"z\".into()));",
                  "    let tail: Vec<Ast> = vec![ast1, ast2, ast3];",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    if let Some(Frame::Concat { head, tail }) = result {",
                  "    assert_eq!(tail[1], ast3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let ast1 = Ast::Literal(Literal(\"x\".into()));\n    |                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:29\n    |\n569 |     let ast2 = Ast::Literal(Literal(\"y\".into()));\n    |                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:29\n    |\n570 |     let ast3 = Ast::Literal(Literal(\"z\".into()));\n    |                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:29\n    |\n579 |     let ast1 = Ast::Literal(Literal(\"x\".into()));\n    |                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:29\n    |\n580 |     let ast2 = Ast::Literal(Literal(\"y\".into()));\n    |                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:29\n    |\n581 |     let ast3 = Ast::Literal(Literal(\"z\".into()));\n    |                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:589:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n589 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:589:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n589 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:589:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n589 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:589:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n589 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let tail: Vec<Ast> = (0..10)",
                "        .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))",
                "        .collect();",
                "    let induct = Frame::Concat {",
                "        head: &tail[0],",
                "        tail: &tail,",
                "    };",
                "    ",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let popped_frame = result.unwrap();",
                  "    assert_matches!(popped_frame, Frame::Concat { head, tail });"
                ],
                [
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let popped_frame = result.unwrap();",
                  "    assert_eq!(head, &tail[0]);"
                ],
                [
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let popped_frame = result.unwrap();",
                  "    assert_eq!(tail.len(), 9);"
                ],
                [
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let popped_frame = result.unwrap();",
                  "    assert_eq!(tail[0], &tail[1]);"
                ],
                [
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let popped_frame = result.unwrap();",
                  "    assert_eq!(tail[1..], &tail[2..]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let tail: Vec<Ast> = (0..10)",
                  "        .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))",
                  "        .collect();",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let tail: Vec<Ast> = (0..10)",
                  "        .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))",
                  "        .collect();",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let popped_frame = result.unwrap();",
                  "    assert_matches!(popped_frame, Frame::Concat { head, tail });",
                  "}"
                ],
                [
                  "{",
                  "    let tail: Vec<Ast> = (0..10)",
                  "        .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))",
                  "        .collect();",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let popped_frame = result.unwrap();",
                  "    assert_eq!(head, &tail[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let tail: Vec<Ast> = (0..10)",
                  "        .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))",
                  "        .collect();",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let popped_frame = result.unwrap();",
                  "    assert_eq!(tail.len(), 9);",
                  "}"
                ],
                [
                  "{",
                  "    let tail: Vec<Ast> = (0..10)",
                  "        .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))",
                  "        .collect();",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let popped_frame = result.unwrap();",
                  "    assert_eq!(tail[0], tail[1]);  ",
                  "}"
                ],
                [
                  "{",
                  "    let tail: Vec<Ast> = (0..10)",
                  "        .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))",
                  "        .collect();",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();",
                  "    let induct = Frame::Concat { head: &tail[0], tail: &tail };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let popped_frame = result.unwrap();",
                  "    assert_eq!(tail[1..], &tail[2..]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |         .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))\n    |                               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:55\n    |\n578 |     let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: cannot find macro `assert_matches` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n583 |     assert_matches!(popped_frame, Frame::Concat { head, tail });\n    |     ^^^^^^^^^^^^^^\n    |\nhelp: consider importing this macro\n    |\n560 +    use std::assert_matches::assert_matches;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |         .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))\n    |                               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:55\n    |\n578 |     let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |         .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))\n    |                               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:55\n    |\n578 |     let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `head` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:16\n    |\n583 |     assert_eq!(head, &tail[0]);\n    |                ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |         .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))\n    |                               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:55\n    |\n578 |     let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |         .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))\n    |                               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:55\n    |\n578 |     let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |         .map(|i| Ast::Literal(Literal(format!(\"element{}\", i))))\n    |                               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:55\n    |\n578 |     let tail: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal(format!(\"element{}\", i)))).collect();\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: can't compare `[ast::Ast]` with `&[ast::Ast]`\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n583 |     assert_eq!(tail[1..], &tail[2..]);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `[ast::Ast] == &[ast::Ast]`\n    |\n    = help: the trait `PartialEq<&[ast::Ast]>` is not implemented for `[ast::Ast]`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider dereferencing here\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:40:35\n    |\n40  |                 if !(*left_val == **right_val) {\n    |                                   +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let tail: Vec<Ast> = (0..100)",
                "        .map(|i| Ast::Literal(Literal(format!(\"char{}\", i))))",
                "        .collect();",
                "    let induct = Frame::Concat {",
                "        head: &tail[0],",
                "        tail: &tail,",
                "    };",
                "    ",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let tail: Vec<Ast> = (0..100)",
                  "    .map(|i| Ast::Literal(Literal(format!(\"char{}\", i))))",
                  "    .collect();",
                  "    let induct = Frame::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail,",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let tail: Vec<Ast> = (0..100)",
                  "    .map(|i| Ast::Literal(Literal(format!(\"char{}\", i))))",
                  "    .collect();",
                  "    let induct = Frame::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail,",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    assert_eq!(result.unwrap(), Frame::Concat {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let tail: Vec<Ast> = (0..100)",
                  "        .map(|i| Ast::Literal(Literal(format!(\"char{}\", i))))",
                  "        .collect();",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let tail: Vec<Ast> = (0..100)",
                  "    .map(|i| Ast::Literal(Literal(format!(\"char{}\", i))))",
                  "    .collect();",
                  "    let induct = Frame::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail,",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let tail: Vec<Ast> = (0..100)",
                  "        .map(|i| Ast::Literal(Literal(format!(\"char{}\", i))))",
                  "        .collect();",
                  "    let induct = Frame::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail,",
                  "    };",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    let tail: Vec<Ast> = (0..100)",
                  "    .map(|i| Ast::Literal(Literal(format!(\"char{}\", i))))",
                  "    .collect();",
                  "    let induct = Frame::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail,",
                  "    };",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(induct);",
                  "    assert_eq!(result.unwrap(), Frame::Concat {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |         .map(|i| Ast::Literal(Literal(format!(\"char{}\", i))))\n    |                               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:27\n    |\n579 |     .map(|i| Ast::Literal(Literal(format!(\"char{}\", i))))\n    |                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:587:15\n    |\n567 | {\n    | - closing delimiter possibly meant for this\n...\n587 |     assert_eq!(result.unwrap(), Frame::Concat {\n    |               ^ unclosed delimiter\n588 | }\n589 | }\n    | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:589:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n589 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: induct matches Frame::Group(_) is true\n",
        "// constraint: induct matches Frame::Group(_) is true\n",
        "// expected return value/type: None\n"
      ],
      "input_infer": "Frame::Group(&ast::Group) where ast::Group has a size of 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "",
                "    let ast_group = ast::Group {",
                "        // Initialize with relevant fields to represent an empty group",
                "        children: Vec::new(), // Assuming children represents the content of the group.",
                "        span: Span::new(0, 0), // Initialize with an empty span",
                "    };",
                "",
                "    let induct = Frame::Group(&ast_group);",
                "    let visitor = &mut DummyVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    let result = heap_visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let induct = Frame::Group(&ast_group);",
                  "    let visitor = &mut DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.pop(induct);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast_group = ast::Group {",
                  "        // Initialize with relevant fields to represent an empty group",
                  "        children: Vec::new(), // Assuming children represents the content of the group.",
                  "        span: Span::new(0, 0), // Initialize with an empty span",
                  "    };",
                  "",
                  "    let induct = Frame::Group(&ast_group);",
                  "    let visitor = &mut DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.pop(induct);",
                  "    let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let induct = Frame::Group(&ast_group);",
                  "    let visitor = &mut DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.pop(induct);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:15\n    |\n578 |         span: Span::new(0, 0), // Initialize with an empty span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:586:62\n    |\n586 |     let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Group` has no field named `children`\n   --> regex-syntax/src/ast/visitor.rs:577:9\n    |\n577 |         children: Vec::new(), // Assuming children represents the content of the group.\n    |         ^^^^^^^^ `ast::Group` does not have this field\n    |\n    = note: available fields are: `kind`, `ast`\n\nerror[E0560]: struct `ast::Group` has no field named `children`\n   --> regex-syntax/src/ast/visitor.rs:586:34\n    |\n586 |     let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };\n    |                                  ^^^^^^^^ `ast::Group` does not have this field\n    |\n    = note: available fields are: `kind`, `ast`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:591:5\n    |\n591 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:591:5\n    |\n591 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0433, E0560.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "",
                "    let ast_group = ast::Group {",
                "        // Initialize with relevant fields to represent an empty group",
                "        children: Vec::new(),",
                "        span: Span::new(0, 0),",
                "    };",
                "",
                "    let child_nodes: Vec<Ast> = Vec::new(); // Empty tail",
                "",
                "    let induct = Frame::Concat { head: &Ast::Group(ast_group), tail: &child_nodes };",
                "    let visitor = &mut DummyVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    let result = heap_visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let induct = Frame::Group(&ast_group);",
                  "    let result = heap_visitor.pop(induct);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast_group = ast::Group {",
                  "        // Initialize with relevant fields to represent an empty group",
                  "        children: Vec::new(),",
                  "        span: Span::new(0, 0),",
                  "    };",
                  "",
                  "    let child_nodes: Vec<Ast> = Vec::new(); // Empty tail",
                  "",
                  "    let induct = Frame::Concat { head: &Ast::Group(ast_group), tail: &child_nodes };",
                  "    let visitor = &mut DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.pop(induct);",
                  "    let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let induct = Frame::Group(&ast_group);",
                  "    let result = heap_visitor.pop(induct);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:15\n    |\n578 |         span: Span::new(0, 0),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:588:62\n    |\n588 |     let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Group` has no field named `children`\n   --> regex-syntax/src/ast/visitor.rs:577:9\n    |\n577 |         children: Vec::new(),\n    |         ^^^^^^^^ `ast::Group` does not have this field\n    |\n    = note: available fields are: `kind`, `ast`\n\nerror[E0560]: struct `ast::Group` has no field named `children`\n   --> regex-syntax/src/ast/visitor.rs:588:34\n    |\n588 |     let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };\n    |                                  ^^^^^^^^ `ast::Group` does not have this field\n    |\n    = note: available fields are: `kind`, `ast`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:591:5\n    |\n591 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:591:5\n    |\n591 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0433, E0560.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "",
                "    let ast_group = ast::Group {",
                "        // Initialize with relevant fields to represent an empty group",
                "        children: Vec::new(),",
                "        span: Span::new(0, 0),",
                "    };",
                "",
                "    let child_nodes: Vec<Ast> = Vec::new(); // Empty tail",
                "",
                "    let induct = Frame::Alternation { head: &Ast::Group(ast_group), tail: &child_nodes };",
                "    let visitor = &mut DummyVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    let result = heap_visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let child_nodes: Vec<Ast> = Vec::new();",
                  "    let induct = Frame::Group(&ast_group);",
                  "    let visitor = &mut DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.pop(induct);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast_group = ast::Group {",
                  "        // Initialize with relevant fields to represent an empty group",
                  "        children: Vec::new(),",
                  "        span: Span::new(0, 0),",
                  "    };",
                  "",
                  "    let child_nodes: Vec<Ast> = Vec::new(); // Empty tail",
                  "",
                  "    let induct = Frame::Alternation { head: &Ast::Group(ast_group), tail: &child_nodes };",
                  "    let visitor = &mut DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.pop(induct);",
                  "    let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let child_nodes: Vec<Ast> = Vec::new();",
                  "    let induct = Frame::Group(&ast_group);",
                  "    let visitor = &mut DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.pop(induct);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:15\n    |\n578 |         span: Span::new(0, 0),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:588:62\n    |\n588 |     let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Group` has no field named `children`\n   --> regex-syntax/src/ast/visitor.rs:577:9\n    |\n577 |         children: Vec::new(),\n    |         ^^^^^^^^ `ast::Group` does not have this field\n    |\n    = note: available fields are: `kind`, `ast`\n\nerror[E0560]: struct `ast::Group` has no field named `children`\n   --> regex-syntax/src/ast/visitor.rs:588:34\n    |\n588 |     let ast_group = ast::Group { children: Vec::new(), span: Span::new(0, 0) };\n    |                                  ^^^^^^^^ `ast::Group` does not have this field\n    |\n    = note: available fields are: `kind`, `ast`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:594:5\n    |\n594 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:594:5\n    |\n594 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0433, E0560.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "",
                "    let ast_group_1 = ast::Group {",
                "        children: Vec::new(),",
                "        span: Span::new(0, 0),",
                "    };",
                "",
                "    let ast_group_2 = ast::Group {",
                "        children: Vec::new(),",
                "        span: Span::new(0, 0),",
                "    };",
                "",
                "    let child_nodes: Vec<Ast> = vec![Ast::Group(ast_group_2)]; // Non-empty tail",
                "",
                "    let induct = Frame::Concat { head: &Ast::Group(ast_group_1), tail: &child_nodes };",
                "    let visitor = &mut DummyVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    let result = heap_visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast_group_1 = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let ast_group_2 = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let child_nodes: Vec<Ast> = vec![Ast::Group(ast_group_2)];",
                  "    let induct = Frame::Group(&ast_group_1);",
                  "    let result = heap_visitor.pop(induct);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast_group_1 = ast::Group {",
                  "        children: Vec::new(),",
                  "        span: Span::new(0, 0),",
                  "    };",
                  "",
                  "    let ast_group_2 = ast::Group {",
                  "        children: Vec::new(),",
                  "        span: Span::new(0, 0),",
                  "    };",
                  "",
                  "    let child_nodes: Vec<Ast> = vec![Ast::Group(ast_group_2)]; // Non-empty tail",
                  "",
                  "    let induct = Frame::Concat { head: &Ast::Group(ast_group_1), tail: &child_nodes };",
                  "    let visitor = &mut DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.pop(induct);",
                  "    let ast_group_1 = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "",
                  "    let child_nodes: Vec<Ast> = vec![Ast::Group(ast_group_2)];",
                  "    let induct = Frame::Group(&ast_group_1);",
                  "    let result = heap_visitor.pop(induct);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:15\n    |\n577 |         span: Span::new(0, 0),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:15\n    |\n582 |         span: Span::new(0, 0),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let ast_group_1 = ast::Group { children: Vec::new(), span: Span::new(0, 0) };\n    |                                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Group` has no field named `children`\n   --> regex-syntax/src/ast/visitor.rs:576:9\n    |\n576 |         children: Vec::new(),\n    |         ^^^^^^^^ `ast::Group` does not have this field\n    |\n    = note: available fields are: `kind`, `ast`\n\nerror[E0560]: struct `ast::Group` has no field named `children`\n   --> regex-syntax/src/ast/visitor.rs:581:9\n    |\n581 |         children: Vec::new(),\n    |         ^^^^^^^^ `ast::Group` does not have this field\n    |\n    = note: available fields are: `kind`, `ast`\n\nerror[E0560]: struct `ast::Group` has no field named `children`\n   --> regex-syntax/src/ast/visitor.rs:592:36\n    |\n592 |     let ast_group_1 = ast::Group { children: Vec::new(), span: Span::new(0, 0) };\n    |                                    ^^^^^^^^ `ast::Group` does not have this field\n    |\n    = note: available fields are: `kind`, `ast`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:597:5\n    |\n597 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:597:5\n    |\n597 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0433, E0560.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "",
                "    let ast_group_1 = ast::Group {",
                "        children: Vec::new(),",
                "        span: Span::new(0, 0),",
                "    };",
                "",
                "    let ast_group_2 = ast::Group {",
                "        children: Vec::new(),",
                "        span: Span::new(0, 0),",
                "    };",
                "",
                "    let child_nodes: Vec<Ast> = vec![Ast::Group(ast_group_2)]; // Non-empty tail",
                "",
                "    let induct = Frame::Alternation { head: &Ast::Group(ast_group_1), tail: &child_nodes };",
                "    let visitor = &mut DummyVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    let result = heap_visitor.pop(induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast_group_1 = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let ast_group_2 = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let child_nodes: Vec<Ast> = vec![Ast::Group(ast_group_2)];",
                  "    let induct = Frame::Group(&ast_group_1);",
                  "    let heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.pop(induct);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast_group_1 = ast::Group {",
                  "        children: Vec::new(),",
                  "        span: Span::new(0, 0),",
                  "    };",
                  "",
                  "    let ast_group_2 = ast::Group {",
                  "        children: Vec::new(),",
                  "        span: Span::new(0, 0),",
                  "    };",
                  "",
                  "    let child_nodes: Vec<Ast> = vec![Ast::Group(ast_group_2)]; // Non-empty tail",
                  "",
                  "    let induct = Frame::Alternation { head: &Ast::Group(ast_group_1), tail: &child_nodes };",
                  "    let visitor = &mut DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.pop(induct);",
                  "    let ast_group_1 = ast::Group { kind: /* appropriate kind */, ast: /* appropriate ast */ };",
                  "    let ast_group_2 = ast::Group { children: Vec::new(), span: Span::new(0, 0) };",
                  "    let child_nodes: Vec<Ast> = vec![Ast::Group(ast_group_2)];",
                  "    let induct = Frame::Group(&ast_group_1);",
                  "    let heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.pop(induct);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `,`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let ast_group_1 = ast::Group { kind: /* appropriate kind */, ast: /* appropriate ast */ };\n    |                       ---------- while parsing this struct     ^ expected expression\n\nerror: expected expression, found `}`\n   --> regex-syntax/src/ast/visitor.rs:592:93\n    |\n592 |     let ast_group_1 = ast::Group { kind: /* appropriate kind */, ast: /* appropriate ast */ };\n    |                       ---------- while parsing this struct                                  ^ expected expression\n\nerror: expected expression\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let ast_group_1 = ast::Group { kind: /* appropriate kind */, ast: /* appropriate ast */ };\n    |                                                                ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/ast/visitor.rs:560:8\n    |\n560 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_pop_23` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:1\n    |\n566 | / fn test_pop_23()\n567 | | {\n568 | |     struct DummyVisitor;\n...   |\n598 | |     assert_eq!(result, None);\n599 | | }\n    | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: induct matches Frame::Repetition(_) is true\n",
        "// constraint: induct matches Frame::Repetition(_) is true\n",
        "// expected return value/type: None\n"
      ],
      "input_infer": "induct: Frame::Repetition(&ast::Repetition), return: None\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockVisitor;",
                "",
                "    impl Visitor for MockVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "",
                "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let repetition = ast::Repetition; // Need to instantiate a repetition node.",
                "    let frame = Frame::Repetition(&repetition);",
                "    ",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.pop(frame);",
                "}"
              ],
              "oracles": [
                [
                  "    let repetition = ast::Repetition;",
                  "    let frame = Frame::Repetition(&repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    assert!(result.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let repetition = ast::Repetition; // Need to instantiate a repetition node.",
                  "    let frame = Frame::Repetition(&repetition);",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let repetition = ast::Repetition;",
                  "    let frame = Frame::Repetition(&repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    assert!(result.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:574:9\n    |\n574 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n575 | |             Ok(())\n576 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Repetition`\n    --> regex-syntax/src/ast/visitor.rs:579:22\n     |\n579  |       let repetition = ast::Repetition; // Need to instantiate a repetition node.\n     |                        ^^^^^^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | / pub struct Repetition {\n1128 | |     /// The span of this operation.\n1129 | |     pub span: Span,\n1130 | |     /// The actual operation.\n...    |\n1135 | |     pub ast: Box<Ast>,\n1136 | | }\n     | |_- `ast::Repetition` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n579  |     let repetition = ast::Repetition { span: val, op: val, greedy: val, ast: val }; // Need to instantiate a repetition node.\n     |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Repetition;\n     |\n560  +    use ast::visitor::Frame::Repetition;\n     |\n560  +    use hir::HirKind::Repetition;\n     |\nhelp: if you import `Repetition`, refer to it directly\n     |\n579  -     let repetition = ast::Repetition; // Need to instantiate a repetition node.\n579  +     let repetition = Repetition; // Need to instantiate a repetition node.\n     |\n\nerror[E0423]: expected value, found struct `ast::Repetition`\n    --> regex-syntax/src/ast/visitor.rs:584:22\n     |\n584  |       let repetition = ast::Repetition;\n     |                        ^^^^^^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | / pub struct Repetition {\n1128 | |     /// The span of this operation.\n1129 | |     pub span: Span,\n1130 | |     /// The actual operation.\n...    |\n1135 | |     pub ast: Box<Ast>,\n1136 | | }\n     | |_- `ast::Repetition` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n584  |     let repetition = ast::Repetition { span: val, op: val, greedy: val, ast: val };\n     |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Repetition;\n     |\n560  +    use ast::visitor::Frame::Repetition;\n     |\n560  +    use hir::HirKind::Repetition;\n     |\nhelp: if you import `Repetition`, refer to it directly\n     |\n584  -     let repetition = ast::Repetition;\n584  +     let repetition = Repetition;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0407, E0423.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockVisitor;",
                "",
                "    impl Visitor for MockVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "",
                "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let group = ast::Group; // Need to instantiate a group node.",
                "    let frame = Frame::Group(&group);",
                "    ",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.pop(frame);",
                "}"
              ],
              "oracles": [
                [
                  "    let group = ast::Group;",
                  "    let frame = Frame::Repetition(&group);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let group = ast::Group; // Need to instantiate a group node.",
                  "    let frame = Frame::Group(&group);",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let group = ast::Group;",
                  "    let frame = Frame::Repetition(&group);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "#[derive(Debug)]  ",
                  "struct Visitor {}  ",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0404]: expected trait, found struct `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:570:10\n    |\n33  | pub trait Visitor {\n    |           ------- you might have meant to refer to this trait\n...\n570 |     impl Visitor for MockVisitor {\n    |          ^^^^^^^ not a trait\n\nerror[E0423]: expected value, found struct `ast::Group`\n    --> regex-syntax/src/ast/visitor.rs:579:17\n     |\n579  |       let group = ast::Group; // Need to instantiate a group node.\n     |                   ^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1192:1\n     |\n1192 | / pub struct Group {\n1193 | |     /// The span of this group.\n1194 | |     pub span: Span,\n1195 | |     /// The kind of this group.\n...    |\n1198 | |     pub ast: Box<Ast>,\n1199 | | }\n     | |_- `ast::Group` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n579  |     let group = ast::Group { span: val, kind: val, ast: val }; // Need to instantiate a group node.\n     |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Group;\n     |\n560  +    use ast::visitor::Frame::Group;\n     |\n560  +    use hir::HirKind::Group;\n     |\nhelp: if you import `Group`, refer to it directly\n     |\n579  -     let group = ast::Group; // Need to instantiate a group node.\n579  +     let group = Group; // Need to instantiate a group node.\n     |\n\nerror[E0423]: expected value, found struct `ast::Group`\n    --> regex-syntax/src/ast/visitor.rs:584:17\n     |\n584  |       let group = ast::Group;\n     |                   ^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1192:1\n     |\n1192 | / pub struct Group {\n1193 | |     /// The span of this group.\n1194 | |     pub span: Span,\n1195 | |     /// The kind of this group.\n...    |\n1198 | |     pub ast: Box<Ast>,\n1199 | | }\n     | |_- `ast::Group` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n584  |     let group = ast::Group { span: val, kind: val, ast: val };\n     |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Group;\n     |\n560  +    use ast::visitor::Frame::Group;\n     |\n560  +    use hir::HirKind::Group;\n     |\nhelp: if you import `Group`, refer to it directly\n     |\n584  -     let group = ast::Group;\n584  +     let group = Group;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nSome errors have detailed explanations: E0404, E0423.\nFor more information about an error, try `rustc --explain E0404`.\nwarning: `regex-syntax` (lib test) generated 14 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockVisitor;",
                "",
                "    impl Visitor for MockVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "",
                "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let concat = ast::Concat {",
                "        head: &Ast::Empty(ast::Span),",
                "        tail: &[],",
                "    };",
                "    let frame = Frame::Concat {",
                "        head: &concat.head,",
                "        tail: &concat.tail,",
                "    };",
                "",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.pop(frame);",
                "}"
              ],
              "oracles": [
                [
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);"
                ],
                [
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);"
                ],
                [
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Empty(ast::Span)];",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, Some(Frame::Concat { head: &tail[0], tail: &tail[1..] }));"
                ],
                [
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Empty(ast::Span)];",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, Some(Frame::Alternation { head: &tail[0], tail: &tail[1..] }));"
                ],
                [
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Empty(ast::Span)];",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);"
                ],
                [
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Empty(ast::Span)];",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let concat = ast::Concat {",
                  "        asts: vec![Ast::Empty(ast::Span)],",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "        head: &concat.head,",
                  "        tail: &concat.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let concat = ast::Concat {",
                  "          head: &Ast::Empty(ast::Span { start: /* value */, end: /* value */ }),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "        head: &concat.head,",
                  "        tail: &concat.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let concat = ast::Concat {",
                  "        head: &Ast::Empty(ast::Span),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "        head: &concat.head,",
                  "        tail: &concat.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Empty(ast::Span)];",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, Some(Frame::Concat { head: &tail[0], tail: &tail[1..] }));",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let concat = ast::Concat {",
                  "        head: &Ast::Empty(ast::Span),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "        head: &concat.head,",
                  "        tail: &concat.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Empty(ast::Span)];",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, Some(Frame::Alternation { head: &tail[0], tail: &tail[1..] }));",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let concat = ast::Concat {",
                  "        head: &Ast::Empty(ast::Span),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "        head: &concat.head,",
                  "        tail: &concat.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "      let concat = ast::Concat { span: ast::Span { start: /* value */, end: /* value */ }, asts: vec![Ast::Empty(ast::Span { start: /* value */, end: /* value */ })] };  ",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Empty(ast::Span)];",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let concat = ast::Concat {",
                  "        head: &Ast::Empty(ast::Span),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "        head: &concat.head,",
                  "        tail: &concat.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Empty(ast::Span)];",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &tail };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result = visitor.pop(frame);",
                  "    let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result = visitor.pop(frame);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:574:9\n    |\n574 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n575 | |             Ok(())\n576 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:580:31\n    |\n580 |           asts: vec![Ast::Empty(ast::Span)],\n    |                                 ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:590:50\n    |\n590 |       let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                    ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Repetition`\n    --> regex-syntax/src/ast/visitor.rs:591:36\n     |\n591  |       let frame = Frame::Repetition(&ast::Repetition);\n     |                                      ^^^^^^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | / pub struct Repetition {\n1128 | |     /// The span of this operation.\n1129 | |     pub span: Span,\n1130 | |     /// The actual operation.\n...    |\n1135 | |     pub ast: Box<Ast>,\n1136 | | }\n     | |_- `ast::Repetition` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n591  |     let frame = Frame::Repetition(&ast::Repetition { span: val, op: val, greedy: val, ast: val });\n     |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Repetition;\n     |\n560  +    use ast::visitor::Frame::Repetition;\n     |\n560  +    use hir::HirKind::Repetition;\n     |\nhelp: if you import `Repetition`, refer to it directly\n     |\n591  -     let frame = Frame::Repetition(&ast::Repetition);\n591  +     let frame = Frame::Repetition(&Repetition);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:581:9\n    |\n581 |         tail: &[],\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`\n\nerror[E0609]: no field `head` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:584:23\n    |\n584 |         head: &concat.head,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |         tail: &concat.tail,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:590:62\n    |\n590 |     let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                              ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:594:5\n    |\n594 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:594:5\n    |\n594 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0407, E0423, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `,`\n   --> regex-syntax/src/ast/visitor.rs:580:59\n    |\n580 |           head: &Ast::Empty(ast::Span { start: /* value */, end: /* value */ }),\n    |                             ---------                     ^ expected expression\n    |                             |\n    |                             while parsing this struct\n\nerror: expected expression, found `}`\n   --> regex-syntax/src/ast/visitor.rs:580:78\n    |\n580 |           head: &Ast::Empty(ast::Span { start: /* value */, end: /* value */ }),\n    |                             --------- while parsing this struct              ^ expected expression\n\nerror: expected expression\n   --> regex-syntax/src/ast/visitor.rs:580:59\n    |\n580 |           head: &Ast::Empty(ast::Span { start: /* value */, end: /* value */ }),\n    |                                                           ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/ast/visitor.rs:560:8\n    |\n560 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_pop_27` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:1\n    |\n566 | / fn test_pop_27()\n567 | | {\n568 | |     struct MockVisitor;\n...   |\n596 | |     assert_eq!(result, None);\n597 | | }\n    | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:574:9\n    |\n574 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n575 | |             Ok(())\n576 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:580:27\n    |\n580 |           head: &Ast::Empty(ast::Span),\n    |                             ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:590:50\n    |\n590 |       let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                    ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Repetition`\n    --> regex-syntax/src/ast/visitor.rs:591:36\n     |\n591  |       let frame = Frame::Repetition(&ast::Repetition);\n     |                                      ^^^^^^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | / pub struct Repetition {\n1128 | |     /// The span of this operation.\n1129 | |     pub span: Span,\n1130 | |     /// The actual operation.\n...    |\n1135 | |     pub ast: Box<Ast>,\n1136 | | }\n     | |_- `ast::Repetition` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n591  |     let frame = Frame::Repetition(&ast::Repetition { span: val, op: val, greedy: val, ast: val });\n     |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Repetition;\n     |\n560  +    use ast::visitor::Frame::Repetition;\n     |\n560  +    use hir::HirKind::Repetition;\n     |\nhelp: if you import `Repetition`, refer to it directly\n     |\n591  -     let frame = Frame::Repetition(&ast::Repetition);\n591  +     let frame = Frame::Repetition(&Repetition);\n     |\n\nerror[E0423]: expected value, found struct `ast::Group`\n    --> regex-syntax/src/ast/visitor.rs:594:31\n     |\n594  |       let frame = Frame::Group(&ast::Group);\n     |                                 ^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1192:1\n     |\n1192 | / pub struct Group {\n1193 | |     /// The span of this group.\n1194 | |     pub span: Span,\n1195 | |     /// The kind of this group.\n...    |\n1198 | |     pub ast: Box<Ast>,\n1199 | | }\n     | |_- `ast::Group` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n594  |     let frame = Frame::Group(&ast::Group { span: val, kind: val, ast: val });\n     |                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Group;\n     |\n560  +    use ast::visitor::Frame::Group;\n     |\n560  +    use hir::HirKind::Group;\n     |\nhelp: if you import `Group`, refer to it directly\n     |\n594  -     let frame = Frame::Group(&ast::Group);\n594  +     let frame = Frame::Group(&Group);\n     |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:596:32\n    |\n596 |       let tail = vec![Ast::Empty(ast::Span)];\n    |                                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:597:51\n    |\n597 |       let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };\n    |                                                     ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:580:9\n    |\n580 |         head: &Ast::Empty(ast::Span),\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:581:9\n    |\n581 |         tail: &[],\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:584:23\n    |\n584 |         head: &concat.head,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |         tail: &concat.tail,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:590:62\n    |\n590 |     let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                              ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:599:5\n    |\n599 |     assert_eq!(result, Some(Frame::Concat { head: &tail[0], tail: &tail[1..] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:599:5\n    |\n599 |     assert_eq!(result, Some(Frame::Concat { head: &tail[0], tail: &tail[1..] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0407, E0423, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:574:9\n    |\n574 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n575 | |             Ok(())\n576 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:580:27\n    |\n580 |           head: &Ast::Empty(ast::Span),\n    |                             ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:590:50\n    |\n590 |       let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                    ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Repetition`\n    --> regex-syntax/src/ast/visitor.rs:591:36\n     |\n591  |       let frame = Frame::Repetition(&ast::Repetition);\n     |                                      ^^^^^^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | / pub struct Repetition {\n1128 | |     /// The span of this operation.\n1129 | |     pub span: Span,\n1130 | |     /// The actual operation.\n...    |\n1135 | |     pub ast: Box<Ast>,\n1136 | | }\n     | |_- `ast::Repetition` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n591  |     let frame = Frame::Repetition(&ast::Repetition { span: val, op: val, greedy: val, ast: val });\n     |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Repetition;\n     |\n560  +    use ast::visitor::Frame::Repetition;\n     |\n560  +    use hir::HirKind::Repetition;\n     |\nhelp: if you import `Repetition`, refer to it directly\n     |\n591  -     let frame = Frame::Repetition(&ast::Repetition);\n591  +     let frame = Frame::Repetition(&Repetition);\n     |\n\nerror[E0423]: expected value, found struct `ast::Group`\n    --> regex-syntax/src/ast/visitor.rs:594:31\n     |\n594  |       let frame = Frame::Group(&ast::Group);\n     |                                 ^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1192:1\n     |\n1192 | / pub struct Group {\n1193 | |     /// The span of this group.\n1194 | |     pub span: Span,\n1195 | |     /// The kind of this group.\n...    |\n1198 | |     pub ast: Box<Ast>,\n1199 | | }\n     | |_- `ast::Group` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n594  |     let frame = Frame::Group(&ast::Group { span: val, kind: val, ast: val });\n     |                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Group;\n     |\n560  +    use ast::visitor::Frame::Group;\n     |\n560  +    use hir::HirKind::Group;\n     |\nhelp: if you import `Group`, refer to it directly\n     |\n594  -     let frame = Frame::Group(&ast::Group);\n594  +     let frame = Frame::Group(&Group);\n     |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:596:32\n    |\n596 |       let tail = vec![Ast::Empty(ast::Span)];\n    |                                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:597:51\n    |\n597 |       let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };\n    |                                                     ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:599:56\n    |\n599 |       let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &tail };\n    |                                                          ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:580:9\n    |\n580 |         head: &Ast::Empty(ast::Span),\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:581:9\n    |\n581 |         tail: &[],\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:584:23\n    |\n584 |         head: &concat.head,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |         tail: &concat.tail,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:590:62\n    |\n590 |     let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                              ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:601:5\n    |\n601 |     assert_eq!(result, Some(Frame::Alternation { head: &tail[0], tail: &tail[1..] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:601:5\n    |\n601 |     assert_eq!(result, Some(Frame::Alternation { head: &tail[0], tail: &tail[1..] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0407, E0423, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `,`\n   --> regex-syntax/src/ast/visitor.rs:590:70\n    |\n590 |       let concat = ast::Concat { span: ast::Span { start: /* value */, end: /* value */ }, asts: vec![Ast::Empty(ast::Span { start: /* va...\n    |                                        ---------                     ^ expected expression\n    |                                        |\n    |                                        while parsing this struct\n\nerror: expected expression, found `}`\n   --> regex-syntax/src/ast/visitor.rs:590:89\n    |\n590 |       let concat = ast::Concat { span: ast::Span { start: /* value */, end: /* value */ }, asts: vec![Ast::Empty(ast::Span { start: /* va...\n    |                                        --------- while parsing this struct              ^ expected expression\n\nerror: expected expression\n   --> regex-syntax/src/ast/visitor.rs:590:70\n    |\n590 |       let concat = ast::Concat { span: ast::Span { start: /* value */, end: /* value */ }, asts: vec![Ast::Empty(ast::Span { start: /* va...\n    |                                                                      ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/ast/visitor.rs:560:8\n    |\n560 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_pop_30` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:1\n    |\n566 | / fn test_pop_30()\n567 | | {\n568 | |     struct MockVisitor;\n...   |\n603 | |     assert_eq!(result, None);\n604 | | }\n    | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:574:9\n    |\n574 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n575 | |             Ok(())\n576 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:580:27\n    |\n580 |           head: &Ast::Empty(ast::Span),\n    |                             ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:590:50\n    |\n590 |       let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                    ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Repetition`\n    --> regex-syntax/src/ast/visitor.rs:591:36\n     |\n591  |       let frame = Frame::Repetition(&ast::Repetition);\n     |                                      ^^^^^^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | / pub struct Repetition {\n1128 | |     /// The span of this operation.\n1129 | |     pub span: Span,\n1130 | |     /// The actual operation.\n...    |\n1135 | |     pub ast: Box<Ast>,\n1136 | | }\n     | |_- `ast::Repetition` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n591  |     let frame = Frame::Repetition(&ast::Repetition { span: val, op: val, greedy: val, ast: val });\n     |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Repetition;\n     |\n560  +    use ast::visitor::Frame::Repetition;\n     |\n560  +    use hir::HirKind::Repetition;\n     |\nhelp: if you import `Repetition`, refer to it directly\n     |\n591  -     let frame = Frame::Repetition(&ast::Repetition);\n591  +     let frame = Frame::Repetition(&Repetition);\n     |\n\nerror[E0423]: expected value, found struct `ast::Group`\n    --> regex-syntax/src/ast/visitor.rs:594:31\n     |\n594  |       let frame = Frame::Group(&ast::Group);\n     |                                 ^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1192:1\n     |\n1192 | / pub struct Group {\n1193 | |     /// The span of this group.\n1194 | |     pub span: Span,\n1195 | |     /// The kind of this group.\n...    |\n1198 | |     pub ast: Box<Ast>,\n1199 | | }\n     | |_- `ast::Group` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n594  |     let frame = Frame::Group(&ast::Group { span: val, kind: val, ast: val });\n     |                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Group;\n     |\n560  +    use ast::visitor::Frame::Group;\n     |\n560  +    use hir::HirKind::Group;\n     |\nhelp: if you import `Group`, refer to it directly\n     |\n594  -     let frame = Frame::Group(&ast::Group);\n594  +     let frame = Frame::Group(&Group);\n     |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:596:32\n    |\n596 |       let tail = vec![Ast::Empty(ast::Span)];\n    |                                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:597:51\n    |\n597 |       let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &tail };\n    |                                                     ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:599:56\n    |\n599 |       let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &tail };\n    |                                                          ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:601:51\n    |\n601 |       let frame = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                     ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:603:56\n    |\n603 |       let frame = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                          ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:580:9\n    |\n580 |         head: &Ast::Empty(ast::Span),\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:581:9\n    |\n581 |         tail: &[],\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:584:23\n    |\n584 |         head: &concat.head,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |         tail: &concat.tail,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:590:62\n    |\n590 |     let concat = ast::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                              ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:605:5\n    |\n605 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:605:5\n    |\n605 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0407, E0423, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockVisitor;",
                "",
                "    impl Visitor for MockVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "",
                "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                "    let concat = ast::Concat {",
                "        head: &tail[0],",
                "        tail: &tail[1..],",
                "    };",
                "    let frame = Frame::Concat {",
                "        head: &concat.head,",
                "        tail: &concat.tail,",
                "    };",
                "",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.pop(frame);",
                "}"
              ],
              "oracles": [
                [
                  "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                  "    let concat = ast::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "    head: &concat.head,",
                  "    tail: &concat.tail,",
                  "    };",
                  "    assert!(matches!(visitor.pop(Frame::Repetition(_)), None));"
                ],
                [
                  "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                  "    let concat = ast::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "    head: &concat.head,",
                  "    tail: &concat.tail,",
                  "    };",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    assert!(matches!(visitor.pop(frame), None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                  "    let concat = ast::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "        head: &concat.head,",
                  "        tail: &concat.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                  "    let concat = ast::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "    head: &concat.head,",
                  "    tail: &concat.tail,",
                  "    };",
                  "    assert!(matches!(visitor.pop(Frame::Repetition(_)), None));",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                  "    let concat = ast::Concat {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "        head: &concat.head,",
                  "        tail: &concat.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                  "    let concat = ast::Concat {",
                  "    head: &tail[0],",
                  "    tail: &tail[1..],",
                  "    };",
                  "    let frame = Frame::Concat {",
                  "    head: &concat.head,",
                  "    tail: &concat.tail,",
                  "    };",
                  "    let frame = Frame::Group(&ast::Group);",
                  "    assert!(matches!(visitor.pop(frame), None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:574:9\n    |\n574 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n575 | |             Ok(())\n576 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:34\n    |\n579 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                    ^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n579 |     let tail = vec![Ast::Literal(ast::Literal { span: val, kind: val, c: val }), Ast::Dot(ast::Span)];\n    |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n579 -     let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n579 +     let tail = vec![Ast::Literal(Literal), Ast::Dot(ast::Span)];\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:579:58\n    |\n579 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                                            ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                    ^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n591 |     let tail = vec![Ast::Literal(ast::Literal { span: val, kind: val, c: val }), Ast::Dot(ast::Span)];\n    |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n591 -     let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n591 +     let tail = vec![Ast::Literal(Literal), Ast::Dot(ast::Span)];\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:591:58\n    |\n591 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                                            ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n   --> regex-syntax/src/ast/visitor.rs:600:52\n    |\n600 |     assert!(matches!(visitor.pop(Frame::Repetition(_)), None));\n    |                                                    ^ `_` not allowed here\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:581:9\n    |\n581 |         head: &tail[0],\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:582:9\n    |\n582 |         tail: &tail[1..],\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |         head: &concat.head,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:586:23\n    |\n586 |         tail: &concat.tail,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:593:5\n    |\n593 |     head: &tail[0],\n    |     ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:594:5\n    |\n594 |     tail: &tail[1..],\n    |     ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:597:19\n    |\n597 |     head: &concat.head,\n    |                   ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:598:19\n    |\n598 |     tail: &concat.tail,\n    |                   ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0407, E0423, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:574:9\n    |\n574 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n575 | |             Ok(())\n576 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:34\n    |\n579 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                    ^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n579 |     let tail = vec![Ast::Literal(ast::Literal { span: val, kind: val, c: val }), Ast::Dot(ast::Span)];\n    |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n579 -     let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n579 +     let tail = vec![Ast::Literal(Literal), Ast::Dot(ast::Span)];\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:579:58\n    |\n579 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                                            ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                    ^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n591 |     let tail = vec![Ast::Literal(ast::Literal { span: val, kind: val, c: val }), Ast::Dot(ast::Span)];\n    |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n591 -     let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n591 +     let tail = vec![Ast::Literal(Literal), Ast::Dot(ast::Span)];\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:591:58\n    |\n591 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                                            ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Group`\n    --> regex-syntax/src/ast/visitor.rs:600:31\n     |\n600  |       let frame = Frame::Group(&ast::Group);\n     |                                 ^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1192:1\n     |\n1192 | / pub struct Group {\n1193 | |     /// The span of this group.\n1194 | |     pub span: Span,\n1195 | |     /// The kind of this group.\n...    |\n1198 | |     pub ast: Box<Ast>,\n1199 | | }\n     | |_- `ast::Group` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n600  |     let frame = Frame::Group(&ast::Group { span: val, kind: val, ast: val });\n     |                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Group;\n     |\n560  +    use ast::visitor::Frame::Group;\n     |\n560  +    use hir::HirKind::Group;\n     |\nhelp: if you import `Group`, refer to it directly\n     |\n600  -     let frame = Frame::Group(&ast::Group);\n600  +     let frame = Frame::Group(&Group);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:581:9\n    |\n581 |         head: &tail[0],\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:582:9\n    |\n582 |         tail: &tail[1..],\n    |         ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |         head: &concat.head,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:586:23\n    |\n586 |         tail: &concat.tail,\n    |                       ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:593:5\n    |\n593 |     head: &tail[0],\n    |     ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:594:5\n    |\n594 |     tail: &tail[1..],\n    |     ^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:597:19\n    |\n597 |     head: &concat.head,\n    |                   ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Concat`\n   --> regex-syntax/src/ast/visitor.rs:598:19\n    |\n598 |     tail: &concat.tail,\n    |                   ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0407, E0423, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockVisitor;",
                "",
                "    impl Visitor for MockVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "",
                "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let alternation = ast::Alternation {",
                "        head: &Ast::Empty(ast::Span),",
                "        tail: &[],",
                "    };",
                "    let frame = Frame::Alternation {",
                "        head: &alternation.head,",
                "        tail: &alternation.tail,",
                "    };",
                "",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.pop(frame);",
                "}"
              ],
              "oracles": [
                [
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    assert_eq!(result_repetition, None);"
                ],
                [
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    let frame_group = Frame::Group(&ast::Group{});",
                  "    let result_group = visitor.pop(frame_group);",
                  "    assert_eq!(result_group, None);"
                ],
                [
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    let frame_group = Frame::Group(&ast::Group{});",
                  "    let result_group = visitor.pop(frame_group);",
                  "    let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_concat_empty = visitor.pop(frame_concat_empty);",
                  "    assert_eq!(result_concat_empty, None);"
                ],
                [
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    let frame_group = Frame::Group(&ast::Group{});",
                  "    let result_group = visitor.pop(frame_group);",
                  "    let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_concat_empty = visitor.pop(frame_concat_empty);",
                  "    let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };",
                  "    let result_concat_non_empty = visitor.pop(frame_concat_non_empty);",
                  "    assert_eq!(result_concat_non_empty, Some(Frame::Concat { head: &Ast::Literal(ast::Literal{}), tail: &[] }));"
                ],
                [
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    let frame_group = Frame::Group(&ast::Group{});",
                  "    let result_group = visitor.pop(frame_group);",
                  "    let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_concat_empty = visitor.pop(frame_concat_empty);",
                  "    let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };",
                  "    let result_concat_non_empty = visitor.pop(frame_concat_non_empty);",
                  "    let frame_alternation_empty = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_alternation_empty = visitor.pop(frame_alternation_empty);",
                  "    assert_eq!(result_alternation_empty, None);"
                ],
                [
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    let frame_group = Frame::Group(&ast::Group{});",
                  "    let result_group = visitor.pop(frame_group);",
                  "    let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_concat_empty = visitor.pop(frame_concat_empty);",
                  "    let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };",
                  "    let result_concat_non_empty = visitor.pop(frame_concat_non_empty);",
                  "    let frame_alternation_empty = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_alternation_empty = visitor.pop(frame_alternation_empty);",
                  "    let frame_alternation_non_empty = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };",
                  "    let result_alternation_non_empty = visitor.pop(frame_alternation_non_empty);",
                  "    assert_eq!(result_alternation_non_empty, Some(Frame::Alternation { head: &Ast::Literal(ast::Literal{}), tail: &[] }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let alternation = ast::Alternation {",
                  "        head: &Ast::Empty(ast::Span),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Alternation {",
                  "        head: &alternation.head,",
                  "        tail: &alternation.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    assert_eq!(result_repetition.debug(), None);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let alternation = ast::Alternation {",
                  "        head: &Ast::Empty(ast::Span),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Alternation {",
                  "        head: &alternation.head,",
                  "        tail: &alternation.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    let frame_group = Frame::Group(&ast::Group{});",
                  "    let result_group = visitor.pop(frame_group);",
                  "    assert_eq!(result_group, None);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let alternation = ast::Alternation {",
                  "        head: &Ast::Empty(ast::Span),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Alternation {",
                  "        head: &alternation.head,",
                  "        tail: &alternation.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    let frame_group = Frame::Group(&ast::Group{});",
                  "    let result_group = visitor.pop(frame_group);",
                  "    let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_concat_empty = visitor.pop(frame_concat_empty);",
                  "    assert_eq!(result_concat_empty, None);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let alternation = ast::Alternation {",
                  "        head: &Ast::Empty(ast::Span),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Alternation {",
                  "        head: &alternation.head,",
                  "        tail: &alternation.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    let frame_group = Frame::Group(&ast::Group{});",
                  "    let result_group = visitor.pop(frame_group);",
                  "    let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_concat_empty = visitor.pop(frame_concat_empty);",
                  "    let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };",
                  "    let result_concat_non_empty = visitor.pop(frame_concat_non_empty);",
                  "    assert_eq!(result_concat_non_empty, Some(Frame::Concat { head: &Ast::Literal(ast::Literal{}), tail: &[] }));",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let alternation = ast::Alternation {",
                  "        head: &Ast::Empty(ast::Span),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Alternation {",
                  "        head: &alternation.head,",
                  "        tail: &alternation.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    let frame_group = Frame::Group(&ast::Group{});",
                  "    let result_group = visitor.pop(frame_group);",
                  "    let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_concat_empty = visitor.pop(frame_concat_empty);",
                  "    let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };",
                  "    let result_concat_non_empty = visitor.pop(frame_concat_non_empty);",
                  "    let frame_alternation_empty = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_alternation_empty = visitor.pop(frame_alternation_empty);",
                  "    assert_eq!(result_alternation_empty, None);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let alternation = ast::Alternation {",
                  "        head: &Ast::Empty(ast::Span),",
                  "        tail: &[],",
                  "    };",
                  "    let frame = Frame::Alternation {",
                  "        head: &alternation.head,",
                  "        tail: &alternation.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let frame_repetition = Frame::Repetition(&ast::Repetition{});",
                  "    let result_repetition = visitor.pop(frame_repetition);",
                  "    let frame_group = Frame::Group(&ast::Group{});",
                  "    let result_group = visitor.pop(frame_group);",
                  "    let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_concat_empty = visitor.pop(frame_concat_empty);",
                  "    let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };",
                  "    let result_concat_non_empty = visitor.pop(frame_concat_non_empty);",
                  "    let frame_alternation_empty = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[] };",
                  "    let result_alternation_empty = visitor.pop(frame_alternation_empty);",
                  "    let frame_alternation_non_empty = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };",
                  "    let result_alternation_non_empty = visitor.pop(frame_alternation_non_empty);",
                  "    assert_eq!(result_alternation_non_empty, Some(Frame::Alternation { head: &Ast::Literal(ast::Literal{}), tail: &[] }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:574:9\n    |\n574 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n575 | |             Ok(())\n576 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:580:27\n    |\n580 |           head: &Ast::Empty(ast::Span),\n    |                             ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n570 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Alternation` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:580:9\n    |\n580 |         head: &Ast::Empty(ast::Span),\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Alternation` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:581:9\n    |\n581 |         tail: &[],\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:584:28\n    |\n584 |         head: &alternation.head,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:585:28\n    |\n585 |         tail: &alternation.tail,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0063]: missing fields `ast`, `greedy`, `op` and 1 other field in initializer of `ast::Repetition`\n   --> regex-syntax/src/ast/visitor.rs:590:47\n    |\n590 |     let frame_repetition = Frame::Repetition(&ast::Repetition{});\n    |                                               ^^^^^^^^^^^^^^^ missing `ast`, `greedy`, `op` and 1 other field\n\nerror[E0599]: no method named `debug` found for enum `Option` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:592:34\n    |\n592 |     assert_eq!(result_repetition.debug(), None);\n    |                                  ^^^^^ method not found in `Option<Frame<'_>>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0063, E0407, E0423, E0560, E0599, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:571:9\n    |\n571 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n572 | |             Ok(())\n573 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:577:27\n    |\n577 |           head: &Ast::Empty(ast::Span),\n    |                             ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:567:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n567 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Alternation` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:577:9\n    |\n577 |         head: &Ast::Empty(ast::Span),\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Alternation` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:578:9\n    |\n578 |         tail: &[],\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:581:28\n    |\n581 |         head: &alternation.head,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:582:28\n    |\n582 |         tail: &alternation.tail,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0063]: missing fields `ast`, `greedy`, `op` and 1 other field in initializer of `ast::Repetition`\n   --> regex-syntax/src/ast/visitor.rs:587:47\n    |\n587 |     let frame_repetition = Frame::Repetition(&ast::Repetition{});\n    |                                               ^^^^^^^^^^^^^^^ missing `ast`, `greedy`, `op` and 1 other field\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n   --> regex-syntax/src/ast/visitor.rs:589:37\n    |\n589 |     let frame_group = Frame::Group(&ast::Group{});\n    |                                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:591:5\n    |\n591 |     assert_eq!(result_group, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:591:5\n    |\n591 |     assert_eq!(result_group, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0063, E0277, E0369, E0407, E0423, E0432, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:571:9\n    |\n571 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n572 | |             Ok(())\n573 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:577:27\n    |\n577 |           head: &Ast::Empty(ast::Span),\n    |                             ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |       let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:567:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n567 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Alternation` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:577:9\n    |\n577 |         head: &Ast::Empty(ast::Span),\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Alternation` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:578:9\n    |\n578 |         tail: &[],\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:581:28\n    |\n581 |         head: &alternation.head,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:582:28\n    |\n582 |         tail: &alternation.tail,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0063]: missing fields `ast`, `greedy`, `op` and 1 other field in initializer of `ast::Repetition`\n   --> regex-syntax/src/ast/visitor.rs:587:47\n    |\n587 |     let frame_repetition = Frame::Repetition(&ast::Repetition{});\n    |                                               ^^^^^^^^^^^^^^^ missing `ast`, `greedy`, `op` and 1 other field\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n   --> regex-syntax/src/ast/visitor.rs:589:37\n    |\n589 |     let frame_group = Frame::Group(&ast::Group{});\n    |                                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:593:5\n    |\n593 |     assert_eq!(result_concat_empty, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:593:5\n    |\n593 |     assert_eq!(result_concat_empty, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0063, E0277, E0369, E0407, E0423, E0432, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:571:9\n    |\n571 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n572 | |             Ok(())\n573 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:577:27\n    |\n577 |           head: &Ast::Empty(ast::Span),\n    |                             ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |       let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:593:68\n    |\n593 |       let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };\n    |                                                                      ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:567:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n567 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Alternation` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:577:9\n    |\n577 |         head: &Ast::Empty(ast::Span),\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Alternation` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:578:9\n    |\n578 |         tail: &[],\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:581:28\n    |\n581 |         head: &alternation.head,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:582:28\n    |\n582 |         tail: &alternation.tail,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0063]: missing fields `ast`, `greedy`, `op` and 1 other field in initializer of `ast::Repetition`\n   --> regex-syntax/src/ast/visitor.rs:587:47\n    |\n587 |     let frame_repetition = Frame::Repetition(&ast::Repetition{});\n    |                                               ^^^^^^^^^^^^^^^ missing `ast`, `greedy`, `op` and 1 other field\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n   --> regex-syntax/src/ast/visitor.rs:589:37\n    |\n589 |     let frame_group = Frame::Group(&ast::Group{});\n    |                                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:593:101\n    |\n593 |     let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };\n    |                                                                                                     ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:595:82\n    |\n595 |     assert_eq!(result_concat_non_empty, Some(Frame::Concat { head: &Ast::Literal(ast::Literal{}), tail: &[] }));\n    |                                                                                  ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:595:5\n    |\n595 |     assert_eq!(result_concat_non_empty, Some(Frame::Concat { head: &Ast::Literal(ast::Literal{}), tail: &[] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:595:5\n    |\n595 |     assert_eq!(result_concat_non_empty, Some(Frame::Concat { head: &Ast::Literal(ast::Literal{}), tail: &[] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0063, E0277, E0369, E0407, E0423, E0432, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:571:9\n    |\n571 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n572 | |             Ok(())\n573 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:577:27\n    |\n577 |           head: &Ast::Empty(ast::Span),\n    |                             ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |       let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:593:68\n    |\n593 |       let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };\n    |                                                                      ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:595:74\n    |\n595 |       let frame_alternation_empty = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                                            ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:567:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n567 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Alternation` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:577:9\n    |\n577 |         head: &Ast::Empty(ast::Span),\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Alternation` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:578:9\n    |\n578 |         tail: &[],\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:581:28\n    |\n581 |         head: &alternation.head,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:582:28\n    |\n582 |         tail: &alternation.tail,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0063]: missing fields `ast`, `greedy`, `op` and 1 other field in initializer of `ast::Repetition`\n   --> regex-syntax/src/ast/visitor.rs:587:47\n    |\n587 |     let frame_repetition = Frame::Repetition(&ast::Repetition{});\n    |                                               ^^^^^^^^^^^^^^^ missing `ast`, `greedy`, `op` and 1 other field\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n   --> regex-syntax/src/ast/visitor.rs:589:37\n    |\n589 |     let frame_group = Frame::Group(&ast::Group{});\n    |                                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:593:101\n    |\n593 |     let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };\n    |                                                                                                     ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:597:5\n    |\n597 |     assert_eq!(result_alternation_empty, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:597:5\n    |\n597 |     assert_eq!(result_alternation_empty, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0063, E0277, E0369, E0407, E0423, E0432, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:571:9\n    |\n571 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n572 | |             Ok(())\n573 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:577:27\n    |\n577 |           head: &Ast::Empty(ast::Span),\n    |                             ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |       let frame_concat_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:593:68\n    |\n593 |       let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };\n    |                                                                      ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:595:74\n    |\n595 |       let frame_alternation_empty = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[] };\n    |                                                                            ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:597:78\n    |\n597 |       let frame_alternation_non_empty = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };\n    |                                                                                ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:567:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n567 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Alternation` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:577:9\n    |\n577 |         head: &Ast::Empty(ast::Span),\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Alternation` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:578:9\n    |\n578 |         tail: &[],\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:581:28\n    |\n581 |         head: &alternation.head,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:582:28\n    |\n582 |         tail: &alternation.tail,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0063]: missing fields `ast`, `greedy`, `op` and 1 other field in initializer of `ast::Repetition`\n   --> regex-syntax/src/ast/visitor.rs:587:47\n    |\n587 |     let frame_repetition = Frame::Repetition(&ast::Repetition{});\n    |                                               ^^^^^^^^^^^^^^^ missing `ast`, `greedy`, `op` and 1 other field\n\nerror[E0063]: missing fields `ast`, `kind` and `span` in initializer of `ast::Group`\n   --> regex-syntax/src/ast/visitor.rs:589:37\n    |\n589 |     let frame_group = Frame::Group(&ast::Group{});\n    |                                     ^^^^^^^^^^ missing `ast`, `kind` and `span`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:593:101\n    |\n593 |     let frame_concat_non_empty = Frame::Concat { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };\n    |                                                                                                     ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:597:111\n    |\n597 |     let frame_alternation_non_empty = Frame::Alternation { head: &Ast::Empty(ast::Span), tail: &[Ast::Literal(ast::Literal{})] };\n    |                                                                                                               ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nerror[E0063]: missing fields `c`, `kind` and `span` in initializer of `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:599:92\n    |\n599 |     assert_eq!(result_alternation_non_empty, Some(Frame::Alternation { head: &Ast::Literal(ast::Literal{}), tail: &[] }));\n    |                                                                                            ^^^^^^^^^^^^ missing `c`, `kind` and `span`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:599:5\n    |\n599 |     assert_eq!(result_alternation_non_empty, Some(Frame::Alternation { head: &Ast::Literal(ast::Literal{}), tail: &[] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:599:5\n    |\n599 |     assert_eq!(result_alternation_non_empty, Some(Frame::Alternation { head: &Ast::Literal(ast::Literal{}), tail: &[] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0063, E0277, E0369, E0407, E0423, E0432, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockVisitor;",
                "",
                "    impl Visitor for MockVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "",
                "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                "    let alternation = ast::Alternation {",
                "        head: &tail[0],",
                "        tail: &tail[1..],",
                "    };",
                "    let frame = Frame::Alternation {",
                "        head: &alternation.head,",
                "        tail: &alternation.tail,",
                "    };",
                "",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.pop(frame);",
                "}"
              ],
              "oracles": [
                [
                  "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockVisitor;",
                  "",
                  "    impl Visitor for MockVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                  "    let alternation = ast::Alternation {",
                  "        head: &tail[0],",
                  "        tail: &tail[1..],",
                  "    };",
                  "    let frame = Frame::Alternation {",
                  "        head: &alternation.head,",
                  "        tail: &alternation.tail,",
                  "    };",
                  "",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.pop(frame);",
                  "    let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];",
                  "    let frame = Frame::Repetition(&ast::Repetition);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0407]: method `visit` is not a member of trait `Visitor`\n   --> regex-syntax/src/ast/visitor.rs:571:9\n    |\n571 | /         fn visit(&mut self, _ast: &Ast) -> Result<Self::Output, Self::Err> {\n572 | |             Ok(())\n573 | |         }\n    | |_________^ not a member of trait `Visitor`\n\nerror[E0423]: expected value, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:34\n    |\n576 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                    ^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n576 |     let tail = vec![Ast::Literal(ast::Literal { span: val, kind: val, c: val }), Ast::Dot(ast::Span)];\n    |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n576 -     let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n576 +     let tail = vec![Ast::Literal(Literal), Ast::Dot(ast::Span)];\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:576:58\n    |\n576 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                                            ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:34\n    |\n588 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                    ^^^^^^^^^^^^\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | / pub struct Literal {\n615 | |     /// The span of this literal.\n616 | |     pub span: Span,\n617 | |     /// The kind of this literal.\n...   |\n620 | |     pub c: char,\n621 | | }\n    | |_- `ast::Literal` defined here\n    |\nhelp: use struct literal syntax instead\n    |\n588 |     let tail = vec![Ast::Literal(ast::Literal { span: val, kind: val, c: val }), Ast::Dot(ast::Span)];\n    |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\nhelp: if you import `Literal`, refer to it directly\n    |\n588 -     let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n588 +     let tail = vec![Ast::Literal(Literal), Ast::Dot(ast::Span)];\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/ast/visitor.rs:588:58\n    |\n588 |       let tail = vec![Ast::Literal(ast::Literal), Ast::Dot(ast::Span)];\n    |                                                            ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0423]: expected value, found struct `ast::Repetition`\n    --> regex-syntax/src/ast/visitor.rs:589:36\n     |\n589  |       let frame = Frame::Repetition(&ast::Repetition);\n     |                                      ^^^^^^^^^^^^^^^\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | / pub struct Repetition {\n1128 | |     /// The span of this operation.\n1129 | |     pub span: Span,\n1130 | |     /// The actual operation.\n...    |\n1135 | |     pub ast: Box<Ast>,\n1136 | | }\n     | |_- `ast::Repetition` defined here\n     |\nhelp: use struct literal syntax instead\n     |\n589  |     let frame = Frame::Repetition(&ast::Repetition { span: val, op: val, greedy: val, ast: val });\n     |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n560  +    use ast::Ast::Repetition;\n     |\n560  +    use ast::visitor::Frame::Repetition;\n     |\n560  +    use hir::HirKind::Repetition;\n     |\nhelp: if you import `Repetition`, refer to it directly\n     |\n589  -     let frame = Frame::Repetition(&ast::Repetition);\n589  +     let frame = Frame::Repetition(&Repetition);\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:567:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n567 |     impl Visitor for MockVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0560]: struct `ast::Alternation` has no field named `head`\n   --> regex-syntax/src/ast/visitor.rs:578:9\n    |\n578 |         head: &tail[0],\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0560]: struct `ast::Alternation` has no field named `tail`\n   --> regex-syntax/src/ast/visitor.rs:579:9\n    |\n579 |         tail: &tail[1..],\n    |         ^^^^ `ast::Alternation` does not have this field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `head` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:582:28\n    |\n582 |         head: &alternation.head,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0609]: no field `tail` on type `ast::Alternation`\n   --> regex-syntax/src/ast/visitor.rs:583:28\n    |\n583 |         tail: &alternation.tail,\n    |                            ^^^^ unknown field\n    |\n    = note: available fields are: `span`, `asts`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:590:5\n    |\n590 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:590:5\n    |\n590 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0407, E0423, E0432, E0560, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}