{
  "name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::pop_group",
  "name_with_impl": "regex_syntax::ast::parse::{impl#4}::pop_group",
  "mod_info": {
    "name": "ast::parse",
    "loc": "regex-syntax/src/ast/mod.rs:21:1:21:15"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/parse.rs:737:5:783:6",
  "fn_tests": [
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: (*left_val == *right_val) is true\n",
        "// constraint: stack.pop() matches Some(Group { concat, group, ignore_whitespace }) or Some(Alternation(alt)) is true\n",
        "// constraint: stack.pop() matches Some(Group { concat, group, ignore_whitespace }) or Some(Alternation(alt)) is true\n",
        "// constraint: stack.pop() matches Some(Alternation(alt)) is true\n",
        "// constraint: stack.pop() matches Some(Alternation(_)) or Some(Group { concat, group, ignore_whitespace }) is true\n",
        "// constraint: stack.pop() matches None is true\n",
        "// constraint: stack.pop() matches Some(Group { concat, group, ignore_whitespace }) is true\n",
        "// constraint: alt matches None is true\n",
        "// expected return value/type: Ok(prior_concat)\n"
      ],
      "input_infer": "0 <= nest_limit <= 10; 0 <= capture_index <= 20; 0 <= parser.pos.offset <= 100; 1 <= parser.pos.line <= 10; 1 <= parser.pos.column <= 10; stack.group.length >= 1; group_concat.asts.length >= 1;\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let group_concat = ast::Concat {",
                "        span: ast::Span {",
                "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                "            end: ast::Position { offset: 10, line: 1, column: 11 },",
                "        },",
                "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                "    };",
                "",
                "    let mut parser = Parser {",
                "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                "        nest_limit: 5,",
                "        capture_index: Cell::new(0),",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![",
                "            ast::GroupState::Group {",
                "                concat: ast::Concat::default(),",
                "                group: ast::Group {",
                "                    span: ast::Span::default(),",
                "                    kind: ast::GroupKind::default(),",
                "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                "                },",
                "                ignore_whitespace: false,",
                "            }",
                "        ]),",
                "        ..Default::default()",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: \"\",",
                "    };",
                "",
                "    parser_instance.pop_group(group_concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let group_concat = ast::Concat { span: ast::Span { start: ast::Position { offset: 0, line: 1, column: 1 }, end: ast::Position { offset: 10, line: 1, column: 11 } }, asts: vec![ast::Ast::Empty(ast::Span::default())] };",
                  "    let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    assert_eq!(parser_instance.pop_group(group_concat).is_ok(), true);"
                ],
                [
                  "    let group_concat = ast::Concat { span: ast::Span { start: ast::Position { offset: 0, line: 1, column: 1 }, end: ast::Position { offset: 10, line: 1, column: 11 } }, asts: vec![ast::Ast::Empty(ast::Span::default())] };",
                  "    let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    assert_eq!(parser_instance.pos().offset, 10);"
                ],
                [
                  "    let group_concat = ast::Concat { span: ast::Span { start: ast::Position { offset: 0, line: 1, column: 1 }, end: ast::Position { offset: 10, line: 1, column: 11 } }, asts: vec![ast::Ast::Empty(ast::Span::default())] };",
                  "    let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    assert_eq!(parser_instance.stack_group.borrow().len(), 0);"
                ],
                [
                  "    let group_concat = ast::Concat { span: ast::Span { start: ast::Position { offset: 0, line: 1, column: 1 }, end: ast::Position { offset: 10, line: 1, column: 11 } }, asts: vec![ast::Ast::Empty(ast::Span::default())] };",
                  "    let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    assert_eq!(parser.parser().ignore_whitespace.get(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 10, line: 1, column: 11 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat { span: ast::Span { start: ast::Position { offset: 0, line: 1, column: 1 }, end: ast::Position { offset: 10, line: 1, column: 11 } }, asts: vec![ast::Ast::Empty(ast::Span::default())] };",
                  "    let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    assert_eq!(parser_instance.pop_group(group_concat).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 10, line: 1, column: 11 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat { span: ast::Span { start: ast::Position { offset: 0, line: 1, column: 1 }, end: ast::Position { offset: 10, line: 1, column: 11 } }, asts: vec![ast::Ast::Empty(ast::Span::default())] };",
                  "    let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    assert_eq!(parser_instance.pos().offset, 10);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 10, line: 1, column: 11 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat { span: ast::Span { start: ast::Position { offset: 0, line: 1, column: 1 }, end: ast::Position { offset: 10, line: 1, column: 11 } }, asts: vec![ast::Ast::Empty(ast::Span::default())] };",
                  "    let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    assert_eq!(parser_instance.stack_group.borrow().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 10, line: 1, column: 11 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat { span: ast::Span { start: ast::Position { offset: 0, line: 1, column: 1 }, end: ast::Position { offset: 10, line: 1, column: 11 } }, asts: vec![ast::Ast::Empty(ast::Span::default())] };",
                  "    let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    assert_eq!(parser.parser().ignore_whitespace.get(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5411:246\n     |\n5411 | ...c![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::de...\n     |                                               ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5411 -     let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n5411 +     let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5410:208\n     |\n5410 | ... asts: vec![ast::Ast::Empty(ast::Span::default())] };\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:287\n     |\n5411 | ...upState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast:...\n     |                                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:335\n     |\n5411 | ..., group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())...\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:368\n     |\n5411 | ...an::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }])...\n     |                                         ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:420\n     |\n5411 | ...t: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5411:469\n     |\n5411 | ...e_whitespace: false, }]), ..Default::default() };\n     |                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5411:246\n     |\n5411 | ...c![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::de...\n     |                                               ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5411 -     let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n5411 +     let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5410:208\n     |\n5410 | ... asts: vec![ast::Ast::Empty(ast::Span::default())] };\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:287\n     |\n5411 | ...upState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast:...\n     |                                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:335\n     |\n5411 | ..., group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())...\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:368\n     |\n5411 | ...an::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }])...\n     |                                         ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:420\n     |\n5411 | ...t: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5411:469\n     |\n5411 | ...e_whitespace: false, }]), ..Default::default() };\n     |                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5411:246\n     |\n5411 | ...c![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::de...\n     |                                               ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5411 -     let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n5411 +     let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5410:208\n     |\n5410 | ... asts: vec![ast::Ast::Empty(ast::Span::default())] };\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:287\n     |\n5411 | ...upState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast:...\n     |                                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:335\n     |\n5411 | ..., group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())...\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:368\n     |\n5411 | ...an::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }])...\n     |                                         ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:420\n     |\n5411 | ...t: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5411:469\n     |\n5411 | ...e_whitespace: false, }]), ..Default::default() };\n     |                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0609]: no field `stack_group` on type `parse::ParserI<'_, &parse::Parser>`\n    --> regex-syntax/src/ast/parse.rs:5413:32\n     |\n5413 |     assert_eq!(parser_instance.stack_group.borrow().len(), 0);\n     |                                ^^^^^^^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n5413 |     assert_eq!(parser_instance.parser.stack_group.borrow().len(), 0);\n     |                                +++++++\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5411:246\n     |\n5411 | ...c![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::de...\n     |                                               ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5411 -     let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![ast::GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n5411 +     let mut parser = Parser { pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }), nest_limit: 5, capture_index: Cell::new(0), ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![GroupState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5410:208\n     |\n5410 | ... asts: vec![ast::Ast::Empty(ast::Span::default())] };\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:287\n     |\n5411 | ...upState::Group { concat: ast::Concat::default(), group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast:...\n     |                                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:335\n     |\n5411 | ..., group: ast::Group { span: ast::Span::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())...\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:368\n     |\n5411 | ...an::default(), kind: ast::GroupKind::default(), ast: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }])...\n     |                                         ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5411:420\n     |\n5411 | ...t: Box::new(ast::Ast::Empty(ast::Span::default())), }, ignore_whitespace: false, }]), ..Default::default() };\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5411:469\n     |\n5411 | ...e_whitespace: false, }]), ..Default::default() };\n     |                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no method named `parser` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5413:23\n     |\n233  | pub struct Parser {\n     | ----------------- method `parser` not found for this struct\n...\n5413 |     assert_eq!(parser.parser().ignore_whitespace.get(), false);\n     |                       ^^^^^^\n     |\nhelp: there is a method `parse` with a similar name, but with different arguments\n    --> regex-syntax/src/ast/parse.rs:344:5\n     |\n344  |     pub fn parse(&mut self, pattern: &str) -> Result<Ast> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let group_concat = ast::Concat {",
                "        span: ast::Span {",
                "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                "            end: ast::Position { offset: 15, line: 1, column: 16 },",
                "        },",
                "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                "    };",
                "",
                "    let mut parser = Parser {",
                "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                "        nest_limit: 5,",
                "        capture_index: Cell::new(0),",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![",
                "            ast::GroupState::Alternation(ast::Alternation {",
                "                span: ast::Span::default(),",
                "                asts: vec![ast::Ast::Empty(ast::Span::default())],",
                "            }),",
                "            ast::GroupState::Group {",
                "                concat: ast::Concat::default(),",
                "                group: ast::Group {",
                "                    span: ast::Span::default(),",
                "                    kind: ast::GroupKind::default(),",
                "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                "                },",
                "                ignore_whitespace: false,",
                "            }",
                "        ]),",
                "        ..Default::default()",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: \"\",",
                "    };",
                "",
                "    parser_instance.pop_group(group_concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    assert_eq!(parser_instance.char(), ')');"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    assert!(parser_instance.stack_group.borrow().len() > 0);"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    assert!(matches!(parser_instance.parser().stack_group.borrow().last(), Some(ast::GroupState::Group { .. })));"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    assert!(matches!(parser_instance.parser().stack_group.borrow().last(), Some(ast::GroupState::Alternation(_))));"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert!(parser_instance.parser().stack_group.borrow().is_empty());"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert_eq!(parser_instance.offset(), 10);"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert_eq!(parser_instance.line(), 1);"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert_eq!(parser_instance.column(), 11);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Alternation(ast::Alternation {",
                  "                span: ast::Span::default(),",
                  "                asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "            }),",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    assert_eq!(parser_instance.char(), ')');",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Alternation(ast::Alternation {",
                  "                span: ast::Span::default(),",
                  "                asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "            }),",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    assert!(parser_instance.stack_group.borrow().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Alternation(ast::Alternation {",
                  "                span: ast::Span::default(),",
                  "                asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "            }),",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    assert!(matches!(parser_instance.parser().stack_group.borrow().last(), Some(ast::GroupState::Group { .. })));",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Alternation(ast::Alternation {",
                  "                span: ast::Span::default(),",
                  "                asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "            }),",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    GroupState::Group {  ",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    assert!(matches!(parser_instance.parser().stack_group.borrow().last(), Some(ast::GroupState::Alternation(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Alternation(ast::Alternation {",
                  "                span: ast::Span::default(),",
                  "                asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "            }),",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Alternation(ast::Alternation {",
                  "                span: ast::Span::default(),",
                  "                asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "            }),",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert!(parser_instance.parser().stack_group.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Alternation(ast::Alternation {",
                  "                span: ast::Span::default(),",
                  "                asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "            }),",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    GroupState::Group {  ",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert_eq!(parser_instance.offset(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Alternation(ast::Alternation {",
                  "                span: ast::Span::default(),",
                  "                asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "            }),",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert_eq!(parser_instance.line(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Alternation(ast::Alternation {",
                  "                span: ast::Span::default(),",
                  "                asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "            }),",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 15, line: 1, column: 16 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "    nest_limit: 5,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![",
                  "    ast::GroupState::Alternation(ast::Alternation {",
                  "    span: ast::Span::default(),",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    }),",
                  "    ast::GroupState::Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group {",
                  "    span: ast::Span::default(),",
                  "    kind: ast::GroupKind::default(),",
                  "    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "    },",
                  "    ignore_whitespace: false,",
                  "    }",
                  "    ]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert_eq!(parser_instance.column(), 11);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Alternation(ast::Alternation {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Alternation(ast::Alternation {\n5391 +             GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n5395 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5395 -             ast::GroupState::Group {\n5395 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5428:10\n     |\n5428 |     ast::GroupState::Alternation(ast::Alternation {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5428 -     ast::GroupState::Alternation(ast::Alternation {\n5428 +     GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5432:10\n     |\n5432 |     ast::GroupState::Group {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5432 -     ast::GroupState::Group {\n5432 +     GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:34\n     |\n5392 |                 span: ast::Span::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:55\n     |\n5393 |                 asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                                       ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:62\n     |\n5400 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5405:11\n     |\n5405 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:43\n     |\n5419 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5429:22\n     |\n5429 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5430:43\n     |\n5430 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5433:26\n     |\n5433 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:22\n     |\n5435 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5436:27\n     |\n5436 |     kind: ast::GroupKind::default(),\n     |                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5437:46\n     |\n5437 |     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5442:7\n     |\n5442 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Alternation(ast::Alternation {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Alternation(ast::Alternation {\n5391 +             GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n5395 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5395 -             ast::GroupState::Group {\n5395 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5428:10\n     |\n5428 |     ast::GroupState::Alternation(ast::Alternation {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5428 -     ast::GroupState::Alternation(ast::Alternation {\n5428 +     GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5432:10\n     |\n5432 |     ast::GroupState::Group {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5432 -     ast::GroupState::Group {\n5432 +     GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:34\n     |\n5392 |                 span: ast::Span::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:55\n     |\n5393 |                 asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                                       ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:62\n     |\n5400 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5405:11\n     |\n5405 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:43\n     |\n5419 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5429:22\n     |\n5429 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5430:43\n     |\n5430 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5433:26\n     |\n5433 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:22\n     |\n5435 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5436:27\n     |\n5436 |     kind: ast::GroupKind::default(),\n     |                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5437:46\n     |\n5437 |     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5442:7\n     |\n5442 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0609]: no field `stack_group` on type `parse::ParserI<'_, &parse::Parser>`\n    --> regex-syntax/src/ast/parse.rs:5448:29\n     |\n5448 |     assert!(parser_instance.stack_group.borrow().len() > 0);\n     |                             ^^^^^^^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n5448 |     assert!(parser_instance.parser.stack_group.borrow().len() > 0);\n     |                             +++++++\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Alternation(ast::Alternation {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Alternation(ast::Alternation {\n5391 +             GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n5395 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5395 -             ast::GroupState::Group {\n5395 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5428:10\n     |\n5428 |     ast::GroupState::Alternation(ast::Alternation {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5428 -     ast::GroupState::Alternation(ast::Alternation {\n5428 +     GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5432:10\n     |\n5432 |     ast::GroupState::Group {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5432 -     ast::GroupState::Group {\n5432 +     GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5448:86\n     |\n5448 |     assert!(matches!(parser_instance.parser().stack_group.borrow().last(), Some(ast::GroupState::Group { .. })));\n     |                                                                                      ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5448 -     assert!(matches!(parser_instance.parser().stack_group.borrow().last(), Some(ast::GroupState::Group { .. })));\n5448 +     assert!(matches!(parser_instance.parser().stack_group.borrow().last(), Some(GroupState::Group { .. })));\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:34\n     |\n5392 |                 span: ast::Span::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:55\n     |\n5393 |                 asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                                       ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:62\n     |\n5400 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5405:11\n     |\n5405 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:43\n     |\n5419 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5429:22\n     |\n5429 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5430:43\n     |\n5430 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5433:26\n     |\n5433 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:22\n     |\n5435 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5436:27\n     |\n5436 |     kind: ast::GroupKind::default(),\n     |                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5437:46\n     |\n5437 |     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5442:7\n     |\n5442 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Alternation(ast::Alternation {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Alternation(ast::Alternation {\n5391 +             GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n5395 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5395 -             ast::GroupState::Group {\n5395 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5428:10\n     |\n5428 |     ast::GroupState::Alternation(ast::Alternation {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5428 -     ast::GroupState::Alternation(ast::Alternation {\n5428 +     GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5448:86\n     |\n5448 |     assert!(matches!(parser_instance.parser().stack_group.borrow().last(), Some(ast::GroupState::Alternation(_))));\n     |                                                                                      ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5448 -     assert!(matches!(parser_instance.parser().stack_group.borrow().last(), Some(ast::GroupState::Alternation(_))));\n5448 +     assert!(matches!(parser_instance.parser().stack_group.borrow().last(), Some(GroupState::Alternation(_))));\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:34\n     |\n5392 |                 span: ast::Span::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:55\n     |\n5393 |                 asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                                       ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:62\n     |\n5400 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5405:11\n     |\n5405 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:43\n     |\n5419 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5429:22\n     |\n5429 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5430:43\n     |\n5430 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5433:26\n     |\n5433 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:22\n     |\n5435 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5436:27\n     |\n5436 |     kind: ast::GroupKind::default(),\n     |                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5437:46\n     |\n5437 |     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5442:7\n     |\n5442 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Alternation(ast::Alternation {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Alternation(ast::Alternation {\n5391 +             GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n5395 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5395 -             ast::GroupState::Group {\n5395 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5428:10\n     |\n5428 |     ast::GroupState::Alternation(ast::Alternation {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5428 -     ast::GroupState::Alternation(ast::Alternation {\n5428 +     GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5432:10\n     |\n5432 |     ast::GroupState::Group {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5432 -     ast::GroupState::Group {\n5432 +     GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:34\n     |\n5392 |                 span: ast::Span::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:55\n     |\n5393 |                 asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                                       ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:62\n     |\n5400 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5405:11\n     |\n5405 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:43\n     |\n5419 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5429:22\n     |\n5429 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5430:43\n     |\n5430 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5433:26\n     |\n5433 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:22\n     |\n5435 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5436:27\n     |\n5436 |     kind: ast::GroupKind::default(),\n     |                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5437:46\n     |\n5437 |     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5442:7\n     |\n5442 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Alternation(ast::Alternation {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Alternation(ast::Alternation {\n5391 +             GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n5395 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5395 -             ast::GroupState::Group {\n5395 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5428:10\n     |\n5428 |     ast::GroupState::Alternation(ast::Alternation {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5428 -     ast::GroupState::Alternation(ast::Alternation {\n5428 +     GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5432:10\n     |\n5432 |     ast::GroupState::Group {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5432 -     ast::GroupState::Group {\n5432 +     GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:34\n     |\n5392 |                 span: ast::Span::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:55\n     |\n5393 |                 asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                                       ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:62\n     |\n5400 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5405:11\n     |\n5405 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:43\n     |\n5419 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5429:22\n     |\n5429 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5430:43\n     |\n5430 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5433:26\n     |\n5433 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:22\n     |\n5435 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5436:27\n     |\n5436 |     kind: ast::GroupKind::default(),\n     |                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5437:46\n     |\n5437 |     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5442:7\n     |\n5442 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Alternation(ast::Alternation {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Alternation(ast::Alternation {\n5391 +             GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n5395 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5395 -             ast::GroupState::Group {\n5395 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5428:10\n     |\n5428 |     ast::GroupState::Alternation(ast::Alternation {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5428 -     ast::GroupState::Alternation(ast::Alternation {\n5428 +     GroupState::Alternation(ast::Alternation {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:34\n     |\n5392 |                 span: ast::Span::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:55\n     |\n5393 |                 asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                                       ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:62\n     |\n5400 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5405:11\n     |\n5405 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:43\n     |\n5419 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5429:22\n     |\n5429 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5430:43\n     |\n5430 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5433:26\n     |\n5433 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:22\n     |\n5435 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5436:27\n     |\n5436 |     kind: ast::GroupKind::default(),\n     |                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5437:46\n     |\n5437 |     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5442:7\n     |\n5442 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Alternation(ast::Alternation {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Alternation(ast::Alternation {\n5391 +             GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n5395 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5395 -             ast::GroupState::Group {\n5395 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5428:10\n     |\n5428 |     ast::GroupState::Alternation(ast::Alternation {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5428 -     ast::GroupState::Alternation(ast::Alternation {\n5428 +     GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5432:10\n     |\n5432 |     ast::GroupState::Group {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5432 -     ast::GroupState::Group {\n5432 +     GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:34\n     |\n5392 |                 span: ast::Span::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:55\n     |\n5393 |                 asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                                       ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:62\n     |\n5400 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5405:11\n     |\n5405 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:43\n     |\n5419 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5429:22\n     |\n5429 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5430:43\n     |\n5430 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5433:26\n     |\n5433 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:22\n     |\n5435 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5436:27\n     |\n5436 |     kind: ast::GroupKind::default(),\n     |                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5437:46\n     |\n5437 |     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5442:7\n     |\n5442 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Alternation(ast::Alternation {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Alternation(ast::Alternation {\n5391 +             GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n5395 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5395 -             ast::GroupState::Group {\n5395 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5428:10\n     |\n5428 |     ast::GroupState::Alternation(ast::Alternation {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5428 -     ast::GroupState::Alternation(ast::Alternation {\n5428 +     GroupState::Alternation(ast::Alternation {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5432:10\n     |\n5432 |     ast::GroupState::Group {\n     |          ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5432 -     ast::GroupState::Group {\n5432 +     GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:34\n     |\n5392 |                 span: ast::Span::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:55\n     |\n5393 |                 asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                                       ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:38\n     |\n5396 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:38\n     |\n5398 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5399:43\n     |\n5399 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5400:62\n     |\n5400 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5405:11\n     |\n5405 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5419:43\n     |\n5419 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5429:22\n     |\n5429 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5430:43\n     |\n5430 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5433:26\n     |\n5433 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5435:22\n     |\n5435 |     span: ast::Span::default(),\n     |                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5436:27\n     |\n5436 |     kind: ast::GroupKind::default(),\n     |                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5437:46\n     |\n5437 |     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5442:7\n     |\n5442 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let group_concat = ast::Concat {",
                "        span: ast::Span {",
                "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                "            end: ast::Position { offset: 5, line: 1, column: 6 },",
                "        },",
                "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                "    };",
                "",
                "    let mut parser = Parser {",
                "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                "        nest_limit: 5,",
                "        capture_index: Cell::new(0),",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        ..Default::default()",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: \"\",",
                "    };",
                "",
                "    parser_instance.pop_group(group_concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert_eq!(parser_instance.pos(), ast::Position { offset: 9, line: 1, column: 10 });"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack = parser_instance.parser().stack_group.borrow();",
                  "    assert!(stack.is_empty());"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack = parser_instance.parser().stack_group.borrow();",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack = parser_instance.parser().stack_group.borrow();",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::GroupUnopened);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert_eq!(parser_instance.pos(), ast::Position { offset: 9, line: 1, column: 10 });",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack = parser_instance.parser().stack_group.borrow();",
                  "    assert!(stack.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack = parser_instance.parser().stack_group.borrow();",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 9, line: 1, column: 10 }),",
                  "        nest_limit: 5,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack = parser_instance.parser().stack_group.borrow();",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::GroupUnopened);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:47\n     |\n5382 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:11\n     |\n5392 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:43\n     |\n5406 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:47\n     |\n5382 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:11\n     |\n5392 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:43\n     |\n5406 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:47\n     |\n5382 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:11\n     |\n5392 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:43\n     |\n5406 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:47\n     |\n5382 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:11\n     |\n5392 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:43\n     |\n5406 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let group_concat = ast::Concat {",
                "        span: ast::Span {",
                "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                "            end: ast::Position { offset: 5, line: 1, column: 6 },",
                "        },",
                "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                "    };",
                "",
                "    let mut parser = Parser {",
                "        pos: Cell::new(ast::Position { offset: 1, line: 1, column: 2 }),",
                "        nest_limit: 0,",
                "        capture_index: Cell::new(0),",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        ..Default::default()",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: \"\",",
                "    };",
                "",
                "    parser_instance.pop_group(group_concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 1, line: 1, column: 2 }),",
                  "    nest_limit: 0,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group::default(),",
                  "    ignore_whitespace: false,",
                  "    }]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 1, line: 1, column: 2 }),",
                  "    nest_limit: 0,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group::default(),",
                  "    ignore_whitespace: false,",
                  "    }]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert_eq!(prior_concat.asts.len(), 1);"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 1, line: 1, column: 2 }),",
                  "    nest_limit: 0,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group::default(),",
                  "    ignore_whitespace: false,",
                  "    }]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert!(matches!(prior_concat.asts[0], ast::Ast::Group(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 1, line: 1, column: 2 }),",
                  "        nest_limit: 0,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 1, line: 1, column: 2 }),",
                  "    nest_limit: 0,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group::default(),",
                  "    ignore_whitespace: false,",
                  "    }]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 1, line: 1, column: 2 }),",
                  "        nest_limit: 0,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 1, line: 1, column: 2 }),",
                  "    nest_limit: 0,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group::default(),",
                  "    ignore_whitespace: false,",
                  "    }]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert_eq!(prior_concat.asts.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 1, line: 1, column: 2 }),",
                  "        nest_limit: 0,",
                  "        capture_index: Cell::new(0),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 5, line: 1, column: 6 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let mut parser = Parser {",
                  "    pos: Cell::new(ast::Position { offset: 1, line: 1, column: 2 }),",
                  "    nest_limit: 0,",
                  "    capture_index: Cell::new(0),",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![Group {",
                  "    concat: ast::Concat::default(),",
                  "    group: ast::Group::default(),",
                  "    ignore_whitespace: false,",
                  "    }]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert!(matches!(prior_concat.asts[0], ast::Ast::Group(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5413:36\n     |\n5413 |     stack_group: RefCell::new(vec![Group {\n     |                                    ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5391:11\n     |\n5391 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:43\n     |\n5405 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:26\n     |\n5414 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Group` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:24\n     |\n5415 |     group: ast::Group::default(),\n     |                        ^^^^^^^ function or associated item not found in `ast::Group`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1192:1\n     |\n1192 | pub struct Group {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5418:7\n     |\n5418 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5413:36\n     |\n5413 |     stack_group: RefCell::new(vec![Group {\n     |                                    ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5391:11\n     |\n5391 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:43\n     |\n5405 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:26\n     |\n5414 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Group` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:24\n     |\n5415 |     group: ast::Group::default(),\n     |                        ^^^^^^^ function or associated item not found in `ast::Group`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1192:1\n     |\n1192 | pub struct Group {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5418:7\n     |\n5418 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5413:36\n     |\n5413 |     stack_group: RefCell::new(vec![Group {\n     |                                    ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5391:11\n     |\n5391 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:43\n     |\n5405 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:26\n     |\n5414 |     concat: ast::Concat::default(),\n     |                          ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Group` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:24\n     |\n5415 |     group: ast::Group::default(),\n     |                        ^^^^^^^ function or associated item not found in `ast::Group`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1192:1\n     |\n1192 | pub struct Group {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5418:7\n     |\n5418 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let group_concat = ast::Concat {",
                "        span: ast::Span {",
                "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                "        },",
                "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                "    };",
                "",
                "    let mut parser = Parser {",
                "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                "        nest_limit: 10,",
                "        capture_index: Cell::new(5),",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![",
                "            ast::GroupState::Group {",
                "                concat: ast::Concat::default(),",
                "                group: ast::Group {",
                "                    span: ast::Span::default(),",
                "                    kind: ast::GroupKind::default(),",
                "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                "                },",
                "                ignore_whitespace: false,",
                "            }",
                "        ]),",
                "        ..Default::default()",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: \"\",",
                "    };",
                "",
                "    parser_instance.pop_group(group_concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert_eq!(parser.pos.get(), ast::Position { offset: 15, line: 1, column: 16 });"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert_eq!(parser.nest_limit, 10);"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert_eq!(parser.capture_index.get(), 5);"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert!(!parser.ignore_whitespace.get());"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert!(parser.comments.borrow().is_empty());"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack_group = parser.stack_group.borrow();",
                  "    assert_eq!(stack_group.len(), 1);"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack_group = parser.stack_group.borrow();",
                  "    assert!(matches!(stack_group.get(0), Some(ast::GroupState::Group { .. })));"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack_group = parser.stack_group.borrow();",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack_group = parser.stack_group.borrow();",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert_eq!(prior_concat.asts.len(), 1);"
                ],
                [
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack_group = parser.stack_group.borrow();",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert_matches!(prior_concat.asts[0], ast::Ast::Group(_));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                  "        nest_limit: 10,",
                  "        capture_index: Cell::new(5),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert_eq!(parser.pos.get(), ast::Position { offset: 15, line: 1, column: 16 });",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                  "        nest_limit: 10,",
                  "        capture_index: Cell::new(5),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert_eq!(parser.nest_limit, 10);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                  "        nest_limit: 10,",
                  "        capture_index: Cell::new(5),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert_eq!(parser.capture_index.get(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                  "        nest_limit: 10,",
                  "        capture_index: Cell::new(5),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert!(!parser.ignore_whitespace.get());",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                  "        nest_limit: 10,",
                  "        capture_index: Cell::new(5),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    assert!(parser.comments.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                  "        nest_limit: 10,",
                  "        capture_index: Cell::new(5),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack_group = parser.stack_group.borrow();",
                  "    assert_eq!(stack_group.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                  "        nest_limit: 10,",
                  "        capture_index: Cell::new(5),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack_group = parser.stack_group.borrow();",
                  "    assert!(matches!(stack_group.get(0), Some(ast::GroupState::Group { .. })));",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                  "        nest_limit: 10,",
                  "        capture_index: Cell::new(5),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack_group = parser.stack_group.borrow();",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                  "        nest_limit: 10,",
                  "        capture_index: Cell::new(5),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack_group = parser.stack_group.borrow();",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert_eq!(prior_concat.asts.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let group_concat = ast::Concat {",
                  "        span: ast::Span {",
                  "            start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "            end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "        },",
                  "        asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "",
                  "    let mut parser = Parser {",
                  "        pos: Cell::new(ast::Position { offset: 15, line: 1, column: 16 }),",
                  "        nest_limit: 10,",
                  "        capture_index: Cell::new(5),",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![",
                  "            ast::GroupState::Group {",
                  "                concat: ast::Concat::default(),",
                  "                group: ast::Group {",
                  "                    span: ast::Span::default(),",
                  "                    kind: ast::GroupKind::default(),",
                  "                    ast: Box::new(ast::Ast::Empty(ast::Span::default())),",
                  "                },",
                  "                ignore_whitespace: false,",
                  "            }",
                  "        ]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    parser_instance.pop_group(group_concat);",
                  "    let group_concat = ast::Concat {",
                  "    span: ast::Span {",
                  "    start: ast::Position { offset: 0, line: 1, column: 1 },",
                  "    end: ast::Position { offset: 20, line: 1, column: 21 },",
                  "    },",
                  "    asts: vec![ast::Ast::Empty(ast::Span::default())],",
                  "    };",
                  "    let stack_group = parser.stack_group.borrow();",
                  "    let result = parser_instance.pop_group(group_concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert_matches!(prior_concat.asts[0], ast::Ast::Group(_));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:43\n     |\n5415 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:43\n     |\n5415 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:43\n     |\n5415 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:43\n     |\n5415 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:43\n     |\n5415 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:43\n     |\n5415 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5418:52\n     |\n5418 |     assert!(matches!(stack_group.get(0), Some(ast::GroupState::Group { .. })));\n     |                                                    ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5418 -     assert!(matches!(stack_group.get(0), Some(ast::GroupState::Group { .. })));\n5418 +     assert!(matches!(stack_group.get(0), Some(GroupState::Group { .. })));\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:43\n     |\n5415 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:43\n     |\n5415 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:43\n     |\n5415 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: cannot find macro `assert_matches` in this scope\n    --> regex-syntax/src/ast/parse.rs:5420:5\n     |\n5420 |     assert_matches!(prior_concat.asts[0], ast::Ast::Group(_));\n     |     ^^^^^^^^^^^^^^\n     |\nhelp: consider importing this macro\n     |\n5368 +    use std::assert_matches::assert_matches;\n     |\n\nerror[E0433]: failed to resolve: could not find `GroupState` in `ast`\n    --> regex-syntax/src/ast/parse.rs:5391:18\n     |\n5391 |             ast::GroupState::Group {\n     |                  ^^^^^^^^^^ could not find `GroupState` in `ast`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::parse::GroupState;\n     |\nhelp: if you import `GroupState`, refer to it directly\n     |\n5391 -             ast::GroupState::Group {\n5391 +             GroupState::Group {\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:47\n     |\n5381 |         asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                               ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Concat` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:38\n     |\n5392 |                 concat: ast::Concat::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Concat`\n     |\n    ::: regex-syntax/src/ast/mod.rs:586:1\n     |\n586  | pub struct Concat {\n     | ----------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:38\n     |\n5394 |                     span: ast::Span::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5395:43\n     |\n5395 |                     kind: ast::GroupKind::default(),\n     |                                           ^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |                     ast: Box::new(ast::Ast::Empty(ast::Span::default())),\n     |                                                              ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5401:11\n     |\n5401 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:43\n     |\n5415 |     asts: vec![ast::Ast::Empty(ast::Span::default())],\n     |                                           ^^^^^^^ function or associated item not found in `Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: (*left_val == *right_val) is true\n",
        "// constraint: stack.pop() matches Some(Group { concat, group, ignore_whitespace }) or Some(Alternation(alt)) is true\n",
        "// constraint: stack.pop() matches None is true\n",
        "// constraint: stack.pop() matches Some(Group { concat, group, ignore_whitespace }) is true\n",
        "// constraint: alt matches Some(mut alt) is true\n",
        "// constraint: alt matches Some(mut alt) is true\n",
        "// expected return value/type: Ok(prior_concat)\n"
      ],
      "input_infer": "0 <= nest_limit <= 100, 0 <= capture_index <= 100, 0 <= asts.length <= 10, valid_pattern_length = 0 <= length of pattern string <= 1000, valid_span_length = 0 <= length of span <= 100, valid_group_count = 0 <= group count <= 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc(def)\";",
                "    let span = Span {",
                "        start: Position { offset: 0, line: 1, column: 1 },",
                "        end: Position { offset: 10, line: 1, column: 11 },",
                "    };",
                "    let group = Group {",
                "        span: span.clone(),",
                "        kind: GroupKind::Capture,",
                "        ast: Box::new(Ast::Empty(span.clone())),",
                "    };",
                "    let concat = Concat {",
                "        span: span.clone(),",
                "        asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                "    };",
                "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                "    ",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { offset: 10, line: 1, column: 11 }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group,",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI::new(parser, pattern);",
                "    let result = parser_instance.pop_group(concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 0, line: 1, column: 1 },",
                  "    end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "    span: span.clone(),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    parser_instance.parser().stack_group = stack_group;",
                  "    assert_eq!(parser_instance.char(), ')');"
                ],
                [
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 0, line: 1, column: 1 },",
                  "    end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "    span: span.clone(),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    parser_instance.parser().stack_group = stack_group;",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 0, line: 1, column: 1 },",
                  "    end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "    span: span.clone(),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    parser_instance.parser().stack_group = stack_group;",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert_eq!(prior_concat.asts.len(), 1);"
                ],
                [
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 0, line: 1, column: 1 },",
                  "    end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "    span: span.clone(),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    parser_instance.parser().stack_group = stack_group;",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert!(matches!(prior_concat.asts[0], Ast::Group(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    ",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 10, line: 1, column: 11 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 0, line: 1, column: 1 },",
                  "    end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "    span: span.clone(),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    parser_instance.parser().stack_group = stack_group;",
                  "    assert_eq!(parser_instance.char(), ')');",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    ",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 10, line: 1, column: 11 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 0, line: 1, column: 1 },",
                  "    end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "    span: span.clone(),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    parser_instance.parser().stack_group = stack_group;",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    ",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 10, line: 1, column: 11 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 0, line: 1, column: 1 },",
                  "    end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "    span: span.clone(),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    parser_instance.parser().stack_group = stack_group;",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert_eq!(prior_concat.asts.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    ",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 10, line: 1, column: 11 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"abc(def)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 0, line: 1, column: 1 },",
                  "    end: Position { offset: 10, line: 1, column: 11 },",
                  "    };",
                  "    let group = Group {",
                  "    span: span.clone(),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    parser_instance.parser().stack_group = stack_group;",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let prior_concat = result.unwrap();",
                  "    assert!(matches!(prior_concat.asts[0], Ast::Group(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:18\n     |\n5386 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:33\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:17\n     |\n5411 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5413:11\n     |\n5413 |     kind: GroupKind::Capture,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5416:18\n     |\n5416 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5418:29\n     |\n5418 |     asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:18\n     |\n5392 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:18\n     |\n5386 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:33\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:17\n     |\n5411 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5413:11\n     |\n5413 |     kind: GroupKind::Capture,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5416:18\n     |\n5416 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5418:29\n     |\n5418 |     asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:18\n     |\n5392 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:18\n     |\n5386 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:33\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:17\n     |\n5411 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5413:11\n     |\n5413 |     kind: GroupKind::Capture,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5416:18\n     |\n5416 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5418:29\n     |\n5418 |     asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:18\n     |\n5392 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:18\n     |\n5386 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:33\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5411:17\n     |\n5411 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5413:11\n     |\n5413 |     kind: GroupKind::Capture,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5416:18\n     |\n5416 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5418:29\n     |\n5418 |     asts: vec![Ast::Literal(Literal::new(\"abc\")), Ast::Group(group.clone())],\n     |                             ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:18\n     |\n5392 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let pattern = \"abc)\";",
                "    let span = Span {",
                "        start: Position { offset: 3, line: 1, column: 4 },",
                "        end: Position { offset: 4, line: 1, column: 5 },",
                "    };",
                "    let concat = Concat {",
                "        span: span.clone(),",
                "        asts: vec![],",
                "    };",
                "    let stack_group = RefCell::new(vec![]);",
                "",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { offset: 4, line: 1, column: 5 }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group,",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI::new(parser, pattern);",
                "    let result = parser_instance.pop_group(concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 3, line: 1, column: 4 },",
                  "    end: Position { offset: 4, line: 1, column: 5 },",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![],",
                  "    };",
                  "    let stack_group = RefCell::new(vec![]);",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position { offset: 4, line: 1, column: 5 }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group,",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \"abc)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 3, line: 1, column: 4 },",
                  "    end: Position { offset: 4, line: 1, column: 5 },",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![],",
                  "    };",
                  "    let stack_group = RefCell::new(vec![]);",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position { offset: 4, line: 1, column: 5 }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group,",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::GroupUnopened);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 3, line: 1, column: 4 },",
                  "        end: Position { offset: 4, line: 1, column: 5 },",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![],",
                  "    };",
                  "    let stack_group = RefCell::new(vec![]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 4, line: 1, column: 5 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"abc)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 3, line: 1, column: 4 },",
                  "    end: Position { offset: 4, line: 1, column: 5 },",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![],",
                  "    };",
                  "    let stack_group = RefCell::new(vec![]);",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position { offset: 4, line: 1, column: 5 }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group,",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 3, line: 1, column: 4 },",
                  "        end: Position { offset: 4, line: 1, column: 5 },",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![],",
                  "    };",
                  "    let stack_group = RefCell::new(vec![]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 4, line: 1, column: 5 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"abc)\";",
                  "    let span = Span {",
                  "    start: Position { offset: 3, line: 1, column: 4 },",
                  "    end: Position { offset: 4, line: 1, column: 5 },",
                  "    };",
                  "    let concat = Concat {",
                  "    span: span.clone(),",
                  "    asts: vec![],",
                  "    };",
                  "    let stack_group = RefCell::new(vec![]);",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position { offset: 4, line: 1, column: 5 }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group,",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::GroupUnopened);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n5382 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5407:18\n     |\n5407 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:18\n     |\n5388 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5412:18\n     |\n5412 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n5382 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5407:18\n     |\n5407 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5388:18\n     |\n5388 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5412:18\n     |\n5412 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"a(b|c)\";",
                "    let span = Span {",
                "        start: Position { offset: 0, line: 1, column: 1 },",
                "        end: Position { offset: 6, line: 1, column: 7 },",
                "    };",
                "    let group = Group {",
                "        span: span.clone(),",
                "        kind: GroupKind::Capture,",
                "        ast: Box::new(Ast::Empty(span.clone())),",
                "    };",
                "    let alt = Alternation {",
                "        span: span.clone(),",
                "        asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],",
                "    };",
                "    let concat = Concat {",
                "        span: span.clone(),",
                "        asts: vec![Ast::Literal(Literal::new(\"a\"))],",
                "    };",
                "    let mut stack_group = RefCell::new(vec![",
                "        GroupState::Alternation(alt.clone()),",
                "        GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false },",
                "    ]);",
                "",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { offset: 6, line: 1, column: 7 }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group,",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI::new(parser, pattern);",
                "    let result = parser_instance.pop_group(concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(result.unwrap(), prior_concat);"
                ],
                [
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(parser_instance.pos(), Position { offset: 7, line: 1, column: 8 });"
                ],
                [
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(parser_instance.stack_group.borrow().len(), 1);"
                ],
                [
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(parser_instance.stack_group.borrow()[0], GroupState::Alternation(alt));"
                ],
                [
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(parser_instance.parser().ignore_whitespace.get(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 6, line: 1, column: 7 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let alt = Alternation {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"a\"))],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![",
                  "        GroupState::Alternation(alt.clone()),",
                  "        GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false },",
                  "    ]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 6, line: 1, column: 7 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 6, line: 1, column: 7 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let alt = Alternation {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"a\"))],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![",
                  "        GroupState::Alternation(alt.clone()),",
                  "        GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false },",
                  "    ]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 6, line: 1, column: 7 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(result.unwrap(), prior_concat);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 6, line: 1, column: 7 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let alt = Alternation {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"a\"))],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![",
                  "        GroupState::Alternation(alt.clone()),",
                  "        GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false },",
                  "    ]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 6, line: 1, column: 7 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(parser_instance.pos(), Position { offset: 7, line: 1, column: 8 });",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 6, line: 1, column: 7 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let alt = Alternation {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"a\"))],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![",
                  "        GroupState::Alternation(alt.clone()),",
                  "        GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false },",
                  "    ]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 6, line: 1, column: 7 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(parser_instance.stack_group.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 6, line: 1, column: 7 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let alt = Alternation {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"a\"))],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![",
                  "        GroupState::Alternation(alt.clone()),",
                  "        GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false },",
                  "    ]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 6, line: 1, column: 7 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(parser_instance.stack_group.borrow()[0], GroupState::Alternation(alt));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 6, line: 1, column: 7 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let alt = Alternation {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![Ast::Literal(Literal::new(\"a\"))],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![",
                  "        GroupState::Alternation(alt.clone()),",
                  "        GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false },",
                  "    ]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 6, line: 1, column: 7 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"a(b|c)\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 6, line: 1, column: 7 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };",
                  "    let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };",
                  "    let mut stack_group = RefCell::new(vec![ GroupState::Alternation(alt.clone()), GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false } ]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(parser_instance.parser().ignore_whitespace.get(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |     let alt = Alternation {\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:33\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:66\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5390:18\n     |\n5390 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5392:33\n     |\n5392 |         asts: vec![Ast::Literal(Literal::new(\"a\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:17\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5415:51\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5416:15\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:73\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                         ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:106\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                                                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5417:18\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5417:71\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                                                                       ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5399:18\n     |\n5399 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5419:18\n     |\n5419 |     let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal:...\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |     let alt = Alternation {\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:33\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:66\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5390:18\n     |\n5390 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5392:33\n     |\n5392 |         asts: vec![Ast::Literal(Literal::new(\"a\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:17\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5415:51\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5416:15\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:73\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                         ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:106\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                                                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5417:18\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5417:71\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                                                                       ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0425]: cannot find value `prior_concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5422:33\n     |\n5422 |     assert_eq!(result.unwrap(), prior_concat);\n     |                                 ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5399:18\n     |\n5399 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5419:18\n     |\n5419 |     let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal:...\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |     let alt = Alternation {\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:33\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:66\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5390:18\n     |\n5390 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5392:33\n     |\n5392 |         asts: vec![Ast::Literal(Literal::new(\"a\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:17\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5415:51\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5416:15\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:73\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                         ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:106\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                                                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5417:18\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5417:71\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                                                                       ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5399:18\n     |\n5399 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5419:18\n     |\n5419 |     let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal:...\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |     let alt = Alternation {\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:33\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:66\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5390:18\n     |\n5390 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5392:33\n     |\n5392 |         asts: vec![Ast::Literal(Literal::new(\"a\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:17\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5415:51\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5416:15\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:73\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                         ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:106\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                                                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5417:18\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5417:71\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                                                                       ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5399:18\n     |\n5399 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5419:18\n     |\n5419 |     let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal:...\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0609]: no field `stack_group` on type `parse::ParserI<'_, parse::Parser>`\n    --> regex-syntax/src/ast/parse.rs:5422:32\n     |\n5422 |     assert_eq!(parser_instance.stack_group.borrow().len(), 1);\n     |                                ^^^^^^^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n5422 |     assert_eq!(parser_instance.parser.stack_group.borrow().len(), 1);\n     |                                +++++++\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433, E0609.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |     let alt = Alternation {\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:33\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:66\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5390:18\n     |\n5390 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5392:33\n     |\n5392 |         asts: vec![Ast::Literal(Literal::new(\"a\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:17\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5415:51\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5416:15\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:73\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                         ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:106\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                                                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5417:18\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5417:71\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                                                                       ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5399:18\n     |\n5399 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5419:18\n     |\n5419 |     let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal:...\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0609]: no field `stack_group` on type `parse::ParserI<'_, parse::Parser>`\n    --> regex-syntax/src/ast/parse.rs:5422:32\n     |\n5422 |     assert_eq!(parser_instance.stack_group.borrow()[0], GroupState::Alternation(alt));\n     |                                ^^^^^^^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n5422 |     assert_eq!(parser_instance.parser.stack_group.borrow()[0], GroupState::Alternation(alt));\n     |                                +++++++\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433, E0609.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:15\n     |\n5386 |     let alt = Alternation {\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:33\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5388:66\n     |\n5388 |         asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))],\n     |                                                                  ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5390:18\n     |\n5390 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5392:33\n     |\n5392 |         asts: vec![Ast::Literal(Literal::new(\"a\"))],\n     |                                 ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5415:17\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5415:51\n     |\n5415 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n    --> regex-syntax/src/ast/parse.rs:5416:15\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |               ^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Alternation;\n     |\n5368 +    use ast::Ast::Alternation;\n     |\n5368 +    use ast::parse::GroupState::Alternation;\n     |\n5368 +    use hir::HirKind::Alternation;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:73\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                         ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5416:106\n     |\n5416 |     let alt = Alternation { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"b\")), Ast::Literal(Literal::new(\"c\"))] };\n     |                                                                                                          ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5417:18\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n    --> regex-syntax/src/ast/parse.rs:5417:71\n     |\n5417 |     let concat = Concat { span: span.clone(), asts: vec![Ast::Literal(Literal::new(\"a\"))] };\n     |                                                                       ^^^^^^^ use of undeclared type `Literal`\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Literal;\n     |\n5368 +    use hir::Literal;\n     |\n5368 +    use hir::literal::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5399:18\n     |\n5399 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5419:18\n     |\n5419 |     let parser = Parser { pos: Cell::new(Position { offset: 6, line: 1, column: 7 }), capture_index: Cell::new(0), nest_limit: 10, octal:...\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"()\";",
                "    let span = Span {",
                "        start: Position { offset: 0, line: 1, column: 1 },",
                "        end: Position { offset: 2, line: 1, column: 3 },",
                "    };",
                "    let group = Group {",
                "        span: span.clone(),",
                "        kind: GroupKind::Capture,",
                "        ast: Box::new(Ast::Empty(span.clone())),",
                "    };",
                "    let concat = Concat {",
                "        span: span.clone(),",
                "        asts: vec![],",
                "    };",
                "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                "",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { offset: 2, line: 1, column: 3 }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group,",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI::new(parser, pattern);",
                "    let result = parser_instance.pop_group(concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"()\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 2, line: 1, column: 3 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let concat = Concat { span: span.clone(), asts: vec![] };",
                  "    let stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let pattern = \"()\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 2, line: 1, column: 3 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let concat = Concat { span: span.clone(), asts: vec![] };",
                  "    let stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(result.unwrap().asts.len(), 1);"
                ],
                [
                  "    let pattern = \"()\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 2, line: 1, column: 3 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let concat = Concat { span: span.clone(), asts: vec![] };",
                  "    let stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(result.unwrap().asts[0], Ast::Group(group));"
                ],
                [
                  "    let pattern = \"()\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 2, line: 1, column: 3 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let concat = Concat { span: span.clone(), asts: vec![] };",
                  "    let stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(parser_instance.pos(), Position { offset: 2, line: 1, column: 3 });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"()\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 2, line: 1, column: 3 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 2, line: 1, column: 3 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"()\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 2, line: 1, column: 3 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let concat = Concat { span: span.clone(), asts: vec![] };",
                  "    let stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"()\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 2, line: 1, column: 3 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 2, line: 1, column: 3 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"()\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 2, line: 1, column: 3 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let concat = Concat { span: span.clone(), asts: vec![] };",
                  "    let stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(result.unwrap().asts.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"()\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 2, line: 1, column: 3 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 2, line: 1, column: 3 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"()\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 2, line: 1, column: 3 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let concat = Concat { span: span.clone(), asts: vec![] };",
                  "    let stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(result.unwrap().asts[0], Ast::Group(group));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"()\";",
                  "    let span = Span {",
                  "        start: Position { offset: 0, line: 1, column: 1 },",
                  "        end: Position { offset: 2, line: 1, column: 3 },",
                  "    };",
                  "    let group = Group {",
                  "        span: span.clone(),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Empty(span.clone())),",
                  "    };",
                  "    let concat = Concat {",
                  "        span: span.clone(),",
                  "        asts: vec![],",
                  "    };",
                  "    let mut stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { offset: 2, line: 1, column: 3 }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group,",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    let pattern = \"()\";",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 2, line: 1, column: 3 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let concat = Concat { span: span.clone(), asts: vec![] };",
                  "    let stack_group = RefCell::new(vec![GroupState::Group { concat: concat.clone(), group: group, ignore_whitespace: false }]);",
                  "    let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group, scratch: RefCell::new(String::new()) };",
                  "    let parser_instance = ParserI::new(parser, pattern);",
                  "    let result = parser_instance.pop_group(concat);",
                  "    assert_eq!(parser_instance.pos(), Position { offset: 2, line: 1, column: 3 });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:18\n     |\n5386 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5408:17\n     |\n5408 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5408:51\n     |\n5408 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5409:18\n     |\n5409 |     let concat = Concat { span: span.clone(), asts: vec![] };\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:18\n     |\n5392 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5411:18\n     |\n5411 |     let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal:...\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:18\n     |\n5386 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5408:17\n     |\n5408 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5408:51\n     |\n5408 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5409:18\n     |\n5409 |     let concat = Concat { span: span.clone(), asts: vec![] };\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:18\n     |\n5392 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5411:18\n     |\n5411 |     let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal:...\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:18\n     |\n5386 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5408:17\n     |\n5408 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5408:51\n     |\n5408 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5409:18\n     |\n5409 |     let concat = Concat { span: span.clone(), asts: vec![] };\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:18\n     |\n5392 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5411:18\n     |\n5411 |     let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal:...\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:17\n     |\n5381 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5383:15\n     |\n5383 |         kind: GroupKind::Capture,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:18\n     |\n5386 |     let concat = Concat {\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5408:17\n     |\n5408 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5408:51\n     |\n5408 |     let group = Group { span: span.clone(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5409:18\n     |\n5409 |     let concat = Concat { span: span.clone(), asts: vec![] };\n     |                  ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5392:18\n     |\n5392 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nerror[E0063]: missing fields `capture_names` and `stack_class` in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5411:18\n     |\n5411 |     let parser = Parser { pos: Cell::new(Position { offset: 2, line: 1, column: 3 }), capture_index: Cell::new(0), nest_limit: 10, octal:...\n     |                  ^^^^^^ missing `capture_names` and `stack_class`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: (*left_val == *right_val) is false\n"
      ],
      "input_infer": "0 < left_val < right_val < usize::MAX\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = Parser { /* initialization */ };",
                "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                "    let parser_i = ParserI::new(&parser, \"(abc\");",
                "",
                "    let result = parser_i.pop_group(group_concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::GroupUnopened);"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "    assert_eq!(result.unwrap_err().pattern, \"(abc\");"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "    assert_eq!(result.unwrap_err().span.start, Position { offset: 1, line: 1, column: 2 });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::GroupUnopened);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "    assert_eq!(result.unwrap_err().pattern, \"(abc\");",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc\");",
                  "    assert_eq!(result.unwrap_err().span.start, Position { offset: 1, line: 1, column: 2 });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:24\n     |\n5377 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:24\n     |\n5382 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5381:18\n     |\n5381 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:24\n     |\n5377 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:24\n     |\n5382 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5381:18\n     |\n5381 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:24\n     |\n5377 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:24\n     |\n5382 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5381:18\n     |\n5381 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:24\n     |\n5377 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:24\n     |\n5382 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5381:18\n     |\n5381 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = Parser { /* initialization */ };",
                "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                "",
                "    let result = parser_i.pop_group(group_concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert_eq!(parser_i.char(), ')');"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert!(parser_i.pop_group(group_concat).is_ok());"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    let result = parser_i.pop_group(group_concat).unwrap();",
                  "    assert_eq!(result.asts.len(), 1);"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    let result = parser_i.pop_group(group_concat).unwrap();",
                  "    assert!(matches!(result.asts[0], Ast::Group(_)));"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    let result = parser_i.pop_group(group_concat).unwrap();",
                  "    assert_eq!(result.span.end, parser_i.pos());"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    let result = parser_i.pop_group(group_concat).unwrap();",
                  "    assert!(parser_i.is_eof());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert_eq!(parser_i.char(), ')');",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert!(parser_i.pop_group(group_concat).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    let result = parser_i.pop_group(group_concat).unwrap();",
                  "    assert_eq!(result.asts.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    let result = parser_i.pop_group(group_concat).unwrap();",
                  "    assert!(matches!(result.asts[0], Ast::Group(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    let result = parser_i.pop_group(group_concat).unwrap();",
                  "    assert_eq!(result.span.end, parser_i.pos());",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    let result = parser_i.pop_group(group_concat).unwrap();",
                  "    assert!(parser_i.is_eof());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:17\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5378:51\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:24\n     |\n5379 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5385:51\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:24\n     |\n5386 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5383:18\n     |\n5383 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:17\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5378:51\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:24\n     |\n5379 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5385:51\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:24\n     |\n5386 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5383:18\n     |\n5383 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:17\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5378:51\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:24\n     |\n5379 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5385:51\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:24\n     |\n5386 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5383:18\n     |\n5383 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:17\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5378:51\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:24\n     |\n5379 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5385:51\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:24\n     |\n5386 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5383:18\n     |\n5383 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:17\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5378:51\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:24\n     |\n5379 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5385:51\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:24\n     |\n5386 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5383:18\n     |\n5383 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:17\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5378:51\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:24\n     |\n5379 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5385:51\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:24\n     |\n5386 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5383:18\n     |\n5383 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = Parser { /* initialization */ };",
                "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                "    let group_concat = Concat { span, asts: vec![] };",
                "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                "",
                "    let result = parser_i.pop_group(group_concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert_eq!(result.unwrap().asts.len(), 1);"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert_eq!(parser_i.pos().offset, 5);"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert_eq!(parser_i.char(), 'a');"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert_eq!(result.unwrap().asts.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert_eq!(parser_i.pos().offset, 5);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group_concat = Concat { span, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc)\");",
                  "    assert_eq!(parser_i.char(), 'a');",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:24\n     |\n5378 |     let group_concat = Concat { span, asts: vec![] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:24\n     |\n5384 |     let group_concat = Concat { span, asts: vec![] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n5382 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:24\n     |\n5378 |     let group_concat = Concat { span, asts: vec![] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:24\n     |\n5384 |     let group_concat = Concat { span, asts: vec![] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n5382 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:24\n     |\n5378 |     let group_concat = Concat { span, asts: vec![] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:24\n     |\n5384 |     let group_concat = Concat { span, asts: vec![] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n5382 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:24\n     |\n5378 |     let group_concat = Concat { span, asts: vec![] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:24\n     |\n5384 |     let group_concat = Concat { span, asts: vec![] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n5382 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let parser = Parser { /* initialization */ };",
                "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                "    let parser_i = ParserI::new(&parser, \")\");",
                "",
                "    let result = parser_i.pop_group(group_concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \")\");",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \")\");",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::GroupUnopened);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \")\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \")\");",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \")\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } }, asts: vec![] };",
                  "    let parser_i = ParserI::new(&parser, \")\");",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::GroupUnopened);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:24\n     |\n5378 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:24\n     |\n5383 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n5377 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n5382 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:24\n     |\n5378 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:24\n     |\n5383 |     let group_concat = Concat { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, colum...\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5377:18\n     |\n5377 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:18\n     |\n5382 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = Parser { /* initialization */ };",
                "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                "",
                "    let result = parser_i.pop_group(group_concat);",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "    assert_eq!(parser_i.char(), ')');"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "    assert!(parser_i.pop_group(group_concat).is_ok());"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "    assert_eq!(parser_i.pos().offset, 2);"
                ],
                [
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "    assert_eq!(parser_i.parser().ignore_whitespace.get(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "    assert_eq!(parser_i.char(), ')');",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "    assert!(parser_i.pop_group(group_concat).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "    assert_eq!(parser_i.pos().offset, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "",
                  "    let result = parser_i.pop_group(group_concat);",
                  "    let parser = Parser { /* initialization */ };",
                  "    let span = Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 1, line: 1, column: 2 } };",
                  "    let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };",
                  "    let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };",
                  "    let parser_i = ParserI::new(&parser, \"(abc|(def))\");",
                  "    assert_eq!(parser_i.parser().ignore_whitespace.get(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:17\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5378:51\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:24\n     |\n5379 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5385:51\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:24\n     |\n5386 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5383:18\n     |\n5383 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5378:17\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5378:51\n     |\n5378 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5379:24\n     |\n5379 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5385:17\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5385:51\n     |\n5385 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:24\n     |\n5386 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5376:18\n     |\n5376 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5383:18\n     |\n5383 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:17\n     |\n5375 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:24\n     |\n5376 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:17\n     |\n5382 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5382:51\n     |\n5382 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:24\n     |\n5383 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5373:18\n     |\n5373 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:18\n     |\n5380 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5375:17\n     |\n5375 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5375:51\n     |\n5375 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5376:24\n     |\n5376 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:17\n     |\n5382 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Group;\n     |\n5368 +    use ast::Group;\n     |\n5368 +    use ast::parse::GroupState::Group;\n     |\n5368 +    use hir::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/ast/parse.rs:5382:51\n     |\n5382 |     let group = Group { span: span.clone(), kind: GroupKind::Simple, ast: Box::new(Ast::Empty(span.clone())) };\n     |                                                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n5368 +    use ast::GroupKind;\n     |\n5368 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n    --> regex-syntax/src/ast/parse.rs:5383:24\n     |\n5383 |     let group_concat = Concat { span: span.clone(), asts: vec![Ast::Group(group)] };\n     |                        ^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n5368 +    use ast::Ast::Concat;\n     |\n5368 +    use ast::Concat;\n     |\n5368 +    use hir::HirKind::Concat;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5373:18\n     |\n5373 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 8 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:18\n     |\n5380 |     let parser = Parser { /* initialization */ };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 8 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}