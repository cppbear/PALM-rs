{
  "name": "regex_syntax::ast::ast::ClassSetUnion::into_item",
  "name_with_impl": "regex_syntax::ast::{impl#25}::into_item",
  "mod_info": {
    "name": "ast",
    "loc": "regex-syntax/src/lib.rs:113:1:113:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/ast/mod.rs:1060:5:1066:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self.items.len() matches 0 is true\n",
        "// constraint: self.items.len() matches 1 is true\n",
        "// constraint: self.items.len() matches _ is true\n",
        "// expected return value/type: ClassSetItem::Union(self)\n"
      ],
      "input_infer": "0, 1, 2\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position, end: Position };",
                "    let class_set_union = ClassSetUnion { span, items: Vec::new() };",
                "    let result = class_set_union.into_item();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = class_set_union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Empty(span));"
                ],
                [
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal)] };",
                  "    let result = class_set_union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Literal(Literal));"
                ],
                [
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal)] };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal), ClassSetItem::Literal(Literal)] };",
                  "    let result = class_set_union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Union(class_set_union));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } };  ",
                  "    let class_set_union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = class_set_union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Empty(span));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal)] };",
                  "    let result = class_set_union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Literal(Literal));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal)] };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal), ClassSetItem::Literal(Literal)] };",
                  "    let result = class_set_union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Union(class_set_union));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1533:83\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1533 |       let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal)] };\n     |                                                                                     ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1533 |     let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal { span: val, kind: val, c: val })] };\n     |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1535:46\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1535 |       assert_eq!(result, ClassSetItem::Literal(Literal));\n     |                                                ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1535 |     assert_eq!(result, ClassSetItem::Literal(Literal { span: val, kind: val, c: val }));\n     |                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1529:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1529 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1532:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1532 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1533:83\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1533 |       let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal)] };\n     |                                                                                     ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1533 |     let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal { span: val, kind: val, c: val })] };\n     |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1535:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1535 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1536:83\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1536 |       let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal), ClassSetItem::Literal(Literal)] };\n     |                                                                                     ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1536 |     let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal { span: val, kind: val, c: val }), ClassSetItem::Literal(Literal)] };\n     |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1536:115\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1536 |       let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal), ClassSetItem::Literal(Literal)] };\n     |                                                                                                                     ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1536 |     let class_set_union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal), ClassSetItem::Literal(Literal { span: val, kind: val, c: val })] };\n     |                                                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position, end: Position };",
                "    let literal_item = ClassSetItem::Literal(Literal);",
                "    let class_set_union = ClassSetUnion { span, items: vec![literal_item] };",
                "    let result = class_set_union.into_item();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position, end: Position };",
                  "    let literal_item = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item] };",
                  "    let result = class_set_union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Literal(Literal));"
                ],
                [
                  "    let span = Span { start: Position, end: Position };",
                  "    let literal_item = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item] };",
                  "    let result = class_set_union.into_item();",
                  "    let empty_union = ClassSetUnion { span, items: vec![] };",
                  "    let result_empty = empty_union.into_item();",
                  "    assert_eq!(result_empty, ClassSetItem::Empty(span));"
                ],
                [
                  "    let span = Span { start: Position, end: Position };",
                  "    let literal_item = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item] };",
                  "    let result = class_set_union.into_item();",
                  "    let empty_union = ClassSetUnion { span, items: vec![] };",
                  "    let result_empty = empty_union.into_item();",
                  "    let multiple_items_union = ClassSetUnion { span, items: vec![literal_item.clone(), literal_item] };",
                  "    let result_multiple = multiple_items_union.into_item();",
                  "    assert!(matches!(result_multiple, ClassSetItem::Union(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position, end: Position };",
                  "    let literal_item = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item] };",
                  "    let result = class_set_union.into_item();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } };  ",
                  "    let literal_item = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item] };",
                  "    let result = class_set_union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Literal(Literal));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position, end: Position };",
                  "    let literal_item = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item] };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let literal_item = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item] };",
                  "    let result = class_set_union.into_item();",
                  "    let empty_union = ClassSetUnion { span, items: vec![] };",
                  "    let result_empty = empty_union.into_item();",
                  "    assert_eq!(result_empty, ClassSetItem::Empty(span));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position, end: Position };",
                  "    let literal_item = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item] };",
                  "    let result = class_set_union.into_item();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } };  ",
                  "    let literal_item = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item] };",
                  "    let result = class_set_union.into_item();",
                  "    let empty_union = ClassSetUnion { span, items: vec![] };",
                  "    let result_empty = empty_union.into_item();",
                  "    let multiple_items_union = ClassSetUnion { span, items: vec![literal_item.clone(), literal_item] };",
                  "    let result_multiple = multiple_items_union.into_item();",
                  "    assert!(matches!(result_multiple, ClassSetItem::Union(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1527:46\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1527 |       let literal_item = ClassSetItem::Literal(Literal);\n     |                                                ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1527 |     let literal_item = ClassSetItem::Literal(Literal { span: val, kind: val, c: val });\n     |                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1531:46\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1531 |       let literal_item = ClassSetItem::Literal(Literal);\n     |                                                ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1531 |     let literal_item = ClassSetItem::Literal(Literal { span: val, kind: val, c: val });\n     |                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1534:46\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1534 |       assert_eq!(result, ClassSetItem::Literal(Literal));\n     |                                                ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1534 |     assert_eq!(result, ClassSetItem::Literal(Literal { span: val, kind: val, c: val }));\n     |                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1527:46\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1527 |       let literal_item = ClassSetItem::Literal(Literal);\n     |                                                ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1527 |     let literal_item = ClassSetItem::Literal(Literal { span: val, kind: val, c: val });\n     |                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1530:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1530 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1531:46\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1531 |       let literal_item = ClassSetItem::Literal(Literal);\n     |                                                ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1531 |     let literal_item = ClassSetItem::Literal(Literal { span: val, kind: val, c: val });\n     |                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1527:46\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1527 |       let literal_item = ClassSetItem::Literal(Literal);\n     |                                                ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1527 |     let literal_item = ClassSetItem::Literal(Literal { span: val, kind: val, c: val });\n     |                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1531:46\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1531 |       let literal_item = ClassSetItem::Literal(Literal);\n     |                                                ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1531 |     let literal_item = ClassSetItem::Literal(Literal { span: val, kind: val, c: val });\n     |                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position, end: Position };",
                "    let literal_item_1 = ClassSetItem::Literal(Literal);",
                "    let literal_item_2 = ClassSetItem::Literal(Literal);",
                "    let class_set_union = ClassSetUnion { span, items: vec![literal_item_1, literal_item_2] };",
                "    let result = class_set_union.into_item();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position, end: Position };",
                  "    let literal_item_1 = ClassSetItem::Literal(Literal);",
                  "    let literal_item_2 = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item_1, literal_item_2] };",
                  "    let result = class_set_union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Union(class_set_union));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } };  ",
                  "    let literal_item_1 = ClassSetItem::Literal(Literal);",
                  "    let literal_item_2 = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item_1, literal_item_2] };",
                  "    let result = class_set_union.into_item();",
                  "    let span = Span { start: Position, end: Position };",
                  "    let literal_item_1 = ClassSetItem::Literal(Literal);",
                  "    let literal_item_2 = ClassSetItem::Literal(Literal);",
                  "    let class_set_union = ClassSetUnion { span, items: vec![literal_item_1, literal_item_2] };",
                  "    let result = class_set_union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Union(class_set_union));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1527:48\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1527 |       let literal_item_1 = ClassSetItem::Literal(Literal);\n     |                                                  ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1527 |     let literal_item_1 = ClassSetItem::Literal(Literal { span: val, kind: val, c: val });\n     |                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1528:48\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1528 |       let literal_item_2 = ClassSetItem::Literal(Literal);\n     |                                                  ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1528 |     let literal_item_2 = ClassSetItem::Literal(Literal { span: val, kind: val, c: val });\n     |                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1531:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1531 |       let span = Span { start: Position, end: Position };\n     |                                ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1531:45\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1531 |       let span = Span { start: Position, end: Position };\n     |                                               ^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1532 |       let literal_item_1 = ClassSetItem::Literal(Literal);\n     |                                                  ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1532 |     let literal_item_1 = ClassSetItem::Literal(Literal { span: val, kind: val, c: val });\n     |                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nerror[E0423]: expected value, found struct `Literal`\n    --> regex-syntax/src/ast/mod.rs:1533:48\n     |\n614  | / pub struct Literal {\n615  | |     /// The span of this literal.\n616  | |     pub span: Span,\n617  | |     /// The kind of this literal.\n...    |\n620  | |     pub c: char,\n621  | | }\n     | |_- `Literal` defined here\n...\n1533 |       let literal_item_2 = ClassSetItem::Literal(Literal);\n     |                                                  ^^^^^^^\n     |\nhelp: use struct literal syntax instead\n     |\n1533 |     let literal_item_2 = ClassSetItem::Literal(Literal { span: val, kind: val, c: val });\n     |                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: consider importing one of these tuple variants instead\n     |\n1518 +    use ast::Ast::Literal;\n     |\n1518 +    use ast::ClassSetItem::Literal;\n     |\n1518 +    use hir::HirKind::Literal;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.items.len() matches 1 is true\n",
        "// constraint: self.items.len() matches 1 is true\n",
        "// constraint: self.items.pop().unwrap() is \n"
      ],
      "input_infer": "items.len() = 1, item = ClassSetItem::Literal(Literal), item = ClassSetItem::Range(ClassSetRange)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(5) };",
                "    let item = ClassSetItem::Literal(Literal('a'));",
                "    let mut union = ClassSetUnion { span, items: vec![item] };",
                "    union.into_item();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item = ClassSetItem::Literal(Literal('a'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Literal(Literal('a')));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Position(u32);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassSetRange {",
                  "    start: char,",
                  "    end: char,",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Literal(char);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassAscii;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassUnicode;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassPerl;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassBracketed;",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item = ClassSetItem::Literal(Literal('a'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item] };",
                  "    union.into_item();",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item = ClassSetItem::Literal(Literal('a'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Literal(Literal('a')));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:30\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:48\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1550:38\n     |\n1550 |     let item = ClassSetItem::Literal(Literal('a'));\n     |                --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1553:30\n     |\n1553 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1553:48\n     |\n1553 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1554:38\n     |\n1554 |     let item = ClassSetItem::Literal(Literal('a'));\n     |                --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1557:46\n     |\n1557 |     assert_eq!(result, ClassSetItem::Literal(Literal('a')));\n     |                        --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                        |\n     |                        arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(5) };",
                "    let item = ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' });",
                "    let mut union = ClassSetUnion { span, items: vec![item] };",
                "    union.into_item();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item = ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' });",
                  "    let mut union = ClassSetUnion { span, items: vec![item] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Position(u32);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassSetRange {",
                  "    start: char,",
                  "    end: char,",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Literal(char);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassAscii;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassUnicode;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassPerl;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassBracketed;",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item = ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' });",
                  "    let mut union = ClassSetUnion { span, items: vec![item] };",
                  "    union.into_item();",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item = ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' });",
                  "    let mut union = ClassSetUnion { span, items: vec![item] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:30\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:48\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1550:36\n     |\n1550 |     let item = ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' });\n     |                ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ast::ClassSetRange`, found `ntest_callback::ClassSetRange`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::ClassSetRange` and `ast::ClassSetRange` have similar names, but are actually distinct types\nnote: `ntest_callback::ClassSetRange` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1530:1\n     |\n1530 | struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^\nnote: `ast::ClassSetRange` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:973:5\n     |\n973  |     Range(ClassSetRange),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1553:30\n     |\n1553 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1553:48\n     |\n1553 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1554:36\n     |\n1554 |     let item = ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' });\n     |                ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ast::ClassSetRange`, found `ntest_callback::ClassSetRange`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::ClassSetRange` and `ast::ClassSetRange` have similar names, but are actually distinct types\nnote: `ntest_callback::ClassSetRange` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1530:1\n     |\n1530 | struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^\nnote: `ast::ClassSetRange` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:973:5\n     |\n973  |     Range(ClassSetRange),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1557:44\n     |\n1557 |     assert_eq!(result, ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n     |                        ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ast::ClassSetRange`, found `ntest_callback::ClassSetRange`\n     |                        |\n     |                        arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::ClassSetRange` and `ast::ClassSetRange` have similar names, but are actually distinct types\nnote: `ntest_callback::ClassSetRange` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1530:1\n     |\n1530 | struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^\nnote: `ast::ClassSetRange` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:973:5\n     |\n973  |     Range(ClassSetRange),\n     |     ^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(5) };",
                "    let item1 = ClassSetItem::Literal(Literal('a'));",
                "    let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });",
                "    let mut union = ClassSetUnion { span, items: vec![item1, item2] };",
                "    union.into_item();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item1 = ClassSetItem::Literal(Literal('a'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item1] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Literal(Literal('a')));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item1 = ClassSetItem::Literal(Literal('a'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item1] };",
                  "    let result = union.into_item();",
                  "    let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });",
                  "    let mut union = ClassSetUnion { span, items: vec![item2] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Range(ClassSetRange { start: '0', end: '9' }));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item1 = ClassSetItem::Literal(Literal('a'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item1] };",
                  "    let result = union.into_item();",
                  "    let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });",
                  "    let mut union = ClassSetUnion { span, items: vec![item2] };",
                  "    let result = union.into_item();",
                  "    let item3 = ClassSetItem::Literal(Literal('b'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item1, item2, item3] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Union(union));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Position(u32);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassSetRange {",
                  "    start: char,",
                  "    end: char,",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Literal(char);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassAscii;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassUnicode;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassPerl;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassBracketed;",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item1 = ClassSetItem::Literal(Literal('a'));",
                  "    let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });",
                  "    let mut union = ClassSetUnion { span, items: vec![item1, item2] };",
                  "    union.into_item();",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item1 = ClassSetItem::Literal(Literal('a'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item1] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Literal(Literal('a')));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Position(u32);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassSetRange {",
                  "    start: char,",
                  "    end: char,",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Literal(char);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassAscii;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassUnicode;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassPerl;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassBracketed;",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item1 = ClassSetItem::Literal(Literal('a'));",
                  "    let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });",
                  "    let mut union = ClassSetUnion { span, items: vec![item1, item2] };",
                  "    union.into_item();",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item1 = ClassSetItem::Literal(Literal('a'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item1] };",
                  "    let result = union.into_item();",
                  "    let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });",
                  "    let mut union = ClassSetUnion { span, items: vec![item2] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Range(ClassSetRange { start: '0', end: '9' }));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Position(u32);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassSetRange {",
                  "    start: char,",
                  "    end: char,",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Literal(char);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassAscii;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassUnicode;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassPerl;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassBracketed;",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item1 = ClassSetItem::Literal(Literal('a'));",
                  "    let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });",
                  "    let mut union = ClassSetUnion { span, items: vec![item1, item2] };",
                  "    union.into_item();",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let item1 = ClassSetItem::Literal(Literal('a'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item1] };",
                  "    let result = union.into_item();",
                  "    let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });",
                  "    let mut union = ClassSetUnion { span, items: vec![item2] };",
                  "    let result = union.into_item();",
                  "    let item3 = ClassSetItem::Literal(Literal('b'));",
                  "    let mut union = ClassSetUnion { span, items: vec![item1, item2, item3] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Union(union));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:30\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:48\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1550:39\n     |\n1550 |     let item1 = ClassSetItem::Literal(Literal('a'));\n     |                 --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1551:37\n     |\n1551 |     let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });\n     |                 ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ast::ClassSetRange`, found `ntest_callback::ClassSetRange`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::ClassSetRange` and `ast::ClassSetRange` have similar names, but are actually distinct types\nnote: `ntest_callback::ClassSetRange` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1530:1\n     |\n1530 | struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^\nnote: `ast::ClassSetRange` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:973:5\n     |\n973  |     Range(ClassSetRange),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1554:30\n     |\n1554 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1554:48\n     |\n1554 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1555:39\n     |\n1555 |     let item1 = ClassSetItem::Literal(Literal('a'));\n     |                 --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1558:46\n     |\n1558 |     assert_eq!(result, ClassSetItem::Literal(Literal('a')));\n     |                        --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                        |\n     |                        arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:30\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:48\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1550:39\n     |\n1550 |     let item1 = ClassSetItem::Literal(Literal('a'));\n     |                 --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1551:37\n     |\n1551 |     let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });\n     |                 ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ast::ClassSetRange`, found `ntest_callback::ClassSetRange`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::ClassSetRange` and `ast::ClassSetRange` have similar names, but are actually distinct types\nnote: `ntest_callback::ClassSetRange` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1530:1\n     |\n1530 | struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^\nnote: `ast::ClassSetRange` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:973:5\n     |\n973  |     Range(ClassSetRange),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1554:30\n     |\n1554 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1554:48\n     |\n1554 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1555:39\n     |\n1555 |     let item1 = ClassSetItem::Literal(Literal('a'));\n     |                 --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1558:37\n     |\n1558 |     let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });\n     |                 ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ast::ClassSetRange`, found `ntest_callback::ClassSetRange`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::ClassSetRange` and `ast::ClassSetRange` have similar names, but are actually distinct types\nnote: `ntest_callback::ClassSetRange` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1530:1\n     |\n1530 | struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^\nnote: `ast::ClassSetRange` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:973:5\n     |\n973  |     Range(ClassSetRange),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1561:44\n     |\n1561 |     assert_eq!(result, ClassSetItem::Range(ClassSetRange { start: '0', end: '9' }));\n     |                        ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ast::ClassSetRange`, found `ntest_callback::ClassSetRange`\n     |                        |\n     |                        arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::ClassSetRange` and `ast::ClassSetRange` have similar names, but are actually distinct types\nnote: `ntest_callback::ClassSetRange` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1530:1\n     |\n1530 | struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^\nnote: `ast::ClassSetRange` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:973:5\n     |\n973  |     Range(ClassSetRange),\n     |     ^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:30\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:48\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1550:39\n     |\n1550 |     let item1 = ClassSetItem::Literal(Literal('a'));\n     |                 --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1551:37\n     |\n1551 |     let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });\n     |                 ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ast::ClassSetRange`, found `ntest_callback::ClassSetRange`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::ClassSetRange` and `ast::ClassSetRange` have similar names, but are actually distinct types\nnote: `ntest_callback::ClassSetRange` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1530:1\n     |\n1530 | struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^\nnote: `ast::ClassSetRange` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:973:5\n     |\n973  |     Range(ClassSetRange),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1554:30\n     |\n1554 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1554:48\n     |\n1554 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1555:39\n     |\n1555 |     let item1 = ClassSetItem::Literal(Literal('a'));\n     |                 --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1558:37\n     |\n1558 |     let item2 = ClassSetItem::Range(ClassSetRange { start: '0', end: '9' });\n     |                 ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ast::ClassSetRange`, found `ntest_callback::ClassSetRange`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::ClassSetRange` and `ast::ClassSetRange` have similar names, but are actually distinct types\nnote: `ntest_callback::ClassSetRange` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1530:1\n     |\n1530 | struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^\nnote: `ast::ClassSetRange` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:973:5\n     |\n973  |     Range(ClassSetRange),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1561:39\n     |\n1561 |     let item3 = ClassSetItem::Literal(Literal('b'));\n     |                 --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                 |\n     |                 arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(5) };",
                "    let mut union = ClassSetUnion { span, items: Vec::new() };",
                "    union.into_item();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a'))] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Literal(Literal('a')));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a'))] };",
                  "    let result = union.into_item();",
                  "    let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a')), ClassSetItem::Literal(Literal('b'))] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Union(union));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a'))] };",
                  "    let result = union.into_item();",
                  "    let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a')), ClassSetItem::Literal(Literal('b'))] };",
                  "    let result = union.into_item();",
                  "    let mut union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Empty(span));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Position(u32);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassSetRange {",
                  "    start: char,",
                  "    end: char,",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Literal(char);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassAscii;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassUnicode;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassPerl;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassBracketed;",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let mut union = ClassSetUnion { span, items: Vec::new() };",
                  "    union.into_item();",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a'))] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Literal(Literal('a')));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Position(u32);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassSetRange {",
                  "    start: char,",
                  "    end: char,",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Literal(char);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassAscii;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassUnicode;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassPerl;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassBracketed;",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let mut union = ClassSetUnion { span, items: Vec::new() };",
                  "    union.into_item();",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a'))] };",
                  "    let result = union.into_item();",
                  "    let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a')), ClassSetItem::Literal(Literal('b'))] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Union(union));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Position(u32);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassSetRange {",
                  "    start: char,",
                  "    end: char,",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct Literal(char);",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassAscii;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassUnicode;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassPerl;",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct ClassBracketed;",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let mut union = ClassSetUnion { span, items: Vec::new() };",
                  "    union.into_item();",
                  "    let span = Span { start: Position(0), end: Position(5) };",
                  "    let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a'))] };",
                  "    let result = union.into_item();",
                  "    let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a')), ClassSetItem::Literal(Literal('b'))] };",
                  "    let result = union.into_item();",
                  "    let mut union = ClassSetUnion { span, items: Vec::new() };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Empty(span));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:30\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:48\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1552:30\n     |\n1552 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1552:48\n     |\n1552 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1553:77\n     |\n1553 |     let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a'))] };\n     |                                                       --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                                                       |\n     |                                                       arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1555:46\n     |\n1555 |     assert_eq!(result, ClassSetItem::Literal(Literal('a')));\n     |                        --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                        |\n     |                        arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:30\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:48\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1552:30\n     |\n1552 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1552:48\n     |\n1552 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1553:77\n     |\n1553 |     let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a'))] };\n     |                                                       --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                                                       |\n     |                                                       arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1555:77\n     |\n1555 |     let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a')), ClassSetItem::Literal(Literal('b'))] };\n     |                                                       --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                                                       |\n     |                                                       arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1555:114\n     |\n1555 |     let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a')), ClassSetItem::Literal(Literal('b'))] };\n     |                                                                                            --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                                                                                            |\n     |                                                                                            arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:30\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1549:48\n     |\n1549 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1552:30\n     |\n1552 |     let span = Span { start: Position(0), end: Position(5) };\n     |                              ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1552:48\n     |\n1552 |     let span = Span { start: Position(0), end: Position(5) };\n     |                                                ^^^^^^^^^^^ expected `ast::Position`, found `ntest_callback::Position`\n     |\n     = note: `ntest_callback::Position` and `ast::Position` have similar names, but are actually distinct types\nnote: `ntest_callback::Position` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1527:1\n     |\n1527 | struct Position(u32);\n     | ^^^^^^^^^^^^^^^\nnote: `ast::Position` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1553:77\n     |\n1553 |     let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a'))] };\n     |                                                       --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                                                       |\n     |                                                       arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1555:77\n     |\n1555 |     let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a')), ClassSetItem::Literal(Literal('b'))] };\n     |                                                       --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                                                       |\n     |                                                       arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/mod.rs:1555:114\n     |\n1555 |     let mut union = ClassSetUnion { span, items: vec![ClassSetItem::Literal(Literal('a')), ClassSetItem::Literal(Literal('b'))] };\n     |                                                                                            --------------------- ^^^^^^^^^^^^ expected `ast::Literal`, found `ntest_callback::Literal`\n     |                                                                                            |\n     |                                                                                            arguments to this enum variant are incorrect\n     |\n     = note: `ntest_callback::Literal` and `ast::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::ast::llmtests` of the current crate\n    --> regex-syntax/src/ast/mod.rs:1536:1\n     |\n1536 | struct Literal(char);\n     | ^^^^^^^^^^^^^^\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: self.items.len() matches 0 is true\n",
        "// constraint: self.items.len() matches 0 is true\n",
        "// expected return value/type: ClassSetItem::Empty(self.span)\n"
      ],
      "input_infer": "self.items.len() = 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let union = ClassSetUnion { span, items: vec![] };",
                "    let _result = union.into_item();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let union = ClassSetUnion { span, items: vec![] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Empty(span));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let union = ClassSetUnion { span, items: vec![] };",
                  "    let _result = union.into_item();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 0, line: 0, column: 0 } };  ",
                  "    let union = ClassSetUnion { span, items: vec![] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Empty(span));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(0) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let item = ClassSetItem::Literal(Literal::new('a'));",
                "    let union = ClassSetUnion { span, items: vec![item.clone()] };",
                "    let _result = union.into_item();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let item = ClassSetItem::Literal(Literal::new('a'));",
                  "    let union = ClassSetUnion { span, items: vec![] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Empty(span));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 0 } };  ",
                  "    let item = ClassSetItem::Literal(Literal::new('a'));",
                  "    let union = ClassSetUnion { span, items: vec![item.clone()] };",
                  "    let _result = union.into_item();",
                  "      let span = Span { start: Position { offset: 0, line: 0, column: 0 }, end: Position { offset: 1, line: 0, column: 1 } };",
                  "    let item = ClassSetItem::Literal(Literal::new('a'));",
                  "    let union = ClassSetUnion { span, items: vec![] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Empty(span));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:47\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `new` not found for this struct\n...\n1527 |     let item = ClassSetItem::Literal(Literal::new('a'));\n     |                                               ^^^ function or associated item not found in `Literal`\n     |\nhelp: there is a method `ne` with a similar name\n     |\n1527 |     let item = ClassSetItem::Literal(Literal::ne('a'));\n     |                                               ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1531:47\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `new` not found for this struct\n...\n1531 |     let item = ClassSetItem::Literal(Literal::new('a'));\n     |                                               ^^^ function or associated item not found in `Literal`\n     |\nhelp: there is a method `ne` with a similar name\n     |\n1531 |     let item = ClassSetItem::Literal(Literal::ne('a'));\n     |                                               ~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(2) };",
                "    let item1 = ClassSetItem::Literal(Literal::new('a'));",
                "    let item2 = ClassSetItem::Literal(Literal::new('b'));",
                "    let union = ClassSetUnion { span, items: vec![item1, item2] };",
                "    let _result = union.into_item();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(2) };",
                  "    let item1 = ClassSetItem::Literal(Literal::new('a'));",
                  "    let item2 = ClassSetItem::Literal(Literal::new('b'));",
                  "    let union = ClassSetUnion { span, items: vec![] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Empty(span));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(2) };",
                  "    let item1 = ClassSetItem::Literal(Literal::new('a'));",
                  "    let item2 = ClassSetItem::Literal(Literal::new('b'));",
                  "    let union = ClassSetUnion { span, items: vec![item1, item2] };",
                  "    let _result = union.into_item();",
                  "    let span = Span { start: Position(0), end: Position(2) };",
                  "    let item1 = ClassSetItem::Literal(Literal::new('a'));",
                  "    let item2 = ClassSetItem::Literal(Literal::new('b'));",
                  "    let union = ClassSetUnion { span, items: vec![] };",
                  "    let result = union.into_item();",
                  "    assert_eq!(result, ClassSetItem::Empty(span));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(2) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1526:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1526 |       let span = Span { start: Position(0), end: Position(2) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1527:48\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `new` not found for this struct\n...\n1527 |     let item1 = ClassSetItem::Literal(Literal::new('a'));\n     |                                                ^^^ function or associated item not found in `Literal`\n     |\nhelp: there is a method `ne` with a similar name\n     |\n1527 |     let item1 = ClassSetItem::Literal(Literal::ne('a'));\n     |                                                ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1528:48\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `new` not found for this struct\n...\n1528 |     let item2 = ClassSetItem::Literal(Literal::new('b'));\n     |                                                ^^^ function or associated item not found in `Literal`\n     |\nhelp: there is a method `ne` with a similar name\n     |\n1528 |     let item2 = ClassSetItem::Literal(Literal::ne('b'));\n     |                                                ~~\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1531:30\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1531 |       let span = Span { start: Position(0), end: Position(2) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/mod.rs:1531:48\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n...\n1531 |       let span = Span { start: Position(0), end: Position(2) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1532:48\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `new` not found for this struct\n...\n1532 |     let item1 = ClassSetItem::Literal(Literal::new('a'));\n     |                                                ^^^ function or associated item not found in `Literal`\n     |\nhelp: there is a method `ne` with a similar name\n     |\n1532 |     let item1 = ClassSetItem::Literal(Literal::ne('a'));\n     |                                                ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `ast::Literal` in the current scope\n    --> regex-syntax/src/ast/mod.rs:1533:48\n     |\n614  | pub struct Literal {\n     | ------------------ function or associated item `new` not found for this struct\n...\n1533 |     let item2 = ClassSetItem::Literal(Literal::new('b'));\n     |                                                ^^^ function or associated item not found in `Literal`\n     |\nhelp: there is a method `ne` with a similar name\n     |\n1533 |     let item2 = ClassSetItem::Literal(Literal::ne('b'));\n     |                                                ~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}