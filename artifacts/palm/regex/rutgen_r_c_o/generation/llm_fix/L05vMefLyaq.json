{
  "name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::unclosed_class_error",
  "name_with_impl": "regex_syntax::ast::parse::{impl#4}::unclosed_class_error",
  "mod_info": {
    "name": "ast::parse",
    "loc": "regex-syntax/src/ast/mod.rs:21:1:21:15"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/parse.rs:910:5:922:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: state in self.parser().stack_class.borrow().iter().rev() is true\n",
        "// constraint: *state matches ClassState::Open { ref set, .. } is false\n",
        "// constraint: *state matches _ is true\n",
        "// constraint: state in self.parser().stack_class.borrow().iter().rev() is false\n"
      ],
      "input_infer": "0 to 0, 1 to 1, 2 to 2, 3 to 3, 1000 to 1000\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { /* initialize fields */ }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 100,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]), // No open class",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI::new(&parser, \"example pattern\");",
                "    parser_instance.unclosed_class_error(); // Should panic",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser { stack_class: RefCell::new(vec![]) };",
                  "    let result = std::panic::catch_unwind(|| { parser_instance.unclosed_class_error() });",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let parser = Parser { stack_class: RefCell::new(vec![]) };",
                  "    let result = std::panic::catch_unwind(|| { parser_instance.unclosed_class_error() });",
                  "    assert_eq!(result.unwrap_err().downcast_ref::<&str>(), Some(&\"no open character class found\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { /* initialize fields */ }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 100,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]), // No open class",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"example pattern\");",
                  "    parser_instance.unclosed_class_error(); // Should panic",
                  "    let parser = Parser { stack_class: RefCell::new(vec![]) };",
                  "    let result = std::panic::catch_unwind(|| { parser_instance.unclosed_class_error() });",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { /* initialize fields */ }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 100,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]), // No open class",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"example pattern\");",
                  "    parser_instance.unclosed_class_error(); // Should panic",
                  "    let parser = Parser { stack_class: RefCell::new(vec![]) };",
                  "    let result = std::panic::catch_unwind(|| { parser_instance.unclosed_class_error() });",
                  "    assert_eq!(result.unwrap_err().downcast_ref::<&str>(), Some(&\"no open character class found\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5378:24\n     |\n5378 |         pos: Cell::new(Position { /* initialize fields */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5393:18\n     |\n5393 |     let parser = Parser { stack_class: RefCell::new(vec![]) };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5378:24\n     |\n5378 |         pos: Cell::new(Position { /* initialize fields */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5393:18\n     |\n5393 |     let parser = Parser { stack_class: RefCell::new(vec![]) };\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { /* initialize fields */ }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 100,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![",
                "            ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Not open class",
                "        ]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI::new(&parser, \"example pattern\");",
                "    parser_instance.unclosed_class_error(); // Should panic",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }]),",
                  "    };",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    parser_instance.unclosed_class_error();",
                  "    });",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { /* initialize fields */ }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 100,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Not open class",
                  "        ]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"example pattern\");",
                  "    parser_instance.unclosed_class_error(); // Should panic",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }]),",
                  "    };",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    parser_instance.unclosed_class_error();",
                  "    });",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5378:24\n     |\n5378 |         pos: Cell::new(Position { /* initialize fields */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0599]: no variant or associated item named `And` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:63\n     |\n5387 |             ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Not open class\n     |                                                               ^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `And` not found for this enum\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:88\n     |\n5387 |             ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Not open class\n     |                                                                                        ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `And` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:86\n     |\n5396 |     stack_class: RefCell::new(vec![ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }]),\n     |                                                                                      ^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `And` not found for this enum\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:111\n     |\n5396 |     stack_class: RefCell::new(vec![ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }]),\n     |                                                                                                               ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5395:18\n     |\n5395 |     let parser = Parser {\n     |                  ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { /* initialize fields */ }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 100,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![",
                "            ClassState::Open { union: ast::ClassSetUnion::new(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::new() } },",
                "            ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Mixed states",
                "        ]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI::new(&parser, \"example pattern\");",
                "    parser_instance.unclosed_class_error(); // Should panic",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position { /* initialize fields */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 100,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open { union: ast::ClassSetUnion::new(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::new() } },",
                  "    ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Mixed states",
                  "    ]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"example pattern\");",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    parser_instance.unclosed_class_error();",
                  "    });",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position { /* initialize fields */ }),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 100,",
                  "        octal: false,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open { union: ast::ClassSetUnion::new(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::new() } },",
                  "            ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Mixed states",
                  "        ]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"example pattern\");",
                  "    parser_instance.unclosed_class_error(); // Should panic",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position { /* initialize fields */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 100,",
                  "    octal: false,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open { union: ast::ClassSetUnion::new(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::new() } },",
                  "    ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Mixed states",
                  "    ]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"example pattern\");",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    parser_instance.unclosed_class_error();",
                  "    });",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5378:24\n     |\n5378 |         pos: Cell::new(Position { /* initialize fields */ }),\n     |                        ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:59\n     |\n5387 | ...   ClassState::Open { union: ast::ClassSetUnion::new(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, ki...\n     |                                                     ^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:113\n     |\n5387 | ..., set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::new() } },\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5387:121\n     |\n5387 | ...st::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::new() } },\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:163\n     |\n5387 | ...}, negated: false, kind: ast::ClassSet::new() } },\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `And` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:63\n     |\n5388 |             ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Mixed states\n     |                                                               ^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `And` not found for this enum\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:88\n     |\n5388 |             ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Mixed states\n     |                                                                                        ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5397:20\n     |\n5397 |     pos: Cell::new(Position { /* initialize fields */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:51\n     |\n5406 |     ClassState::Open { union: ast::ClassSetUnion::new(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind...\n     |                                                   ^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:105\n     |\n5406 | ..., set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::new() } },\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5406:113\n     |\n5406 | ...st::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::new() } },\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:155\n     |\n5406 | ...}, negated: false, kind: ast::ClassSet::new() } },\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `And` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5407:55\n     |\n5407 |     ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Mixed states\n     |                                                       ^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `And` not found for this enum\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5407:80\n     |\n5407 |     ClassState::Op { kind: ast::ClassSetBinaryOpKind::And, lhs: ast::ClassSet::new() }, // Mixed states\n     |                                                                                ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: state in self.parser().stack_class.borrow().iter().rev() is true\n",
        "// constraint: *state matches ClassState::Open { ref set, .. } is true\n",
        "// constraint: *state matches ClassState::Open { ref set, .. } is true\n"
      ],
      "input_infer": "1 <= stack_class.size() <= 10, 0 <= set.span.start < set.span.end <= 1000, 0 <= self.parser().stack_class.borrow().iter().rev().count() <= 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                "    ",
                "    let parser = Parser {",
                "        stack_class: RefCell::new(vec![state]),",
                "        ..Default::default()",
                "    };",
                "    ",
                "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z]\" };",
                "    ",
                "    let _ = parser_instance.unclosed_class_error();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    assert_eq!(state, ClassState::Open { union: ast::ClassSetUnion::default(), set });"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    assert_eq!(parser_instance.error(set.span, ast::ErrorKind::ClassUnclosed).kind, ast::ErrorKind::ClassUnclosed);"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    assert_eq!(parser_instance.error(set.span, ast::ErrorKind::ClassUnclosed).span, set.span);"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    assert!(parser_instance.stack_class.borrow().iter().rev().any(|s| matches!(s, ClassState::Open { .. })));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state]),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z]\" };",
                  "    ",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    assert_eq!(state, ClassState::Open { union: ast::ClassSetUnion::default(), set });",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state]),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z]\" };",
                  "    ",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    assert_eq!(parser_instance.error(set.span, ast::ErrorKind::ClassUnclosed).kind, ast::ErrorKind::ClassUnclosed);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state]),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z]\" };",
                  "    ",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    assert_eq!(parser_instance.error(set.span, ast::ErrorKind::ClassUnclosed).span, set.span);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state]),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z]\" };",
                  "    ",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };",
                  "    assert!(parser_instance.stack_class.borrow().iter().rev().any(|s| matches!(s, ClassState::Open { .. })));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |               ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5389:15\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |               ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:30\n     |\n5376 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:38\n     |\n5376 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:75\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                           ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                           ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:63\n     |\n5378 |     let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };\n     |                                                               ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:11\n     |\n5382 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:38\n     |\n5388 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:75\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                           ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                           ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:63\n     |\n5390 |     let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };\n     |                                                               ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5391:69\n     |\n5391 |     assert_eq!(state, ClassState::Open { union: ast::ClassSetUnion::default(), set });\n     |                                                                     ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `parse::ClassState`\n    --> regex-syntax/src/ast/parse.rs:5391:5\n     |\n5391 |     assert_eq!(state, ClassState::Open { union: ast::ClassSetUnion::default(), set });\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     parse::ClassState\n     |     parse::ClassState\n     |\nnote: an implementation of `PartialEq` might be missing for `parse::ClassState`\n    --> regex-syntax/src/ast/parse.rs:311:1\n     |\n311  | enum ClassState {\n     | ^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `parse::ClassState` with `#[derive(PartialEq)]`\n     |\n311  + #[derive(PartialEq)]\n312  | enum ClassState {\n     |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |               ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5389:15\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |               ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:30\n     |\n5376 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:38\n     |\n5376 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:75\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                           ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                           ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:63\n     |\n5378 |     let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };\n     |                                                               ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:11\n     |\n5382 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:38\n     |\n5388 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:75\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                           ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                           ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:63\n     |\n5390 |     let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };\n     |                                                               ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |               ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5389:15\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |               ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:30\n     |\n5376 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:38\n     |\n5376 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:75\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                           ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                           ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:63\n     |\n5378 |     let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };\n     |                                                               ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:11\n     |\n5382 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:38\n     |\n5388 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:75\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                           ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                           ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:63\n     |\n5390 |     let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };\n     |                                                               ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |               ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5389:15\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |               ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:30\n     |\n5376 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:38\n     |\n5376 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:75\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                           ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                           ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:63\n     |\n5378 |     let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };\n     |                                                               ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5382:11\n     |\n5382 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5388:38\n     |\n5388 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5389:75\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                           ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5389 |     let set = ClassBracketed { span, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                           ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:63\n     |\n5390 |     let state = ClassState::Open { union: ast::ClassSetUnion::default(), set };\n     |                                                               ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0609]: no field `stack_class` on type `parse::ParserI<'_, &parse::Parser>`\n    --> regex-syntax/src/ast/parse.rs:5391:29\n     |\n5391 |     assert!(parser_instance.stack_class.borrow().iter().rev().any(|s| matches!(s, ClassState::Open { .. })));\n     |                             ^^^^^^^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n5391 |     assert!(parser_instance.parser.stack_class.borrow().iter().rev().any(|s| matches!(s, ClassState::Open { .. })));\n     |                             +++++++\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0599, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span1 = Span { start: 0, end: 5 };",
                "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                "    ",
                "    let span2 = Span { start: 6, end: 10 };",
                "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                "    ",
                "    let parser = Parser {",
                "        stack_class: RefCell::new(vec![state1, state2]),",
                "        ..Default::default()",
                "    };",
                "    ",
                "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                "    ",
                "    let _ = parser_instance.unclosed_class_error();",
                "}"
              ],
              "oracles": [
                [
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.kind, ast::ErrorKind::ClassUnclosed);"
                ],
                [
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.span.start, 0);"
                ],
                [
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.span.end, 5);"
                ],
                [
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.pattern, \"[a-z][0-9]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    ",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state1, state2]),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    ",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.kind, ast::ErrorKind::ClassUnclosed);",
                  "}"
                ],
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    ",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state1, state2]),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    ",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.span.start, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    ",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state1, state2]),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    ",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.span.end, 5);",
                  "}"
                ],
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    ",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state1, state2]),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    ",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.pattern, \"[a-z][0-9]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:16\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:16\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:16\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:16\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:31\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:39\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:83\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:64\n     |\n5378 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:31\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:39\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:83\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:64\n     |\n5382 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:39\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:83\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:64\n     |\n5394 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:39\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:83\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:64\n     |\n5397 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:7\n     |\n5400 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:16\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:16\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:16\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:16\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:31\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:39\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:83\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:64\n     |\n5378 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:31\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:39\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:83\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:64\n     |\n5382 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:39\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:83\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:64\n     |\n5394 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:39\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:83\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:64\n     |\n5397 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:7\n     |\n5400 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5404:34\n     |\n5404 |     assert_eq!(error.span.start, 0);\n     |                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:16\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:16\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:16\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:16\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:31\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:39\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:83\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:64\n     |\n5378 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:31\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:39\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:83\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:64\n     |\n5382 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:39\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:83\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:64\n     |\n5394 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:39\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:83\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:64\n     |\n5397 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:7\n     |\n5400 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5404:32\n     |\n5404 |     assert_eq!(error.span.end, 5);\n     |                                ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:16\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:16\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:16\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:16\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:31\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:39\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:83\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:64\n     |\n5378 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:31\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:39\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:83\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:64\n     |\n5382 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:39\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:83\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:64\n     |\n5394 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:39\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:83\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:64\n     |\n5397 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:7\n     |\n5400 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span1 = Span { start: 0, end: 5 };",
                "    let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };",
                "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                "",
                "    let span2 = Span { start: 6, end: 10 };",
                "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                "",
                "    let parser = Parser {",
                "        stack_class: RefCell::new(vec![state1, state2]),",
                "        ..Default::default()",
                "    };",
                "",
                "    let parser_instance = ParserI { parser: &parser, pattern: \"[^a-z][0-9]\" };",
                "",
                "    let _ = parser_instance.unclosed_class_error();",
                "}"
              ],
              "oracles": [
                [
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[^a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.kind, ast::ErrorKind::ClassUnclosed);"
                ],
                [
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[^a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.span, span2);"
                ],
                [
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[^a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.pattern, \"[^a-z][0-9]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state1, state2]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[^a-z][0-9]\" };",
                  "",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[^a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.kind, ast::ErrorKind::ClassUnclosed);",
                  "}"
                ],
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state1, state2]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[^a-z][0-9]\" };",
                  "",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[^a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.span, span2);",
                  "}"
                ],
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![state1, state2]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[^a-z][0-9]\" };",
                  "",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let span1 = Span { start: 0, end: 5 };",
                  "    let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };",
                  "    let span2 = Span { start: 6, end: 10 };",
                  "    let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };",
                  "    let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![state1, state2]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"[^a-z][0-9]\" };",
                  "    let error = parser_instance.unclosed_class_error();",
                  "    assert_eq!(error.pattern, \"[^a-z][0-9]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:16\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:16\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:16\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:16\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:31\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:39\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:82\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                  ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                  ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:64\n     |\n5378 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:31\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:39\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:83\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:64\n     |\n5382 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:39\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:82\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                  ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                  ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:64\n     |\n5394 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:39\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:83\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:64\n     |\n5397 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:7\n     |\n5400 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:16\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:16\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:16\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:16\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:31\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:39\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:82\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                  ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                  ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:64\n     |\n5378 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:31\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:39\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:83\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:64\n     |\n5382 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:39\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:82\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                  ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                  ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:64\n     |\n5394 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:39\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:83\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:64\n     |\n5397 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:7\n     |\n5400 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5377:16\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5381:16\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:16\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/ast/parse.rs:5396:16\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n5368 +    use ast::ClassBracketed;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:31\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5376:39\n     |\n5376 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:82\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                  ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5377 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                  ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:64\n     |\n5378 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:31\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5380:39\n     |\n5380 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:83\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5381 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:64\n     |\n5382 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:31\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5392:39\n     |\n5392 |     let span1 = Span { start: 0, end: 5 };\n     |                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5393:82\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                  ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5393 |     let set1 = ClassBracketed { span: span1, negated: true, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                  ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5394:64\n     |\n5394 |     let state1 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set1 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:31\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5395:39\n     |\n5395 |     let span2 = Span { start: 6, end: 10 };\n     |                                       ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:83\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::Union(vec![]) };\n     |                                                                                   ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n5396 |     let set2 = ClassBracketed { span: span2, negated: false, kind: ast::ClassSet::union(vec![]) };\n     |                                                                                   ~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:64\n     |\n5397 |     let state2 = ClassState::Open { union: ast::ClassSetUnion::default(), set: set2 };\n     |                                                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5400:7\n     |\n5400 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic(expected = \"no open character class found\")]"
              ],
              "prefix": [
                "{",
                "    let parser = Parser {",
                "        stack_class: RefCell::new(vec![]),",
                "        ..Default::default()",
                "    };",
                "",
                "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                "",
                "    let _ = parser_instance.unclosed_class_error();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser { stack_class: RefCell::new(vec![]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    let result = std::panic::catch_unwind(|| { parser_instance.unclosed_class_error() });",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let parser = Parser { stack_class: RefCell::new(vec![]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    let result = std::panic::catch_unwind(|| { parser_instance.unclosed_class_error() });",
                  "    assert_eq!(result.err().unwrap().downcast_ref::<&str>(), Some(&\"no open character class found\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let parser = Parser { stack_class: RefCell::new(vec![]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    let result = std::panic::catch_unwind(|| { parser_instance.unclosed_class_error() });",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        ..Default::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "",
                  "    let _ = parser_instance.unclosed_class_error();",
                  "    let parser = Parser { stack_class: RefCell::new(vec![]), ..Default::default() };",
                  "    let parser_instance = ParserI { parser: &parser, pattern: \"\" };",
                  "    let result = std::panic::catch_unwind(|| { parser_instance.unclosed_class_error() });",
                  "    assert_eq!(result.err().unwrap().downcast_ref::<&str>(), Some(&\"no open character class found\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5379:11\n     |\n5379 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5385:64\n     |\n5385 |     let parser = Parser { stack_class: RefCell::new(vec![]), ..Default::default() };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5379:11\n     |\n5379 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5385:64\n     |\n5385 |     let parser = Parser { stack_class: RefCell::new(vec![]), ..Default::default() };\n     |                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: state in self.parser().stack_class.borrow().iter().rev() is false\n"
      ],
      "input_infer": "test input ranges: stack_class length = 0; stack_class length = 1 (ClassState::Open); stack_class length > 1 with all elements non-ClassState::Open\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = Parser {",
                "        stack_class: RefCell::new(vec![]),",
                "        ..Default::default()",
                "    };",
                "    let parser_i = ParserI::new(parser, \"\");",
                "    parser_i.unclosed_class_error();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    assert!(std::panic::catch_unwind(|| {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        ..Default::default()",
                  "    };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    parser_i.unclosed_class_error();",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![]),",
                  "    ..Default::default()",
                  "    };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    assert!(std::panic::catch_unwind(|| {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n    --> regex-syntax/src/ast/parse.rs:5387:37\n     |\n5375 | {\n     | - closing delimiter possibly meant for this\n...\n5387 |     assert!(std::panic::catch_unwind(|| {\n     |                                     ^ unclosed delimiter\n5388 | }\n5389 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/ast/parse.rs:5389:3\n     |\n5367 | mod llmtests {\n     |              - unclosed delimiter\n...\n5389 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let open_class = ClassState::Open {",
                "        union: ast::ClassSetUnion::default(),",
                "        set: ast::ClassBracketed {",
                "            span: Span { start: 0, end: 1 },",
                "            negated: false,",
                "            kind: ast::ClassSet::default(),",
                "        },",
                "    };",
                "    let parser = Parser {",
                "        stack_class: RefCell::new(vec![open_class]),",
                "        ..Default::default()",
                "    };",
                "    let parser_i = ParserI::new(parser, \"\");",
                "    parser_i.unclosed_class_error();",
                "}"
              ],
              "oracles": [
                [
                  "    let open_class = ClassState::Open { union: ast::ClassSetUnion::default(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };",
                  "    let parser = Parser { stack_class: RefCell::new(vec![open_class]), ..Default::default() };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    let error = parser_i.unclosed_class_error();",
                  "    assert_eq!(error.kind, ast::ErrorKind::ClassUnclosed);"
                ],
                [
                  "    let open_class = ClassState::Open { union: ast::ClassSetUnion::default(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };",
                  "    let parser = Parser { stack_class: RefCell::new(vec![open_class]), ..Default::default() };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    let error = parser_i.unclosed_class_error();",
                  "    assert_eq!(error.span, Span { start: 0, end: 1 });"
                ],
                [
                  "    let open_class = ClassState::Open { union: ast::ClassSetUnion::default(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };",
                  "    let parser = Parser { stack_class: RefCell::new(vec![open_class]), ..Default::default() };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    let error = parser_i.unclosed_class_error();",
                  "    assert_eq!(error.pattern, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let open_class = ClassState::Open {",
                  "        union: ast::ClassSetUnion::default(),",
                  "        set: ast::ClassBracketed {",
                  "            span: Span { start: 0, end: 1 },",
                  "            negated: false,",
                  "            kind: ast::ClassSet::default(),",
                  "        },",
                  "    };",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![open_class]),",
                  "        ..Default::default()",
                  "    };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    parser_i.unclosed_class_error();",
                  "    let open_class = ClassState::Open { union: ast::ClassSetUnion::default(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };",
                  "    let parser = Parser { stack_class: RefCell::new(vec![open_class]), ..Default::default() };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    let error = parser_i.unclosed_class_error();",
                  "    assert_eq!(error.kind, ast::ErrorKind::ClassUnclosed);",
                  "}"
                ],
                [
                  "{",
                  "    let open_class = ClassState::Open {",
                  "        union: ast::ClassSetUnion::default(),",
                  "        set: ast::ClassBracketed {",
                  "            span: Span { start: 0, end: 1 },",
                  "            negated: false,",
                  "            kind: ast::ClassSet::default(),",
                  "        },",
                  "    };",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![open_class]),",
                  "        ..Default::default()",
                  "    };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    parser_i.unclosed_class_error();",
                  "    let open_class = ClassState::Open { union: ast::ClassSetUnion::default(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };",
                  "    let parser = Parser { stack_class: RefCell::new(vec![open_class]), ..Default::default() };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    let error = parser_i.unclosed_class_error();",
                  "    assert_eq!(error.span, Span { start: 0, end: 1 });",
                  "}"
                ],
                [
                  "{",
                  "    let open_class = ClassState::Open {",
                  "        union: ast::ClassSetUnion::default(),",
                  "        set: ast::ClassBracketed {",
                  "            span: Span { start: 0, end: 1 },",
                  "            negated: false,",
                  "            kind: ast::ClassSet::default(),",
                  "        },",
                  "    };",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![open_class]),",
                  "        ..Default::default()",
                  "    };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    parser_i.unclosed_class_error();",
                  "    let open_class = ClassState::Open { union: ast::ClassSetUnion::default(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };",
                  "    let parser = Parser { stack_class: RefCell::new(vec![open_class]), ..Default::default() };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    let error = parser_i.unclosed_class_error();",
                  "    assert_eq!(error.pattern, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:36\n     |\n5377 |         union: ast::ClassSetUnion::default(),\n     |                                    ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:33\n     |\n5379 |             span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |             span: Span { start: 0, end: 1 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:34\n     |\n5381 |             kind: ast::ClassSet::default(),\n     |                                  ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:68\n     |\n5390 |     let open_class = ClassState::Open { union: ast::ClassSetUnion::default(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 },...\n     |                                                                    ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:126\n     |\n5390 | ..., set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:134\n     |\n5390 | ...st::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:176\n     |\n5390 | ... negated: false, kind: ast::ClassSet::default(), }, };\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5391:74\n     |\n5391 |     let parser = Parser { stack_class: RefCell::new(vec![open_class]), ..Default::default() };\n     |                                                                          ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:36\n     |\n5377 |         union: ast::ClassSetUnion::default(),\n     |                                    ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:33\n     |\n5379 |             span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |             span: Span { start: 0, end: 1 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:34\n     |\n5381 |             kind: ast::ClassSet::default(),\n     |                                  ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:68\n     |\n5390 |     let open_class = ClassState::Open { union: ast::ClassSetUnion::default(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 },...\n     |                                                                    ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:126\n     |\n5390 | ..., set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:134\n     |\n5390 | ...st::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:176\n     |\n5390 | ... negated: false, kind: ast::ClassSet::default(), }, };\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5391:74\n     |\n5391 |     let parser = Parser { stack_class: RefCell::new(vec![open_class]), ..Default::default() };\n     |                                                                          ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:42\n     |\n5394 |     assert_eq!(error.span, Span { start: 0, end: 1 });\n     |                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:50\n     |\n5394 |     assert_eq!(error.span, Span { start: 0, end: 1 });\n     |                                                  ^ expected `Position`, found integer\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:36\n     |\n5377 |         union: ast::ClassSetUnion::default(),\n     |                                    ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:33\n     |\n5379 |             span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |             span: Span { start: 0, end: 1 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:34\n     |\n5381 |             kind: ast::ClassSet::default(),\n     |                                  ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:68\n     |\n5390 |     let open_class = ClassState::Open { union: ast::ClassSetUnion::default(), set: ast::ClassBracketed { span: Span { start: 0, end: 1 },...\n     |                                                                    ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:126\n     |\n5390 | ..., set: ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5390:134\n     |\n5390 | ...st::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ast::ClassSet::default(), }, };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:176\n     |\n5390 | ... negated: false, kind: ast::ClassSet::default(), }, };\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5391:74\n     |\n5391 |     let parser = Parser { stack_class: RefCell::new(vec![open_class]), ..Default::default() };\n     |                                                                          ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let non_open_class1 = ClassState::Op {",
                "        kind: ast::ClassSetBinaryOpKind::default(),",
                "        lhs: ast::ClassSet::default(),",
                "    };",
                "    let non_open_class2 = ClassState::Op {",
                "        kind: ast::ClassSetBinaryOpKind::default(),",
                "        lhs: ast::ClassSet::default(),",
                "    };",
                "    let parser = Parser {",
                "        stack_class: RefCell::new(vec![non_open_class1, non_open_class2]),",
                "        ..Default::default()",
                "    };",
                "    let parser_i = ParserI::new(parser, \"\");",
                "    parser_i.unclosed_class_error();",
                "}"
              ],
              "oracles": [
                [
                  "    let non_open_class1 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };",
                  "    let non_open_class2 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };",
                  "    let parser = Parser { stack_class: RefCell::new(vec![non_open_class1, non_open_class2]), ..Default::default() };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    let result = parser_i.unclosed_class_error();",
                  "    assert_eq!(result.kind, ast::ErrorKind::ClassUnclosed);"
                ],
                [
                  "    let non_open_class1 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };",
                  "    let non_open_class2 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };",
                  "    let parser = Parser { stack_class: RefCell::new(vec![non_open_class1, non_open_class2]), ..Default::default() };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    let result = parser_i.unclosed_class_error();",
                  "    assert_eq!(result.pattern, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let non_open_class1 = ClassState::Op {",
                  "        kind: ast::ClassSetBinaryOpKind::default(),",
                  "        lhs: ast::ClassSet::default(),",
                  "    };",
                  "    let non_open_class2 = ClassState::Op {",
                  "        kind: ast::ClassSetBinaryOpKind::default(),",
                  "        lhs: ast::ClassSet::default(),",
                  "    };",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![non_open_class1, non_open_class2]),",
                  "        ..Default::default()",
                  "    };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    parser_i.unclosed_class_error();",
                  "    let non_open_class1 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };",
                  "    let non_open_class2 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };",
                  "    let parser = Parser { stack_class: RefCell::new(vec![non_open_class1, non_open_class2]), ..Default::default() };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    let result = parser_i.unclosed_class_error();",
                  "    assert_eq!(result.kind, ast::ErrorKind::ClassUnclosed);",
                  "}"
                ],
                [
                  "{",
                  "    let non_open_class1 = ClassState::Op {",
                  "        kind: ast::ClassSetBinaryOpKind::default(),",
                  "        lhs: ast::ClassSet::default(),",
                  "    };",
                  "    let non_open_class2 = ClassState::Op {",
                  "        kind: ast::ClassSetBinaryOpKind::default(),",
                  "        lhs: ast::ClassSet::default(),",
                  "    };",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![non_open_class1, non_open_class2]),",
                  "        ..Default::default()",
                  "    };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    parser_i.unclosed_class_error();",
                  "    let non_open_class1 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };",
                  "    let non_open_class2 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };",
                  "    let parser = Parser { stack_class: RefCell::new(vec![non_open_class1, non_open_class2]), ..Default::default() };",
                  "    let parser_i = ParserI::new(parser, \"\");",
                  "    let result = parser_i.unclosed_class_error();",
                  "    assert_eq!(result.pattern, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:42\n     |\n5377 |         kind: ast::ClassSetBinaryOpKind::default(),\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:29\n     |\n5378 |         lhs: ast::ClassSet::default(),\n     |                             ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:42\n     |\n5381 |         kind: ast::ClassSetBinaryOpKind::default(),\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n5382 |         lhs: ast::ClassSet::default(),\n     |                             ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:77\n     |\n5390 |     let non_open_class1 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };\n     |                                                                             ^^^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:108\n     |\n5390 |     let non_open_class1 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };\n     |                                                                                                            ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5391:77\n     |\n5391 |     let non_open_class2 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };\n     |                                                                             ^^^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5391:108\n     |\n5391 |     let non_open_class2 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };\n     |                                                                                                            ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:96\n     |\n5392 |     let parser = Parser { stack_class: RefCell::new(vec![non_open_class1, non_open_class2]), ..Default::default() };\n     |                                                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:42\n     |\n5377 |         kind: ast::ClassSetBinaryOpKind::default(),\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:29\n     |\n5378 |         lhs: ast::ClassSet::default(),\n     |                             ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5381:42\n     |\n5381 |         kind: ast::ClassSetBinaryOpKind::default(),\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n5382 |         lhs: ast::ClassSet::default(),\n     |                             ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5386:11\n     |\n5386 |         ..Default::default()\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:77\n     |\n5390 |     let non_open_class1 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };\n     |                                                                             ^^^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:108\n     |\n5390 |     let non_open_class1 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };\n     |                                                                                                            ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5391:77\n     |\n5391 |     let non_open_class2 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };\n     |                                                                             ^^^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `default` not found for this enum\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5391:108\n     |\n5391 |     let non_open_class2 = ClassState::Op { kind: ast::ClassSetBinaryOpKind::default(), lhs: ast::ClassSet::default() };\n     |                                                                                                            ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `parse::Parser: Default` is not satisfied\n    --> regex-syntax/src/ast/parse.rs:5392:96\n     |\n5392 |     let parser = Parser { stack_class: RefCell::new(vec![non_open_class1, non_open_class2]), ..Default::default() };\n     |                                                                                                ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `parse::Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}