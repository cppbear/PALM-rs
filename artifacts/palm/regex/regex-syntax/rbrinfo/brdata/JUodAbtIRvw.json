{
  "name": "regex_syntax::unicode::simple_fold",
  "name_with_impl": "regex_syntax::unicode::simple_fold",
  "mod_info": {
    "name": "unicode",
    "loc": "regex-syntax/src/lib.rs:118:1:118:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/unicode.rs:49:1:60:2",
  "doc": "/// Return an iterator over the equivalence class of simple case mappings\n/// for the given codepoint. The equivalence class does not include the\n/// given codepoint.\n///\n/// If the equivalence class is empty, then this returns the next scalar\n/// value that has a non-empty equivalence class, if it exists. If no such\n/// scalar value exists, then `None` is returned. The point of this behavior\n/// is to permit callers to avoid calling `simple_fold` more than they need\n/// to, since there is some cost to fetching the equivalence class.\n",
  "code": [
    "pub fn simple_fold(c: char) -> result::Result<SimpleFoldIter, Option<char>> {",
    "    CASE_FOLDING_SIMPLE",
    "        .binary_search_by_key(&c, |&(c1, _)| c1)",
    "        .map(|i| SimpleFoldIter(CASE_FOLDING_SIMPLE[i].1.iter()))",
    "        .map_err(|i| {",
    "            if i >= CASE_FOLDING_SIMPLE.len() {",
    "                None",
    "            } else {",
    "                Some(CASE_FOLDING_SIMPLE[i].0)",
    "            }",
    "        })",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}