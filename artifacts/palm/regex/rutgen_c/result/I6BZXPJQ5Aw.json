{"function_name":"regex::compile::compile::Compiler::c_empty_look","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/compile.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[11,11,11,11],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[487,488,489,490],"codes_lines_covered":[[["{","    struct TestHir;","    ","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    ","    assert!(result.is_ok());","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[487,488,489,490]],[["{","    struct TestHir;","    ","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    ","    assert!(result.is_ok());","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[487,488,489,490]],[["{","    struct TestHir;","    ","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartText);","    ","    assert!(result.is_ok());","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[487,488,489,490]],[["{","    struct TestHir;","    ","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    ","    assert!(result.is_ok());","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[487,488,489,490]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestHir;","    ","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    ","    assert!(result.is_ok());","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[]],[["{","    struct TestHir;","    ","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    ","    assert!(result.is_ok());","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[]],[["{","    struct TestHir;","    ","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartText);","    ","    assert!(result.is_ok());","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[]],[["{","    struct TestHir;","    ","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    ","    assert!(result.is_ok());","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[]]]}