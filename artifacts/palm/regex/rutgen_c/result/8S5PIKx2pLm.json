{"function_name":"regex::dfa::dfa::Transitions::add","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":3,"tests_lines":[29,31,31],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":1,"oracles_passed_rate":33.33333333333333,"tests_run":3,"tests_passed":1,"tests_passed_rate":33.33333333333333,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1621,1622,1623,1624,1625,1626,1627,1628],"codes_lines_covered":[[["{","    struct TransitionsTest {","        table: Vec<StatePtr>,","        num_byte_classes: usize,","    }","","    impl TransitionsTest {","        fn new(num_byte_classes: usize) -> Self {","            Self {","                table: Vec::new(),","                num_byte_classes,","            }","        }","","        fn add(&mut self) -> Option<StatePtr> {","            let si = self.table.len();","            if si > STATE_MAX as usize {","                return None;","            }","            self.table.extend(repeat(STATE_UNKNOWN).take(self.num_byte_classes));","            Some(usize_to_u32(si))","        }","    }","","    let mut transitions = TransitionsTest::new(2);","    let state_ptr = transitions.add();","    assert_eq!(state_ptr, Some(0));","    assert_eq!(transitions.table.len(), 2);","}"],[]],[["{","    struct TransitionsTest {","        table: Vec<StatePtr>,","        num_byte_classes: usize,","    }","","    impl TransitionsTest {","        fn new(num_byte_classes: usize) -> Self {","            Self {","                table: Vec::new(),","                num_byte_classes,","            }","        }","","        fn add(&mut self) -> Option<StatePtr> {","            let si = self.table.len();","            if si > STATE_MAX as usize {","                return None;","            }","            self.table.extend(repeat(STATE_UNKNOWN).take(self.num_byte_classes));","            Some(usize_to_u32(si))","        }","    }","","    let mut transitions = TransitionsTest::new(2);","    for _ in 0..(STATE_MAX as usize / 2) {","        transitions.add();","    }","    let state_ptr = transitions.add();","    assert_eq!(state_ptr, None);","}"],[]],[["{","    struct TransitionsTest {","        table: Vec<StatePtr>,","        num_byte_classes: usize,","    }","","    impl TransitionsTest {","        fn new(num_byte_classes: usize) -> Self {","            Self {","                table: Vec::new(),","                num_byte_classes,","            }","        }","","        fn add(&mut self) -> Option<StatePtr> {","            let si = self.table.len();","            if si > STATE_MAX as usize {","                return None;","            }","            self.table.extend(repeat(STATE_UNKNOWN).take(self.num_byte_classes));","            Some(usize_to_u32(si))","        }","    }","","    let mut transitions = TransitionsTest::new(2);","    for _ in 0..=STATE_MAX as usize {","        transitions.add();","    }","    let state_ptr = transitions.add();","    assert_eq!(state_ptr, None);","}"],[]]],"codes_branches":[{"start_line":1623,"start_column":12,"end_line":1623,"end_column":35,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TransitionsTest {","        table: Vec<StatePtr>,","        num_byte_classes: usize,","    }","","    impl TransitionsTest {","        fn new(num_byte_classes: usize) -> Self {","            Self {","                table: Vec::new(),","                num_byte_classes,","            }","        }","","        fn add(&mut self) -> Option<StatePtr> {","            let si = self.table.len();","            if si > STATE_MAX as usize {","                return None;","            }","            self.table.extend(repeat(STATE_UNKNOWN).take(self.num_byte_classes));","            Some(usize_to_u32(si))","        }","    }","","    let mut transitions = TransitionsTest::new(2);","    let state_ptr = transitions.add();","    assert_eq!(state_ptr, Some(0));","    assert_eq!(transitions.table.len(), 2);","}"],[{"start_line":1623,"start_column":12,"end_line":1623,"end_column":35,"positive":false,"negative":false}]],[["{","    struct TransitionsTest {","        table: Vec<StatePtr>,","        num_byte_classes: usize,","    }","","    impl TransitionsTest {","        fn new(num_byte_classes: usize) -> Self {","            Self {","                table: Vec::new(),","                num_byte_classes,","            }","        }","","        fn add(&mut self) -> Option<StatePtr> {","            let si = self.table.len();","            if si > STATE_MAX as usize {","                return None;","            }","            self.table.extend(repeat(STATE_UNKNOWN).take(self.num_byte_classes));","            Some(usize_to_u32(si))","        }","    }","","    let mut transitions = TransitionsTest::new(2);","    for _ in 0..(STATE_MAX as usize / 2) {","        transitions.add();","    }","    let state_ptr = transitions.add();","    assert_eq!(state_ptr, None);","}"],[{"start_line":1623,"start_column":12,"end_line":1623,"end_column":35,"positive":false,"negative":false}]],[["{","    struct TransitionsTest {","        table: Vec<StatePtr>,","        num_byte_classes: usize,","    }","","    impl TransitionsTest {","        fn new(num_byte_classes: usize) -> Self {","            Self {","                table: Vec::new(),","                num_byte_classes,","            }","        }","","        fn add(&mut self) -> Option<StatePtr> {","            let si = self.table.len();","            if si > STATE_MAX as usize {","                return None;","            }","            self.table.extend(repeat(STATE_UNKNOWN).take(self.num_byte_classes));","            Some(usize_to_u32(si))","        }","    }","","    let mut transitions = TransitionsTest::new(2);","    for _ in 0..=STATE_MAX as usize {","        transitions.add();","    }","    let state_ptr = transitions.add();","    assert_eq!(state_ptr, None);","}"],[{"start_line":1623,"start_column":12,"end_line":1623,"end_column":35,"positive":false,"negative":false}]]]}