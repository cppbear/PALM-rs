{"function_name":"regex::input::<input::ByteInput<'t> as input::Input>::previous_char","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/input.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[8,8,8,9],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":4,"tests_passed":2,"tests_passed_rate":50.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[264,265,266],"codes_lines_covered":[[["{","    let input_data: &[u8] = b\"abc\";","    let input = ByteInput { text: input_data, only_utf8: true };","    let at = InputAt { pos: 0, c: Char(0), byte: None, len: 0 };","    ","    let result = input.previous_char(at);","    assert_eq!(result.0, 0); // Expecting the char value corresponding to the start of the input","}"],[264,265,266]],[["{","    let input_data: &[u8] = b\"a\";","    let input = ByteInput { text: input_data, only_utf8: true };","    let at = InputAt { pos: 1, c: Char(0), byte: None, len: 0 };","    ","    let result = input.previous_char(at);","    assert_eq!(result.0, 'a' as u32); // Expecting the char value for 'a'","}"],[264,265,266]],[["{","    let input_data: &[u8] = b\"\\xE2\\x9C\\x94\"; // U+2714 CHECK MARK","    let input = ByteInput { text: input_data, only_utf8: true };","    let at = InputAt { pos: 3, c: Char(0), byte: None, len: 0 };","    ","    let result = input.previous_char(at);","    assert_eq!(result.0, 0x2714); // Expecting the char value for the check mark","}"],[264,265,266]],[["{","    let input_data: &[u8] = b\"\";","    let input = ByteInput { text: input_data, only_utf8: true };","    let at = InputAt { pos: 0, c: Char(0), byte: None, len: 0 };","    ","    let result = input.previous_char(at);","    // If pos is 0, we expect it to handle gracefully, potentially returning a default or invalid char.","    assert_eq!(result.0, 0); // Assuming it returns 0 for empty input scenario","}"],[264,265,266]]],"codes_branches":[],"codes_branches_covered":[[["{","    let input_data: &[u8] = b\"abc\";","    let input = ByteInput { text: input_data, only_utf8: true };","    let at = InputAt { pos: 0, c: Char(0), byte: None, len: 0 };","    ","    let result = input.previous_char(at);","    assert_eq!(result.0, 0); // Expecting the char value corresponding to the start of the input","}"],[]],[["{","    let input_data: &[u8] = b\"a\";","    let input = ByteInput { text: input_data, only_utf8: true };","    let at = InputAt { pos: 1, c: Char(0), byte: None, len: 0 };","    ","    let result = input.previous_char(at);","    assert_eq!(result.0, 'a' as u32); // Expecting the char value for 'a'","}"],[]],[["{","    let input_data: &[u8] = b\"\\xE2\\x9C\\x94\"; // U+2714 CHECK MARK","    let input = ByteInput { text: input_data, only_utf8: true };","    let at = InputAt { pos: 3, c: Char(0), byte: None, len: 0 };","    ","    let result = input.previous_char(at);","    assert_eq!(result.0, 0x2714); // Expecting the char value for the check mark","}"],[]],[["{","    let input_data: &[u8] = b\"\";","    let input = ByteInput { text: input_data, only_utf8: true };","    let at = InputAt { pos: 0, c: Char(0), byte: None, len: 0 };","    ","    let result = input.previous_char(at);","    // If pos is 0, we expect it to handle gracefully, potentially returning a default or invalid char.","    assert_eq!(result.0, 0); // Assuming it returns 0 for empty input scenario","}"],[]]]}