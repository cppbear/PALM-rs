{"function_name":"regex::re_unicode::re_unicode::Regex::as_str","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/re_unicode.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":2,"tests_lines":[31,31],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[687,688,689],"codes_lines_covered":[[["{","    struct MockExecReadOnly {","        res: Vec<String>,","    }","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","    impl MockExec {","        fn new(res: Vec<String>) -> Self {","            MockExec {","                ro: Arc::new(MockExecReadOnly { res }),","            }","        }","","        fn regex_strings(&self) -> &[String] {","            &self.ro.res","        }","    }","    ","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn as_str(&self) -> &str {","            &self.0.regex_strings()[0]","        }","    }","","    let mock_exec = MockExec::new(vec![String::from(\"mock_regex\")]);","    let regex = MockRegex(mock_exec);","    assert_eq!(regex.as_str(), \"mock_regex\");","}"],[]],[["{","    struct MockExecReadOnly {","        res: Vec<String>,","    }","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","    impl MockExec {","        fn new(res: Vec<String>) -> Self {","            MockExec {","                ro: Arc::new(MockExecReadOnly { res }),","            }","        }","","        fn regex_strings(&self) -> &[String] {","            &self.ro.res","        }","    }","    ","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn as_str(&self) -> &str {","            &self.0.regex_strings()[0]","        }","    }","","    let mock_exec = MockExec::new(vec![String::from(\"\")]);","    let regex = MockRegex(mock_exec);","    assert_eq!(regex.as_str(), \"\");","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MockExecReadOnly {","        res: Vec<String>,","    }","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","    impl MockExec {","        fn new(res: Vec<String>) -> Self {","            MockExec {","                ro: Arc::new(MockExecReadOnly { res }),","            }","        }","","        fn regex_strings(&self) -> &[String] {","            &self.ro.res","        }","    }","    ","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn as_str(&self) -> &str {","            &self.0.regex_strings()[0]","        }","    }","","    let mock_exec = MockExec::new(vec![String::from(\"mock_regex\")]);","    let regex = MockRegex(mock_exec);","    assert_eq!(regex.as_str(), \"mock_regex\");","}"],[]],[["{","    struct MockExecReadOnly {","        res: Vec<String>,","    }","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","    impl MockExec {","        fn new(res: Vec<String>) -> Self {","            MockExec {","                ro: Arc::new(MockExecReadOnly { res }),","            }","        }","","        fn regex_strings(&self) -> &[String] {","            &self.ro.res","        }","    }","    ","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn as_str(&self) -> &str {","            &self.0.regex_strings()[0]","        }","    }","","    let mock_exec = MockExec::new(vec![String::from(\"\")]);","    let regex = MockRegex(mock_exec);","    assert_eq!(regex.as_str(), \"\");","}"],[]]]}