{"function_name":"regex::dfa::dfa::Transitions::set_next","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":2,"tests_lines":[31,33],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1636,1637,1638],"codes_lines_covered":[[["{","    struct TestTransitions {","        table: Vec<StatePtr>,","        num_byte_classes: usize,","    }","    ","    impl TestTransitions {","        fn new(num_byte_classes: usize) -> Self {","            Self {","                table: vec![STATE_UNKNOWN; 10], // Initialize with 10 slots","                num_byte_classes,","            }","        }","","        fn set_next(&mut self, si: StatePtr, cls: usize, next: StatePtr) {","            self.table[si as usize + cls] = next;","        }","","        fn next(&self, si: StatePtr, cls: usize) -> StatePtr {","            self.table[si as usize + cls]","        }","    }","","    let mut transitions = TestTransitions::new(2);","","    transitions.set_next(0, 0, STATE_MATCH);","    assert_eq!(transitions.next(0, 0), STATE_MATCH);","","    transitions.set_next(0, 1, STATE_DEAD);","    assert_eq!(transitions.next(0, 1), STATE_DEAD);","}"],[]],[["{","    struct TestTransitions {","        table: Vec<StatePtr>,","        num_byte_classes: usize,","    }","","    impl TestTransitions {","        fn new(num_byte_classes: usize) -> Self {","            Self {","                table: vec![STATE_UNKNOWN; 10], // Initialize with 10 slots","                num_byte_classes,","            }","        }","","        fn set_next(&mut self, si: StatePtr, cls: usize, next: StatePtr) {","            self.table[si as usize + cls] = next;","        }","","        fn next(&self, si: StatePtr, cls: usize) -> StatePtr {","            self.table[si as usize + cls]","        }","    }","","    let mut transitions = TestTransitions::new(2);","","    // Test setting a transition at the upper boundary","    transitions.set_next(8, 0, STATE_QUIT);","    assert_eq!(transitions.next(8, 0), STATE_QUIT);","","    // Test setting beyond the boundary (this should normally panic or be a no-op)","    transitions.set_next(9, 0, STATE_DEAD);","    assert_eq!(transitions.next(9, 0), STATE_UNKNOWN); // verifiy it remains unknown unless specifically set","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestTransitions {","        table: Vec<StatePtr>,","        num_byte_classes: usize,","    }","    ","    impl TestTransitions {","        fn new(num_byte_classes: usize) -> Self {","            Self {","                table: vec![STATE_UNKNOWN; 10], // Initialize with 10 slots","                num_byte_classes,","            }","        }","","        fn set_next(&mut self, si: StatePtr, cls: usize, next: StatePtr) {","            self.table[si as usize + cls] = next;","        }","","        fn next(&self, si: StatePtr, cls: usize) -> StatePtr {","            self.table[si as usize + cls]","        }","    }","","    let mut transitions = TestTransitions::new(2);","","    transitions.set_next(0, 0, STATE_MATCH);","    assert_eq!(transitions.next(0, 0), STATE_MATCH);","","    transitions.set_next(0, 1, STATE_DEAD);","    assert_eq!(transitions.next(0, 1), STATE_DEAD);","}"],[]],[["{","    struct TestTransitions {","        table: Vec<StatePtr>,","        num_byte_classes: usize,","    }","","    impl TestTransitions {","        fn new(num_byte_classes: usize) -> Self {","            Self {","                table: vec![STATE_UNKNOWN; 10], // Initialize with 10 slots","                num_byte_classes,","            }","        }","","        fn set_next(&mut self, si: StatePtr, cls: usize, next: StatePtr) {","            self.table[si as usize + cls] = next;","        }","","        fn next(&self, si: StatePtr, cls: usize) -> StatePtr {","            self.table[si as usize + cls]","        }","    }","","    let mut transitions = TestTransitions::new(2);","","    // Test setting a transition at the upper boundary","    transitions.set_next(8, 0, STATE_QUIT);","    assert_eq!(transitions.next(8, 0), STATE_QUIT);","","    // Test setting beyond the boundary (this should normally panic or be a no-op)","    transitions.set_next(9, 0, STATE_DEAD);","    assert_eq!(transitions.next(9, 0), STATE_UNKNOWN); // verifiy it remains unknown unless specifically set","}"],[]]]}