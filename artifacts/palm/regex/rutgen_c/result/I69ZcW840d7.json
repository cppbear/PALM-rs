{"function_name":"regex::dfa::dfa::Transitions::next","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":3,"tests_lines":[10,14,12],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1641,1642,1643],"codes_lines_covered":[[["{","    let mut transitions = Transitions {","        table: vec![0, 1, 2, 3, 4, 5, 6, 7],","        num_byte_classes: 8,","    };","    let si: StatePtr = 0;","    let cls: usize = 1;","    let result = transitions.next(si, cls);","    assert_eq!(result, 1);","}"],[1641,1642,1643]],[["{","    let transitions = Transitions {","        table: vec![0, 1, 2, 3, 4, 5, 6, 7],","        num_byte_classes: 8,","    };","    let si: StatePtr = 6; // This is the maximum index for `table` when cls is 1","    let cls: usize = 2;","","    // Accessing beyond the bounds of the table should panic","    let panic_result = std::panic::catch_unwind(|| {","        transitions.next(si, cls);","    });","    assert!(panic_result.is_err());","}"],[1641,1642,1643]],[["{","    let mut transitions = Transitions {","        table: vec![0, 1, 2, 3, 4, 5, 6, 7],","        num_byte_classes: 8,","    };","    let si: StatePtr = STATE_UNKNOWN;","    let cls: usize = 0; // Using a valid byte class","","    // Accessing unknown state, should return default","    let result = transitions.next(si, cls);","    assert_eq!(result, 0); // Assumes default valid return value","}"],[1641,1642,1643]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut transitions = Transitions {","        table: vec![0, 1, 2, 3, 4, 5, 6, 7],","        num_byte_classes: 8,","    };","    let si: StatePtr = 0;","    let cls: usize = 1;","    let result = transitions.next(si, cls);","    assert_eq!(result, 1);","}"],[]],[["{","    let transitions = Transitions {","        table: vec![0, 1, 2, 3, 4, 5, 6, 7],","        num_byte_classes: 8,","    };","    let si: StatePtr = 6; // This is the maximum index for `table` when cls is 1","    let cls: usize = 2;","","    // Accessing beyond the bounds of the table should panic","    let panic_result = std::panic::catch_unwind(|| {","        transitions.next(si, cls);","    });","    assert!(panic_result.is_err());","}"],[]],[["{","    let mut transitions = Transitions {","        table: vec![0, 1, 2, 3, 4, 5, 6, 7],","        num_byte_classes: 8,","    };","    let si: StatePtr = STATE_UNKNOWN;","    let cls: usize = 0; // Using a valid byte class","","    // Accessing unknown state, should return default","    let result = transitions.next(si, cls);","    assert_eq!(result, 0); // Assumes default valid return value","}"],[]]]}