{"function_name":"regex::input::<&'a T as input::Input>::previous_char","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/input.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":2,"tests_lines":[46,44],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":1,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[119],"codes_lines_covered":[[["{","    struct TestInput {","        data: Vec<u32>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(self.data[i]),","                byte: None,","                len: self.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            self.at(at.pos + 1).c","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            self.at(at.pos - 1).c","        }","","        fn is_empty_match(&self, _at: InputAt, _empty: &InstEmptyLook) -> bool {","            false","        }","        ","        fn prefix_at(&self, _prefixes: &LiteralSearcher, _at: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &[]","        }","    }","","    let input = TestInput { data: vec![97, 98, 99] }; // characters 'a', 'b', 'c'","    let at = input.at(1); // pointing to 'b'","    let char_before = input.previous_char(at);","    ","    assert_eq!(char_before, Char(97)); // should be 'a'","}"],[]],[["{","    struct TestInput {","        data: Vec<u32>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(self.data[i]),","                byte: None,","                len: self.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            self.at(at.pos + 1).c","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            self.at(at.pos - 1).c","        }","","        fn is_empty_match(&self, _at: InputAt, _empty: &InstEmptyLook) -> bool {","            false","        }","        ","        fn prefix_at(&self, _prefixes: &LiteralSearcher, _at: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &[]","        }","    }","","    let input = TestInput { data: vec![97, 98, 99] }; // 'a', 'b', 'c'","    let at = input.at(0); // pointing to 'a'","    let _char_before = input.previous_char(at); // should panic when trying to go before the first character","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestInput {","        data: Vec<u32>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(self.data[i]),","                byte: None,","                len: self.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            self.at(at.pos + 1).c","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            self.at(at.pos - 1).c","        }","","        fn is_empty_match(&self, _at: InputAt, _empty: &InstEmptyLook) -> bool {","            false","        }","        ","        fn prefix_at(&self, _prefixes: &LiteralSearcher, _at: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &[]","        }","    }","","    let input = TestInput { data: vec![97, 98, 99] }; // characters 'a', 'b', 'c'","    let at = input.at(1); // pointing to 'b'","    let char_before = input.previous_char(at);","    ","    assert_eq!(char_before, Char(97)); // should be 'a'","}"],[]],[["{","    struct TestInput {","        data: Vec<u32>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(self.data[i]),","                byte: None,","                len: self.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            self.at(at.pos + 1).c","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            self.at(at.pos - 1).c","        }","","        fn is_empty_match(&self, _at: InputAt, _empty: &InstEmptyLook) -> bool {","            false","        }","        ","        fn prefix_at(&self, _prefixes: &LiteralSearcher, _at: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &[]","        }","    }","","    let input = TestInput { data: vec![97, 98, 99] }; // 'a', 'b', 'c'","    let at = input.at(0); // pointing to 'a'","    let _char_before = input.previous_char(at); // should panic when trying to go before the first character","}"],[]]]}