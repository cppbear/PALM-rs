{"function_name":"regex::pikevm::pikevm::Threads::caps","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/pikevm.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":3,"tests_lines":[10,8,10],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[373,374,375,376],"codes_lines_covered":[[["{","    let mut threads = Threads::new();","    threads.slots_per_thread = 2; // Assume we have 2 slots per thread","    threads.caps = vec![None; 6]; // Preallocate for 3 threads","    ","    let pc = 1; // Choosing the second thread (index 1)","    let caps = threads.caps(pc);","    ","    assert_eq!(caps.len(), 2); // Should return a slice of length 2","}"],[373,374,375,376]],[["{","    let mut threads = Threads::new();","    threads.slots_per_thread = 2; // Assume we have 2 slots per thread","    threads.caps = vec![None; 4]; // Preallocate for 2 threads","    ","    let pc = 3; // Choosing an out-of-bounds index","    threads.caps(pc); // Should panic because the index is out of bounds","}"],[373,374,375,376]],[["{","    let mut threads = Threads::new();","    threads.slots_per_thread = 2; // Assume we have 2 slots per thread","    threads.caps = vec![None; 4]; // Preallocate for 2 threads","    ","    let pc = 0; // Choosing the first thread (index 0)","    let caps = threads.caps(pc);","    ","    assert_eq!(caps.len(), 2); // Should return a slice of length 2","}"],[373,374,375,376]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut threads = Threads::new();","    threads.slots_per_thread = 2; // Assume we have 2 slots per thread","    threads.caps = vec![None; 6]; // Preallocate for 3 threads","    ","    let pc = 1; // Choosing the second thread (index 1)","    let caps = threads.caps(pc);","    ","    assert_eq!(caps.len(), 2); // Should return a slice of length 2","}"],[]],[["{","    let mut threads = Threads::new();","    threads.slots_per_thread = 2; // Assume we have 2 slots per thread","    threads.caps = vec![None; 4]; // Preallocate for 2 threads","    ","    let pc = 3; // Choosing an out-of-bounds index","    threads.caps(pc); // Should panic because the index is out of bounds","}"],[]],[["{","    let mut threads = Threads::new();","    threads.slots_per_thread = 2; // Assume we have 2 slots per thread","    threads.caps = vec![None; 4]; // Preallocate for 2 threads","    ","    let pc = 0; // Choosing the first thread (index 0)","    let caps = threads.caps(pc);","    ","    assert_eq!(caps.len(), 2); // Should return a slice of length 2","}"],[]]]}