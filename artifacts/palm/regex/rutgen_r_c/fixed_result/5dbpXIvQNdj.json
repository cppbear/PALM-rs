{"function_name":"regex_syntax::hir::literal::hir::literal::Literals::cross_add","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":28,"tests_lines":[5,9,8,9,14,14,12,14,9,9,9,10,7,9,12,12,12,21,19,19,29,21,23,27,19,18,18,77],"oracles":28,"oracles_compiled":22,"oracles_compiled_rate":78.57142857142857,"tests_compiled":22,"tests_compiled_rate":78.57142857142857,"oracles_run":22,"oracles_passed":10,"oracles_passed_rate":45.45454545454545,"tests_run":22,"tests_passed":10,"tests_passed_rate":45.45454545454545,"lines":31,"lines_covered":29,"lines_coveraged_rate":93.54838709677419,"branches":14,"branches_covered":11,"branches_coverage_rate":78.57142857142857,"codes_lines":[421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,451,452],"codes_lines_covered":[[["{","    let mut literals = Literals::empty(); // Assume the empty() initializes an empty `Literals` object","    let result = literals.cross_add(&[]); // Pass an empty slice","    assert_eq!(result, true); // Expected return value is true","}"],[421,422,423,424,425,426,452]],[["{","    let mut literals = Literals::empty(); ","    literals.set_limit_size(5); // Set limit size for the literals","    literals.add(Literal::new(vec![1, 2, 3])); // Adding a literal","    let result = literals.cross_add(&[4, 5]); // Add bytes that should fit","    assert_eq!(result, true);","    assert_eq!(literals.literals().len(), 1); // Should still have one literal","    assert_eq!(literals.literals()[0].is_cut(), false); // The literal should not be cut","}"],[421,422,423,424,425,427,428,433,434,435,437,438,439,440,441,442,443,444,445,446,448,451,452]],[["{","    let mut literals = Literals::empty(); ","    literals.set_limit_size(2); // Limit size is 2","    literals.add(Literal::new(vec![1])); // Add a literal that takes 1 byte","    let result = literals.cross_add(&[2, 3, 4]); // This should exceed the limit","    assert_eq!(result, false); // Expected return value is false","    assert_eq!(literals.literals().len(), 1); // Should still have one literal","}"],[421,422,423,424,425,427,428,433,434,435,436,452]],[["{","    let mut literals = Literals::empty();","    literals.set_limit_size(5);","    literals.add(Literal::new(vec![1, 2])); // Starting with a 2-byte literal","    let result = literals.cross_add(&[3, 4, 5]); // Adding 3 more bytes","    assert_eq!(result, true); // Should be true","    assert_eq!(literals.literals().len(), 1); // Should still have just one literal","    assert_eq!(literals.literals()[0].is_cut(), true); // The literal should be cut now","}"],[421,422,423,424,425,427,428,433,434,435,437,438,439,440,441,442,443,444,445,446,448,451,452]],[["{","    let mut literals = Literals {","        lits: vec![],","        limit_size: 10,","        limit_class: 1,","    };","","    let result = literals.cross_add(&[1, 2, 3, 4, 5]);","","    assert!(result);","    assert_eq!(literals.lits.len(), 1);","    assert_eq!(literals.lits[0].v, vec![1]);","    assert!(!literals.lits[0].is_cut());","}"],[421,422,423,424,425,427,428,429,430,431,432,452]],[["{","    let mut literals = Literals {","        lits: vec![],","        limit_size: 5,","        limit_class: 1,","    };","","    let result = literals.cross_add(&[1, 2, 3, 4, 5]);","","    assert!(result);","    assert_eq!(literals.lits.len(), 1);","    assert_eq!(literals.lits[0].v, vec![1, 2, 3, 4, 5]);","    assert!(literals.lits[0].is_cut());","}"],[421,422,423,424,425,427,428,429,430,431,432,452]],[["{","    let mut literals = Literals {","        lits: vec![],","        limit_size: 2,","        limit_class: 1,","    };","","    let result = literals.cross_add(&[1, 2, 3]);","","    assert!(!result);","    assert!(literals.lits.is_empty());","}"],[421,422,423,424,425,427,428,429,430,431,432,452]],[["{","    let mut literals = Literals {","        lits: vec![],","        limit_size: 10,","        limit_class: 1,","    };","","    let result = literals.cross_add(&[10]);","","    assert!(result);","    assert_eq!(literals.lits.len(), 1);","    assert_eq!(literals.lits[0].v, vec![10]);","    assert!(!literals.lits[0].is_cut());","}"],[421,422,423,424,425,427,428,429,430,431,432,452]],[["{","    let mut literals = Literals {","        lits: Vec::new(),","        limit_size: 5,","        limit_class: 10,","    };","    let result = literals.cross_add(&[]);","    assert_eq!(result, true);","}"],[421,422,423,424,425,426,452]],[["{","    let mut literals = Literals {","        lits: Vec::new(),","        limit_size: 5,","        limit_class: 10,","    };","    let result = literals.cross_add(&[1, 2, 3]);","    assert_eq!(result, false);","}"],[421,422,423,424,425,427,428,429,430,431,432,452]],[["{","    let mut literals = Literals {","        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3])],","        limit_size: 5,","        limit_class: 10,","    };","    let result = literals.cross_add(&[4, 5, 6]); // size + lits.len() == 5 + 2 = 7 >= limit_size = 5","    assert_eq!(result, false);","}"],[421,422,423,424,425,427,428,433,434,435,436,452]],[["{","    let mut literals = Literals {","        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3])],","        limit_size: 5,","        limit_class: 10,","    };","    let result = literals.cross_add(&[4]); // size + (lits.len() == 2) == 2 + 2 = 4, fits within the limit","    assert_eq!(result, true);","    assert_eq!(literals.lits[0].is_cut(), false); // Check if the first literal is not cut","}"],[421,422,423,424,425,427,428,433,434,435,436,452]],[["{","    let mut literals = Literals::empty();","    let result = literals.cross_add(&[1, 2, 3]);","    assert_eq!(result, true);","    assert_eq!(literals.literals().len(), 1);","    assert_eq!(literals.literals()[0].is_cut(), false);","}"],[421,422,423,424,425,427,428,429,430,431,432,452]],[["{","    let mut literals = Literals {","        lits: vec![Literal::new(vec![1])],","        limit_size: 1,","        limit_class: 1,","    };","    let result = literals.cross_add(&[1, 2]);","    assert_eq!(result, false);","}"],[421,422,423,424,425,427,428,433,434,435,436,452]],[["{","    let mut literals = {","        let mut lits = Literals {","            lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b'])],","            limit_size: 4,","            limit_class: 1,","        };","        lits.set_limit_size(4);","        lits","    };","    let bytes = b\"cd\"; // bytes.len() == 2","","    let result = literals.cross_add(bytes);","    ","    assert!(result);","    assert_eq!(literals.lits.len(), 2);","    assert_eq!(literals.lits[0].is_cut(), true);","    assert_eq!(literals.lits[0].v, vec![b'a', b'c']);","    assert_eq!(literals.lits[1].is_cut(), true);","    assert_eq!(literals.lits[1].v, vec![b'b', b'd']);","}"],[421,422,423,424,425,427,428,433,434,435,436,452]],[["{","    let mut literals = {","        let mut lits = Literals {","            lits: vec![Literal::new(vec![b'x'])],","            limit_size: 6,","            limit_class: 1,","        };","        lits.set_limit_size(6);","        lits","    };","    let bytes = b\"yz\"; // bytes.len() == 2","","    let result = literals.cross_add(bytes);","","    assert!(result);","    assert_eq!(literals.lits.len(), 1);","    assert_eq!(literals.lits[0].is_cut(), true);","    assert_eq!(literals.lits[0].v, vec![b'x', b'y', b'z']);","}"],[421,422,423,424,425,427,428,433,434,435,437,438,439,440,441,442,443,444,445,446,448,451,452]],[["{","    let mut literals = {","        let mut lits = Literals {","            lits: vec![Literal::new(vec![b'1'])],","            limit_size: 3, // 3 is the limit","            limit_class: 1,","        };","        lits.set_limit_size(3);","        lits","    };","    let bytes = b\"2\"; // Adding a single byte, reaching the limit exactly","","    let result = literals.cross_add(bytes);","    ","    assert!(result);","    assert_eq!(literals.lits.len(), 1);","    assert_eq!(literals.lits[0].is_cut(), true);","    assert_eq!(literals.lits[0].v, vec![b'1', b'2']);","}"],[421,422,423,424,425,427,428,433,434,435,437,438,439,440,443,444,445,446,448,451,452]],[["{","    // Helper structure to represent Hir","    struct Hir;","","    // Create a Literals instance with some populated literals","    let mut literals = Literals {","        lits: vec![","            Literal::new(vec![1, 2, 3]),","            Literal::new(vec![4, 5, 6]),","        ],","        limit_size: 10,","        limit_class: 1,","    };","","    // Define bytes that can be added without exceeding the limit","    let bytes: &[u8] = &[7, 8];","","    // Call the cross_add method","    let result = literals.cross_add(bytes);","","    // Verify the expected output is true","    assert!(result);","    // Verify that the literals were extended correctly","    assert_eq!(literals.lits[0].v, vec![1, 2, 3, 7]);","    assert_eq!(literals.lits[1].v, vec![4, 5, 6, 7]);","    assert!(!literals.lits[0].is_cut());","}"],[421,422,423,424,425,427,428,433,434,435,437,438,439,440,441,442,443,444,445,446,448,451,452]],[["{","    struct Hir;","","    let mut literals = Literals {","        lits: vec![","            Literal::new(vec![1, 2, 3]),","        ],","        limit_size: 10,","        limit_class: 1,","    };","","    let bytes: &[u8] = &[4, 5, 6, 7, 8]; // This will fit without exceeding limits","","    let result = literals.cross_add(bytes);","","    assert!(result);","    assert_eq!(literals.lits[0].v, vec![1, 2, 3, 4, 5]);","    assert!(literals.lits[0].is_cut()); // Should be cut","}"],[421,422,423,424,425,427,428,433,434,435,437,438,439,440,441,442,443,444,445,446,448,451,452]],[["{","    struct Hir;","","    let mut literals = Literals {","        lits: vec![","            Literal::new(vec![1, 2, 3, 4, 5]),","        ],","        limit_size: 5, // Limit size is small","        limit_class: 1,","    };","","    let bytes: &[u8] = &[6, 7]; // Adding this will exceed limit","","    let result = literals.cross_add(bytes);","","    assert!(!result); // Should return false, no modifications should happen","    assert_eq!(literals.lits[0].v, vec![1, 2, 3, 4, 5]); // Should remain unchanged","}"],[421,422,423,424,425,427,428,433,434,435,436,452]],[["{","    struct Hir;","","    let mut literals = Literals {","        lits: vec![","            Literal::new(vec![1, 2, 3]),","        ],","        limit_size: 10,","        limit_class: 1,","    };","","    let bytes: &[u8] = &[]; // Empty byte array","","    let result = literals.cross_add(bytes);","","    assert!(result); // Should return true, no modifications should happen","    assert_eq!(literals.lits[0].v, vec![1, 2, 3]); // Should remain unchanged","}"],[421,422,423,424,425,426,452]],[["{","    struct LocalLiteral {","        v: Vec<u8>,","        cut: bool,","    }","","    impl LocalLiteral {","        pub fn new(bytes: Vec<u8>) -> LocalLiteral {","            LocalLiteral { v: bytes, cut: false }","        }","        pub fn is_cut(&self) -> bool {","            self.cut","        }","        pub fn extend(&mut self, bytes: &[u8]) {","            self.v.extend_from_slice(bytes);","        }","        pub fn cut(&mut self) {","            self.cut = true;","        }","    }","","    struct LocalLiterals {","        lits: Vec<LocalLiteral>,","        limit_size: usize,","    }","","    impl LocalLiterals {","        pub fn new(limit_size: usize) -> LocalLiterals {","            LocalLiterals {","                lits: Vec::new(),","                limit_size,","            }","        }","        ","        pub fn num_bytes(&self) -> usize {","            self.lits.iter().map(|lit| lit.v.len()).sum()","        }","","        pub fn cross_add(&mut self, bytes: &[u8]) -> bool {","            if bytes.is_empty() {","                return true;","            }","            if self.lits.is_empty() {","                let i = cmp::min(self.limit_size, bytes.len());","                self.lits.push(LocalLiteral::new(bytes[..i].to_owned()));","                self.lits[0].cut = i < bytes.len();","                return !self.lits[0].is_cut();","            }","            let size = self.num_bytes();","            if size + self.lits.len() >= self.limit_size {","                return false;","            }","            let mut i = 1;","            while size + (i * self.lits.len()) <= self.limit_size && i < bytes.len() {","                i += 1;","            }","            for lit in &mut self.lits {","                if !lit.is_cut() {","                    lit.extend(&bytes[..i]);","                    if i < bytes.len() {","                        lit.cut();","                    }","                }","            }","            true","        }","    }","","    let mut literals = LocalLiterals::new(10);","    literals.lits.push(LocalLiteral::new(vec![1, 2, 3])); // non-empty lits","    literals.lits.push(LocalLiteral::new(vec![4, 5])); // non-empty lits","","    let result = literals.cross_add(&[6, 7, 8]); // fitting bytes","    assert!(result);","    assert_eq!(literals.lits[0].v, vec![1, 2, 3, 6]); // first literal extended","    assert_eq!(literals.lits[1].v, vec![4, 5, 6]); // second literal cut since more bytes available","}"],[]]],"codes_branches":[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":true,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":true,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":true,"negative":true},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":true,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":true,"negative":true},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":true,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    let mut literals = Literals::empty(); // Assume the empty() initializes an empty `Literals` object","    let result = literals.cross_add(&[]); // Pass an empty slice","    assert_eq!(result, true); // Expected return value is true","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":true,"negative":false},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":false},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals::empty(); ","    literals.set_limit_size(5); // Set limit size for the literals","    literals.add(Literal::new(vec![1, 2, 3])); // Adding a literal","    let result = literals.cross_add(&[4, 5]); // Add bytes that should fit","    assert_eq!(result, true);","    assert_eq!(literals.literals().len(), 1); // Should still have one literal","    assert_eq!(literals.literals()[0].is_cut(), false); // The literal should not be cut","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":true},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":true,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":true,"negative":true},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":true,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":true}]],[["{","    let mut literals = Literals::empty(); ","    literals.set_limit_size(2); // Limit size is 2","    literals.add(Literal::new(vec![1])); // Add a literal that takes 1 byte","    let result = literals.cross_add(&[2, 3, 4]); // This should exceed the limit","    assert_eq!(result, false); // Expected return value is false","    assert_eq!(literals.literals().len(), 1); // Should still have one literal","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":true,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals::empty();","    literals.set_limit_size(5);","    literals.add(Literal::new(vec![1, 2])); // Starting with a 2-byte literal","    let result = literals.cross_add(&[3, 4, 5]); // Adding 3 more bytes","    assert_eq!(result, true); // Should be true","    assert_eq!(literals.literals().len(), 1); // Should still have just one literal","    assert_eq!(literals.literals()[0].is_cut(), true); // The literal should be cut now","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":true},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":true,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":true,"negative":true},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":true,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":true}]],[["{","    let mut literals = Literals {","        lits: vec![],","        limit_size: 10,","        limit_class: 1,","    };","","    let result = literals.cross_add(&[1, 2, 3, 4, 5]);","","    assert!(result);","    assert_eq!(literals.lits.len(), 1);","    assert_eq!(literals.lits[0].v, vec![1]);","    assert!(!literals.lits[0].is_cut());","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":true,"negative":false},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals {","        lits: vec![],","        limit_size: 5,","        limit_class: 1,","    };","","    let result = literals.cross_add(&[1, 2, 3, 4, 5]);","","    assert!(result);","    assert_eq!(literals.lits.len(), 1);","    assert_eq!(literals.lits[0].v, vec![1, 2, 3, 4, 5]);","    assert!(literals.lits[0].is_cut());","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":true,"negative":false},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals {","        lits: vec![],","        limit_size: 2,","        limit_class: 1,","    };","","    let result = literals.cross_add(&[1, 2, 3]);","","    assert!(!result);","    assert!(literals.lits.is_empty());","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":true,"negative":false},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals {","        lits: vec![],","        limit_size: 10,","        limit_class: 1,","    };","","    let result = literals.cross_add(&[10]);","","    assert!(result);","    assert_eq!(literals.lits.len(), 1);","    assert_eq!(literals.lits[0].v, vec![10]);","    assert!(!literals.lits[0].is_cut());","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":true,"negative":false},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals {","        lits: Vec::new(),","        limit_size: 5,","        limit_class: 10,","    };","    let result = literals.cross_add(&[]);","    assert_eq!(result, true);","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":true,"negative":false},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":false},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals {","        lits: Vec::new(),","        limit_size: 5,","        limit_class: 10,","    };","    let result = literals.cross_add(&[1, 2, 3]);","    assert_eq!(result, false);","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":true,"negative":false},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals {","        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3])],","        limit_size: 5,","        limit_class: 10,","    };","    let result = literals.cross_add(&[4, 5, 6]); // size + lits.len() == 5 + 2 = 7 >= limit_size = 5","    assert_eq!(result, false);","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":true,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals {","        lits: vec![Literal::new(vec![1, 2]), Literal::new(vec![3])],","        limit_size: 5,","        limit_class: 10,","    };","    let result = literals.cross_add(&[4]); // size + (lits.len() == 2) == 2 + 2 = 4, fits within the limit","    assert_eq!(result, true);","    assert_eq!(literals.lits[0].is_cut(), false); // Check if the first literal is not cut","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":true,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals::empty();","    let result = literals.cross_add(&[1, 2, 3]);","    assert_eq!(result, true);","    assert_eq!(literals.literals().len(), 1);","    assert_eq!(literals.literals()[0].is_cut(), false);","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":true,"negative":false},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = Literals {","        lits: vec![Literal::new(vec![1])],","        limit_size: 1,","        limit_class: 1,","    };","    let result = literals.cross_add(&[1, 2]);","    assert_eq!(result, false);","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":true,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = {","        let mut lits = Literals {","            lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b'])],","            limit_size: 4,","            limit_class: 1,","        };","        lits.set_limit_size(4);","        lits","    };","    let bytes = b\"cd\"; // bytes.len() == 2","","    let result = literals.cross_add(bytes);","    ","    assert!(result);","    assert_eq!(literals.lits.len(), 2);","    assert_eq!(literals.lits[0].is_cut(), true);","    assert_eq!(literals.lits[0].v, vec![b'a', b'c']);","    assert_eq!(literals.lits[1].is_cut(), true);","    assert_eq!(literals.lits[1].v, vec![b'b', b'd']);","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":true,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    let mut literals = {","        let mut lits = Literals {","            lits: vec![Literal::new(vec![b'x'])],","            limit_size: 6,","            limit_class: 1,","        };","        lits.set_limit_size(6);","        lits","    };","    let bytes = b\"yz\"; // bytes.len() == 2","","    let result = literals.cross_add(bytes);","","    assert!(result);","    assert_eq!(literals.lits.len(), 1);","    assert_eq!(literals.lits[0].is_cut(), true);","    assert_eq!(literals.lits[0].v, vec![b'x', b'y', b'z']);","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":true},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":true,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":true,"negative":true},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":true,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":true}]],[["{","    let mut literals = {","        let mut lits = Literals {","            lits: vec![Literal::new(vec![b'1'])],","            limit_size: 3, // 3 is the limit","            limit_class: 1,","        };","        lits.set_limit_size(3);","        lits","    };","    let bytes = b\"2\"; // Adding a single byte, reaching the limit exactly","","    let result = literals.cross_add(bytes);","    ","    assert!(result);","    assert_eq!(literals.lits.len(), 1);","    assert_eq!(literals.lits[0].is_cut(), true);","    assert_eq!(literals.lits[0].v, vec![b'1', b'2']);","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":true},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":true,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":true},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":true,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":true}]],[["{","    // Helper structure to represent Hir","    struct Hir;","","    // Create a Literals instance with some populated literals","    let mut literals = Literals {","        lits: vec![","            Literal::new(vec![1, 2, 3]),","            Literal::new(vec![4, 5, 6]),","        ],","        limit_size: 10,","        limit_class: 1,","    };","","    // Define bytes that can be added without exceeding the limit","    let bytes: &[u8] = &[7, 8];","","    // Call the cross_add method","    let result = literals.cross_add(bytes);","","    // Verify the expected output is true","    assert!(result);","    // Verify that the literals were extended correctly","    assert_eq!(literals.lits[0].v, vec![1, 2, 3, 7]);","    assert_eq!(literals.lits[1].v, vec![4, 5, 6, 7]);","    assert!(!literals.lits[0].is_cut());","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":true},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":true,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":true,"negative":true},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":true,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":true}]],[["{","    struct Hir;","","    let mut literals = Literals {","        lits: vec![","            Literal::new(vec![1, 2, 3]),","        ],","        limit_size: 10,","        limit_class: 1,","    };","","    let bytes: &[u8] = &[4, 5, 6, 7, 8]; // This will fit without exceeding limits","","    let result = literals.cross_add(bytes);","","    assert!(result);","    assert_eq!(literals.lits[0].v, vec![1, 2, 3, 4, 5]);","    assert!(literals.lits[0].is_cut()); // Should be cut","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":true},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":true,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":true,"negative":true},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":true,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":true}]],[["{","    struct Hir;","","    let mut literals = Literals {","        lits: vec![","            Literal::new(vec![1, 2, 3, 4, 5]),","        ],","        limit_size: 5, // Limit size is small","        limit_class: 1,","    };","","    let bytes: &[u8] = &[6, 7]; // Adding this will exceed limit","","    let result = literals.cross_add(bytes);","","    assert!(!result); // Should return false, no modifications should happen","    assert_eq!(literals.lits[0].v, vec![1, 2, 3, 4, 5]); // Should remain unchanged","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":true},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":true},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":true,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    struct Hir;","","    let mut literals = Literals {","        lits: vec![","            Literal::new(vec![1, 2, 3]),","        ],","        limit_size: 10,","        limit_class: 1,","    };","","    let bytes: &[u8] = &[]; // Empty byte array","","    let result = literals.cross_add(bytes);","","    assert!(result); // Should return true, no modifications should happen","    assert_eq!(literals.lits[0].v, vec![1, 2, 3]); // Should remain unchanged","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":true,"negative":false},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":false},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]],[["{","    struct LocalLiteral {","        v: Vec<u8>,","        cut: bool,","    }","","    impl LocalLiteral {","        pub fn new(bytes: Vec<u8>) -> LocalLiteral {","            LocalLiteral { v: bytes, cut: false }","        }","        pub fn is_cut(&self) -> bool {","            self.cut","        }","        pub fn extend(&mut self, bytes: &[u8]) {","            self.v.extend_from_slice(bytes);","        }","        pub fn cut(&mut self) {","            self.cut = true;","        }","    }","","    struct LocalLiterals {","        lits: Vec<LocalLiteral>,","        limit_size: usize,","    }","","    impl LocalLiterals {","        pub fn new(limit_size: usize) -> LocalLiterals {","            LocalLiterals {","                lits: Vec::new(),","                limit_size,","            }","        }","        ","        pub fn num_bytes(&self) -> usize {","            self.lits.iter().map(|lit| lit.v.len()).sum()","        }","","        pub fn cross_add(&mut self, bytes: &[u8]) -> bool {","            if bytes.is_empty() {","                return true;","            }","            if self.lits.is_empty() {","                let i = cmp::min(self.limit_size, bytes.len());","                self.lits.push(LocalLiteral::new(bytes[..i].to_owned()));","                self.lits[0].cut = i < bytes.len();","                return !self.lits[0].is_cut();","            }","            let size = self.num_bytes();","            if size + self.lits.len() >= self.limit_size {","                return false;","            }","            let mut i = 1;","            while size + (i * self.lits.len()) <= self.limit_size && i < bytes.len() {","                i += 1;","            }","            for lit in &mut self.lits {","                if !lit.is_cut() {","                    lit.extend(&bytes[..i]);","                    if i < bytes.len() {","                        lit.cut();","                    }","                }","            }","            true","        }","    }","","    let mut literals = LocalLiterals::new(10);","    literals.lits.push(LocalLiteral::new(vec![1, 2, 3])); // non-empty lits","    literals.lits.push(LocalLiteral::new(vec![4, 5])); // non-empty lits","","    let result = literals.cross_add(&[6, 7, 8]); // fitting bytes","    assert!(result);","    assert_eq!(literals.lits[0].v, vec![1, 2, 3, 6]); // first literal extended","    assert_eq!(literals.lits[1].v, vec![4, 5, 6]); // second literal cut since more bytes available","}"],[{"start_line":425,"start_column":12,"end_line":425,"end_column":28,"positive":false,"negative":false},{"start_line":428,"start_column":12,"end_line":428,"end_column":32,"positive":false,"negative":false},{"start_line":435,"start_column":12,"end_line":435,"end_column":53,"positive":false,"negative":false},{"start_line":439,"start_column":15,"end_line":439,"end_column":62,"positive":false,"negative":false},{"start_line":440,"start_column":16,"end_line":440,"end_column":31,"positive":false,"negative":false},{"start_line":444,"start_column":16,"end_line":444,"end_column":29,"positive":false,"negative":false},{"start_line":446,"start_column":20,"end_line":446,"end_column":35,"positive":false,"negative":false}]]]}