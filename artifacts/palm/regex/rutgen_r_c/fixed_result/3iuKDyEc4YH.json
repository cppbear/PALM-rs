{"function_name":"regex::input::<input::ByteInput<'t> as input::Input>::previous_char","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/input.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[7,6,7,6],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":4,"tests_passed":2,"tests_passed_rate":50.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[264,265,266],"codes_lines_covered":[[["{","    let text: &[u8] = &[0xE2, 0x9C, 0x94]; // Unicode character '✔'","    let input = ByteInput { text, only_utf8: true };","    let at = InputAt { pos: 3, c: Char(0), byte: None, len: 1 };","    let result = input.previous_char(at);","    assert_eq!(result.0, 0x2705); // Check that it returns the correct UTF-8 decoded character","}"],[264,265,266]],[["{","    let text: &[u8] = &[]; // Empty byte array","    let input = ByteInput { text, only_utf8: true };","    let at = InputAt { pos: 0, c: Char(0), byte: None, len: 0 }; // Position is 0","    input.previous_char(at); // This should panic due to out-of-bounds access","}"],[264,265,266]],[["{","    let text: &[u8] = &[0x41]; // ASCII character 'A'","    let input = ByteInput { text, only_utf8: true };","    let at = InputAt { pos: 1, c: Char(0), byte: None, len: 1 };","    let result = input.previous_char(at);","    assert_eq!(result.0, 0x41); // Check that it returns the correct character","}"],[264,265,266]],[["{","    let text: &[u8] = &[0xE2, 0x9C, 0x94]; // Unicode example character","    let input = ByteInput { text, only_utf8: true };","    let at = InputAt { pos: 4, c: Char(0), byte: None, len: 1 }; // Position out of bounds","    input.previous_char(at); // This should panic","}"],[264,265,266]]],"codes_branches":[],"codes_branches_covered":[[["{","    let text: &[u8] = &[0xE2, 0x9C, 0x94]; // Unicode character '✔'","    let input = ByteInput { text, only_utf8: true };","    let at = InputAt { pos: 3, c: Char(0), byte: None, len: 1 };","    let result = input.previous_char(at);","    assert_eq!(result.0, 0x2705); // Check that it returns the correct UTF-8 decoded character","}"],[]],[["{","    let text: &[u8] = &[]; // Empty byte array","    let input = ByteInput { text, only_utf8: true };","    let at = InputAt { pos: 0, c: Char(0), byte: None, len: 0 }; // Position is 0","    input.previous_char(at); // This should panic due to out-of-bounds access","}"],[]],[["{","    let text: &[u8] = &[0x41]; // ASCII character 'A'","    let input = ByteInput { text, only_utf8: true };","    let at = InputAt { pos: 1, c: Char(0), byte: None, len: 1 };","    let result = input.previous_char(at);","    assert_eq!(result.0, 0x41); // Check that it returns the correct character","}"],[]],[["{","    let text: &[u8] = &[0xE2, 0x9C, 0x94]; // Unicode example character","    let input = ByteInput { text, only_utf8: true };","    let at = InputAt { pos: 4, c: Char(0), byte: None, len: 1 }; // Position out of bounds","    input.previous_char(at); // This should panic","}"],[]]]}