{"function_name":"regex::literal::literal::LiteralSearcher::len","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":28,"tests_lines":[41,41,33,33,43,7,13,15,7,42,22,20,12,15,25,18,27,24,24,25,24,9,16,17,10,10,16,16],"oracles":28,"oracles_compiled":10,"oracles_compiled_rate":35.714285714285715,"tests_compiled":10,"tests_compiled_rate":35.714285714285715,"oracles_run":10,"oracles_passed":10,"oracles_passed_rate":100.0,"tests_run":10,"tests_passed":10,"tests_passed_rate":100.0,"lines":10,"lines_covered":7,"lines_coveraged_rate":70.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[170,172,173,174,175,176,177,178,179,181],"codes_lines_covered":[[["{","    // Define a simple FreqyPacked instance.","    let freqy_packed = FreqyPacked {","        pat: b\"example\".to_vec(),","        char_len: 7,","        rare1: b'x',","        rare1i: 3,","        rare2: b'e',","        rare2i: 0,","    };","","    // Create a LiteralSearcher with Matcher::FreqyPacked variant.","    let searcher = LiteralSearcher {","        complete: true,","        lcp: FreqyPacked::new(b\"prefix\".to_vec()),","        lcs: FreqyPacked::new(b\"suffix\".to_vec()),","        matcher: Matcher::FreqyPacked(freqy_packed.clone()),","    };","","    // Assert that the length is as expected.","    assert_eq!(searcher.len(), 1);","}"],[170,172,175,181]],[["{","    // Define a simple SingleByteSet instance.","    let single_byte_set = SingleByteSet {","        sparse: vec![false; 256],","        dense: b\"abc\".to_vec(),","        complete: false,","        all_ascii: true,","    };","","    // Create a LiteralSearcher with Matcher::Bytes variant.","    let searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(b\"prefix\".to_vec()),","        lcs: FreqyPacked::new(b\"suffix\".to_vec()),","        matcher: Matcher::Bytes(single_byte_set),","    };","","    // Assert that the length is as expected.","    assert_eq!(searcher.len(), 3);","}"],[170,172,174,181]],[["{","    // Create a LiteralSearcher with Matcher::Empty variant.","    let searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(b\"prefix\".to_vec()),","        lcs: FreqyPacked::new(b\"suffix\".to_vec()),","        matcher: Matcher::Empty,","    };","","    // Assert that the length is as expected.","    assert_eq!(searcher.len(), 0);","}"],[170,172,173,181]],[["{","    // Define a BoyerMooreSearch structure.","    let boyer_moore_search = BoyerMooreSearch::new(b\"example\".to_vec());","","    // Create a LiteralSearcher with Matcher::BoyerMoore variant.","    let searcher = LiteralSearcher {","        complete: true,","        lcp: FreqyPacked::new(b\"prefix\".to_vec()),","        lcs: FreqyPacked::new(b\"suffix\".to_vec()),","        matcher: Matcher::BoyerMoore(boyer_moore_search),","    };","","    // Assert that the length is as expected.","    assert_eq!(searcher.len(), 1);","}"],[170,172,176,181]],[["{","    // Constructing necessary structs and using the provided initialization methods.","    ","    let single_byte_set = SingleByteSet {","        sparse: vec![false; 256],","        dense: vec![1, 2, 3], // Example dense set with some byte literals.","        complete: true,","        all_ascii: true,","    };","","    let matcher = Matcher::Bytes(single_byte_set);","","    // Creating an empty Literals object for the searcher since it's not relevant for Bytes matcher.","    let lits = Literals::empty(); ","","    let searcher = LiteralSearcher {","        complete: lits.all_complete(),","        lcp: FreqyPacked::new(vec![]), // Using empty pattern for LCP.","        lcs: FreqyPacked::new(vec![]), // Using empty pattern for LCS.","        matcher,","    };","","    // Test: The length should equal the number of elements in the dense bytes.","    assert_eq!(searcher.len(), 3);","}"],[170,172,174,181]],[["{","    // Testing the case where matcher is Empty.","    ","    let matcher = Matcher::Empty;","","    // Creating an empty Literals object for the searcher since it's not relevant for Empty matcher.","    let lits = Literals::empty(); ","","    let searcher = LiteralSearcher {","        complete: lits.all_complete(),","        lcp: FreqyPacked::new(vec![]),","        lcs: FreqyPacked::new(vec![]),","        matcher,","    };","","    // Test: The length should be 0 for an Empty matcher.","    assert_eq!(searcher.len(), 0);","}"],[170,172,173,181]],[["{","    // Testing the case where matcher is FreqyPacked.","","    let freqy_packed = FreqyPacked {","        pat: vec![1, 2, 3, 4], // A sample pattern for testing.","        char_len: 4,","        rare1: 1,","        rare1i: 0,","        rare2: 2,","        rare2i: 1,","    };","","    let matcher = Matcher::FreqyPacked(freqy_packed);","    ","    // Creating an empty Literals object for the searcher since it's not relevant for FreqyPacked matcher.","    let lits = Literals::empty();","","    let searcher = LiteralSearcher {","        complete: lits.all_complete(),","        lcp: FreqyPacked::new(vec![]),","        lcs: FreqyPacked::new(vec![]),","        matcher,","    };","","    // Test: The length should be 1 for a FreqyPacked matcher.","    assert_eq!(searcher.len(), 1);","}"],[170,172,175,181]],[["{","    use syntax::hir::literal::Literals;","    use std::vec;","","    let lits = Literals::empty();","    let searcher = LiteralSearcher::new(lits, Matcher::Empty);","    ","    assert_eq!(searcher.len(), 0);","}"],[170,172,173,181]],[["{","    use syntax::hir::literal::Literals;","    use std::vec;","","    let sparse_set = SingleByteSet {","        sparse: vec![false; 256],","        dense: vec![b'a', b'b', b'c'],","        complete: false,","        all_ascii: true,","    };","    ","    let matcher = Matcher::Bytes(sparse_set);","    let searcher = LiteralSearcher::new(Literals::empty(), matcher);","    ","    assert_eq!(searcher.len(), 3);","}"],[170,172,174,181]],[["{","    use syntax::hir::literal::Literals;","","    let freqy_packed = FreqyPacked {","        pat: b\"abc\".to_vec(),","        char_len: 3,","        rare1: b'a',","        rare1i: 0,","        rare2: b'b',","        rare2i: 1,","    };","    ","    let matcher = Matcher::FreqyPacked(freqy_packed);","    let searcher = LiteralSearcher::new(Literals::empty(), matcher);","    ","    assert_eq!(searcher.len(), 1);","}"],[170,172,175,181]]],"codes_branches":[],"codes_branches_covered":[[["{","    // Define a simple FreqyPacked instance.","    let freqy_packed = FreqyPacked {","        pat: b\"example\".to_vec(),","        char_len: 7,","        rare1: b'x',","        rare1i: 3,","        rare2: b'e',","        rare2i: 0,","    };","","    // Create a LiteralSearcher with Matcher::FreqyPacked variant.","    let searcher = LiteralSearcher {","        complete: true,","        lcp: FreqyPacked::new(b\"prefix\".to_vec()),","        lcs: FreqyPacked::new(b\"suffix\".to_vec()),","        matcher: Matcher::FreqyPacked(freqy_packed.clone()),","    };","","    // Assert that the length is as expected.","    assert_eq!(searcher.len(), 1);","}"],[]],[["{","    // Define a simple SingleByteSet instance.","    let single_byte_set = SingleByteSet {","        sparse: vec![false; 256],","        dense: b\"abc\".to_vec(),","        complete: false,","        all_ascii: true,","    };","","    // Create a LiteralSearcher with Matcher::Bytes variant.","    let searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(b\"prefix\".to_vec()),","        lcs: FreqyPacked::new(b\"suffix\".to_vec()),","        matcher: Matcher::Bytes(single_byte_set),","    };","","    // Assert that the length is as expected.","    assert_eq!(searcher.len(), 3);","}"],[]],[["{","    // Create a LiteralSearcher with Matcher::Empty variant.","    let searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(b\"prefix\".to_vec()),","        lcs: FreqyPacked::new(b\"suffix\".to_vec()),","        matcher: Matcher::Empty,","    };","","    // Assert that the length is as expected.","    assert_eq!(searcher.len(), 0);","}"],[]],[["{","    // Define a BoyerMooreSearch structure.","    let boyer_moore_search = BoyerMooreSearch::new(b\"example\".to_vec());","","    // Create a LiteralSearcher with Matcher::BoyerMoore variant.","    let searcher = LiteralSearcher {","        complete: true,","        lcp: FreqyPacked::new(b\"prefix\".to_vec()),","        lcs: FreqyPacked::new(b\"suffix\".to_vec()),","        matcher: Matcher::BoyerMoore(boyer_moore_search),","    };","","    // Assert that the length is as expected.","    assert_eq!(searcher.len(), 1);","}"],[]],[["{","    // Constructing necessary structs and using the provided initialization methods.","    ","    let single_byte_set = SingleByteSet {","        sparse: vec![false; 256],","        dense: vec![1, 2, 3], // Example dense set with some byte literals.","        complete: true,","        all_ascii: true,","    };","","    let matcher = Matcher::Bytes(single_byte_set);","","    // Creating an empty Literals object for the searcher since it's not relevant for Bytes matcher.","    let lits = Literals::empty(); ","","    let searcher = LiteralSearcher {","        complete: lits.all_complete(),","        lcp: FreqyPacked::new(vec![]), // Using empty pattern for LCP.","        lcs: FreqyPacked::new(vec![]), // Using empty pattern for LCS.","        matcher,","    };","","    // Test: The length should equal the number of elements in the dense bytes.","    assert_eq!(searcher.len(), 3);","}"],[]],[["{","    // Testing the case where matcher is Empty.","    ","    let matcher = Matcher::Empty;","","    // Creating an empty Literals object for the searcher since it's not relevant for Empty matcher.","    let lits = Literals::empty(); ","","    let searcher = LiteralSearcher {","        complete: lits.all_complete(),","        lcp: FreqyPacked::new(vec![]),","        lcs: FreqyPacked::new(vec![]),","        matcher,","    };","","    // Test: The length should be 0 for an Empty matcher.","    assert_eq!(searcher.len(), 0);","}"],[]],[["{","    // Testing the case where matcher is FreqyPacked.","","    let freqy_packed = FreqyPacked {","        pat: vec![1, 2, 3, 4], // A sample pattern for testing.","        char_len: 4,","        rare1: 1,","        rare1i: 0,","        rare2: 2,","        rare2i: 1,","    };","","    let matcher = Matcher::FreqyPacked(freqy_packed);","    ","    // Creating an empty Literals object for the searcher since it's not relevant for FreqyPacked matcher.","    let lits = Literals::empty();","","    let searcher = LiteralSearcher {","        complete: lits.all_complete(),","        lcp: FreqyPacked::new(vec![]),","        lcs: FreqyPacked::new(vec![]),","        matcher,","    };","","    // Test: The length should be 1 for a FreqyPacked matcher.","    assert_eq!(searcher.len(), 1);","}"],[]],[["{","    use syntax::hir::literal::Literals;","    use std::vec;","","    let lits = Literals::empty();","    let searcher = LiteralSearcher::new(lits, Matcher::Empty);","    ","    assert_eq!(searcher.len(), 0);","}"],[]],[["{","    use syntax::hir::literal::Literals;","    use std::vec;","","    let sparse_set = SingleByteSet {","        sparse: vec![false; 256],","        dense: vec![b'a', b'b', b'c'],","        complete: false,","        all_ascii: true,","    };","    ","    let matcher = Matcher::Bytes(sparse_set);","    let searcher = LiteralSearcher::new(Literals::empty(), matcher);","    ","    assert_eq!(searcher.len(), 3);","}"],[]],[["{","    use syntax::hir::literal::Literals;","","    let freqy_packed = FreqyPacked {","        pat: b\"abc\".to_vec(),","        char_len: 3,","        rare1: b'a',","        rare1i: 0,","        rare2: b'b',","        rare2i: 1,","    };","    ","    let matcher = Matcher::FreqyPacked(freqy_packed);","    let searcher = LiteralSearcher::new(Literals::empty(), matcher);","    ","    assert_eq!(searcher.len(), 1);","}"],[]]]}