{"function_name":"regex::dfa::write_varu32","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":10,"tests_lines":[5,5,5,5,5,5,5,5,5,6],"oracles":10,"oracles_compiled":10,"oracles_compiled_rate":100.0,"tests_compiled":10,"tests_compiled_rate":100.0,"oracles_run":10,"oracles_passed":7,"oracles_passed_rate":70.0,"tests_run":10,"tests_passed":7,"tests_passed_rate":70.0,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1821,1822,1823,1824,1825,1826,1827],"codes_lines_covered":[[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b01111111); // Testing with n == 0b01111111","    assert_eq!(data, vec![0b01111111]); // Expecting a single byte output","}"],[1821,1822,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b10000000); // Testing with n == 0b10000000","    assert_eq!(data, vec![0b10000000 | 0b10000000, 0]); // Expecting two bytes output","}"],[1821,1822,1823,1824,1825,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b11111111111111111111111111111111); // Testing with a large n","    assert_eq!(data, vec![0b11111111 | 0b10000000, 0b11111111 | 0b10000000, 0b11111111 | 0b10000000, 0b11111111, 0]); ","}"],[1821,1822,1823,1824,1825,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0); // Testing with n == 0","    assert_eq!(data, vec![0]); // Expecting a single byte output","}"],[1821,1822,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0);","    assert_eq!(data, vec![0]);","}"],[1821,1822,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 1);","    assert_eq!(data, vec![1]);","}"],[1821,1822,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 2);","    assert_eq!(data, vec![2]);","}"],[1821,1822,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 7);","    assert_eq!(data, vec![7]);","}"],[1821,1822,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 8);","    assert_eq!(data, vec![8]);","}"],[1821,1822,1826,1827]],[["{","    let mut data = Vec::new();","    let n: u32 = std::u32::MAX;","    write_varu32(&mut data, n);","    assert_eq!(data, vec![0b1000_0000 | 0b1111_1111, 0b1000_0000 | 0b1111_1111, 0b1000_0000 | 0b1111_1111, 0b1111_1111]);","}"],[1821,1822,1823,1824,1825,1826,1827]]],"codes_branches":[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b01111111); // Testing with n == 0b01111111","    assert_eq!(data, vec![0b01111111]); // Expecting a single byte output","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":false,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b10000000); // Testing with n == 0b10000000","    assert_eq!(data, vec![0b10000000 | 0b10000000, 0]); // Expecting two bytes output","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":true,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b11111111111111111111111111111111); // Testing with a large n","    assert_eq!(data, vec![0b11111111 | 0b10000000, 0b11111111 | 0b10000000, 0b11111111 | 0b10000000, 0b11111111, 0]); ","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":true,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0); // Testing with n == 0","    assert_eq!(data, vec![0]); // Expecting a single byte output","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":false,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0);","    assert_eq!(data, vec![0]);","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":false,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 1);","    assert_eq!(data, vec![1]);","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":false,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 2);","    assert_eq!(data, vec![2]);","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":false,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 7);","    assert_eq!(data, vec![7]);","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":false,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 8);","    assert_eq!(data, vec![8]);","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":false,"negative":true}]],[["{","    let mut data = Vec::new();","    let n: u32 = std::u32::MAX;","    write_varu32(&mut data, n);","    assert_eq!(data, vec![0b1000_0000 | 0b1111_1111, 0b1000_0000 | 0b1111_1111, 0b1000_0000 | 0b1111_1111, 0b1111_1111]);","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":true,"negative":true}]]]}