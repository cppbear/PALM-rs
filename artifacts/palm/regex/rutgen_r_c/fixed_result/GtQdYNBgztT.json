{"function_name":"regex_syntax::hir::<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":10,"tests_lines":[6,8,8,8,6,7,7,8,7,7],"oracles":10,"oracles_compiled":10,"oracles_compiled_rate":100.0,"tests_compiled":10,"tests_compiled_rate":100.0,"oracles_run":10,"oracles_passed":1,"oracles_passed_rate":10.0,"tests_run":10,"tests_passed":1,"tests_passed_rate":10.0,"lines":12,"lines_covered":12,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051],"codes_lines_covered":[[["{","    let mut ranges = Vec::new();","    let class_bytes_range = ClassBytesRange::new(b'0', b'9'); // No intersection with a-z or A-Z","    class_bytes_range.case_fold_simple(&mut ranges);","    assert!(ranges.is_empty());","}"],[1040,1041,1045,1046,1050,1051]],[["{","    let mut ranges = Vec::new();","    let class_bytes_range = ClassBytesRange::new(b'a', b'b'); // Intersects with a-z, but not A-Z","    class_bytes_range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0].start(), b'A' - 32);","    assert_eq!(ranges[0].end(), b'B' - 32);","}"],[1040,1041,1042,1043,1044,1045,1046,1050,1051]],[["{","    let mut ranges = Vec::new();","    let class_bytes_range = ClassBytesRange::new(b'X', b'Y'); // Intersects with A-Z, but not a-z","    class_bytes_range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0].start(), b'x' + 32);","    assert_eq!(ranges[0].end(), b'y' + 32);","}"],[1040,1041,1045,1046,1047,1048,1049,1050,1051]],[["{","    let mut ranges = Vec::new();","    let class_bytes_range = ClassBytesRange::new(b'a', b'z'); // Fully intersects with a-z","    class_bytes_range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0].start(), b'A' - 32);","    assert_eq!(ranges[0].end(), b'Z' - 32);","}"],[1040,1041,1042,1043,1044,1045,1046,1050,1051]],[["{","    let mut ranges = Vec::new();","    let class_bytes_range = ClassBytesRange::new(b'a', b'a'); // No range","    class_bytes_range.case_fold_simple(&mut ranges);","    assert!(ranges.is_empty());","}"],[1040,1041,1042,1043,1044,1045,1046,1050,1051]],[["{","    let mut ranges = Vec::new();","    let range = ClassBytesRange::new(b'a', b'z');","    range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0], ClassBytesRange::new(0, 25));","}"],[1040,1041,1042,1043,1044,1045,1046,1050,1051]],[["{","    let mut ranges = Vec::new();","    let range = ClassBytesRange::new(b'A', b'Z');","    range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0], ClassBytesRange::new(32, 57));","}"],[1040,1041,1045,1046,1047,1048,1049,1050,1051]],[["{","    let mut ranges = Vec::new();","    let range = ClassBytesRange::new(b'a', b'F');","    range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 2);","    assert_eq!(ranges[0], ClassBytesRange::new(0, 25)); // a-z mapped to A-Z","    assert_eq!(ranges[1], ClassBytesRange::new(32, 57)); // A-F mapped to a-f","}"],[1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051]],[["{","    let mut ranges = Vec::new();","    let range = ClassBytesRange::new(b'a', b'x');","    range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0], ClassBytesRange::new(0, 23)); // a-x maps to A-X","}"],[1040,1041,1042,1043,1044,1045,1046,1050,1051]],[["{","    let mut ranges = Vec::new();","    let range = ClassBytesRange::new(b'B', b'Z');","    range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0], ClassBytesRange::new(34, 57)); // B-Z maps to b-z","}"],[1040,1041,1045,1046,1047,1048,1049,1050,1051]]],"codes_branches":[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":true,"negative":true},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut ranges = Vec::new();","    let class_bytes_range = ClassBytesRange::new(b'0', b'9'); // No intersection with a-z or A-Z","    class_bytes_range.case_fold_simple(&mut ranges);","    assert!(ranges.is_empty());","}"],[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":false,"negative":true},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":false,"negative":true}]],[["{","    let mut ranges = Vec::new();","    let class_bytes_range = ClassBytesRange::new(b'a', b'b'); // Intersects with a-z, but not A-Z","    class_bytes_range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0].start(), b'A' - 32);","    assert_eq!(ranges[0].end(), b'B' - 32);","}"],[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":true,"negative":false},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":false,"negative":true}]],[["{","    let mut ranges = Vec::new();","    let class_bytes_range = ClassBytesRange::new(b'X', b'Y'); // Intersects with A-Z, but not a-z","    class_bytes_range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0].start(), b'x' + 32);","    assert_eq!(ranges[0].end(), b'y' + 32);","}"],[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":false,"negative":true},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":true,"negative":false}]],[["{","    let mut ranges = Vec::new();","    let class_bytes_range = ClassBytesRange::new(b'a', b'z'); // Fully intersects with a-z","    class_bytes_range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0].start(), b'A' - 32);","    assert_eq!(ranges[0].end(), b'Z' - 32);","}"],[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":true,"negative":false},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":false,"negative":true}]],[["{","    let mut ranges = Vec::new();","    let class_bytes_range = ClassBytesRange::new(b'a', b'a'); // No range","    class_bytes_range.case_fold_simple(&mut ranges);","    assert!(ranges.is_empty());","}"],[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":true,"negative":false},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":false,"negative":true}]],[["{","    let mut ranges = Vec::new();","    let range = ClassBytesRange::new(b'a', b'z');","    range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0], ClassBytesRange::new(0, 25));","}"],[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":true,"negative":false},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":false,"negative":true}]],[["{","    let mut ranges = Vec::new();","    let range = ClassBytesRange::new(b'A', b'Z');","    range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0], ClassBytesRange::new(32, 57));","}"],[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":false,"negative":true},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":true,"negative":false}]],[["{","    let mut ranges = Vec::new();","    let range = ClassBytesRange::new(b'a', b'F');","    range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 2);","    assert_eq!(ranges[0], ClassBytesRange::new(0, 25)); // a-z mapped to A-Z","    assert_eq!(ranges[1], ClassBytesRange::new(32, 57)); // A-F mapped to a-f","}"],[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":true,"negative":false},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":true,"negative":false}]],[["{","    let mut ranges = Vec::new();","    let range = ClassBytesRange::new(b'a', b'x');","    range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0], ClassBytesRange::new(0, 23)); // a-x maps to A-X","}"],[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":true,"negative":false},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":false,"negative":true}]],[["{","    let mut ranges = Vec::new();","    let range = ClassBytesRange::new(b'B', b'Z');","    range.case_fold_simple(&mut ranges);","    assert_eq!(ranges.len(), 1);","    assert_eq!(ranges[0], ClassBytesRange::new(34, 57)); // B-Z maps to b-z","}"],[{"start_line":1041,"start_column":12,"end_line":1041,"end_column":73,"positive":false,"negative":true},{"start_line":1046,"start_column":12,"end_line":1046,"end_column":73,"positive":true,"negative":false}]]]}