{"function_name":"regex::pikevm::pikevm::Threads::resize","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/pikevm.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":8,"tests_lines":[13,16,14,16,7,8,17,7],"oracles":8,"oracles_compiled":8,"oracles_compiled_rate":100.0,"tests_compiled":8,"tests_compiled_rate":100.0,"oracles_run":8,"oracles_passed":7,"oracles_passed_rate":87.5,"tests_run":8,"tests_passed":7,"tests_passed_rate":87.5,"lines":8,"lines_covered":8,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[364,365,366,367,368,369,370,371],"codes_lines_covered":[[["{","    let mut threads = Threads::new();","    let initial_capacity = threads.set.capacity();","    ","    // Test with num_insts equal to current capacity","    threads.resize(initial_capacity, 5);","    ","    // Verify slots_per_thread remains unchanged","    assert_eq!(threads.slots_per_thread, 0);","    // Verify SparseSet remains unchanged","    assert_eq!(threads.set.len(), 0);","    assert_eq!(threads.set.capacity(), initial_capacity);","}"],[364,365,366,371]],[["{","    let mut threads = Threads::new();","    threads.set = SparseSet::new(10); // Initial capacity of 10","    let new_capacity = 20;","    ","    // Resize with num_insts greater than current capacity","    threads.resize(new_capacity, 5);","    ","    // Verify slots_per_thread is updated","    assert_eq!(threads.slots_per_thread, 10);","    // Verify SparseSet is updated and now has a length of 0","    assert_eq!(threads.set.len(), 0);","    assert_eq!(threads.set.capacity(), new_capacity);","    // Verify caps is initialized properly","    assert_eq!(threads.caps.len(), 50); // 10 * 5 * 2 = 50","}"],[364,365,367,368,369,370,371]],[["{","    let mut threads = Threads::new();","    threads.set = SparseSet::new(5); // Initial capacity of 5","    let initial_capacity = threads.set.capacity();","    ","    // Test with num_insts equal to current capacity","    threads.resize(initial_capacity, 2);","    ","    // Verify slots_per_thread should remain unchanged","    assert_eq!(threads.slots_per_thread, 0);","    // Verify SparseSet remains unchanged","    assert_eq!(threads.set.len(), 0);","    assert_eq!(threads.set.capacity(), initial_capacity);","}"],[364,365,366,371]],[["{","    let mut threads = Threads::new();","    threads.set = SparseSet::new(7); // Initial capacity of 7","    let new_capacity = 15;","    ","    // Resize with num_insts greater than current capacity","    threads.resize(new_capacity, 4);","    ","    // Verify slots_per_thread is updated","    assert_eq!(threads.slots_per_thread, 8);","    // Verify SparseSet is now initialized properly","    assert_eq!(threads.set.len(), 0);","    assert_eq!(threads.set.capacity(), new_capacity);","    // Verify caps is initialized properly","    assert_eq!(threads.caps.len(), 120); // 15 * 4 * 2 = 120","}"],[364,365,367,368,369,370,371]],[["{","    let mut threads = Threads::new();","    threads.resize(5, 2);","    assert_eq!(threads.set.capacity(), 5);","    assert_eq!(threads.slots_per_thread, 4);","    assert_eq!(threads.caps.len(), 20);","}"],[364,365,367,368,369,370,371]],[["{","    let mut threads = Threads::new();","    threads.resize(5, 2); // First resize to set up capacity","    threads.resize(5, 3); // This should not alter the existing capacity","    assert_eq!(threads.set.capacity(), 5);","    assert_eq!(threads.slots_per_thread, 4);","    assert_eq!(threads.caps.len(), 20);","}"],[364,365,366,367,368,369,370,371]],[["{","    let mut threads = Threads::new();","    threads.resize(3, 1);","    assert_eq!(threads.set.capacity(), 3);","    assert_eq!(threads.slots_per_thread, 2);","    assert_eq!(threads.caps.len(), 6);","    ","    threads.resize(6, 2);","    assert_eq!(threads.set.capacity(), 6);","    assert_eq!(threads.slots_per_thread, 4);","    assert_eq!(threads.caps.len(), 24);","","    threads.resize(4, 3);","    assert_eq!(threads.set.capacity(), 4);","    assert_eq!(threads.slots_per_thread, 6);","    assert_eq!(threads.caps.len(), 24); // The slots should keep the maximum","}"],[364,365,367,368,369,370,371]],[["{","    let mut threads = Threads::new();","    threads.resize(5, 0);","    assert_eq!(threads.set.capacity(), 5);","    assert_eq!(threads.slots_per_thread, 0);","    assert_eq!(threads.caps.len(), 0);","}"],[364,365,367,368,369,370,371]]],"codes_branches":[{"start_line":365,"start_column":12,"end_line":365,"end_column":44,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut threads = Threads::new();","    let initial_capacity = threads.set.capacity();","    ","    // Test with num_insts equal to current capacity","    threads.resize(initial_capacity, 5);","    ","    // Verify slots_per_thread remains unchanged","    assert_eq!(threads.slots_per_thread, 0);","    // Verify SparseSet remains unchanged","    assert_eq!(threads.set.len(), 0);","    assert_eq!(threads.set.capacity(), initial_capacity);","}"],[{"start_line":365,"start_column":12,"end_line":365,"end_column":44,"positive":true,"negative":false}]],[["{","    let mut threads = Threads::new();","    threads.set = SparseSet::new(10); // Initial capacity of 10","    let new_capacity = 20;","    ","    // Resize with num_insts greater than current capacity","    threads.resize(new_capacity, 5);","    ","    // Verify slots_per_thread is updated","    assert_eq!(threads.slots_per_thread, 10);","    // Verify SparseSet is updated and now has a length of 0","    assert_eq!(threads.set.len(), 0);","    assert_eq!(threads.set.capacity(), new_capacity);","    // Verify caps is initialized properly","    assert_eq!(threads.caps.len(), 50); // 10 * 5 * 2 = 50","}"],[{"start_line":365,"start_column":12,"end_line":365,"end_column":44,"positive":false,"negative":true}]],[["{","    let mut threads = Threads::new();","    threads.set = SparseSet::new(5); // Initial capacity of 5","    let initial_capacity = threads.set.capacity();","    ","    // Test with num_insts equal to current capacity","    threads.resize(initial_capacity, 2);","    ","    // Verify slots_per_thread should remain unchanged","    assert_eq!(threads.slots_per_thread, 0);","    // Verify SparseSet remains unchanged","    assert_eq!(threads.set.len(), 0);","    assert_eq!(threads.set.capacity(), initial_capacity);","}"],[{"start_line":365,"start_column":12,"end_line":365,"end_column":44,"positive":true,"negative":false}]],[["{","    let mut threads = Threads::new();","    threads.set = SparseSet::new(7); // Initial capacity of 7","    let new_capacity = 15;","    ","    // Resize with num_insts greater than current capacity","    threads.resize(new_capacity, 4);","    ","    // Verify slots_per_thread is updated","    assert_eq!(threads.slots_per_thread, 8);","    // Verify SparseSet is now initialized properly","    assert_eq!(threads.set.len(), 0);","    assert_eq!(threads.set.capacity(), new_capacity);","    // Verify caps is initialized properly","    assert_eq!(threads.caps.len(), 120); // 15 * 4 * 2 = 120","}"],[{"start_line":365,"start_column":12,"end_line":365,"end_column":44,"positive":false,"negative":true}]],[["{","    let mut threads = Threads::new();","    threads.resize(5, 2);","    assert_eq!(threads.set.capacity(), 5);","    assert_eq!(threads.slots_per_thread, 4);","    assert_eq!(threads.caps.len(), 20);","}"],[{"start_line":365,"start_column":12,"end_line":365,"end_column":44,"positive":false,"negative":true}]],[["{","    let mut threads = Threads::new();","    threads.resize(5, 2); // First resize to set up capacity","    threads.resize(5, 3); // This should not alter the existing capacity","    assert_eq!(threads.set.capacity(), 5);","    assert_eq!(threads.slots_per_thread, 4);","    assert_eq!(threads.caps.len(), 20);","}"],[{"start_line":365,"start_column":12,"end_line":365,"end_column":44,"positive":true,"negative":true}]],[["{","    let mut threads = Threads::new();","    threads.resize(3, 1);","    assert_eq!(threads.set.capacity(), 3);","    assert_eq!(threads.slots_per_thread, 2);","    assert_eq!(threads.caps.len(), 6);","    ","    threads.resize(6, 2);","    assert_eq!(threads.set.capacity(), 6);","    assert_eq!(threads.slots_per_thread, 4);","    assert_eq!(threads.caps.len(), 24);","","    threads.resize(4, 3);","    assert_eq!(threads.set.capacity(), 4);","    assert_eq!(threads.slots_per_thread, 6);","    assert_eq!(threads.caps.len(), 24); // The slots should keep the maximum","}"],[{"start_line":365,"start_column":12,"end_line":365,"end_column":44,"positive":false,"negative":true}]],[["{","    let mut threads = Threads::new();","    threads.resize(5, 0);","    assert_eq!(threads.set.capacity(), 5);","    assert_eq!(threads.slots_per_thread, 0);","    assert_eq!(threads.caps.len(), 0);","}"],[{"start_line":365,"start_column":12,"end_line":365,"end_column":44,"positive":false,"negative":true}]]]}