{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_hex_digits","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":16,"tests_lines":[43,71,19,19,18,19,19,18,17,17,17,17,11,12,76,71],"oracles":16,"oracles_compiled":2,"oracles_compiled_rate":12.5,"tests_compiled":2,"tests_compiled_rate":12.5,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":36,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":6,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1637],"codes_lines_covered":[[["{","    struct TestParser {","        scratch: RefCell<String>,","        pos: Cell<Position>,","    }","","    impl TestParser {","        fn new() -> Self {","            TestParser {","                scratch: RefCell::new(String::new()),","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Simulating passing through whitespace","            self.pos.set(Position { offset: self.pos.get().offset + 1, line: 1, column: 2 });","            true","        }","","        fn char(&self) -> char {","            // Simulating an empty input scenario","            '\\0' ","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: String::from(\"test\"), span }","        }","","        fn span(&self) -> Span {","            Span::new(self.pos.get(), self.pos.get())","        }","","        fn pos(&self) -> Position {","            self.pos.get()","        }","        ","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            // The original function as provided","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","            let start = self.pos();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            self.bump_and_bump_space();","            let end = self.pos();","            let hex = scratch.as_str();","            match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {","                None => {","                    Err(self.error(Span::new(start, end), ast::ErrorKind::EscapeHexInvalid))","                }","                Some(c) => {","                    Ok(ast::Literal {","                        span: Span::new(start, end),","                        kind: ast::LiteralKind::HexFixed(kind),","                        c: c,","                    })","                }","            }","        }","    }","","    let parser = TestParser::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::X);","    assert!(result.is_err());","    if let Err(err) = result {","        assert_eq!(err.kind, ast::ErrorKind::EscapeHexInvalid);","    }","}"],[]],[["{","    struct TestParser {","        scratch: RefCell<String>,","        pos: Cell<Position>,","    }","","    impl TestParser {","        fn new() -> Self {","            TestParser {","                scratch: RefCell::new(String::from(\"g\")), // Invalid hex character","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Simulating passing through whitespace","            self.pos.set(Position { offset: self.pos.get().offset + 1, line: 1, column: 2 });","            true","        }","","        fn char(&self) -> char {","            self.scratch.borrow().chars().next().unwrap() ","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: String::from(\"test\"), span }","        }","","        fn span(&self) -> Span {","            Span::new(self.pos.get(), self.pos.get())","        }","","        fn pos(&self) -> Position {","            self.pos.get()","        }","        ","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            // The original function as provided","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","            let start = self.pos();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            self.bump_and_bump_space();","            let end = self.pos();","            let hex = scratch.as_str();","            match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {","                None => {","                    Err(self.error(Span::new(start, end), ast::ErrorKind::EscapeHexInvalid))","                }","                Some(c) => {","                    Ok(ast::Literal {","                        span: Span::new(start, end),","                        kind: ast::LiteralKind::HexFixed(kind),","                        c: c,","                    })","                }","            }","        }","    }","","    let parser = TestParser::new();","    parser.parse_hex_digits(ast::HexLiteralKind::X);","}"],[]]],"codes_branches":[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestParser {","        scratch: RefCell<String>,","        pos: Cell<Position>,","    }","","    impl TestParser {","        fn new() -> Self {","            TestParser {","                scratch: RefCell::new(String::new()),","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Simulating passing through whitespace","            self.pos.set(Position { offset: self.pos.get().offset + 1, line: 1, column: 2 });","            true","        }","","        fn char(&self) -> char {","            // Simulating an empty input scenario","            '\\0' ","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: String::from(\"test\"), span }","        }","","        fn span(&self) -> Span {","            Span::new(self.pos.get(), self.pos.get())","        }","","        fn pos(&self) -> Position {","            self.pos.get()","        }","        ","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            // The original function as provided","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","            let start = self.pos();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            self.bump_and_bump_space();","            let end = self.pos();","            let hex = scratch.as_str();","            match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {","                None => {","                    Err(self.error(Span::new(start, end), ast::ErrorKind::EscapeHexInvalid))","                }","                Some(c) => {","                    Ok(ast::Literal {","                        span: Span::new(start, end),","                        kind: ast::LiteralKind::HexFixed(kind),","                        c: c,","                    })","                }","            }","        }","    }","","    let parser = TestParser::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::X);","    assert!(result.is_err());","    if let Err(err) = result {","        assert_eq!(err.kind, ast::ErrorKind::EscapeHexInvalid);","    }","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct TestParser {","        scratch: RefCell<String>,","        pos: Cell<Position>,","    }","","    impl TestParser {","        fn new() -> Self {","            TestParser {","                scratch: RefCell::new(String::from(\"g\")), // Invalid hex character","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Simulating passing through whitespace","            self.pos.set(Position { offset: self.pos.get().offset + 1, line: 1, column: 2 });","            true","        }","","        fn char(&self) -> char {","            self.scratch.borrow().chars().next().unwrap() ","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: String::from(\"test\"), span }","        }","","        fn span(&self) -> Span {","            Span::new(self.pos.get(), self.pos.get())","        }","","        fn pos(&self) -> Position {","            self.pos.get()","        }","        ","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            // The original function as provided","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","            let start = self.pos();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            self.bump_and_bump_space();","            let end = self.pos();","            let hex = scratch.as_str();","            match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {","                None => {","                    Err(self.error(Span::new(start, end), ast::ErrorKind::EscapeHexInvalid))","                }","                Some(c) => {","                    Ok(ast::Literal {","                        span: Span::new(start, end),","                        kind: ast::LiteralKind::HexFixed(kind),","                        c: c,","                    })","                }","            }","        }","    }","","    let parser = TestParser::new();","    parser.parse_hex_digits(ast::HexLiteralKind::X);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]]]}