{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_set_class_open","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":22,"tests_lines":[49,48,50,109,110,62,62,48,48,48,60,43,51,51,48,45,48,42,47,50,49,44],"oracles":22,"oracles_compiled":2,"oracles_compiled_rate":9.090909090909092,"tests_compiled":2,"tests_compiled_rate":9.090909090909092,"oracles_run":2,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":2,"tests_passed":0,"tests_passed_rate":0.0,"lines":60,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":16,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1886,1887,1888,1890,1891,1892,1893,1894,1895,1896,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940],"codes_lines_covered":[[["{","    struct TestParser {","        input: String,","        pos: Position,","    }","","    impl TestParser {","        fn new(input: &str) -> Self {","            TestParser {","                input: input.to_string(),","                pos: Position { offset: 0, line: 1, column: 1 },","            }","        }","","        fn char(&self) -> char {","            self.input.chars().nth(self.pos.offset).unwrap_or('\\0')","        }","","        fn bump_and_bump_space(&mut self) -> bool {","            if self.pos.offset < self.input.len() {","                self.pos.offset += 1;","                self.pos.column += 1;","                return true;","            }","            false","        }","","        fn span(&self) -> Span {","            Span::new(self.pos, self.pos)","        }","","        fn span_char(&self) -> Span {","            Span::new(self.pos, self.pos)","        }","        ","        fn parse_set_class_open(&mut self) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {","            assert_eq!(self.char(), '[');","            let start = self.pos;","            if !self.bump_and_bump_space() {","                return Err(ast::Error {","                    kind: ast::ErrorKind::ClassUnclosed,","                    pattern: self.input.clone(),","                    span: Span::new(start, self.pos),","                });","            }","","            let negated = if self.char() != '^' {","                false","            } else {","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","                true","            };","","            let mut union = ast::ClassSetUnion {","                span: self.span(),","                items: vec![],","            };","            while self.char() == '-' {","                union.push(ast::ClassSetItem::Literal(ast::Literal {","                    span: self.span_char(),","                    kind: ast::LiteralKind::Verbatim,","                    c: '-',","                }));","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","            }","            if union.items.is_empty() && self.char() == ']' {","                union.push(ast::ClassSetItem::Literal(ast::Literal {","                    span: self.span_char(),","                    kind: ast::LiteralKind::Verbatim,","                    c: ']',","                }));","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","            }","            let set = ast::ClassBracketed {","                span: Span::new(start, self.pos),","                negated,","                kind: ast::ClassSet::union(ast::ClassSetUnion {","                    span: Span::new(union.span.start, union.span.start),","                    items: vec![],","                }),","            };","            Ok((set, union))","        }","    }","","    let mut parser = TestParser::new(\"[^abc-]\");","    let result = parser.parse_set_class_open();","    assert!(result.is_ok());","    let (set, union) = result.unwrap();","    assert!(union.items.is_empty() == false);","}"],[]],[["{","    struct TestParserWithError {","        input: String,","        pos: Position,","    }","","    impl TestParserWithError {","        fn new(input: &str) -> Self {","            TestParserWithError {","                input: input.to_string(),","                pos: Position { offset: 0, line: 1, column: 1 },","            }","        }","","        fn char(&self) -> char {","            self.input.chars().nth(self.pos.offset).unwrap_or('\\0')","        }","","        fn bump_and_bump_space(&mut self) -> bool {","            if self.pos.offset < self.input.len() {","                self.pos.offset += 1;","                self.pos.column += 1;","                return true;","            }","            false","        }","","        fn span(&self) -> Span {","            Span::new(self.pos, self.pos)","        }","","        fn span_char(&self) -> Span {","            Span::new(self.pos, self.pos)","        }","        ","        fn parse_set_class_open(&mut self) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {","            assert_eq!(self.char(), '[');","            let start = self.pos;","            if !self.bump_and_bump_space() {","                return Err(ast::Error {","                    kind: ast::ErrorKind::ClassUnclosed,","                    pattern: self.input.clone(),","                    span: Span::new(start, self.pos),","                });","            }","","            let negated = if self.char() != '^' {","                false","            } else {","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","                true","            };","","            let mut union = ast::ClassSetUnion {","                span: self.span(),","                items: vec![],","            };","            while self.char() == '-' {","                union.push(ast::ClassSetItem::Literal(ast::Literal {","                    span: self.span_char(),","                    kind: ast::LiteralKind::Verbatim,","                    c: '-',","                }));","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","            }","            if union.items.is_empty() && self.char() == ']' {","                union.push(ast::ClassSetItem::Literal(ast::Literal {","                    span: self.span_char(),","                    kind: ast::LiteralKind::Verbatim,","                    c: ']',","                }));","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","            }","            let set = ast::ClassBracketed {","                span: Span::new(start, self.pos),","                negated,","                kind: ast::ClassSet::union(ast::ClassSetUnion {","                    span: Span::new(union.span.start, union.span.start),","                    items: vec![],","                }),","            };","            Ok((set, union))","        }","    }","","    let mut parser = TestParserWithError::new(\"[\");","    let result = parser.parse_set_class_open();","    assert!(result.is_err());","    if let Err(err) = result {","        assert_eq!(err.kind, ast::ErrorKind::ClassUnclosed);","    }","}"],[]]],"codes_branches":[{"start_line":1879,"start_column":12,"end_line":1879,"end_column":39,"positive":false,"negative":false},{"start_line":1887,"start_column":16,"end_line":1887,"end_column":34,"positive":false,"negative":false},{"start_line":1890,"start_column":20,"end_line":1890,"end_column":47,"positive":false,"negative":false},{"start_line":1903,"start_column":15,"end_line":1903,"end_column":33,"positive":false,"negative":false},{"start_line":1909,"start_column":16,"end_line":1909,"end_column":43,"positive":false,"negative":false},{"start_line":1918,"start_column":12,"end_line":1918,"end_column":34,"positive":false,"negative":false},{"start_line":1918,"start_column":38,"end_line":1918,"end_column":56,"positive":false,"negative":false},{"start_line":1924,"start_column":16,"end_line":1924,"end_column":43,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestParser {","        input: String,","        pos: Position,","    }","","    impl TestParser {","        fn new(input: &str) -> Self {","            TestParser {","                input: input.to_string(),","                pos: Position { offset: 0, line: 1, column: 1 },","            }","        }","","        fn char(&self) -> char {","            self.input.chars().nth(self.pos.offset).unwrap_or('\\0')","        }","","        fn bump_and_bump_space(&mut self) -> bool {","            if self.pos.offset < self.input.len() {","                self.pos.offset += 1;","                self.pos.column += 1;","                return true;","            }","            false","        }","","        fn span(&self) -> Span {","            Span::new(self.pos, self.pos)","        }","","        fn span_char(&self) -> Span {","            Span::new(self.pos, self.pos)","        }","        ","        fn parse_set_class_open(&mut self) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {","            assert_eq!(self.char(), '[');","            let start = self.pos;","            if !self.bump_and_bump_space() {","                return Err(ast::Error {","                    kind: ast::ErrorKind::ClassUnclosed,","                    pattern: self.input.clone(),","                    span: Span::new(start, self.pos),","                });","            }","","            let negated = if self.char() != '^' {","                false","            } else {","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","                true","            };","","            let mut union = ast::ClassSetUnion {","                span: self.span(),","                items: vec![],","            };","            while self.char() == '-' {","                union.push(ast::ClassSetItem::Literal(ast::Literal {","                    span: self.span_char(),","                    kind: ast::LiteralKind::Verbatim,","                    c: '-',","                }));","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","            }","            if union.items.is_empty() && self.char() == ']' {","                union.push(ast::ClassSetItem::Literal(ast::Literal {","                    span: self.span_char(),","                    kind: ast::LiteralKind::Verbatim,","                    c: ']',","                }));","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","            }","            let set = ast::ClassBracketed {","                span: Span::new(start, self.pos),","                negated,","                kind: ast::ClassSet::union(ast::ClassSetUnion {","                    span: Span::new(union.span.start, union.span.start),","                    items: vec![],","                }),","            };","            Ok((set, union))","        }","    }","","    let mut parser = TestParser::new(\"[^abc-]\");","    let result = parser.parse_set_class_open();","    assert!(result.is_ok());","    let (set, union) = result.unwrap();","    assert!(union.items.is_empty() == false);","}"],[{"start_line":1879,"start_column":12,"end_line":1879,"end_column":39,"positive":false,"negative":false},{"start_line":1887,"start_column":16,"end_line":1887,"end_column":34,"positive":false,"negative":false},{"start_line":1890,"start_column":20,"end_line":1890,"end_column":47,"positive":false,"negative":false},{"start_line":1903,"start_column":15,"end_line":1903,"end_column":33,"positive":false,"negative":false},{"start_line":1909,"start_column":16,"end_line":1909,"end_column":43,"positive":false,"negative":false},{"start_line":1918,"start_column":12,"end_line":1918,"end_column":34,"positive":false,"negative":false},{"start_line":1918,"start_column":38,"end_line":1918,"end_column":56,"positive":false,"negative":false},{"start_line":1924,"start_column":16,"end_line":1924,"end_column":43,"positive":false,"negative":false}]],[["{","    struct TestParserWithError {","        input: String,","        pos: Position,","    }","","    impl TestParserWithError {","        fn new(input: &str) -> Self {","            TestParserWithError {","                input: input.to_string(),","                pos: Position { offset: 0, line: 1, column: 1 },","            }","        }","","        fn char(&self) -> char {","            self.input.chars().nth(self.pos.offset).unwrap_or('\\0')","        }","","        fn bump_and_bump_space(&mut self) -> bool {","            if self.pos.offset < self.input.len() {","                self.pos.offset += 1;","                self.pos.column += 1;","                return true;","            }","            false","        }","","        fn span(&self) -> Span {","            Span::new(self.pos, self.pos)","        }","","        fn span_char(&self) -> Span {","            Span::new(self.pos, self.pos)","        }","        ","        fn parse_set_class_open(&mut self) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {","            assert_eq!(self.char(), '[');","            let start = self.pos;","            if !self.bump_and_bump_space() {","                return Err(ast::Error {","                    kind: ast::ErrorKind::ClassUnclosed,","                    pattern: self.input.clone(),","                    span: Span::new(start, self.pos),","                });","            }","","            let negated = if self.char() != '^' {","                false","            } else {","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","                true","            };","","            let mut union = ast::ClassSetUnion {","                span: self.span(),","                items: vec![],","            };","            while self.char() == '-' {","                union.push(ast::ClassSetItem::Literal(ast::Literal {","                    span: self.span_char(),","                    kind: ast::LiteralKind::Verbatim,","                    c: '-',","                }));","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","            }","            if union.items.is_empty() && self.char() == ']' {","                union.push(ast::ClassSetItem::Literal(ast::Literal {","                    span: self.span_char(),","                    kind: ast::LiteralKind::Verbatim,","                    c: ']',","                }));","                if !self.bump_and_bump_space() {","                    return Err(ast::Error {","                        kind: ast::ErrorKind::ClassUnclosed,","                        pattern: self.input.clone(),","                        span: Span::new(start, self.pos),","                    });","                }","            }","            let set = ast::ClassBracketed {","                span: Span::new(start, self.pos),","                negated,","                kind: ast::ClassSet::union(ast::ClassSetUnion {","                    span: Span::new(union.span.start, union.span.start),","                    items: vec![],","                }),","            };","            Ok((set, union))","        }","    }","","    let mut parser = TestParserWithError::new(\"[\");","    let result = parser.parse_set_class_open();","    assert!(result.is_err());","    if let Err(err) = result {","        assert_eq!(err.kind, ast::ErrorKind::ClassUnclosed);","    }","}"],[{"start_line":1879,"start_column":12,"end_line":1879,"end_column":39,"positive":false,"negative":false},{"start_line":1887,"start_column":16,"end_line":1887,"end_column":34,"positive":false,"negative":false},{"start_line":1890,"start_column":20,"end_line":1890,"end_column":47,"positive":false,"negative":false},{"start_line":1903,"start_column":15,"end_line":1903,"end_column":33,"positive":false,"negative":false},{"start_line":1909,"start_column":16,"end_line":1909,"end_column":43,"positive":false,"negative":false},{"start_line":1918,"start_column":12,"end_line":1918,"end_column":34,"positive":false,"negative":false},{"start_line":1918,"start_column":38,"end_line":1918,"end_column":56,"positive":false,"negative":false},{"start_line":1924,"start_column":16,"end_line":1924,"end_column":43,"positive":false,"negative":false}]]]}