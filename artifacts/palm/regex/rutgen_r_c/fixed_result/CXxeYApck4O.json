{"function_name":"regex_syntax::hir::literal::prefixes","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":112,"tests_lines":[23,15,26,6,6,8,8,6,9,9,11,11,10,8,10,10,12,11,8,8,9,9,9,6,9,8,8,8,8,9,7,7,9,9,11,8,9,9,9,10,10,8,11,11,13,13,8,10,8,12,7,8,8,8,8,9,10,10,13,17,20,19,19,17,29,29,29,21,39,60,58,61,29,26,20,20,20,12,12,14,14,13,19,19,16,14,35,35,6,8,8,7,7,7,6,8,13,11,11,13,13,9,14,11,8,8,9,9,8,11,8,9],"oracles":112,"oracles_compiled":19,"oracles_compiled_rate":16.964285714285715,"tests_compiled":19,"tests_compiled_rate":16.964285714285715,"oracles_run":19,"oracles_passed":16,"oracles_passed_rate":84.21052631578947,"tests_run":19,"tests_passed":16,"tests_passed_rate":84.21052631578947,"lines":64,"lines_covered":29,"lines_coveraged_rate":45.3125,"branches":16,"branches_covered":5,"branches_coverage_rate":31.25,"codes_lines":[602,603,604,605,606,607,608,609,610,611,612,613,614,616,617,618,619,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,640,641,643,644,647,648,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,670,671,672,675,676,677,678,680],"codes_lines_covered":[[["{","    use hir::{self, Hir, HirKind, RepetitionKind, Literal, Class, Group};","","    // Create a mutable Literals instance","    let mut lits = Literals::empty();","    ","    // Create literals that we will use in the alternation","    let lit1 = Literal::Unicode('a');","    let lit2 = Literal::Unicode('b');","    ","    // Construct HirKind::Alternation with two literals","    let alternation_expr = Hir::alternation(vec![","        Hir::literal(lit1.clone()),","        Hir::literal(lit2.clone()),","    ]);","","    // Test the prefixes function with the alternation expression","    prefixes(&alternation_expr, &mut lits);","    ","    // Check that the literals contain the expected prefixes","    assert!(lits.any_complete()); // Should capture some completions","    assert!(lits.literals().len() > 0); // Should have added literals","}"],[602,603,604,605,606,607,675,676,677,680]],[["{","    use hir::{self, Hir, HirKind};","","    // Create a mutable Literals instance","    let mut lits = Literals::empty();","    ","    // Construct HirKind::Alternation with no elements","    let alternation_expr = Hir::alternation(vec![]);","","    // Test the prefixes function with the empty alternation expression","    prefixes(&alternation_expr, &mut lits);","    ","    // Check that the literals remain empty and no cuts should occur","    assert!(lits.is_empty());","}"],[602,603,678,680]],[["{","    let mut lits = Literals::empty();","    let expr = Hir::concat(vec![]);","    prefixes(&expr, &mut lits);","    assert!(lits.is_empty());","}"],[602,603,678,680]],[["{","    let expr = Hir::concat(vec![]);","    let mut lits = Literals::empty();","","    prefixes(&expr, &mut lits);","    ","    assert!(lits.is_empty());","}"],[602,603,678,680]],[["{","    let mut lits = Literals::empty();","    let expr = Hir::concat(vec![]);","    prefixes(&expr, &mut lits);","    assert!(lits.is_empty());","}"],[602,603,678,680]],[["{","    let empty_concat = Hir::concat(vec![]);","    let mut lits = Literals::empty();","","    prefixes(&empty_concat, &mut lits);","    assert!(lits.is_empty());","}"],[602,603,678,680]],[["{","    let anchor = Hir::anchor(hir::Anchor::StartText);","    let concat_hir = Hir::concat(vec![anchor]);","    let mut literals = Literals::empty();","","    prefixes(&concat_hir, &mut literals);","","    assert!(literals.is_empty());","}"],[602,603,678,680]],[["{","    let concat_hir = Hir::concat(vec![]);","    let mut literals = Literals::empty();","","    prefixes(&concat_hir, &mut literals);","","    assert!(literals.is_empty());","}"],[602,603,678,680]],[["{","    let mut lits = Literals::empty();","    let expr = Hir::concat(vec![]); // empty Concatenation","    ","    prefixes(&expr, &mut lits);","    ","    assert!(lits.is_empty()); // should remain empty","}"],[602,603,678,680]],[["{","    let mut lits = Literals::empty();","    let expr = Hir::concat(vec![Hir::anchor(hir::Anchor::StartText)]); // Anchor at the start","    ","    prefixes(&expr, &mut lits);","    ","    assert!(lits.is_empty()); // should remain empty since it's just an anchor","}"],[602,603,678,680]],[["{","    use hir::{self, HirKind, Repetition, RepetitionRange};","","    // Set the necessary character class and literals","    let unicode_literal = hir::Literal::Unicode('a');","    let literal_hir = Hir::literal(unicode_literal);","    ","    // Prepare a repetition with bounded range (2, 5)","    let repetition = Repetition {","        kind: hir::RepetitionKind::Range(RepetitionRange::Bounded(2, 5)),","        greedy: true,","        hir: Box::new(literal_hir),","    };","","    // Create a Hir expression with this repetition","    let expr = Hir::repetition(repetition);","","    // Initialize literals","    let mut lits = Literals::empty();","    lits.set_limit_size(10);","    lits.set_limit_class(5);","","    // Call the prefixes function","    prefixes(&expr, &mut lits);","","    // Validate that the expected state of lits is as expected","    assert!(lits.any_complete());","    assert!(!lits.is_empty());","}"],[602,603,604,605,606,607,624,625,635,636,643,644,647,648,652,653,654,655,656,663,664,665,666,672,680]],[["{","    use hir::{self, HirKind, Repetition, RepetitionRange};","","    // Set the necessary character literal","    let byte_literal = hir::Literal::Byte(b'b');","    let literal_hir = Hir::literal(byte_literal);","","    // Prepare a repetition with exactly 3","    let repetition = Repetition {","        kind: hir::RepetitionKind::Range(RepetitionRange::Exactly(3)),","        greedy: true,","        hir: Box::new(literal_hir),","    };","","    // Create a Hir expression with this repetition","    let expr = Hir::repetition(repetition);","","    // Initialize literals","    let mut lits = Literals::empty();","    lits.set_limit_size(10);","    lits.set_limit_class(5);","","    // Call the prefixes function","    prefixes(&expr, &mut lits);","","    // Validate that the expected state of lits is as expected","    assert_eq!(lits.literals().len(), 3);","    assert!(lits.any_complete());","}"],[]],[["{","    use hir::{self, HirKind, Repetition, RepetitionRange};","","    // Set the necessary character literal","    let byte_literal = hir::Literal::Byte(b'c');","    let literal_hir = Hir::literal(byte_literal);","","    // Prepare a repetition with at least 1","    let repetition = Repetition {","        kind: hir::RepetitionKind::Range(RepetitionRange::AtLeast(1)),","        greedy: true,","        hir: Box::new(literal_hir),","    };","","    // Create a Hir expression with this repetition","    let expr = Hir::repetition(repetition);","","    // Initialize literals","    let mut lits = Literals::empty();","    lits.set_limit_size(10);","    lits.set_limit_class(5);","","    // Call the prefixes function","    prefixes(&expr, &mut lits);","","    // Validate that the expected state of lits is as expected","    assert!(lits.any_complete());","    assert!(!lits.is_empty());","}"],[]],[["{","    use hir::{self, HirKind, Repetition, RepetitionRange};","","    let byte_literal = hir::Literal::Byte(b'd');","    let literal_hir = Hir::literal(byte_literal);","","    // Prepare a repetition with an unreasonable limit that exceeds expected sizes","    let repetition = Repetition {","        kind: hir::RepetitionKind::Range(RepetitionRange::Bounded(1, 20)), // 20 is high for limit","        greedy: true,","        hir: Box::new(literal_hir),","    };","","    let expr = Hir::repetition(repetition);","","    let mut lits = Literals::empty();","    lits.set_limit_size(5); // Set a lower limit intentionally","    ","    // Call the prefixes function, should panic or error out","    prefixes(&expr, &mut lits);","}"],[]],[["{","    use hir::{Literal, Hir, HirKind};","","    // Setup","    let char_lit = hir::Literal::Unicode('c'); // A single unicode character","    let literal_expr = Hir::literal(char_lit);","    let mut literals = Literals::empty();","    literals.set_limit_size(10); // Set a limit that is achievable within the test","","    // Execution","    prefixes(&literal_expr, &mut literals);","","    // Assertions","    assert!(!literals.is_empty()); // Ensure that something was added","    assert!(literals.limit_size() == 10); // Validate the size limit is maintained","}"],[602,603,604,605,606,607,680]],[["{","    use hir::{Hir, HirKind};","","    // Setup","    let concat_expr = Hir::concat(vec![]);","    let mut literals = Literals::empty();","    literals.set_limit_size(10); // Set a limit that is achievable within the test","","    // Execution","    prefixes(&concat_expr, &mut literals);","","    // Assertions","    assert!(literals.is_empty()); // Ensure that nothing was added","}"],[602,603,678,680]],[["{","    let expr = Hir::empty();","    let mut lits = Literals::empty();","    prefixes(&expr, &mut lits);","    assert!(lits.is_empty());","}"],[602,603,678,680]],[["{","    let anchor = hir::Anchor::StartText;","    let expr = Hir::anchor(anchor);","    let mut lits = Literals::empty();","    prefixes(&expr, &mut lits);","    assert!(lits.is_empty());","}"],[602,603,678,680]],[["{","    let expr = Hir::concat(vec![]);","    let mut lits = Literals::empty();","    prefixes(&expr, &mut lits);","    assert!(lits.is_empty());","}"],[602,603,678,680]]],"codes_branches":[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":true},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":true},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":true},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":true},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    use hir::{self, Hir, HirKind, RepetitionKind, Literal, Class, Group};","","    // Create a mutable Literals instance","    let mut lits = Literals::empty();","    ","    // Create literals that we will use in the alternation","    let lit1 = Literal::Unicode('a');","    let lit2 = Literal::Unicode('b');","    ","    // Construct HirKind::Alternation with two literals","    let alternation_expr = Hir::alternation(vec![","        Hir::literal(lit1.clone()),","        Hir::literal(lit2.clone()),","    ]);","","    // Test the prefixes function with the alternation expression","    prefixes(&alternation_expr, &mut lits);","    ","    // Check that the literals contain the expected prefixes","    assert!(lits.any_complete()); // Should capture some completions","    assert!(lits.literals().len() > 0); // Should have added literals","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    use hir::{self, Hir, HirKind};","","    // Create a mutable Literals instance","    let mut lits = Literals::empty();","    ","    // Construct HirKind::Alternation with no elements","    let alternation_expr = Hir::alternation(vec![]);","","    // Test the prefixes function with the empty alternation expression","    prefixes(&alternation_expr, &mut lits);","    ","    // Check that the literals remain empty and no cuts should occur","    assert!(lits.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let mut lits = Literals::empty();","    let expr = Hir::concat(vec![]);","    prefixes(&expr, &mut lits);","    assert!(lits.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let expr = Hir::concat(vec![]);","    let mut lits = Literals::empty();","","    prefixes(&expr, &mut lits);","    ","    assert!(lits.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let mut lits = Literals::empty();","    let expr = Hir::concat(vec![]);","    prefixes(&expr, &mut lits);","    assert!(lits.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let empty_concat = Hir::concat(vec![]);","    let mut lits = Literals::empty();","","    prefixes(&empty_concat, &mut lits);","    assert!(lits.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let anchor = Hir::anchor(hir::Anchor::StartText);","    let concat_hir = Hir::concat(vec![anchor]);","    let mut literals = Literals::empty();","","    prefixes(&concat_hir, &mut literals);","","    assert!(literals.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let concat_hir = Hir::concat(vec![]);","    let mut literals = Literals::empty();","","    prefixes(&concat_hir, &mut literals);","","    assert!(literals.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let mut lits = Literals::empty();","    let expr = Hir::concat(vec![]); // empty Concatenation","    ","    prefixes(&expr, &mut lits);","    ","    assert!(lits.is_empty()); // should remain empty","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let mut lits = Literals::empty();","    let expr = Hir::concat(vec![Hir::anchor(hir::Anchor::StartText)]); // Anchor at the start","    ","    prefixes(&expr, &mut lits);","    ","    assert!(lits.is_empty()); // should remain empty since it's just an anchor","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    use hir::{self, HirKind, Repetition, RepetitionRange};","","    // Set the necessary character class and literals","    let unicode_literal = hir::Literal::Unicode('a');","    let literal_hir = Hir::literal(unicode_literal);","    ","    // Prepare a repetition with bounded range (2, 5)","    let repetition = Repetition {","        kind: hir::RepetitionKind::Range(RepetitionRange::Bounded(2, 5)),","        greedy: true,","        hir: Box::new(literal_hir),","    };","","    // Create a Hir expression with this repetition","    let expr = Hir::repetition(repetition);","","    // Initialize literals","    let mut lits = Literals::empty();","    lits.set_limit_size(10);","    lits.set_limit_class(5);","","    // Call the prefixes function","    prefixes(&expr, &mut lits);","","    // Validate that the expected state of lits is as expected","    assert!(lits.any_complete());","    assert!(!lits.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":true},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":true},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":true},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":true},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":true}]],[["{","    use hir::{self, HirKind, Repetition, RepetitionRange};","","    // Set the necessary character literal","    let byte_literal = hir::Literal::Byte(b'b');","    let literal_hir = Hir::literal(byte_literal);","","    // Prepare a repetition with exactly 3","    let repetition = Repetition {","        kind: hir::RepetitionKind::Range(RepetitionRange::Exactly(3)),","        greedy: true,","        hir: Box::new(literal_hir),","    };","","    // Create a Hir expression with this repetition","    let expr = Hir::repetition(repetition);","","    // Initialize literals","    let mut lits = Literals::empty();","    lits.set_limit_size(10);","    lits.set_limit_class(5);","","    // Call the prefixes function","    prefixes(&expr, &mut lits);","","    // Validate that the expected state of lits is as expected","    assert_eq!(lits.literals().len(), 3);","    assert!(lits.any_complete());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    use hir::{self, HirKind, Repetition, RepetitionRange};","","    // Set the necessary character literal","    let byte_literal = hir::Literal::Byte(b'c');","    let literal_hir = Hir::literal(byte_literal);","","    // Prepare a repetition with at least 1","    let repetition = Repetition {","        kind: hir::RepetitionKind::Range(RepetitionRange::AtLeast(1)),","        greedy: true,","        hir: Box::new(literal_hir),","    };","","    // Create a Hir expression with this repetition","    let expr = Hir::repetition(repetition);","","    // Initialize literals","    let mut lits = Literals::empty();","    lits.set_limit_size(10);","    lits.set_limit_class(5);","","    // Call the prefixes function","    prefixes(&expr, &mut lits);","","    // Validate that the expected state of lits is as expected","    assert!(lits.any_complete());","    assert!(!lits.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    use hir::{self, HirKind, Repetition, RepetitionRange};","","    let byte_literal = hir::Literal::Byte(b'd');","    let literal_hir = Hir::literal(byte_literal);","","    // Prepare a repetition with an unreasonable limit that exceeds expected sizes","    let repetition = Repetition {","        kind: hir::RepetitionKind::Range(RepetitionRange::Bounded(1, 20)), // 20 is high for limit","        greedy: true,","        hir: Box::new(literal_hir),","    };","","    let expr = Hir::repetition(repetition);","","    let mut lits = Literals::empty();","    lits.set_limit_size(5); // Set a lower limit intentionally","    ","    // Call the prefixes function, should panic or error out","    prefixes(&expr, &mut lits);","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    use hir::{Literal, Hir, HirKind};","","    // Setup","    let char_lit = hir::Literal::Unicode('c'); // A single unicode character","    let literal_expr = Hir::literal(char_lit);","    let mut literals = Literals::empty();","    literals.set_limit_size(10); // Set a limit that is achievable within the test","","    // Execution","    prefixes(&literal_expr, &mut literals);","","    // Assertions","    assert!(!literals.is_empty()); // Ensure that something was added","    assert!(literals.limit_size() == 10); // Validate the size limit is maintained","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    use hir::{Hir, HirKind};","","    // Setup","    let concat_expr = Hir::concat(vec![]);","    let mut literals = Literals::empty();","    literals.set_limit_size(10); // Set a limit that is achievable within the test","","    // Execution","    prefixes(&concat_expr, &mut literals);","","    // Assertions","    assert!(literals.is_empty()); // Ensure that nothing was added","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let expr = Hir::empty();","    let mut lits = Literals::empty();","    prefixes(&expr, &mut lits);","    assert!(lits.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let anchor = hir::Anchor::StartText;","    let expr = Hir::anchor(anchor);","    let mut lits = Literals::empty();","    prefixes(&expr, &mut lits);","    assert!(lits.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]],[["{","    let expr = Hir::concat(vec![]);","    let mut lits = Literals::empty();","    prefixes(&expr, &mut lits);","    assert!(lits.is_empty());","}"],[{"start_line":612,"start_column":16,"end_line":612,"end_column":41,"positive":false,"negative":false},{"start_line":617,"start_column":16,"end_line":617,"end_column":41,"positive":false,"negative":false},{"start_line":652,"start_column":36,"end_line":652,"end_column":49,"positive":false,"negative":false},{"start_line":653,"start_column":36,"end_line":653,"end_column":49,"positive":false,"negative":false},{"start_line":656,"start_column":24,"end_line":656,"end_column":63,"positive":false,"negative":false},{"start_line":657,"start_column":24,"end_line":657,"end_column":40,"positive":false,"negative":false},{"start_line":666,"start_column":20,"end_line":666,"end_column":47,"positive":false,"negative":false},{"start_line":666,"start_column":51,"end_line":666,"end_column":72,"positive":false,"negative":false}]]]}