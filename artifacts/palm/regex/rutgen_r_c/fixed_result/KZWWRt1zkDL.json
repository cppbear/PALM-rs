{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_escape","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":78,"tests_lines":[14,10,10,14,10,45,110,32,32,55,53,52,26,31,31,31,58,59,54,47,60,58,58,49,49,50,65,64,64,8,8,8,8,8,8,8,8,8,8,8,12,12,13,13,13,13,8,64,64,64,57,53,50,21,23,21,24,24,73,73,51,73,65,65,65,65,81,68,57,59,64,64,87,59,59,51,51,59],"oracles":78,"oracles_compiled":7,"oracles_compiled_rate":8.974358974358974,"tests_compiled":7,"tests_compiled_rate":8.974358974358974,"oracles_run":7,"oracles_passed":6,"oracles_passed_rate":85.71428571428571,"tests_run":7,"tests_passed":6,"tests_passed_rate":85.71428571428571,"lines":80,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":10,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1456,1457,1458,1459,1460,1463,1464,1465,1468,1469,1470,1473,1474,1475,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1523],"codes_lines_covered":[[["{","    struct MockParser {","        pattern: String,","        pos: Position,","        octal: bool,","        ignore_whitespace: Cell<bool>,","    }","","    impl MockParser {","        fn new(pattern: &str, pos: Position) -> Self {","            Self {","                pattern: pattern.to_string(),","                pos,","                octal: true,","                ignore_whitespace: Cell::new(true),","            }","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.offset).unwrap_or('\\0')","        }","","        fn bump(&mut self) -> bool {","            self.pos.offset += 1;","            self.pos.offset < self.pattern.len()","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind,","                pattern: self.pattern.clone(),","                span,","            }","        }","","        // Method to initiate the necessary `bump` and `char` processes","        fn parse_escape(&mut self) -> Result<Primitive> {","            assert_eq!(self.char(), '\\\\');","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnexpectedEof));","            }","            let c = self.char();","","            if c == 'u' {","                // Simulate parsing a Unicode escape","                return Ok(Primitive::Unicode(ast::ClassUnicode {","                    span: Span::new(start, self.pos()),","                    negated: false,","                    kind: ast::ClassUnicodeKind::Named(\"Unicode\".to_string()),","                }));","            }","","            Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnrecognized))","        }","    }","","    let mut parser = MockParser::new(\"\\\\u\", Position { offset: 0, line: 1, column: 1 });","    let result = parser.parse_escape();","    assert!(result.is_ok());","}"],[]],[["{","    struct MockParser {","        pattern: String,","        pos: Position,","        octal: bool,","        ignore_whitespace: Cell<bool>,","    }","","    impl MockParser {","        fn new(pattern: &str, pos: Position) -> Self {","            Self {","                pattern: pattern.to_string(),","                pos,","                octal: false,","                ignore_whitespace: Cell::new(true),","            }","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.offset).unwrap_or('\\0')","        }","","        fn bump(&mut self) -> bool {","            self.pos.offset += 1;","            self.pos.offset < self.pattern.len()","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind,","                pattern: self.pattern.clone(),","                span,","            }","        }","","        // Method to initiate the necessary `bump` and `char` processes","        fn parse_escape(&mut self) -> Result<Primitive> {","            assert_eq!(self.char(), '\\\\');","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnexpectedEof));","            }","            let c = self.char();","","            if c == 'd' {","                return Ok(Primitive::Perl(ast::ClassPerl {","                    span: Span::new(start, self.pos()),","                    kind: ast::ClassPerlKind::Digit,","                    negated: false,","                }));","            }","","            Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnrecognized))","        }","    }","","    let mut parser = MockParser::new(\"\\\\d\", Position { offset: 0, line: 1, column: 1 });","    let result = parser.parse_escape();","    assert!(result.is_ok());","}"],[]],[["{","    struct MockParser {","        pattern: String,","        pos: Position,","        octal: bool,","        ignore_whitespace: Cell<bool>,","    }","","    impl MockParser {","        fn new(pattern: &str, pos: Position) -> Self {","            Self {","                pattern: pattern.to_string(),","                pos,","                octal: false,","                ignore_whitespace: Cell::new(true),","            }","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.offset).unwrap_or('\\0')","        }","","        fn bump(&mut self) -> bool {","            self.pos.offset += 1;","            self.pos.offset < self.pattern.len()","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind,","                pattern: self.pattern.clone(),","                span,","            }","        }","","        // Method to initiate the necessary `bump` and `char` processes","        fn parse_escape(&mut self) -> Result<Primitive> {","            assert_eq!(self.char(), '\\\\');","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnexpectedEof));","            }","            let c = self.char();","","            if c == ' ' {","                return Ok(Primitive::Literal(ast::Literal {","                    span: Span::new(start, self.pos()),","                    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),","                    c: ' ',","                }));","            }","            ","            Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnrecognized))","        }","    }","","    let mut parser = MockParser::new(\"\\\\ \", Position { offset: 0, line: 1, column: 1 });","    let result = parser.parse_escape();","    assert!(result.is_ok());","}"],[]],[["{","    struct TestParser<'s> {","        pos: Position,","        pattern: &'s str,","        octal: bool,","    }","","    impl<'s> TestParser<'s> {","        fn char(&self) -> char {","            self.pattern[self.pos.offset..].chars().next().unwrap()","        }","","        fn bump(&mut self) -> bool {","            if self.pos.offset + 1 <= self.pattern.len() {","                self.pos.offset += 1;","                true","            } else {","                false","            }","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: String::from(self.pattern), span }","        }","","        fn parse_hex(&self) -> Result<ast::Literal> {","            Err(self.error(Span::new(self.pos, self.pos), ast::ErrorKind::EscapeUnexpectedEof))","        }","        ","        fn parser(&self) -> &TestParser<'s> {","            self","        }","        ","        fn parse_escape(&mut self) -> Result<Primitive> {","            assert_eq!(self.char(), '\\\\');","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(","                    Span::new(start, self.pos()),","                    ast::ErrorKind::EscapeUnexpectedEof,","                ));","            }","            let c = self.char();","            match c {","                'x' => {","                    let mut lit = self.parse_hex()?;","                    lit.span.start = start;","                    return Ok(Primitive::Literal(lit));","                }","                _ => {}","            }","            // Additional parsing logic...","            Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnrecognized))","        }","    }","","    let mut parser = TestParser {","        pos: Position { offset: 0, line: 1, column: 1 },","        pattern: r\"\\x\",","        octal: true,","    };","","    assert_eq!(parser.parse_escape().is_err(), true);","}"],[]],[["{","    struct TestParser<'s> {","        pos: Position,","        pattern: &'s str,","        octal: bool,","    }","","    impl<'s> TestParser<'s> {","        fn char(&self) -> char {","            self.pattern[self.pos.offset..].chars().next().unwrap()","        }","","        fn bump(&mut self) -> bool {","            if self.pos.offset + 1 <= self.pattern.len() {","                self.pos.offset += 1;","                true","            } else {","                false","            }","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: String::from(self.pattern), span }","        }","","        fn parser(&self) -> &TestParser<'s> {","            self","        }","        ","        fn parse_escape(&mut self) -> Result<Primitive> {","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(","                    Span::new(start, self.pos()),","                    ast::ErrorKind::EscapeUnexpectedEof,","                ));","            }","            let c = self.char();","            if c.is_digit(10) {","                return Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::UnsupportedBackreference));","            }","            Ok(Primitive::Literal(ast::Literal { span: Span::new(start, start), kind: ast::LiteralKind::Verbatim, c }))","        }","    }","","    let mut parser = TestParser {","        pos: Position { offset: 0, line: 1, column: 1 },","        pattern: r\"\\8\",","        octal: false,","    };","","    assert_eq!(parser.parse_escape().is_err(), true);","}"],[]],[["{","    struct TestParser<'s> {","        pos: Position,","        pattern: &'s str,","        octal: bool,","    }","","    impl<'s> TestParser<'s> {","        fn char(&self) -> char {","            self.pattern[self.pos.offset..].chars().next().unwrap()","        }","","        fn bump(&mut self) -> bool {","            if self.pos.offset + 1 <= self.pattern.len() {","                self.pos.offset += 1;","                true","            } else {","                false","            }","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: String::from(self.pattern), span }","        }","","        fn parser(&self) -> &TestParser<'s> {","            self","        }","        ","        fn parse_escape(&mut self) -> Result<Primitive> {","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(","                    Span::new(start, self.pos()),","                    ast::ErrorKind::EscapeUnexpectedEof,","                ));","            }","            let c = self.char();","            ","            if c >= '0' && c <= '7' && !self.octal {","                  return Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::UnsupportedBackreference));","            }","            Ok(Primitive::Literal(ast::Literal { span: Span::new(start, start), kind: ast::LiteralKind::Verbatim, c }))","        }","    }","","    let mut parser = TestParser {","        pos: Position { offset: 0, line: 1, column: 1 },","        pattern: r\"\\1\",","        octal: false,","    };","","    let result = parser.parse_escape();","    assert!(result.is_err());","}"],[]],[["{","    struct DummyParser {","        pattern: String,","        pos: Position,","        octal: bool,","    }","","    impl DummyParser {","        fn new(pattern: &str, octal: bool) -> Self {","            DummyParser {","                pattern: pattern.to_string(),","                pos: Position { offset: 0, line: 1, column: 1 },","                octal,","            }","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.offset).unwrap()","        }","","        fn bump(&mut self) -> bool {","            if self.pos.offset < self.pattern.len() {","                self.pos.offset += 1;","                true","            } else {","                false","            }","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> Result<Primitive> {","            Err(ast::Error { kind, pattern: self.pattern.clone(), span })","        }","","        fn span_char(&self) -> Span {","            Span::new(self.pos, self.pos)","        }","","        fn parser(&self) -> &Self {","            self","        }","","        fn is_eof(&self) -> bool {","            self.pos.offset >= self.pattern.len()","        }","","        fn test_parse_escape(&mut self) -> Result<Primitive> {","            assert_eq!(self.char(), '\\\\');","            let start = self.pos();","            if !self.bump() {","                return self.error(","                    Span::new(start, self.pos()),","                    ast::ErrorKind::EscapeUnexpectedEof,","                );","            }","            let c = self.char();","            // Simplified logic for this test's purpose","            if c == '0' && !self.parser().octal {","                return self.error(","                    Span::new(start, self.span_char().end),","                    ast::ErrorKind::UnsupportedBackreference,","                );","            }","            // Otherwise, just return primitive literal for the test context","            self.bump();","            let span = Span::new(start, self.pos());","            Ok(Primitive::Literal(ast::Literal {","                span,","                kind: ast::LiteralKind::Verbatim,","                c: c,","            }))","        }","    }","","    let mut parser = DummyParser::new(\"\\\\8\", false);","    assert_eq!(","        parser.test_parse_escape(),","        Err(ast::Error {","            kind: ast::ErrorKind::EscapeUnexpectedEof,","            pattern: \"\\\\8\".to_string(),","            span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),","        })","    );","}"],[]]],"codes_branches":[{"start_line":1436,"start_column":12,"end_line":1436,"end_column":24,"positive":false,"negative":false},{"start_line":1446,"start_column":20,"end_line":1446,"end_column":40,"positive":false,"negative":false},{"start_line":1456,"start_column":26,"end_line":1456,"end_column":46,"positive":false,"negative":false},{"start_line":1483,"start_column":12,"end_line":1483,"end_column":32,"positive":false,"negative":false},{"start_line":1502,"start_column":20,"end_line":1502,"end_column":44,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockParser {","        pattern: String,","        pos: Position,","        octal: bool,","        ignore_whitespace: Cell<bool>,","    }","","    impl MockParser {","        fn new(pattern: &str, pos: Position) -> Self {","            Self {","                pattern: pattern.to_string(),","                pos,","                octal: true,","                ignore_whitespace: Cell::new(true),","            }","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.offset).unwrap_or('\\0')","        }","","        fn bump(&mut self) -> bool {","            self.pos.offset += 1;","            self.pos.offset < self.pattern.len()","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind,","                pattern: self.pattern.clone(),","                span,","            }","        }","","        // Method to initiate the necessary `bump` and `char` processes","        fn parse_escape(&mut self) -> Result<Primitive> {","            assert_eq!(self.char(), '\\\\');","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnexpectedEof));","            }","            let c = self.char();","","            if c == 'u' {","                // Simulate parsing a Unicode escape","                return Ok(Primitive::Unicode(ast::ClassUnicode {","                    span: Span::new(start, self.pos()),","                    negated: false,","                    kind: ast::ClassUnicodeKind::Named(\"Unicode\".to_string()),","                }));","            }","","            Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnrecognized))","        }","    }","","    let mut parser = MockParser::new(\"\\\\u\", Position { offset: 0, line: 1, column: 1 });","    let result = parser.parse_escape();","    assert!(result.is_ok());","}"],[{"start_line":1436,"start_column":12,"end_line":1436,"end_column":24,"positive":false,"negative":false},{"start_line":1446,"start_column":20,"end_line":1446,"end_column":40,"positive":false,"negative":false},{"start_line":1456,"start_column":26,"end_line":1456,"end_column":46,"positive":false,"negative":false},{"start_line":1483,"start_column":12,"end_line":1483,"end_column":32,"positive":false,"negative":false},{"start_line":1502,"start_column":20,"end_line":1502,"end_column":44,"positive":false,"negative":false}]],[["{","    struct MockParser {","        pattern: String,","        pos: Position,","        octal: bool,","        ignore_whitespace: Cell<bool>,","    }","","    impl MockParser {","        fn new(pattern: &str, pos: Position) -> Self {","            Self {","                pattern: pattern.to_string(),","                pos,","                octal: false,","                ignore_whitespace: Cell::new(true),","            }","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.offset).unwrap_or('\\0')","        }","","        fn bump(&mut self) -> bool {","            self.pos.offset += 1;","            self.pos.offset < self.pattern.len()","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind,","                pattern: self.pattern.clone(),","                span,","            }","        }","","        // Method to initiate the necessary `bump` and `char` processes","        fn parse_escape(&mut self) -> Result<Primitive> {","            assert_eq!(self.char(), '\\\\');","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnexpectedEof));","            }","            let c = self.char();","","            if c == 'd' {","                return Ok(Primitive::Perl(ast::ClassPerl {","                    span: Span::new(start, self.pos()),","                    kind: ast::ClassPerlKind::Digit,","                    negated: false,","                }));","            }","","            Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnrecognized))","        }","    }","","    let mut parser = MockParser::new(\"\\\\d\", Position { offset: 0, line: 1, column: 1 });","    let result = parser.parse_escape();","    assert!(result.is_ok());","}"],[{"start_line":1436,"start_column":12,"end_line":1436,"end_column":24,"positive":false,"negative":false},{"start_line":1446,"start_column":20,"end_line":1446,"end_column":40,"positive":false,"negative":false},{"start_line":1456,"start_column":26,"end_line":1456,"end_column":46,"positive":false,"negative":false},{"start_line":1483,"start_column":12,"end_line":1483,"end_column":32,"positive":false,"negative":false},{"start_line":1502,"start_column":20,"end_line":1502,"end_column":44,"positive":false,"negative":false}]],[["{","    struct MockParser {","        pattern: String,","        pos: Position,","        octal: bool,","        ignore_whitespace: Cell<bool>,","    }","","    impl MockParser {","        fn new(pattern: &str, pos: Position) -> Self {","            Self {","                pattern: pattern.to_string(),","                pos,","                octal: false,","                ignore_whitespace: Cell::new(true),","            }","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.offset).unwrap_or('\\0')","        }","","        fn bump(&mut self) -> bool {","            self.pos.offset += 1;","            self.pos.offset < self.pattern.len()","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind,","                pattern: self.pattern.clone(),","                span,","            }","        }","","        // Method to initiate the necessary `bump` and `char` processes","        fn parse_escape(&mut self) -> Result<Primitive> {","            assert_eq!(self.char(), '\\\\');","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnexpectedEof));","            }","            let c = self.char();","","            if c == ' ' {","                return Ok(Primitive::Literal(ast::Literal {","                    span: Span::new(start, self.pos()),","                    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),","                    c: ' ',","                }));","            }","            ","            Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnrecognized))","        }","    }","","    let mut parser = MockParser::new(\"\\\\ \", Position { offset: 0, line: 1, column: 1 });","    let result = parser.parse_escape();","    assert!(result.is_ok());","}"],[{"start_line":1436,"start_column":12,"end_line":1436,"end_column":24,"positive":false,"negative":false},{"start_line":1446,"start_column":20,"end_line":1446,"end_column":40,"positive":false,"negative":false},{"start_line":1456,"start_column":26,"end_line":1456,"end_column":46,"positive":false,"negative":false},{"start_line":1483,"start_column":12,"end_line":1483,"end_column":32,"positive":false,"negative":false},{"start_line":1502,"start_column":20,"end_line":1502,"end_column":44,"positive":false,"negative":false}]],[["{","    struct TestParser<'s> {","        pos: Position,","        pattern: &'s str,","        octal: bool,","    }","","    impl<'s> TestParser<'s> {","        fn char(&self) -> char {","            self.pattern[self.pos.offset..].chars().next().unwrap()","        }","","        fn bump(&mut self) -> bool {","            if self.pos.offset + 1 <= self.pattern.len() {","                self.pos.offset += 1;","                true","            } else {","                false","            }","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: String::from(self.pattern), span }","        }","","        fn parse_hex(&self) -> Result<ast::Literal> {","            Err(self.error(Span::new(self.pos, self.pos), ast::ErrorKind::EscapeUnexpectedEof))","        }","        ","        fn parser(&self) -> &TestParser<'s> {","            self","        }","        ","        fn parse_escape(&mut self) -> Result<Primitive> {","            assert_eq!(self.char(), '\\\\');","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(","                    Span::new(start, self.pos()),","                    ast::ErrorKind::EscapeUnexpectedEof,","                ));","            }","            let c = self.char();","            match c {","                'x' => {","                    let mut lit = self.parse_hex()?;","                    lit.span.start = start;","                    return Ok(Primitive::Literal(lit));","                }","                _ => {}","            }","            // Additional parsing logic...","            Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::EscapeUnrecognized))","        }","    }","","    let mut parser = TestParser {","        pos: Position { offset: 0, line: 1, column: 1 },","        pattern: r\"\\x\",","        octal: true,","    };","","    assert_eq!(parser.parse_escape().is_err(), true);","}"],[{"start_line":1436,"start_column":12,"end_line":1436,"end_column":24,"positive":false,"negative":false},{"start_line":1446,"start_column":20,"end_line":1446,"end_column":40,"positive":false,"negative":false},{"start_line":1456,"start_column":26,"end_line":1456,"end_column":46,"positive":false,"negative":false},{"start_line":1483,"start_column":12,"end_line":1483,"end_column":32,"positive":false,"negative":false},{"start_line":1502,"start_column":20,"end_line":1502,"end_column":44,"positive":false,"negative":false}]],[["{","    struct TestParser<'s> {","        pos: Position,","        pattern: &'s str,","        octal: bool,","    }","","    impl<'s> TestParser<'s> {","        fn char(&self) -> char {","            self.pattern[self.pos.offset..].chars().next().unwrap()","        }","","        fn bump(&mut self) -> bool {","            if self.pos.offset + 1 <= self.pattern.len() {","                self.pos.offset += 1;","                true","            } else {","                false","            }","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: String::from(self.pattern), span }","        }","","        fn parser(&self) -> &TestParser<'s> {","            self","        }","        ","        fn parse_escape(&mut self) -> Result<Primitive> {","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(","                    Span::new(start, self.pos()),","                    ast::ErrorKind::EscapeUnexpectedEof,","                ));","            }","            let c = self.char();","            if c.is_digit(10) {","                return Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::UnsupportedBackreference));","            }","            Ok(Primitive::Literal(ast::Literal { span: Span::new(start, start), kind: ast::LiteralKind::Verbatim, c }))","        }","    }","","    let mut parser = TestParser {","        pos: Position { offset: 0, line: 1, column: 1 },","        pattern: r\"\\8\",","        octal: false,","    };","","    assert_eq!(parser.parse_escape().is_err(), true);","}"],[{"start_line":1436,"start_column":12,"end_line":1436,"end_column":24,"positive":false,"negative":false},{"start_line":1446,"start_column":20,"end_line":1446,"end_column":40,"positive":false,"negative":false},{"start_line":1456,"start_column":26,"end_line":1456,"end_column":46,"positive":false,"negative":false},{"start_line":1483,"start_column":12,"end_line":1483,"end_column":32,"positive":false,"negative":false},{"start_line":1502,"start_column":20,"end_line":1502,"end_column":44,"positive":false,"negative":false}]],[["{","    struct TestParser<'s> {","        pos: Position,","        pattern: &'s str,","        octal: bool,","    }","","    impl<'s> TestParser<'s> {","        fn char(&self) -> char {","            self.pattern[self.pos.offset..].chars().next().unwrap()","        }","","        fn bump(&mut self) -> bool {","            if self.pos.offset + 1 <= self.pattern.len() {","                self.pos.offset += 1;","                true","            } else {","                false","            }","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: String::from(self.pattern), span }","        }","","        fn parser(&self) -> &TestParser<'s> {","            self","        }","        ","        fn parse_escape(&mut self) -> Result<Primitive> {","            let start = self.pos();","            if !self.bump() {","                return Err(self.error(","                    Span::new(start, self.pos()),","                    ast::ErrorKind::EscapeUnexpectedEof,","                ));","            }","            let c = self.char();","            ","            if c >= '0' && c <= '7' && !self.octal {","                  return Err(self.error(Span::new(start, self.pos()), ast::ErrorKind::UnsupportedBackreference));","            }","            Ok(Primitive::Literal(ast::Literal { span: Span::new(start, start), kind: ast::LiteralKind::Verbatim, c }))","        }","    }","","    let mut parser = TestParser {","        pos: Position { offset: 0, line: 1, column: 1 },","        pattern: r\"\\1\",","        octal: false,","    };","","    let result = parser.parse_escape();","    assert!(result.is_err());","}"],[{"start_line":1436,"start_column":12,"end_line":1436,"end_column":24,"positive":false,"negative":false},{"start_line":1446,"start_column":20,"end_line":1446,"end_column":40,"positive":false,"negative":false},{"start_line":1456,"start_column":26,"end_line":1456,"end_column":46,"positive":false,"negative":false},{"start_line":1483,"start_column":12,"end_line":1483,"end_column":32,"positive":false,"negative":false},{"start_line":1502,"start_column":20,"end_line":1502,"end_column":44,"positive":false,"negative":false}]],[["{","    struct DummyParser {","        pattern: String,","        pos: Position,","        octal: bool,","    }","","    impl DummyParser {","        fn new(pattern: &str, octal: bool) -> Self {","            DummyParser {","                pattern: pattern.to_string(),","                pos: Position { offset: 0, line: 1, column: 1 },","                octal,","            }","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.offset).unwrap()","        }","","        fn bump(&mut self) -> bool {","            if self.pos.offset < self.pattern.len() {","                self.pos.offset += 1;","                true","            } else {","                false","            }","        }","","        fn pos(&self) -> Position {","            self.pos","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> Result<Primitive> {","            Err(ast::Error { kind, pattern: self.pattern.clone(), span })","        }","","        fn span_char(&self) -> Span {","            Span::new(self.pos, self.pos)","        }","","        fn parser(&self) -> &Self {","            self","        }","","        fn is_eof(&self) -> bool {","            self.pos.offset >= self.pattern.len()","        }","","        fn test_parse_escape(&mut self) -> Result<Primitive> {","            assert_eq!(self.char(), '\\\\');","            let start = self.pos();","            if !self.bump() {","                return self.error(","                    Span::new(start, self.pos()),","                    ast::ErrorKind::EscapeUnexpectedEof,","                );","            }","            let c = self.char();","            // Simplified logic for this test's purpose","            if c == '0' && !self.parser().octal {","                return self.error(","                    Span::new(start, self.span_char().end),","                    ast::ErrorKind::UnsupportedBackreference,","                );","            }","            // Otherwise, just return primitive literal for the test context","            self.bump();","            let span = Span::new(start, self.pos());","            Ok(Primitive::Literal(ast::Literal {","                span,","                kind: ast::LiteralKind::Verbatim,","                c: c,","            }))","        }","    }","","    let mut parser = DummyParser::new(\"\\\\8\", false);","    assert_eq!(","        parser.test_parse_escape(),","        Err(ast::Error {","            kind: ast::ErrorKind::EscapeUnexpectedEof,","            pattern: \"\\\\8\".to_string(),","            span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),","        })","    );","}"],[{"start_line":1436,"start_column":12,"end_line":1436,"end_column":24,"positive":false,"negative":false},{"start_line":1446,"start_column":20,"end_line":1446,"end_column":40,"positive":false,"negative":false},{"start_line":1456,"start_column":26,"end_line":1456,"end_column":46,"positive":false,"negative":false},{"start_line":1483,"start_column":12,"end_line":1483,"end_column":32,"positive":false,"negative":false},{"start_line":1502,"start_column":20,"end_line":1502,"end_column":44,"positive":false,"negative":false}]]]}