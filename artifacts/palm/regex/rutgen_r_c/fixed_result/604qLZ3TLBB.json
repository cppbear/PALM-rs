{"function_name":"regex::input::input::Char::is_word_char","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/input.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[15,13,12,11],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[373,374,375],"codes_lines_covered":[[["{","    struct CharWrapper(u32);","    impl CharWrapper {","        fn is_word_char(self) -> bool {","            char::from_u32(self.0).map_or(false, syntax::is_word_character)","        }","    }","","    assert_eq!(CharWrapper(97).is_word_char(), true);  // 'a'","    assert_eq!(CharWrapper(122).is_word_char(), true); // 'z'","    assert_eq!(CharWrapper(65).is_word_char(), true);  // 'A'","    assert_eq!(CharWrapper(90).is_word_char(), true);  // 'Z'","    assert_eq!(CharWrapper(48).is_word_char(), true);  // '0'","    assert_eq!(CharWrapper(57).is_word_char(), true);  // '9'","}"],[]],[["{","    struct CharWrapper(u32);","    impl CharWrapper {","        fn is_word_char(self) -> bool {","            char::from_u32(self.0).map_or(false, syntax::is_word_character)","        }","    }","","    assert_eq!(CharWrapper(32).is_word_char(), false);  // Space","    assert_eq!(CharWrapper(33).is_word_char(), false);  // '!'","    assert_eq!(CharWrapper(46).is_word_char(), false);  // '.'","    assert_eq!(CharWrapper(64).is_word_char(), false);  // '@'","}"],[]],[["{","    struct CharWrapper(u32);","    impl CharWrapper {","        fn is_word_char(self) -> bool {","            char::from_u32(self.0).map_or(false, syntax::is_word_character)","        }","    }","","    // Testing invalid Unicode code points","    assert_eq!(CharWrapper(0xD800).is_word_char(), false); // High surrogate","    assert_eq!(CharWrapper(0xDFFF).is_word_char(), false); // Low surrogate","}"],[]],[["{","    struct CharWrapper(u32);","    impl CharWrapper {","        fn is_word_char(self) -> bool {","            char::from_u32(self.0).map_or(false, syntax::is_word_character)","        }","    }","","    assert_eq!(CharWrapper(0).is_word_char(), false);        // Unicode U+0000","    assert_eq!(CharWrapper(0x10FFFF).is_word_char(), false); // Maximum valid Unicode code point","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct CharWrapper(u32);","    impl CharWrapper {","        fn is_word_char(self) -> bool {","            char::from_u32(self.0).map_or(false, syntax::is_word_character)","        }","    }","","    assert_eq!(CharWrapper(97).is_word_char(), true);  // 'a'","    assert_eq!(CharWrapper(122).is_word_char(), true); // 'z'","    assert_eq!(CharWrapper(65).is_word_char(), true);  // 'A'","    assert_eq!(CharWrapper(90).is_word_char(), true);  // 'Z'","    assert_eq!(CharWrapper(48).is_word_char(), true);  // '0'","    assert_eq!(CharWrapper(57).is_word_char(), true);  // '9'","}"],[]],[["{","    struct CharWrapper(u32);","    impl CharWrapper {","        fn is_word_char(self) -> bool {","            char::from_u32(self.0).map_or(false, syntax::is_word_character)","        }","    }","","    assert_eq!(CharWrapper(32).is_word_char(), false);  // Space","    assert_eq!(CharWrapper(33).is_word_char(), false);  // '!'","    assert_eq!(CharWrapper(46).is_word_char(), false);  // '.'","    assert_eq!(CharWrapper(64).is_word_char(), false);  // '@'","}"],[]],[["{","    struct CharWrapper(u32);","    impl CharWrapper {","        fn is_word_char(self) -> bool {","            char::from_u32(self.0).map_or(false, syntax::is_word_character)","        }","    }","","    // Testing invalid Unicode code points","    assert_eq!(CharWrapper(0xD800).is_word_char(), false); // High surrogate","    assert_eq!(CharWrapper(0xDFFF).is_word_char(), false); // Low surrogate","}"],[]],[["{","    struct CharWrapper(u32);","    impl CharWrapper {","        fn is_word_char(self) -> bool {","            char::from_u32(self.0).map_or(false, syntax::is_word_character)","        }","    }","","    assert_eq!(CharWrapper(0).is_word_char(), false);        // Unicode U+0000","    assert_eq!(CharWrapper(0x10FFFF).is_word_char(), false); // Maximum valid Unicode code point","}"],[]]]}