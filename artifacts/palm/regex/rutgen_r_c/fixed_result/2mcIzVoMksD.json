{"function_name":"regex_syntax::hir::literal::escape_bytes","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":12,"tests_lines":[5,5,5,5,5,5,5,5,5,5,5,6],"oracles":12,"oracles_compiled":12,"oracles_compiled_rate":100.0,"tests_compiled":12,"tests_compiled_rate":100.0,"oracles_run":12,"oracles_passed":9,"oracles_passed_rate":75.0,"tests_run":12,"tests_passed":9,"tests_passed_rate":75.0,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[973,974,975,976,977,978,979],"codes_lines_covered":[[["{","    let input: &[u8] = &['a' as u8, 'b' as u8, 'c' as u8];","    let result = escape_bytes(input);","    assert_eq!(result, \"abc\");","}"],[973,974,975,976,977,978,979]],[["{","    let input: &[u8] = &[0, 1, 2, 3];","    let result = escape_bytes(input);","    assert_eq!(result, \"\\\\x00\\\\x01\\\\x02\\\\x03\");","}"],[973,974,975,976,977,978,979]],[["{","    let input: &[u8] = &[255, 128, 127];","    let result = escape_bytes(input);","    assert_eq!(result, \"\\\\xff\\\\x80\\\\x7f\");","}"],[973,974,975,976,977,978,979]],[["{","    let input: &[u8] = &[];","    let result = escape_bytes(input);","    assert_eq!(result, \"\");","}"],[973,974,975,978,979]],[["{","    let input: &[u8] = &[240, 241, 242];","    let result = escape_bytes(input);","    assert_eq!(result, \"\\\\xf0\\\\xf1\\\\xf2\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\");","}"],[973,974,975,978,979]],[["{","    let bytes: &[u8] = &[97]; // 'a'","    let result = escape_bytes(bytes);","    assert_eq!(result, \"a\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[1]; // non-printable byte","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\u{1}\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[65, 66, 67]; // 'A', 'B', 'C'","    let result = escape_bytes(bytes);","    assert_eq!(result, \"ABC\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[10, 20]; // newline and non-printable byte","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\n\\u{14}\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[0, 255]; // null and maximum byte value","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\u{0}\\u{ff}\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).collect(); // All byte values from 0 to 255","    let result = escape_bytes(&bytes);","    let expected: String = bytes.iter().map(|&b| escape_byte(b)).collect();","    assert_eq!(result, expected);","}"],[973,974,975,976,977,978,979]]],"codes_branches":[],"codes_branches_covered":[[["{","    let input: &[u8] = &['a' as u8, 'b' as u8, 'c' as u8];","    let result = escape_bytes(input);","    assert_eq!(result, \"abc\");","}"],[]],[["{","    let input: &[u8] = &[0, 1, 2, 3];","    let result = escape_bytes(input);","    assert_eq!(result, \"\\\\x00\\\\x01\\\\x02\\\\x03\");","}"],[]],[["{","    let input: &[u8] = &[255, 128, 127];","    let result = escape_bytes(input);","    assert_eq!(result, \"\\\\xff\\\\x80\\\\x7f\");","}"],[]],[["{","    let input: &[u8] = &[];","    let result = escape_bytes(input);","    assert_eq!(result, \"\");","}"],[]],[["{","    let input: &[u8] = &[240, 241, 242];","    let result = escape_bytes(input);","    assert_eq!(result, \"\\\\xf0\\\\xf1\\\\xf2\");","}"],[]],[["{","    let bytes: &[u8] = &[];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\");","}"],[]],[["{","    let bytes: &[u8] = &[97]; // 'a'","    let result = escape_bytes(bytes);","    assert_eq!(result, \"a\");","}"],[]],[["{","    let bytes: &[u8] = &[1]; // non-printable byte","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\u{1}\");","}"],[]],[["{","    let bytes: &[u8] = &[65, 66, 67]; // 'A', 'B', 'C'","    let result = escape_bytes(bytes);","    assert_eq!(result, \"ABC\");","}"],[]],[["{","    let bytes: &[u8] = &[10, 20]; // newline and non-printable byte","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\n\\u{14}\");","}"],[]],[["{","    let bytes: &[u8] = &[0, 255]; // null and maximum byte value","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\u{0}\\u{ff}\");","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).collect(); // All byte values from 0 to 255","    let result = escape_bytes(&bytes);","    let expected: String = bytes.iter().map(|&b| escape_byte(b)).collect();","    assert_eq!(result, expected);","}"],[]]]}