{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::bump","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":6,"tests_lines":[38,28,23,23,54,58],"oracles":6,"oracles_compiled":3,"oracles_compiled_rate":50.0,"tests_compiled":3,"tests_compiled_rate":50.0,"oracles_run":3,"oracles_passed":1,"oracles_passed_rate":33.33333333333333,"tests_run":3,"tests_passed":1,"tests_passed_rate":33.33333333333333,"lines":19,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],"codes_lines_covered":[[["{","    struct DummyParser {","        pos: Cell<Position>,","        pattern: String,","    }","","    impl DummyParser {","        fn new(pattern: &str) -> Self {","            Self {","                pos: Cell::new(Position { offset: pattern.len(), line: 1, column: 1 }),","                pattern: pattern.to_string(),","            }","        }","","        fn pos(&self) -> Position {","            self.pos.get()","        }","","        fn is_eof(&self) -> bool {","            self.pos().offset >= self.pattern.len()","        }","","        fn char(&self) -> char {","            '\\0' // No character to return as we are at EOF","        }","","        fn bump(&self) -> bool {","            if self.is_eof() {","                return false;","            }","            // Note: The actual implementation details are irrelevant for this case","            true","        }","    }","","    let parser = DummyParser::new(\"abc\");","    assert_eq!(parser.bump(), false);","}"],[]],[["{","    struct TestParser {","        pos: Cell<Position>,","        pattern: String,","    }","","    impl TestParser {","        fn new(pattern: &str) -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                pattern: pattern.to_string(),","            }","        }","","        fn pos(&self) -> Position {","            self.pos.get()","        }","","        fn is_eof(&self) -> bool {","            self.pos.get().offset >= self.pattern.len()","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.get().offset).unwrap_or('\\0')","        }","","        fn bump(&self) -> bool {","            if self.is_eof() {","                return false;","            }","            let Position { mut offset, mut line, mut column } = self.pos();","            if self.char() == '\\n' {","                line = line.checked_add(1).unwrap();","                column = 1;","            } else {","                column = column.checked_add(1).unwrap();","            }","            offset += self.char().len_utf8();","            self.pos.set(Position {","                offset: offset,","                line: line,","                column: column,","            });","            self.pattern[self.pos().offset..].chars().next().is_some()","        }","    }","","    let parser = TestParser::new(\"abc\\ndef\");","    let result = parser.bump();","    assert!(result);","    assert_eq!(parser.pos().line, 1);","    assert_eq!(parser.pos().column, 4);","    assert_eq!(parser.pos().offset, 3);","}"],[]],[["{","    struct TestParser {","        pos: Cell<Position>,","        pattern: String,","    }","","    impl TestParser {","        fn new(pattern: &str) -> Self {","            Self {","                pos: Cell::new(Position { offset: pattern.len(), line: 1, column: 1 }),","                pattern: pattern.to_string(),","            }","        }","","        fn pos(&self) -> Position {","            self.pos.get()","        }","","        fn is_eof(&self) -> bool {","            self.pos.get().offset >= self.pattern.len()","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.get().offset).unwrap_or('\\0')","        }","","        fn bump(&self) -> bool {","            if self.is_eof() {","                return false;","            }","            let Position { mut offset, mut line, mut column } = self.pos();","            if self.char() == '\\n' {","                line = line.checked_add(1).unwrap();","                column = 1;","            } else {","                column = column.checked_add(1).unwrap();","            }","            offset += self.char().len_utf8();","            self.pos.set(Position {","                offset: offset,","                line: line,","                column: column,","            });","            self.pattern[self.pos().offset..].chars().next().is_some()","        }","    }","","    let parser = TestParser::new(\"abc\");","    // Move to end of input","    for _ in 0..3 {","        parser.bump();","    }","    let result = parser.bump();","    assert!(!result);","    assert_eq!(parser.pos().line, 1);","    assert_eq!(parser.pos().column, 4);","    assert_eq!(parser.pos().offset, 3);","}"],[]]],"codes_branches":[{"start_line":482,"start_column":12,"end_line":482,"end_column":25,"positive":false,"negative":false},{"start_line":486,"start_column":12,"end_line":486,"end_column":31,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct DummyParser {","        pos: Cell<Position>,","        pattern: String,","    }","","    impl DummyParser {","        fn new(pattern: &str) -> Self {","            Self {","                pos: Cell::new(Position { offset: pattern.len(), line: 1, column: 1 }),","                pattern: pattern.to_string(),","            }","        }","","        fn pos(&self) -> Position {","            self.pos.get()","        }","","        fn is_eof(&self) -> bool {","            self.pos().offset >= self.pattern.len()","        }","","        fn char(&self) -> char {","            '\\0' // No character to return as we are at EOF","        }","","        fn bump(&self) -> bool {","            if self.is_eof() {","                return false;","            }","            // Note: The actual implementation details are irrelevant for this case","            true","        }","    }","","    let parser = DummyParser::new(\"abc\");","    assert_eq!(parser.bump(), false);","}"],[{"start_line":482,"start_column":12,"end_line":482,"end_column":25,"positive":false,"negative":false},{"start_line":486,"start_column":12,"end_line":486,"end_column":31,"positive":false,"negative":false}]],[["{","    struct TestParser {","        pos: Cell<Position>,","        pattern: String,","    }","","    impl TestParser {","        fn new(pattern: &str) -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                pattern: pattern.to_string(),","            }","        }","","        fn pos(&self) -> Position {","            self.pos.get()","        }","","        fn is_eof(&self) -> bool {","            self.pos.get().offset >= self.pattern.len()","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.get().offset).unwrap_or('\\0')","        }","","        fn bump(&self) -> bool {","            if self.is_eof() {","                return false;","            }","            let Position { mut offset, mut line, mut column } = self.pos();","            if self.char() == '\\n' {","                line = line.checked_add(1).unwrap();","                column = 1;","            } else {","                column = column.checked_add(1).unwrap();","            }","            offset += self.char().len_utf8();","            self.pos.set(Position {","                offset: offset,","                line: line,","                column: column,","            });","            self.pattern[self.pos().offset..].chars().next().is_some()","        }","    }","","    let parser = TestParser::new(\"abc\\ndef\");","    let result = parser.bump();","    assert!(result);","    assert_eq!(parser.pos().line, 1);","    assert_eq!(parser.pos().column, 4);","    assert_eq!(parser.pos().offset, 3);","}"],[{"start_line":482,"start_column":12,"end_line":482,"end_column":25,"positive":false,"negative":false},{"start_line":486,"start_column":12,"end_line":486,"end_column":31,"positive":false,"negative":false}]],[["{","    struct TestParser {","        pos: Cell<Position>,","        pattern: String,","    }","","    impl TestParser {","        fn new(pattern: &str) -> Self {","            Self {","                pos: Cell::new(Position { offset: pattern.len(), line: 1, column: 1 }),","                pattern: pattern.to_string(),","            }","        }","","        fn pos(&self) -> Position {","            self.pos.get()","        }","","        fn is_eof(&self) -> bool {","            self.pos.get().offset >= self.pattern.len()","        }","","        fn char(&self) -> char {","            self.pattern.chars().nth(self.pos.get().offset).unwrap_or('\\0')","        }","","        fn bump(&self) -> bool {","            if self.is_eof() {","                return false;","            }","            let Position { mut offset, mut line, mut column } = self.pos();","            if self.char() == '\\n' {","                line = line.checked_add(1).unwrap();","                column = 1;","            } else {","                column = column.checked_add(1).unwrap();","            }","            offset += self.char().len_utf8();","            self.pos.set(Position {","                offset: offset,","                line: line,","                column: column,","            });","            self.pattern[self.pos().offset..].chars().next().is_some()","        }","    }","","    let parser = TestParser::new(\"abc\");","    // Move to end of input","    for _ in 0..3 {","        parser.bump();","    }","    let result = parser.bump();","    assert!(!result);","    assert_eq!(parser.pos().line, 1);","    assert_eq!(parser.pos().column, 4);","    assert_eq!(parser.pos().offset, 3);","}"],[{"start_line":482,"start_column":12,"end_line":482,"end_column":25,"positive":false,"negative":false},{"start_line":486,"start_column":12,"end_line":486,"end_column":31,"positive":false,"negative":false}]]]}