{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_flags","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":11,"tests_lines":[69,36,36,40,64,59,62,70,68,56,93],"oracles":11,"oracles_compiled":1,"oracles_compiled_rate":9.090909090909092,"tests_compiled":1,"tests_compiled_rate":9.090909090909092,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":45,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":14,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1334,1335,1336,1337,1339,1340,1341,1342,1343,1344,1345,1346,1348,1349,1350,1351,1352,1353,1355,1356,1357,1358,1359,1360],"codes_lines_covered":[[["{","    struct MockParser {","        input: Vec<char>,","        pos: usize,","    }","","    impl MockParser {","        fn new(input: &str) -> Self {","            MockParser {","                input: input.chars().collect(),","                pos: 0,","            }","        }","","        fn char(&self) -> char {","            self.input[self.pos]","        }","","        fn bump(&mut self) -> bool {","            if self.pos < self.input.len() - 1 {","                self.pos += 1;","                true","            } else {","                false","            }","        }","","        fn span_char(&self) -> Span {","            Span {","                start: Position { offset: self.pos, line: 1, column: 1 },","                end: Position { offset: self.pos + 1, line: 1, column: 1 },","            }","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: self.input.iter().collect(), span }","        }","        ","        fn parse_flags(&mut self) -> Result<ast::Flags> {","            let mut flags = ast::Flags {","                span: self.span_char(),","                items: vec![],","            };","            let mut last_was_negation = None;","            while self.char() != ':' && self.char() != ')' {","                if self.char() == '-' {","                    last_was_negation = Some(self.span_char());","                    let item = ast::FlagsItem {","                        span: self.span_char(),","                        kind: ast::FlagsItemKind::Negation,","                    };","                    if let Some(i) = flags.add_item(item) {","                        return Err(self.error(","                            self.span_char(),","                            ast::ErrorKind::FlagRepeatedNegation { original: flags.items[i].span },","                        ));","                    }","                } else {","                    last_was_negation = None;","                    let item = ast::FlagsItem {","                        span: self.span_char(),","                        kind: ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive),","                    };","                    if let Some(i) = flags.add_item(item) {","                        return Err(self.error(","                            self.span_char(),","                            ast::ErrorKind::FlagDuplicate { original: flags.items[i].span },","                        ));","                    }","                }","                if !self.bump() {","                    return Err(self.error(","                        self.span_char(),","                        ast::ErrorKind::FlagUnexpectedEof,","                    ));","                }","            }","            if let Some(span) = last_was_negation {","                return Err(self.error(span, ast::ErrorKind::FlagDanglingNegation));","            }","            flags.span.end = flags.span.end; // dummy assignment for completion","            Ok(flags)","        }","    }","","    let mut parser = MockParser::new(\"-:\"); // Input that triggers dangling negation","    let result = parser.parse_flags();","    assert!(result.is_err());","    ","    if let Err(err) = result {","        assert_eq!(err.kind, ast::ErrorKind::FlagDanglingNegation);","    }","}"],[]]],"codes_branches":[{"start_line":1318,"start_column":15,"end_line":1318,"end_column":33,"positive":false,"negative":false},{"start_line":1318,"start_column":37,"end_line":1318,"end_column":55,"positive":false,"negative":false},{"start_line":1319,"start_column":16,"end_line":1319,"end_column":34,"positive":false,"negative":false},{"start_line":1325,"start_column":24,"end_line":1325,"end_column":31,"positive":false,"negative":false},{"start_line":1339,"start_column":24,"end_line":1339,"end_column":31,"positive":false,"negative":false},{"start_line":1348,"start_column":16,"end_line":1348,"end_column":28,"positive":false,"negative":false},{"start_line":1355,"start_column":16,"end_line":1355,"end_column":26,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockParser {","        input: Vec<char>,","        pos: usize,","    }","","    impl MockParser {","        fn new(input: &str) -> Self {","            MockParser {","                input: input.chars().collect(),","                pos: 0,","            }","        }","","        fn char(&self) -> char {","            self.input[self.pos]","        }","","        fn bump(&mut self) -> bool {","            if self.pos < self.input.len() - 1 {","                self.pos += 1;","                true","            } else {","                false","            }","        }","","        fn span_char(&self) -> Span {","            Span {","                start: Position { offset: self.pos, line: 1, column: 1 },","                end: Position { offset: self.pos + 1, line: 1, column: 1 },","            }","        }","","        fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error { kind, pattern: self.input.iter().collect(), span }","        }","        ","        fn parse_flags(&mut self) -> Result<ast::Flags> {","            let mut flags = ast::Flags {","                span: self.span_char(),","                items: vec![],","            };","            let mut last_was_negation = None;","            while self.char() != ':' && self.char() != ')' {","                if self.char() == '-' {","                    last_was_negation = Some(self.span_char());","                    let item = ast::FlagsItem {","                        span: self.span_char(),","                        kind: ast::FlagsItemKind::Negation,","                    };","                    if let Some(i) = flags.add_item(item) {","                        return Err(self.error(","                            self.span_char(),","                            ast::ErrorKind::FlagRepeatedNegation { original: flags.items[i].span },","                        ));","                    }","                } else {","                    last_was_negation = None;","                    let item = ast::FlagsItem {","                        span: self.span_char(),","                        kind: ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive),","                    };","                    if let Some(i) = flags.add_item(item) {","                        return Err(self.error(","                            self.span_char(),","                            ast::ErrorKind::FlagDuplicate { original: flags.items[i].span },","                        ));","                    }","                }","                if !self.bump() {","                    return Err(self.error(","                        self.span_char(),","                        ast::ErrorKind::FlagUnexpectedEof,","                    ));","                }","            }","            if let Some(span) = last_was_negation {","                return Err(self.error(span, ast::ErrorKind::FlagDanglingNegation));","            }","            flags.span.end = flags.span.end; // dummy assignment for completion","            Ok(flags)","        }","    }","","    let mut parser = MockParser::new(\"-:\"); // Input that triggers dangling negation","    let result = parser.parse_flags();","    assert!(result.is_err());","    ","    if let Err(err) = result {","        assert_eq!(err.kind, ast::ErrorKind::FlagDanglingNegation);","    }","}"],[{"start_line":1318,"start_column":15,"end_line":1318,"end_column":33,"positive":false,"negative":false},{"start_line":1318,"start_column":37,"end_line":1318,"end_column":55,"positive":false,"negative":false},{"start_line":1319,"start_column":16,"end_line":1319,"end_column":34,"positive":false,"negative":false},{"start_line":1325,"start_column":24,"end_line":1325,"end_column":31,"positive":false,"negative":false},{"start_line":1339,"start_column":24,"end_line":1339,"end_column":31,"positive":false,"negative":false},{"start_line":1348,"start_column":16,"end_line":1348,"end_column":28,"positive":false,"negative":false},{"start_line":1355,"start_column":16,"end_line":1355,"end_column":26,"positive":false,"negative":false}]]]}