{"function_name":"regex_syntax::hir::literal::hir::literal::Literals::all_complete","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":6,"tests_lines":[31,28,31,11,13,8],"oracles":6,"oracles_compiled":4,"oracles_compiled_rate":66.66666666666666,"tests_compiled":4,"tests_compiled_rate":66.66666666666666,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[143,144,145],"codes_lines_covered":[[["{","    struct LiteralMock {","        cut: bool,","    }","","    impl LiteralMock {","        fn is_cut(&self) -> bool {","            self.cut","        }","    }","","    struct LiteralsMock {","        lits: Vec<LiteralMock>,","    }","","    impl LiteralsMock {","        fn all_complete(&self) -> bool {","            !self.lits.is_empty() && self.lits.iter().all(|l| !l.is_cut())","        }","    }","","    // Test case where lits is non-empty and contains no cut literals","    let literals = LiteralsMock {","        lits: vec![","            LiteralMock { cut: false },","            LiteralMock { cut: false },","        ],","    };","    ","    assert!(literals.all_complete());","}"],[]],[["{","    struct LiteralMock {","        cut: bool,","    }","","    impl LiteralMock {","        fn is_cut(&self) -> bool {","            self.cut","        }","    }","","    struct LiteralsMock {","        lits: Vec<LiteralMock>,","    }","","    impl LiteralsMock {","        fn all_complete(&self) -> bool {","            !self.lits.is_empty() && self.lits.iter().all(|l| !l.is_cut())","        }","    }","","    // Test case where lits is empty","    let literals = LiteralsMock {","        lits: vec![],","    };","    ","    assert!(!literals.all_complete());","}"],[]],[["{","    struct LiteralMock {","        cut: bool,","    }","","    impl LiteralMock {","        fn is_cut(&self) -> bool {","            self.cut","        }","    }","","    struct LiteralsMock {","        lits: Vec<LiteralMock>,","    }","","    impl LiteralsMock {","        fn all_complete(&self) -> bool {","            !self.lits.is_empty() && self.lits.iter().all(|l| !l.is_cut())","        }","    }","","    // Test case where lits contains a cut literal","    let literals = LiteralsMock {","        lits: vec![","            LiteralMock { cut: false },","            LiteralMock { cut: true },","        ],","    };","    ","    assert!(!literals.all_complete());","}"],[]],[["{","    let literals = Literals {","        lits: Vec::new(),","        limit_size: 10,","        limit_class: 1,","    };","    assert!(!literals.all_complete());","}"],[143,144,145]]],"codes_branches":[{"start_line":144,"start_column":9,"end_line":144,"end_column":30,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    struct LiteralMock {","        cut: bool,","    }","","    impl LiteralMock {","        fn is_cut(&self) -> bool {","            self.cut","        }","    }","","    struct LiteralsMock {","        lits: Vec<LiteralMock>,","    }","","    impl LiteralsMock {","        fn all_complete(&self) -> bool {","            !self.lits.is_empty() && self.lits.iter().all(|l| !l.is_cut())","        }","    }","","    // Test case where lits is non-empty and contains no cut literals","    let literals = LiteralsMock {","        lits: vec![","            LiteralMock { cut: false },","            LiteralMock { cut: false },","        ],","    };","    ","    assert!(literals.all_complete());","}"],[{"start_line":144,"start_column":9,"end_line":144,"end_column":30,"positive":false,"negative":false}]],[["{","    struct LiteralMock {","        cut: bool,","    }","","    impl LiteralMock {","        fn is_cut(&self) -> bool {","            self.cut","        }","    }","","    struct LiteralsMock {","        lits: Vec<LiteralMock>,","    }","","    impl LiteralsMock {","        fn all_complete(&self) -> bool {","            !self.lits.is_empty() && self.lits.iter().all(|l| !l.is_cut())","        }","    }","","    // Test case where lits is empty","    let literals = LiteralsMock {","        lits: vec![],","    };","    ","    assert!(!literals.all_complete());","}"],[{"start_line":144,"start_column":9,"end_line":144,"end_column":30,"positive":false,"negative":false}]],[["{","    struct LiteralMock {","        cut: bool,","    }","","    impl LiteralMock {","        fn is_cut(&self) -> bool {","            self.cut","        }","    }","","    struct LiteralsMock {","        lits: Vec<LiteralMock>,","    }","","    impl LiteralsMock {","        fn all_complete(&self) -> bool {","            !self.lits.is_empty() && self.lits.iter().all(|l| !l.is_cut())","        }","    }","","    // Test case where lits contains a cut literal","    let literals = LiteralsMock {","        lits: vec![","            LiteralMock { cut: false },","            LiteralMock { cut: true },","        ],","    };","    ","    assert!(!literals.all_complete());","}"],[{"start_line":144,"start_column":9,"end_line":144,"end_column":30,"positive":false,"negative":false}]],[["{","    let literals = Literals {","        lits: Vec::new(),","        limit_size: 10,","        limit_class: 1,","    };","    assert!(!literals.all_complete());","}"],[{"start_line":144,"start_column":9,"end_line":144,"end_column":30,"positive":false,"negative":true}]]]}