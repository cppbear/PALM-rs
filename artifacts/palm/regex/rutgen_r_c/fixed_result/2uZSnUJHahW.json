{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_hex_brace","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":19,"tests_lines":[61,30,37,32,54,53,53,49,49,66,103,64,63,63,57,49,45,48,43],"oracles":19,"oracles_compiled":1,"oracles_compiled_rate":5.263157894736842,"tests_compiled":1,"tests_compiled_rate":5.263157894736842,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":45,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":10,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1691],"codes_lines_covered":[[["{","    struct MockParser {","        scratch: RefCell<String>,","        pos: Cell<Position>,","        input: &'static str,","        index: usize,","    }","","    impl MockParser {","        fn new(input: &'static str) -> Self {","            MockParser {","                scratch: RefCell::new(String::new()),","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                input,","                index: 0,","            }","        }","","        // Implement bump_and_bump_space, char, is_eof, and error as before","","        // Simulate parsing where the hex representation is empty","        fn parse_hex_brace(&mut self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            // Assuming this simulates the branch where hex is empty.","            Ok(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 0, line: 1, column: 1 }), kind: ast::LiteralKind::HexBrace(kind), c: ' ' })","        }","    }","","    let mut parser = MockParser::new(\"{\");","    parser.parse_hex_brace(ast::HexLiteralKind::X); // This should panic","}"],[]]],"codes_branches":[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":false,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":false,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockParser {","        scratch: RefCell<String>,","        pos: Cell<Position>,","        input: &'static str,","        index: usize,","    }","","    impl MockParser {","        fn new(input: &'static str) -> Self {","            MockParser {","                scratch: RefCell::new(String::new()),","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                input,","                index: 0,","            }","        }","","        // Implement bump_and_bump_space, char, is_eof, and error as before","","        // Simulate parsing where the hex representation is empty","        fn parse_hex_brace(&mut self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            // Assuming this simulates the branch where hex is empty.","            Ok(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 0, line: 1, column: 1 }), kind: ast::LiteralKind::HexBrace(kind), c: ' ' })","        }","    }","","    let mut parser = MockParser::new(\"{\");","    parser.parse_hex_brace(ast::HexLiteralKind::X); // This should panic","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":false,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":false,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]]]}