{"function_name":"regex::literal::literal::BoyerMooreSearch::check_match","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":10,"tests_lines":[38,33,32,19,19,20,9,9,9,9],"oracles":10,"oracles_compiled":10,"oracles_compiled_rate":100.0,"tests_compiled":10,"tests_compiled_rate":100.0,"oracles_run":10,"oracles_passed":6,"oracles_passed_rate":60.0,"tests_run":10,"tests_passed":6,"tests_passed_rate":60.0,"lines":14,"lines_covered":13,"lines_coveraged_rate":92.85714285714286,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[746,747,748,749,750,751,752,753,754,755,756,757,760,761],"codes_lines_covered":[[["{","    struct TestBoyerMooreSearch {","        guard: u8,","        guard_reverse_idx: usize,","        pattern: Vec<u8>,","    }","","    impl TestBoyerMooreSearch {","        fn check_match(&self, haystack: &[u8], window_end: usize) -> bool {","            // guard test","            if haystack[window_end - self.guard_reverse_idx] != self.guard {","                return false;","            }","","            // match loop","            let window_start = window_end - (self.pattern.len() - 1);","            for i in 0..self.pattern.len() {","                if self.pattern[i] != haystack[window_start + i] {","                    return false;","                }","            }","","            true","        }","    }","","    let pattern = b\"abc\".to_vec();","    let guard = b'z'; // selecting a guard that is not in the haystack","    let search = TestBoyerMooreSearch {","        guard,","        guard_reverse_idx: 1,","        pattern: pattern.clone(),","    };","","    let haystack = b\"xyzabc\";","    let window_end = haystack.len(); // Position at the end of haystack","    assert_eq!(search.check_match(haystack, window_end), false);","}"],[]],[["{","    struct TestBoyerMooreSearch {","        pattern: Vec<u8>,","        guard: u8,","        guard_reverse_idx: usize,","    }","    ","    impl BoyerMooreSearch {","        fn new_test(pattern: Vec<u8>) -> Self {","            let guard = pattern[0];","            let guard_reverse_idx = 0;","            let skip_table = vec![0; pattern.len()];","            let md2_shift = 0;","            BoyerMooreSearch {","                pattern,","                skip_table,","                guard,","                guard_reverse_idx,","                md2_shift,","            }","        }","    }","","    let pattern = b\"abc\".to_vec();    ","    let haystack = b\"abcdxyz\";","    let window_end = 3;","","    let bms = BoyerMooreSearch::new_test(pattern);","    ","    // The guard condition is satisfied since the last character checked is 'c'","    // which matches the guard, and this pattern does not match the haystack.","    assert_eq!(bms.check_match(haystack, window_end), false);","}"],[746,747,748,749,761]],[["{","    struct TestBoyerMooreSearch {","        pattern: Vec<u8>,","        guard: u8,","        guard_reverse_idx: usize,","    }","    ","    impl BoyerMooreSearch {","        fn new_test(pattern: Vec<u8>) -> Self {","            let guard = pattern[0];","            let guard_reverse_idx = 0;","            let skip_table = vec![0; pattern.len()];","            let md2_shift = 0;","            BoyerMooreSearch {","                pattern,","                skip_table,","                guard,","                guard_reverse_idx,","                md2_shift,","            }","        }","    }","","    let pattern = b\"xyz\".to_vec();    ","    let haystack = b\"abcdefgzyx\";","    let window_end = 10; // To check against the 'z'","","    let bms = BoyerMooreSearch::new_test(pattern);","","    // In this case, the guard is 'x' but the characters don't match the pattern.","    assert_eq!(bms.check_match(haystack, window_end), false);","}"],[746,747,748,750,751,752,753,754]],[["{","    struct TestBoyerMooreSearch {","        boyer_moore: BoyerMooreSearch,","    }","","    impl TestBoyerMooreSearch {","        fn new(pattern: Vec<u8>) -> Self {","            TestBoyerMooreSearch {","                boyer_moore: BoyerMooreSearch::new(pattern),","            }","        }","    }","","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xxabcxx\";","    let searcher = TestBoyerMooreSearch::new(pattern.clone());","","    assert!(searcher.boyer_moore.check_match(haystack, 5)); // 5 is the index of 'c'","}"],[746,747,748,749,761]],[["{","    struct TestBoyerMooreSearch {","        boyer_moore: BoyerMooreSearch,","    }","","    impl TestBoyerMooreSearch {","        fn new(pattern: Vec<u8>) -> Self {","            TestBoyerMooreSearch {","                boyer_moore: BoyerMooreSearch::new(pattern),","            }","        }","    }","","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xxabcyy\";","    let searcher = TestBoyerMooreSearch::new(pattern.clone());","","    assert!(!searcher.boyer_moore.check_match(haystack, 6)); // 6 is the index of 'y'","}"],[746,747,748,749,761]],[["{","    struct TestBoyerMooreSearch {","        boyer_moore: BoyerMooreSearch,","    }","","    impl TestBoyerMooreSearch {","        fn new(pattern: Vec<u8>) -> Self {","            TestBoyerMooreSearch {","                boyer_moore: BoyerMooreSearch::new(pattern),","            }","        }","    }","","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xxabcxx\";","    let searcher = TestBoyerMooreSearch::new(pattern.clone());","","    // This should panic because the window_end is too small","    searcher.boyer_moore.check_match(haystack, 2); // 2 is an invalid index in this context","}"],[746,747,748,749,761]],[["{","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xyzabc\".to_vec();","    let window_end = 5; // points to the last character 'c' in \"xyzabc\"","    ","    let bms = BoyerMooreSearch::new(pattern.clone());","    ","    assert_eq!(bms.check_match(&haystack, window_end), true);","}"],[746,747,748,750,751,752,753,754,755,757,760,761]],[["{","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xyzabc\".to_vec();","    let window_end = 6; // out of bounds; haystack[window_end - 1] should equal 'c', but it will access haystack[5]","    ","    let bms = BoyerMooreSearch::new(pattern.clone());","","    assert_eq!(bms.check_match(&haystack, window_end), false);","}"],[746,747,748,749,761]],[["{","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xyzdef\".to_vec();","    let window_end = 6; // haystack ends; no match","    ","    let bms = BoyerMooreSearch::new(pattern.clone());","","    assert_eq!(bms.check_match(&haystack, window_end), false);","}"],[746,747,748,749,761]],[["{","    let pattern = b\"\".to_vec();","    let haystack = b\"xyzabc\".to_vec();","    let window_end = 3; // Ensure we don't panic on empty pattern","    ","    let bms = BoyerMooreSearch::new(pattern.clone());","","    assert_eq!(bms.check_match(&haystack, window_end), false);","}"],[]]],"codes_branches":[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":true,"negative":true},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    struct TestBoyerMooreSearch {","        guard: u8,","        guard_reverse_idx: usize,","        pattern: Vec<u8>,","    }","","    impl TestBoyerMooreSearch {","        fn check_match(&self, haystack: &[u8], window_end: usize) -> bool {","            // guard test","            if haystack[window_end - self.guard_reverse_idx] != self.guard {","                return false;","            }","","            // match loop","            let window_start = window_end - (self.pattern.len() - 1);","            for i in 0..self.pattern.len() {","                if self.pattern[i] != haystack[window_start + i] {","                    return false;","                }","            }","","            true","        }","    }","","    let pattern = b\"abc\".to_vec();","    let guard = b'z'; // selecting a guard that is not in the haystack","    let search = TestBoyerMooreSearch {","        guard,","        guard_reverse_idx: 1,","        pattern: pattern.clone(),","    };","","    let haystack = b\"xyzabc\";","    let window_end = haystack.len(); // Position at the end of haystack","    assert_eq!(search.check_match(haystack, window_end), false);","}"],[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":false,"negative":false},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":false}]],[["{","    struct TestBoyerMooreSearch {","        pattern: Vec<u8>,","        guard: u8,","        guard_reverse_idx: usize,","    }","    ","    impl BoyerMooreSearch {","        fn new_test(pattern: Vec<u8>) -> Self {","            let guard = pattern[0];","            let guard_reverse_idx = 0;","            let skip_table = vec![0; pattern.len()];","            let md2_shift = 0;","            BoyerMooreSearch {","                pattern,","                skip_table,","                guard,","                guard_reverse_idx,","                md2_shift,","            }","        }","    }","","    let pattern = b\"abc\".to_vec();    ","    let haystack = b\"abcdxyz\";","    let window_end = 3;","","    let bms = BoyerMooreSearch::new_test(pattern);","    ","    // The guard condition is satisfied since the last character checked is 'c'","    // which matches the guard, and this pattern does not match the haystack.","    assert_eq!(bms.check_match(haystack, window_end), false);","}"],[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":true,"negative":false},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":false}]],[["{","    struct TestBoyerMooreSearch {","        pattern: Vec<u8>,","        guard: u8,","        guard_reverse_idx: usize,","    }","    ","    impl BoyerMooreSearch {","        fn new_test(pattern: Vec<u8>) -> Self {","            let guard = pattern[0];","            let guard_reverse_idx = 0;","            let skip_table = vec![0; pattern.len()];","            let md2_shift = 0;","            BoyerMooreSearch {","                pattern,","                skip_table,","                guard,","                guard_reverse_idx,","                md2_shift,","            }","        }","    }","","    let pattern = b\"xyz\".to_vec();    ","    let haystack = b\"abcdefgzyx\";","    let window_end = 10; // To check against the 'z'","","    let bms = BoyerMooreSearch::new_test(pattern);","","    // In this case, the guard is 'x' but the characters don't match the pattern.","    assert_eq!(bms.check_match(haystack, window_end), false);","}"],[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":false,"negative":true},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":false}]],[["{","    struct TestBoyerMooreSearch {","        boyer_moore: BoyerMooreSearch,","    }","","    impl TestBoyerMooreSearch {","        fn new(pattern: Vec<u8>) -> Self {","            TestBoyerMooreSearch {","                boyer_moore: BoyerMooreSearch::new(pattern),","            }","        }","    }","","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xxabcxx\";","    let searcher = TestBoyerMooreSearch::new(pattern.clone());","","    assert!(searcher.boyer_moore.check_match(haystack, 5)); // 5 is the index of 'c'","}"],[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":true,"negative":false},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":false}]],[["{","    struct TestBoyerMooreSearch {","        boyer_moore: BoyerMooreSearch,","    }","","    impl TestBoyerMooreSearch {","        fn new(pattern: Vec<u8>) -> Self {","            TestBoyerMooreSearch {","                boyer_moore: BoyerMooreSearch::new(pattern),","            }","        }","    }","","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xxabcyy\";","    let searcher = TestBoyerMooreSearch::new(pattern.clone());","","    assert!(!searcher.boyer_moore.check_match(haystack, 6)); // 6 is the index of 'y'","}"],[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":true,"negative":false},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":false}]],[["{","    struct TestBoyerMooreSearch {","        boyer_moore: BoyerMooreSearch,","    }","","    impl TestBoyerMooreSearch {","        fn new(pattern: Vec<u8>) -> Self {","            TestBoyerMooreSearch {","                boyer_moore: BoyerMooreSearch::new(pattern),","            }","        }","    }","","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xxabcxx\";","    let searcher = TestBoyerMooreSearch::new(pattern.clone());","","    // This should panic because the window_end is too small","    searcher.boyer_moore.check_match(haystack, 2); // 2 is an invalid index in this context","}"],[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":true,"negative":false},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":false}]],[["{","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xyzabc\".to_vec();","    let window_end = 5; // points to the last character 'c' in \"xyzabc\"","    ","    let bms = BoyerMooreSearch::new(pattern.clone());","    ","    assert_eq!(bms.check_match(&haystack, window_end), true);","}"],[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":false,"negative":true},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":true}]],[["{","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xyzabc\".to_vec();","    let window_end = 6; // out of bounds; haystack[window_end - 1] should equal 'c', but it will access haystack[5]","    ","    let bms = BoyerMooreSearch::new(pattern.clone());","","    assert_eq!(bms.check_match(&haystack, window_end), false);","}"],[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":true,"negative":false},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":false}]],[["{","    let pattern = b\"abc\".to_vec();","    let haystack = b\"xyzdef\".to_vec();","    let window_end = 6; // haystack ends; no match","    ","    let bms = BoyerMooreSearch::new(pattern.clone());","","    assert_eq!(bms.check_match(&haystack, window_end), false);","}"],[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":true,"negative":false},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":false}]],[["{","    let pattern = b\"\".to_vec();","    let haystack = b\"xyzabc\".to_vec();","    let window_end = 3; // Ensure we don't panic on empty pattern","    ","    let bms = BoyerMooreSearch::new(pattern.clone());","","    assert_eq!(bms.check_match(&haystack, window_end), false);","}"],[{"start_line":748,"start_column":12,"end_line":748,"end_column":71,"positive":false,"negative":false},{"start_line":755,"start_column":16,"end_line":755,"end_column":61,"positive":false,"negative":false}]]]}