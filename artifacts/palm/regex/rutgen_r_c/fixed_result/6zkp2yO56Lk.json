{"function_name":"regex_syntax::hir::hir::Hir::alternation","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":18,"tests_lines":[5,7,15,21,5,6,24,32,5,6,14,11,10,17,5,6,12,13],"oracles":18,"oracles_compiled":8,"oracles_compiled_rate":44.44444444444444,"tests_compiled":8,"tests_compiled_rate":44.44444444444444,"oracles_run":8,"oracles_passed":7,"oracles_passed_rate":87.5,"tests_run":8,"tests_passed":7,"tests_passed_rate":87.5,"lines":36,"lines_covered":36,"lines_coveraged_rate":100.0,"branches":14,"branches_covered":12,"branches_coverage_rate":85.71428571428571,"codes_lines":[432,433,434,435,437,438,439,440,441,442,443,444,447,448,449,451,452,454,455,457,458,460,461,462,463,465,466,467,468,470,471,473,474,475,476,479],"codes_lines_covered":[[["{","    let exprs: Vec<Hir> = Vec::new();","    let result = Hir::alternation(exprs);","    assert_eq!(result.kind, HirKind::Empty);","}"],[432,433,434,479]],[["{","    let exprs: Vec<Hir> = Vec::new();","    let result = Hir::alternation(exprs);","    assert_eq!(result.kind, HirKind::Empty);","}"],[432,433,434,479]],[["{","    let single_expr = Hir::empty();","    let exprs = vec![single_expr];","    let result = Hir::alternation(exprs);","    assert!(matches!(result.kind, HirKind::Empty));","}"],[432,433,435,479]],[["{","    let expr1 = Hir::empty();","    let expr2 = Hir::empty(); // This would be a very simple Hir representation.","    let exprs = vec![expr1.clone(), expr2.clone()];","    ","    let result = Hir::alternation(exprs.clone());","    ","    match &result.kind {","        HirKind::Alternation(kind_exprs) => {","            assert_eq!(kind_exprs.len(), 2);","            assert_eq!(kind_exprs[0].kind, expr1.kind);","            assert_eq!(kind_exprs[1].kind, expr2.kind);","        },","        _ => panic!(\"Expected Alternation kind\"),","    }","","    assert!(result.is_always_utf8());","    assert!(result.is_all_assertions());","    assert!(result.is_anchored_start());","    assert!(result.is_anchored_end());","    assert!(!result.is_any_anchored_start());","    assert!(!result.is_any_anchored_end());","    assert!(!result.is_match_empty());","}"],[432,433,437,438,439,440,441,442,443,444,447,448,449,451,452,454,455,457,458,460,461,462,463,465,466,467,468,470,471,473,474,475,476,479]],[["{","    // Create HIR that doesn't set all the attributes to true.","    let mut info1 = HirInfo::new();","    info1.set_always_utf8(false);","    ","    let mut info2 = HirInfo::new();","    info2.set_always_utf8(false);","    ","    let expr1 = Hir { kind: HirKind::Empty, info: info1 };","    let expr2 = Hir { kind: HirKind::Empty, info: info2 };","    ","    let exprs = vec![expr1.clone(), expr2.clone()];","    ","    let result = Hir::alternation(exprs.clone());","    ","    match &result.kind {","        HirKind::Alternation(kind_exprs) => {","            assert_eq!(kind_exprs.len(), 2);","            assert_eq!(kind_exprs[0].info.is_always_utf8(), false);","            assert_eq!(kind_exprs[1].info.is_always_utf8(), false);","        },","        _ => panic!(\"Expected Alternation kind\"),","    }","    ","    assert!(!result.is_always_utf8());","    assert!(!result.is_all_assertions());","    assert!(!result.is_anchored_start());","    assert!(!result.is_anchored_end());","    assert!(!result.is_any_anchored_start());","    assert!(!result.is_any_anchored_end());","    assert!(!result.is_match_empty());","}"],[432,433,437,438,439,440,441,442,443,444,447,448,449,451,452,454,455,457,458,460,461,462,463,465,466,467,468,470,471,473,474,475,476,479]],[["{","    let exprs: Vec<Hir> = vec![];","    let result = Hir::alternation(exprs);","    assert_eq!(result.kind, HirKind::Empty);","}"],[432,433,434,479]],[["{","    // Test with an empty expression (this should return empty Hir)","    let exprs: Vec<Hir> = vec![];","    let result = Hir::alternation(exprs);","    ","    match result.kind() {","        HirKind::Empty => {}, // Check that the result is of kind Empty","        _ => panic!(\"Expected an Empty kind\"),","    }","}"],[432,433,434,479]],[["{","    let exprs: Vec<Hir> = vec![];","    let result = Hir::alternation(exprs);","    assert_eq!(result.kind(), &HirKind::Empty);","}"],[432,433,434,479]]],"codes_branches":[{"start_line":448,"start_column":29,"end_line":448,"end_column":50,"positive":true,"negative":true},{"start_line":451,"start_column":29,"end_line":451,"end_column":53,"positive":true,"negative":true},{"start_line":454,"start_column":29,"end_line":454,"end_column":53,"positive":true,"negative":true},{"start_line":457,"start_column":29,"end_line":457,"end_column":51,"positive":true,"negative":true},{"start_line":461,"start_column":25,"end_line":461,"end_column":53,"positive":false,"negative":true},{"start_line":466,"start_column":25,"end_line":466,"end_column":51,"positive":false,"negative":true},{"start_line":470,"start_column":29,"end_line":470,"end_column":50,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let exprs: Vec<Hir> = Vec::new();","    let result = Hir::alternation(exprs);","    assert_eq!(result.kind, HirKind::Empty);","}"],[{"start_line":448,"start_column":29,"end_line":448,"end_column":50,"positive":false,"negative":false},{"start_line":451,"start_column":29,"end_line":451,"end_column":53,"positive":false,"negative":false},{"start_line":454,"start_column":29,"end_line":454,"end_column":53,"positive":false,"negative":false},{"start_line":457,"start_column":29,"end_line":457,"end_column":51,"positive":false,"negative":false},{"start_line":461,"start_column":25,"end_line":461,"end_column":53,"positive":false,"negative":false},{"start_line":466,"start_column":25,"end_line":466,"end_column":51,"positive":false,"negative":false},{"start_line":470,"start_column":29,"end_line":470,"end_column":50,"positive":false,"negative":false}]],[["{","    let exprs: Vec<Hir> = Vec::new();","    let result = Hir::alternation(exprs);","    assert_eq!(result.kind, HirKind::Empty);","}"],[{"start_line":448,"start_column":29,"end_line":448,"end_column":50,"positive":false,"negative":false},{"start_line":451,"start_column":29,"end_line":451,"end_column":53,"positive":false,"negative":false},{"start_line":454,"start_column":29,"end_line":454,"end_column":53,"positive":false,"negative":false},{"start_line":457,"start_column":29,"end_line":457,"end_column":51,"positive":false,"negative":false},{"start_line":461,"start_column":25,"end_line":461,"end_column":53,"positive":false,"negative":false},{"start_line":466,"start_column":25,"end_line":466,"end_column":51,"positive":false,"negative":false},{"start_line":470,"start_column":29,"end_line":470,"end_column":50,"positive":false,"negative":false}]],[["{","    let single_expr = Hir::empty();","    let exprs = vec![single_expr];","    let result = Hir::alternation(exprs);","    assert!(matches!(result.kind, HirKind::Empty));","}"],[{"start_line":448,"start_column":29,"end_line":448,"end_column":50,"positive":false,"negative":false},{"start_line":451,"start_column":29,"end_line":451,"end_column":53,"positive":false,"negative":false},{"start_line":454,"start_column":29,"end_line":454,"end_column":53,"positive":false,"negative":false},{"start_line":457,"start_column":29,"end_line":457,"end_column":51,"positive":false,"negative":false},{"start_line":461,"start_column":25,"end_line":461,"end_column":53,"positive":false,"negative":false},{"start_line":466,"start_column":25,"end_line":466,"end_column":51,"positive":false,"negative":false},{"start_line":470,"start_column":29,"end_line":470,"end_column":50,"positive":false,"negative":false}]],[["{","    let expr1 = Hir::empty();","    let expr2 = Hir::empty(); // This would be a very simple Hir representation.","    let exprs = vec![expr1.clone(), expr2.clone()];","    ","    let result = Hir::alternation(exprs.clone());","    ","    match &result.kind {","        HirKind::Alternation(kind_exprs) => {","            assert_eq!(kind_exprs.len(), 2);","            assert_eq!(kind_exprs[0].kind, expr1.kind);","            assert_eq!(kind_exprs[1].kind, expr2.kind);","        },","        _ => panic!(\"Expected Alternation kind\"),","    }","","    assert!(result.is_always_utf8());","    assert!(result.is_all_assertions());","    assert!(result.is_anchored_start());","    assert!(result.is_anchored_end());","    assert!(!result.is_any_anchored_start());","    assert!(!result.is_any_anchored_end());","    assert!(!result.is_match_empty());","}"],[{"start_line":448,"start_column":29,"end_line":448,"end_column":50,"positive":true,"negative":false},{"start_line":451,"start_column":29,"end_line":451,"end_column":53,"positive":true,"negative":false},{"start_line":454,"start_column":29,"end_line":454,"end_column":53,"positive":true,"negative":true},{"start_line":457,"start_column":29,"end_line":457,"end_column":51,"positive":true,"negative":true},{"start_line":461,"start_column":25,"end_line":461,"end_column":53,"positive":false,"negative":true},{"start_line":466,"start_column":25,"end_line":466,"end_column":51,"positive":false,"negative":true},{"start_line":470,"start_column":29,"end_line":470,"end_column":50,"positive":true,"negative":true}]],[["{","    // Create HIR that doesn't set all the attributes to true.","    let mut info1 = HirInfo::new();","    info1.set_always_utf8(false);","    ","    let mut info2 = HirInfo::new();","    info2.set_always_utf8(false);","    ","    let expr1 = Hir { kind: HirKind::Empty, info: info1 };","    let expr2 = Hir { kind: HirKind::Empty, info: info2 };","    ","    let exprs = vec![expr1.clone(), expr2.clone()];","    ","    let result = Hir::alternation(exprs.clone());","    ","    match &result.kind {","        HirKind::Alternation(kind_exprs) => {","            assert_eq!(kind_exprs.len(), 2);","            assert_eq!(kind_exprs[0].info.is_always_utf8(), false);","            assert_eq!(kind_exprs[1].info.is_always_utf8(), false);","        },","        _ => panic!(\"Expected Alternation kind\"),","    }","    ","    assert!(!result.is_always_utf8());","    assert!(!result.is_all_assertions());","    assert!(!result.is_anchored_start());","    assert!(!result.is_anchored_end());","    assert!(!result.is_any_anchored_start());","    assert!(!result.is_any_anchored_end());","    assert!(!result.is_match_empty());","}"],[{"start_line":448,"start_column":29,"end_line":448,"end_column":50,"positive":true,"negative":true},{"start_line":451,"start_column":29,"end_line":451,"end_column":53,"positive":true,"negative":true},{"start_line":454,"start_column":29,"end_line":454,"end_column":53,"positive":true,"negative":true},{"start_line":457,"start_column":29,"end_line":457,"end_column":51,"positive":true,"negative":true},{"start_line":461,"start_column":25,"end_line":461,"end_column":53,"positive":false,"negative":true},{"start_line":466,"start_column":25,"end_line":466,"end_column":51,"positive":false,"negative":true},{"start_line":470,"start_column":29,"end_line":470,"end_column":50,"positive":false,"negative":true}]],[["{","    let exprs: Vec<Hir> = vec![];","    let result = Hir::alternation(exprs);","    assert_eq!(result.kind, HirKind::Empty);","}"],[{"start_line":448,"start_column":29,"end_line":448,"end_column":50,"positive":false,"negative":false},{"start_line":451,"start_column":29,"end_line":451,"end_column":53,"positive":false,"negative":false},{"start_line":454,"start_column":29,"end_line":454,"end_column":53,"positive":false,"negative":false},{"start_line":457,"start_column":29,"end_line":457,"end_column":51,"positive":false,"negative":false},{"start_line":461,"start_column":25,"end_line":461,"end_column":53,"positive":false,"negative":false},{"start_line":466,"start_column":25,"end_line":466,"end_column":51,"positive":false,"negative":false},{"start_line":470,"start_column":29,"end_line":470,"end_column":50,"positive":false,"negative":false}]],[["{","    // Test with an empty expression (this should return empty Hir)","    let exprs: Vec<Hir> = vec![];","    let result = Hir::alternation(exprs);","    ","    match result.kind() {","        HirKind::Empty => {}, // Check that the result is of kind Empty","        _ => panic!(\"Expected an Empty kind\"),","    }","}"],[{"start_line":448,"start_column":29,"end_line":448,"end_column":50,"positive":false,"negative":false},{"start_line":451,"start_column":29,"end_line":451,"end_column":53,"positive":false,"negative":false},{"start_line":454,"start_column":29,"end_line":454,"end_column":53,"positive":false,"negative":false},{"start_line":457,"start_column":29,"end_line":457,"end_column":51,"positive":false,"negative":false},{"start_line":461,"start_column":25,"end_line":461,"end_column":53,"positive":false,"negative":false},{"start_line":466,"start_column":25,"end_line":466,"end_column":51,"positive":false,"negative":false},{"start_line":470,"start_column":29,"end_line":470,"end_column":50,"positive":false,"negative":false}]],[["{","    let exprs: Vec<Hir> = vec![];","    let result = Hir::alternation(exprs);","    assert_eq!(result.kind(), &HirKind::Empty);","}"],[{"start_line":448,"start_column":29,"end_line":448,"end_column":50,"positive":false,"negative":false},{"start_line":451,"start_column":29,"end_line":451,"end_column":53,"positive":false,"negative":false},{"start_line":454,"start_column":29,"end_line":454,"end_column":53,"positive":false,"negative":false},{"start_line":457,"start_column":29,"end_line":457,"end_column":51,"positive":false,"negative":false},{"start_line":461,"start_column":25,"end_line":461,"end_column":53,"positive":false,"negative":false},{"start_line":466,"start_column":25,"end_line":466,"end_column":51,"positive":false,"negative":false},{"start_line":470,"start_column":29,"end_line":470,"end_column":50,"positive":false,"negative":false}]]]}