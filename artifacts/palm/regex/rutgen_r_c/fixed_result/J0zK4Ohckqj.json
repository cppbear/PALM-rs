{"function_name":"regex_syntax::error::error::Spans<'p>::notate","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/error.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":10,"tests_lines":[101,101,101,100,18,18,19,23,92,89],"oracles":10,"oracles_compiled":1,"oracles_compiled_rate":10.0,"tests_compiled":1,"tests_compiled_rate":10.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":17,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,227,228],"codes_lines_covered":[[["{","    use ast::Span;","","    struct TestSpans<'p> {","        pattern: &'p str,","        line_number_width: usize,","        by_line: Vec<Vec<Span>>,","        multi_line: Vec<Span>,","    }","","    impl<'p> TestSpans<'p> {","        fn new(","            pattern: &'p str,","            line_number_width: usize,","            by_line: Vec<Vec<Span>>,","            multi_line: Vec<Span>,","        ) -> Self {","            TestSpans {","                pattern,","                line_number_width,","                by_line,","                multi_line,","            }","        }","","        fn left_pad_line_number(&self, n: usize) -> String {","            let n = n.to_string();","            let pad = self.line_number_width.checked_sub(n.len()).unwrap_or(0);","            let mut result = \" \".repeat(pad);","            result.push_str(&n);","            result","        }","","        fn notate_line(&self, i: usize) -> Option<String> {","            let spans = &self.by_line[i];","            if spans.is_empty() {","                return None;","            }","            let mut notes = String::new();","            for _ in 0..self.line_number_width {","                notes.push(' ');","            }","            let mut pos = 0;","            for span in spans {","                for _ in pos..(span.start.column - 1) {","                    notes.push(' ');","                    pos += 1;","                }","                let note_len = span.end.column.saturating_sub(span.start.column);","                for _ in 0..cmp::max(1, note_len) {","                    notes.push('^');","                    pos += 1;","                }","            }","            Some(notes)","        }","","        fn notate(&self) -> String {","            let mut notated = String::new();","            for (i, line) in self.pattern.lines().enumerate() {","                if self.line_number_width > 0 {","                    notated.push_str(&self.left_pad_line_number(i + 1));","                    notated.push_str(\": \");","                } else {","                    notated.push_str(\"    \");","                }","                notated.push_str(line);","                notated.push('\\n');","                if let Some(notes) = self.notate_line(i) {","                    notated.push_str(&notes);","                    notated.push('\\n');","                }","            }","            notated","        }","    }","","    // Example test case with no spans","    let pattern = \"single line pattern\";","    let line_number_width = 2;","    let by_line = vec![vec![]]; // No spans for the line","    let multi_line: Vec<Span> = vec![];","","    let spans = TestSpans::new(pattern, line_number_width, by_line, multi_line);","    ","    let expected_notation = \" 1: single line pattern\\n\";","    ","    assert_eq!(spans.notate(), expected_notation);","}"],[]]],"codes_branches":[{"start_line":214,"start_column":16,"end_line":214,"end_column":42,"positive":false,"negative":false},{"start_line":222,"start_column":20,"end_line":222,"end_column":31,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    use ast::Span;","","    struct TestSpans<'p> {","        pattern: &'p str,","        line_number_width: usize,","        by_line: Vec<Vec<Span>>,","        multi_line: Vec<Span>,","    }","","    impl<'p> TestSpans<'p> {","        fn new(","            pattern: &'p str,","            line_number_width: usize,","            by_line: Vec<Vec<Span>>,","            multi_line: Vec<Span>,","        ) -> Self {","            TestSpans {","                pattern,","                line_number_width,","                by_line,","                multi_line,","            }","        }","","        fn left_pad_line_number(&self, n: usize) -> String {","            let n = n.to_string();","            let pad = self.line_number_width.checked_sub(n.len()).unwrap_or(0);","            let mut result = \" \".repeat(pad);","            result.push_str(&n);","            result","        }","","        fn notate_line(&self, i: usize) -> Option<String> {","            let spans = &self.by_line[i];","            if spans.is_empty() {","                return None;","            }","            let mut notes = String::new();","            for _ in 0..self.line_number_width {","                notes.push(' ');","            }","            let mut pos = 0;","            for span in spans {","                for _ in pos..(span.start.column - 1) {","                    notes.push(' ');","                    pos += 1;","                }","                let note_len = span.end.column.saturating_sub(span.start.column);","                for _ in 0..cmp::max(1, note_len) {","                    notes.push('^');","                    pos += 1;","                }","            }","            Some(notes)","        }","","        fn notate(&self) -> String {","            let mut notated = String::new();","            for (i, line) in self.pattern.lines().enumerate() {","                if self.line_number_width > 0 {","                    notated.push_str(&self.left_pad_line_number(i + 1));","                    notated.push_str(\": \");","                } else {","                    notated.push_str(\"    \");","                }","                notated.push_str(line);","                notated.push('\\n');","                if let Some(notes) = self.notate_line(i) {","                    notated.push_str(&notes);","                    notated.push('\\n');","                }","            }","            notated","        }","    }","","    // Example test case with no spans","    let pattern = \"single line pattern\";","    let line_number_width = 2;","    let by_line = vec![vec![]]; // No spans for the line","    let multi_line: Vec<Span> = vec![];","","    let spans = TestSpans::new(pattern, line_number_width, by_line, multi_line);","    ","    let expected_notation = \" 1: single line pattern\\n\";","    ","    assert_eq!(spans.notate(), expected_notation);","}"],[{"start_line":214,"start_column":16,"end_line":214,"end_column":42,"positive":false,"negative":false},{"start_line":222,"start_column":20,"end_line":222,"end_column":31,"positive":false,"negative":false}]]]}