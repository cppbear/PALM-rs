{"function_name":"regex_syntax::ast::parse::ast::parse::Parser::reset","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":2,"tests_lines":[63,42],"oracles":2,"oracles_compiled":1,"oracles_compiled_rate":50.0,"tests_compiled":1,"tests_compiled_rate":50.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":9,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[362,363,364,365,366,367,368,369,370],"codes_lines_covered":[[["{","    struct Parser {","        pos: Cell<Position>,","        initial_ignore_whitespace: bool,","        ignore_whitespace: Cell<bool>,","        comments: RefCell<Vec<ast::Comment>>,","        stack_group: RefCell<Vec<GroupState>>,","        stack_class: RefCell<Vec<ClassState>>,","    }","","    impl Parser {","        fn new(initial_ignore_whitespace: bool) -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                initial_ignore_whitespace,","                ignore_whitespace: Cell::new(initial_ignore_whitespace),","                comments: RefCell::new(vec![]),","                stack_group: RefCell::new(vec![]),","                stack_class: RefCell::new(vec![]),","            }","        }","","        fn reset(&self) {","            self.pos.set(Position { offset: 0, line: 1, column: 1 });","            self.ignore_whitespace.set(self.initial_ignore_whitespace);","            self.comments.borrow_mut().clear();","            self.stack_group.borrow_mut().clear();","            self.stack_class.borrow_mut().clear();","        }","    }","","    let parser = Parser::new(true);","","    // Verify initial state","    assert_eq!(parser.ignore_whitespace.get(), true);","","    // Call reset","    parser.reset();","","    // After reset, should reflect initial_whitespace","    assert_eq!(parser.ignore_whitespace.get(), true);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Parser {","        pos: Cell<Position>,","        initial_ignore_whitespace: bool,","        ignore_whitespace: Cell<bool>,","        comments: RefCell<Vec<ast::Comment>>,","        stack_group: RefCell<Vec<GroupState>>,","        stack_class: RefCell<Vec<ClassState>>,","    }","","    impl Parser {","        fn new(initial_ignore_whitespace: bool) -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                initial_ignore_whitespace,","                ignore_whitespace: Cell::new(initial_ignore_whitespace),","                comments: RefCell::new(vec![]),","                stack_group: RefCell::new(vec![]),","                stack_class: RefCell::new(vec![]),","            }","        }","","        fn reset(&self) {","            self.pos.set(Position { offset: 0, line: 1, column: 1 });","            self.ignore_whitespace.set(self.initial_ignore_whitespace);","            self.comments.borrow_mut().clear();","            self.stack_group.borrow_mut().clear();","            self.stack_class.borrow_mut().clear();","        }","    }","","    let parser = Parser::new(true);","","    // Verify initial state","    assert_eq!(parser.ignore_whitespace.get(), true);","","    // Call reset","    parser.reset();","","    // After reset, should reflect initial_whitespace","    assert_eq!(parser.ignore_whitespace.get(), true);","}"],[]]]}