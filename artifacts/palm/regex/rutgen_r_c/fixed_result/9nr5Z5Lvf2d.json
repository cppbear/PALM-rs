{"function_name":"regex::compile::compile::CompileClass<'a, 'b>::compile","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/compile.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":10,"tests_lines":[47,39,21,10,20,18,15,15,11,12],"oracles":10,"oracles_compiled":4,"oracles_compiled_rate":40.0,"tests_compiled":4,"tests_compiled_rate":40.0,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":4,"tests_passed":2,"tests_passed_rate":50.0,"lines":36,"lines_covered":35,"lines_coveraged_rate":97.22222222222221,"branches":8,"branches_covered":5,"branches_coverage_rate":62.5,"codes_lines":[875,876,877,878,879,880,882,883,884,885,887,888,889,890,891,892,893,894,895,896,897,898,900,901,902,903,904,905,906,907,911,912,913,914,915,916],"codes_lines_covered":[[["{","    let mut compiler = Compiler::new();","    let ranges = [","       hir::ClassUnicodeRange::new('a', 'b'),","       hir::ClassUnicodeRange::new('c', 'd'),","   ];","    ","   let utf8_seqs = Utf8Sequences::new('\\x00', '\\x00');  ","   compiler.utf8_seqs = Some(utf8_seqs);  ","","    let compile_class = CompileClass { c: &mut compiler, ranges: &ranges };","    let result = compile_class.compile();","","    match result {","        Ok(Patch { hole, entry }) => {","            assert!(matches!(hole, Hole::Many(_)));","            assert!(entry >= 0);","        },","        Err(_) => panic!(\"Expected Ok but got an Err\"),","    }","}"],[875,876,877,878,879,880,882,883,884,885,887,888,889,890,891,892,893,894,895,896,898,900,901,902,903,904,905,906,907,911,912,913,914,915,916]],[["{","    let mut compiler = Compiler::new();","    let ranges = [","   hir::ClassUnicodeRange::new('a', 'b'),  ","   hir::ClassUnicodeRange::new('c', 'd'),  ","    ];","    let mut utf8_seqs = Utf8Sequences::new('\\x00', '\\x00');","    compiler.utf8_seqs = Some(utf8_seqs);","","    let compile_class = CompileClass { c: &mut compiler, ranges: &ranges };","    let result = compile_class.compile();","","    match result {","        Ok(Patch { hole, entry }) => {","            assert!(matches!(hole, Hole::Many(_)));","            assert!(entry >= 0);","        },","        Err(_) => panic!(\"Expected Ok but got an Err\"),","    }","}"],[875,876,877,878,879,880,882,883,884,885,887,888,889,890,891,892,893,894,895,896,898,900,901,902,903,904,905,906,907,911,912,913,914,915,916]],[["{","    let mut compiler = Compiler::new();","    let ranges: Vec<hir::ClassUnicodeRange> = vec![];","    let mut utf8_seqs = Utf8Sequences::new('\\x00', '\\x00');","    compiler.utf8_seqs = Some(utf8_seqs);","","    let compile_class = CompileClass { c: &mut compiler, ranges: &ranges };","    ","    let result = compile_class.compile();","    ","    match result {","        Ok(Patch { hole, entry }) => {","            assert!(matches!(hole, Hole::Many(_)));","            assert!(entry >= 0);","        },","        Err(_) => panic!(\"Expected Ok but got an Err\"),","    }","}"],[875,876,877,878,879,880,882,911,912,913,914,915,916]],[["{","    struct TestHir;","","    let mut compiler = Compiler::new();","    let ranges: Vec<hir::ClassUnicodeRange> = vec![];","","    let compile_class = CompileClass { c: &mut compiler, ranges: &ranges };","    let result = compile_class.compile();","","    assert!(result.is_ok());","    if let Ok(Patch { hole, entry }) = result {","        assert!(matches!(hole, Hole::Many(h) if h.is_empty()));","        assert_eq!(entry, 0);","    }","}"],[875,876,877,878,879,880,882,911,912,913,914,915,916]]],"codes_branches":[{"start_line":891,"start_column":20,"end_line":891,"end_column":33,"positive":true,"negative":true},{"start_line":891,"start_column":37,"end_line":891,"end_column":56,"positive":true,"negative":false},{"start_line":896,"start_column":24,"end_line":896,"end_column":47,"positive":false,"negative":true},{"start_line":900,"start_column":24,"end_line":900,"end_column":47,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    let mut compiler = Compiler::new();","    let ranges = [","       hir::ClassUnicodeRange::new('a', 'b'),","       hir::ClassUnicodeRange::new('c', 'd'),","   ];","    ","   let utf8_seqs = Utf8Sequences::new('\\x00', '\\x00');  ","   compiler.utf8_seqs = Some(utf8_seqs);  ","","    let compile_class = CompileClass { c: &mut compiler, ranges: &ranges };","    let result = compile_class.compile();","","    match result {","        Ok(Patch { hole, entry }) => {","            assert!(matches!(hole, Hole::Many(_)));","            assert!(entry >= 0);","        },","        Err(_) => panic!(\"Expected Ok but got an Err\"),","    }","}"],[{"start_line":891,"start_column":20,"end_line":891,"end_column":33,"positive":true,"negative":true},{"start_line":891,"start_column":37,"end_line":891,"end_column":56,"positive":true,"negative":false},{"start_line":896,"start_column":24,"end_line":896,"end_column":47,"positive":false,"negative":true},{"start_line":900,"start_column":24,"end_line":900,"end_column":47,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let ranges = [","   hir::ClassUnicodeRange::new('a', 'b'),  ","   hir::ClassUnicodeRange::new('c', 'd'),  ","    ];","    let mut utf8_seqs = Utf8Sequences::new('\\x00', '\\x00');","    compiler.utf8_seqs = Some(utf8_seqs);","","    let compile_class = CompileClass { c: &mut compiler, ranges: &ranges };","    let result = compile_class.compile();","","    match result {","        Ok(Patch { hole, entry }) => {","            assert!(matches!(hole, Hole::Many(_)));","            assert!(entry >= 0);","        },","        Err(_) => panic!(\"Expected Ok but got an Err\"),","    }","}"],[{"start_line":891,"start_column":20,"end_line":891,"end_column":33,"positive":true,"negative":true},{"start_line":891,"start_column":37,"end_line":891,"end_column":56,"positive":true,"negative":false},{"start_line":896,"start_column":24,"end_line":896,"end_column":47,"positive":false,"negative":true},{"start_line":900,"start_column":24,"end_line":900,"end_column":47,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let ranges: Vec<hir::ClassUnicodeRange> = vec![];","    let mut utf8_seqs = Utf8Sequences::new('\\x00', '\\x00');","    compiler.utf8_seqs = Some(utf8_seqs);","","    let compile_class = CompileClass { c: &mut compiler, ranges: &ranges };","    ","    let result = compile_class.compile();","    ","    match result {","        Ok(Patch { hole, entry }) => {","            assert!(matches!(hole, Hole::Many(_)));","            assert!(entry >= 0);","        },","        Err(_) => panic!(\"Expected Ok but got an Err\"),","    }","}"],[{"start_line":891,"start_column":20,"end_line":891,"end_column":33,"positive":false,"negative":false},{"start_line":891,"start_column":37,"end_line":891,"end_column":56,"positive":false,"negative":false},{"start_line":896,"start_column":24,"end_line":896,"end_column":47,"positive":false,"negative":false},{"start_line":900,"start_column":24,"end_line":900,"end_column":47,"positive":false,"negative":false}]],[["{","    struct TestHir;","","    let mut compiler = Compiler::new();","    let ranges: Vec<hir::ClassUnicodeRange> = vec![];","","    let compile_class = CompileClass { c: &mut compiler, ranges: &ranges };","    let result = compile_class.compile();","","    assert!(result.is_ok());","    if let Ok(Patch { hole, entry }) = result {","        assert!(matches!(hole, Hole::Many(h) if h.is_empty()));","        assert_eq!(entry, 0);","    }","}"],[{"start_line":891,"start_column":20,"end_line":891,"end_column":33,"positive":false,"negative":false},{"start_line":891,"start_column":37,"end_line":891,"end_column":56,"positive":false,"negative":false},{"start_line":896,"start_column":24,"end_line":896,"end_column":47,"positive":false,"negative":false},{"start_line":900,"start_column":24,"end_line":900,"end_column":47,"positive":false,"negative":false}]]]}