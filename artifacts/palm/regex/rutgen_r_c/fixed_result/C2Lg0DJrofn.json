{"function_name":"regex::dfa::dfa::Fsm<'a>::has_prefix","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":8,"tests_lines":[41,41,41,32,32,32,32,47],"oracles":8,"oracles_compiled":4,"oracles_compiled_rate":50.0,"tests_compiled":4,"tests_compiled_rate":50.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1572,1573,1574,1575,1576],"codes_lines_covered":[[["{","    struct MockMatcher;","    ","    struct MockLiterals;","","    impl MockMatcher {","        fn empty() -> Self {","            MockMatcher","        }","    }","","    struct MockProgram {","        is_reverse: bool,","        prefixes: MockLiterals,","        is_anchored_start: bool,","    }","","    impl MockLiterals {","        fn is_empty(&self) -> bool {","            true","        }","    }","","    let program = MockProgram {","        is_reverse: false,","        prefixes: MockLiterals,","        is_anchored_start: false,","    };","","    let result = !program.is_reverse && !program.prefixes.is_empty() && !program.is_anchored_start;","    assert_eq!(result, false);","}"],[]],[["{","    struct MockMatcher;","    ","    struct MockLiterals;","","    impl MockMatcher {","        fn empty() -> Self {","            MockMatcher","        }","    }","","    struct MockProgram {","        is_reverse: bool,","        prefixes: MockLiterals,","        is_anchored_start: bool,","    }","","    impl MockLiterals {","        fn is_empty(&self) -> bool {","            false","        }","    }","","    let program = MockProgram {","        is_reverse: false,","        prefixes: MockLiterals,","        is_anchored_start: false,","    };","","    let result = !program.is_reverse && !program.prefixes.is_empty() && !program.is_anchored_start;","    assert_eq!(result, true);","}"],[]],[["{","    struct MockMatcher;","    ","    struct MockLiterals;","","    impl MockMatcher {","        fn empty() -> Self {","            MockMatcher","        }","    }","","    struct MockProgram {","        is_reverse: bool,","        prefixes: MockLiterals,","        is_anchored_start: bool,","    }","","    impl MockLiterals {","        fn is_empty(&self) -> bool {","            true","        }","    }","","    let program = MockProgram {","        is_reverse: true,","        prefixes: MockLiterals,","        is_anchored_start: false,","    };","","    let result = !program.is_reverse && !program.prefixes.is_empty() && !program.is_anchored_start;","    assert_eq!(result, false);","}"],[]],[["{","    struct MockMatcher;","    ","    struct MockLiterals;","","    impl MockMatcher {","        fn empty() -> Self {","            MockMatcher","        }","    }","","    struct MockProgram {","        is_reverse: bool,","        prefixes: MockLiterals,","        is_anchored_start: bool,","    }","","    impl MockLiterals {","        fn is_empty(&self) -> bool {","            false","        }","    }","","    let program = MockProgram {","        is_reverse: false,","        prefixes: MockLiterals,","        is_anchored_start: true,","    };","","    let result = !program.is_reverse && !program.prefixes.is_empty() && !program.is_anchored_start;","    assert_eq!(result, false);","}"],[]]],"codes_branches":[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockMatcher;","    ","    struct MockLiterals;","","    impl MockMatcher {","        fn empty() -> Self {","            MockMatcher","        }","    }","","    struct MockProgram {","        is_reverse: bool,","        prefixes: MockLiterals,","        is_anchored_start: bool,","    }","","    impl MockLiterals {","        fn is_empty(&self) -> bool {","            true","        }","    }","","    let program = MockProgram {","        is_reverse: false,","        prefixes: MockLiterals,","        is_anchored_start: false,","    };","","    let result = !program.is_reverse && !program.prefixes.is_empty() && !program.is_anchored_start;","    assert_eq!(result, false);","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]],[["{","    struct MockMatcher;","    ","    struct MockLiterals;","","    impl MockMatcher {","        fn empty() -> Self {","            MockMatcher","        }","    }","","    struct MockProgram {","        is_reverse: bool,","        prefixes: MockLiterals,","        is_anchored_start: bool,","    }","","    impl MockLiterals {","        fn is_empty(&self) -> bool {","            false","        }","    }","","    let program = MockProgram {","        is_reverse: false,","        prefixes: MockLiterals,","        is_anchored_start: false,","    };","","    let result = !program.is_reverse && !program.prefixes.is_empty() && !program.is_anchored_start;","    assert_eq!(result, true);","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]],[["{","    struct MockMatcher;","    ","    struct MockLiterals;","","    impl MockMatcher {","        fn empty() -> Self {","            MockMatcher","        }","    }","","    struct MockProgram {","        is_reverse: bool,","        prefixes: MockLiterals,","        is_anchored_start: bool,","    }","","    impl MockLiterals {","        fn is_empty(&self) -> bool {","            true","        }","    }","","    let program = MockProgram {","        is_reverse: true,","        prefixes: MockLiterals,","        is_anchored_start: false,","    };","","    let result = !program.is_reverse && !program.prefixes.is_empty() && !program.is_anchored_start;","    assert_eq!(result, false);","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]],[["{","    struct MockMatcher;","    ","    struct MockLiterals;","","    impl MockMatcher {","        fn empty() -> Self {","            MockMatcher","        }","    }","","    struct MockProgram {","        is_reverse: bool,","        prefixes: MockLiterals,","        is_anchored_start: bool,","    }","","    impl MockLiterals {","        fn is_empty(&self) -> bool {","            false","        }","    }","","    let program = MockProgram {","        is_reverse: false,","        prefixes: MockLiterals,","        is_anchored_start: true,","    };","","    let result = !program.is_reverse && !program.prefixes.is_empty() && !program.is_anchored_start;","    assert_eq!(result, false);","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]]]}