{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_capture_name","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":20,"tests_lines":[47,62,57,57,57,66,40,53,57,36,58,65,54,51,53,53,65,61,67,94],"oracles":20,"oracles_compiled":1,"oracles_compiled_rate":5.0,"tests_compiled":1,"tests_compiled_rate":5.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":47,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":12,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296],"codes_lines_covered":[[["{","    struct MockParser {","        pattern: String,","        pos: Position,","        eof: bool,","        current_char: char,","    }","","    impl MockParser {","        fn new(pattern: &str) -> Self {","            Self {","                pattern: pattern.to_string(),","                pos: Position { offset: 0, line: 1, column: 1 },","                eof: false,","                current_char: '<', // Simulate being at the starting point of a capture name","            }","        }","","        fn is_eof(&self) -> bool {","            self.eof","        }","","        fn char(&self) -> char {","            self.current_char","        }","","        fn bump(&mut self) -> bool {","            if self.pos.offset < self.pattern.len() {","                self.pos.offset += 1;","                if self.pos.offset < self.pattern.len() {","                    self.current_char = self.pattern[self.pos.offset..].chars().next().unwrap();","                    true","                } else {","                    self.eof = true;","                    false","                }","            } else {","                self.eof = true;","                false","            }","        }","","        fn span_char(&self) -> Span {","            Span::new(self.pos, self.pos) // Mock span using current position","        }","","        fn error(&self, _span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind,","                pattern: self.pattern.clone(),","                span: self.span_char(),","            }","        }","","        fn parse_capture_name(&mut self, capture_index: u32) -> Result<ast::CaptureName> {","            if self.is_eof() {","                return Err(self.error(self.span_char(), ast::ErrorKind::GroupNameUnexpectedEof));","            }","            let start = self.pos;","            while self.char() != '>' {","                if !is_capture_char(self.char(), self.pos.offset == start.offset) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::GroupNameInvalid));","                }","                if !self.bump() {","                    break;","                }","            }","            let end = self.pos;","            if self.is_eof() {","                return Err(self.error(self.span_char(), ast::ErrorKind::GroupNameUnexpectedEof));","            }","            assert_eq!(self.char(), '>');","            self.bump();","            let name = &self.pattern[start.offset..end.offset];","            if name.is_empty() {","                return Err(self.error(Span::new(start, start), ast::ErrorKind::GroupNameEmpty));","            }","            Ok(ast::CaptureName {","                span: Span::new(start, end),","                name: name.to_string(),","                index: capture_index,","            })","        }","    }","    ","    let mut parser = MockParser::new(\"<1\");","    parser.bump(); // Move past '<'","    parser.current_char = '1'; // Simulate an invalid character for capture name","    let result = parser.parse_capture_name(0);","    assert!(result.is_err());","    if let Err(error) = result {","        assert_eq!(error.kind, ast::ErrorKind::GroupNameInvalid);","    }","}"],[]]],"codes_branches":[{"start_line":1252,"start_column":12,"end_line":1252,"end_column":25,"positive":false,"negative":false},{"start_line":1260,"start_column":16,"end_line":1260,"end_column":34,"positive":false,"negative":false},{"start_line":1263,"start_column":16,"end_line":1263,"end_column":66,"positive":false,"negative":false},{"start_line":1269,"start_column":16,"end_line":1269,"end_column":28,"positive":false,"negative":false},{"start_line":1274,"start_column":12,"end_line":1274,"end_column":25,"positive":false,"negative":false},{"start_line":1283,"start_column":12,"end_line":1283,"end_column":27,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockParser {","        pattern: String,","        pos: Position,","        eof: bool,","        current_char: char,","    }","","    impl MockParser {","        fn new(pattern: &str) -> Self {","            Self {","                pattern: pattern.to_string(),","                pos: Position { offset: 0, line: 1, column: 1 },","                eof: false,","                current_char: '<', // Simulate being at the starting point of a capture name","            }","        }","","        fn is_eof(&self) -> bool {","            self.eof","        }","","        fn char(&self) -> char {","            self.current_char","        }","","        fn bump(&mut self) -> bool {","            if self.pos.offset < self.pattern.len() {","                self.pos.offset += 1;","                if self.pos.offset < self.pattern.len() {","                    self.current_char = self.pattern[self.pos.offset..].chars().next().unwrap();","                    true","                } else {","                    self.eof = true;","                    false","                }","            } else {","                self.eof = true;","                false","            }","        }","","        fn span_char(&self) -> Span {","            Span::new(self.pos, self.pos) // Mock span using current position","        }","","        fn error(&self, _span: Span, kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind,","                pattern: self.pattern.clone(),","                span: self.span_char(),","            }","        }","","        fn parse_capture_name(&mut self, capture_index: u32) -> Result<ast::CaptureName> {","            if self.is_eof() {","                return Err(self.error(self.span_char(), ast::ErrorKind::GroupNameUnexpectedEof));","            }","            let start = self.pos;","            while self.char() != '>' {","                if !is_capture_char(self.char(), self.pos.offset == start.offset) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::GroupNameInvalid));","                }","                if !self.bump() {","                    break;","                }","            }","            let end = self.pos;","            if self.is_eof() {","                return Err(self.error(self.span_char(), ast::ErrorKind::GroupNameUnexpectedEof));","            }","            assert_eq!(self.char(), '>');","            self.bump();","            let name = &self.pattern[start.offset..end.offset];","            if name.is_empty() {","                return Err(self.error(Span::new(start, start), ast::ErrorKind::GroupNameEmpty));","            }","            Ok(ast::CaptureName {","                span: Span::new(start, end),","                name: name.to_string(),","                index: capture_index,","            })","        }","    }","    ","    let mut parser = MockParser::new(\"<1\");","    parser.bump(); // Move past '<'","    parser.current_char = '1'; // Simulate an invalid character for capture name","    let result = parser.parse_capture_name(0);","    assert!(result.is_err());","    if let Err(error) = result {","        assert_eq!(error.kind, ast::ErrorKind::GroupNameInvalid);","    }","}"],[{"start_line":1252,"start_column":12,"end_line":1252,"end_column":25,"positive":false,"negative":false},{"start_line":1260,"start_column":16,"end_line":1260,"end_column":34,"positive":false,"negative":false},{"start_line":1263,"start_column":16,"end_line":1263,"end_column":66,"positive":false,"negative":false},{"start_line":1269,"start_column":16,"end_line":1269,"end_column":28,"positive":false,"negative":false},{"start_line":1274,"start_column":12,"end_line":1274,"end_column":25,"positive":false,"negative":false},{"start_line":1283,"start_column":12,"end_line":1283,"end_column":27,"positive":false,"negative":false}]]]}