{"function_name":"regex::dfa::dfa::CacheInner::reset_size","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[17,17,17,17],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[450,451,452,453,454],"codes_lines_covered":[[["{","    let mut cache = CacheInner {","        compiled: HashMap::new(),","        trans: Transitions {","            table: Vec::new(),","            num_byte_classes: 0,","        },","        states: Vec::new(),","        start_states: Vec::new(),","        stack: Vec::new(),","        flush_count: 0,","        size: 0,","    };","    ","    cache.reset_size();","    assert_eq!(cache.size, 0);","}"],[450,451,452,453,454]],[["{","    let mut cache = CacheInner {","        compiled: HashMap::new(),","        trans: Transitions {","            table: Vec::new(),","            num_byte_classes: 0,","        },","        states: Vec::new(),","        start_states: vec![1, 2, 3], // 3 start states","        stack: Vec::new(),","        flush_count: 0,","        size: 0,","    };","    ","    cache.reset_size();","    assert_eq!(cache.size, 3 * std::mem::size_of::<StatePtr>());","}"],[450,451,452,453,454]],[["{","    let mut cache = CacheInner {","        compiled: HashMap::new(),","        trans: Transitions {","            table: Vec::new(),","            num_byte_classes: 0,","        },","        states: Vec::new(),","        start_states: Vec::new(),","        stack: vec![1, 2, 3], // 3 inst pointers","        flush_count: 0,","        size: 0,","    };","    ","    cache.reset_size();","    assert_eq!(cache.size, 3 * std::mem::size_of::<InstPtr>());","}"],[450,451,452,453,454]],[["{","    let mut cache = CacheInner {","        compiled: HashMap::new(),","        trans: Transitions {","            table: Vec::new(),","            num_byte_classes: 0,","        },","        states: Vec::new(),","        start_states: vec![1, 2, 3], // 3 start states","        stack: vec![1, 2, 3, 4], // 4 inst pointers","        flush_count: 0,","        size: 0,","    };","    ","    cache.reset_size();","    assert_eq!(cache.size, (3 * std::mem::size_of::<StatePtr>()) + (4 * std::mem::size_of::<InstPtr>()));","}"],[450,451,452,453,454]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut cache = CacheInner {","        compiled: HashMap::new(),","        trans: Transitions {","            table: Vec::new(),","            num_byte_classes: 0,","        },","        states: Vec::new(),","        start_states: Vec::new(),","        stack: Vec::new(),","        flush_count: 0,","        size: 0,","    };","    ","    cache.reset_size();","    assert_eq!(cache.size, 0);","}"],[]],[["{","    let mut cache = CacheInner {","        compiled: HashMap::new(),","        trans: Transitions {","            table: Vec::new(),","            num_byte_classes: 0,","        },","        states: Vec::new(),","        start_states: vec![1, 2, 3], // 3 start states","        stack: Vec::new(),","        flush_count: 0,","        size: 0,","    };","    ","    cache.reset_size();","    assert_eq!(cache.size, 3 * std::mem::size_of::<StatePtr>());","}"],[]],[["{","    let mut cache = CacheInner {","        compiled: HashMap::new(),","        trans: Transitions {","            table: Vec::new(),","            num_byte_classes: 0,","        },","        states: Vec::new(),","        start_states: Vec::new(),","        stack: vec![1, 2, 3], // 3 inst pointers","        flush_count: 0,","        size: 0,","    };","    ","    cache.reset_size();","    assert_eq!(cache.size, 3 * std::mem::size_of::<InstPtr>());","}"],[]],[["{","    let mut cache = CacheInner {","        compiled: HashMap::new(),","        trans: Transitions {","            table: Vec::new(),","            num_byte_classes: 0,","        },","        states: Vec::new(),","        start_states: vec![1, 2, 3], // 3 start states","        stack: vec![1, 2, 3, 4], // 4 inst pointers","        flush_count: 0,","        size: 0,","    };","    ","    cache.reset_size();","    assert_eq!(cache.size, (3 * std::mem::size_of::<StatePtr>()) + (4 * std::mem::size_of::<InstPtr>()));","}"],[]]]}