{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_set_class_range","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":23,"tests_lines":[24,24,20,17,56,57,57,57,72,22,54,23,25,18,33,28,27,29,28,98,94,79,58],"oracles":23,"oracles_compiled":4,"oracles_compiled_rate":17.391304347826086,"tests_compiled":4,"tests_compiled_rate":17.391304347826086,"oracles_run":4,"oracles_passed":1,"oracles_passed_rate":25.0,"tests_run":4,"tests_passed":1,"tests_passed_rate":25.0,"lines":34,"lines_covered":24,"lines_coveraged_rate":70.58823529411765,"branches":12,"branches_covered":5,"branches_coverage_rate":41.66666666666667,"codes_lines":[1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1825,1826,1827,1828,1829,1830,1831,1832],"codes_lines_covered":[[["{","    struct TestParser {","        eof: bool,","    }","","    impl TestParser {","        fn is_eof(&self) -> bool {","            self.eof","        }","","        fn parse_set_class_range(&self) -> Result<ast::ClassSetItem> {","            if self.is_eof() {","                panic!(\"Unexpected EOF encountered.\"); // Trigger panic","            }","","            Ok(ast::ClassSetItem::Empty(Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 0, line: 1, column: 2 })))","        }","    }","","    let parser = TestParser { eof: true };","    parser.parse_set_class_range();","}"],[]],[["{","    struct TestParser;","    ","    impl Borrow<Parser> for TestParser {","        fn borrow(&self) -> &Parser {","            // Provide a mock Parser object if needed.","            unimplemented!()","        }","    }","","    let parser = ParserI {","        parser: TestParser,","        pattern: \"a-b\",","    };","    ","    let result = parser.parse_set_class_range();","    assert!(result.is_ok());","","    if let Ok(ast::ClassSetItem::Range(range)) = result {","        assert_eq!(range.start.c, 'a');","        assert_eq!(range.end.c, 'b');","    }","}"],[1797,1798,1799,1800,1802,1803,1804,1805,1806,1807,1808,1809,1810,1813,1814,1815,1816,1818,1819,1820,1821,1822,1823,1825]],[["{","    struct TestParser {","        eof: bool,","    }","","    impl Borrow<Parser> for TestParser {","        fn borrow(&self) -> &Parser {","            unimplemented!()","        }","    }","","    impl TestParser {","        fn is_eof(&self) -> bool {","            self.eof","        }","    }","    ","    let parser = ParserI {","        parser: TestParser { eof: true },","        pattern: \"a-\",","    };","","    let result = parser.parse_set_class_range();","    assert!(result.is_err());","}"],[1797,1798,1799,1800,1802,1803,1804,1805,1806,1807,1808,1809,1810,1813,1814,1815,1816,1818,1819,1820,1821,1822,1823,1825]],[["{","    struct TestParser;","","    impl Borrow<Parser> for TestParser {","        fn borrow(&self) -> &Parser {","            unimplemented!()","        }","    }","","    let parser = ParserI {","        parser: TestParser,","        pattern: \"b-a\", // Invalid range where start > end","    };","","    let result = parser.parse_set_class_range();","    assert!(result.is_err());","    // Check specific error kind for ClassRangeInvalid if possible.","}"],[1797,1798,1799,1800,1802,1803,1804,1805,1806,1807,1808,1809,1810,1813,1814,1815,1816,1818,1819,1820,1821,1822,1823,1825]]],"codes_branches":[{"start_line":1800,"start_column":12,"end_line":1800,"end_column":25,"positive":false,"negative":true},{"start_line":1808,"start_column":12,"end_line":1808,"end_column":30,"positive":false,"negative":true},{"start_line":1809,"start_column":16,"end_line":1809,"end_column":46,"positive":false,"negative":true},{"start_line":1810,"start_column":16,"end_line":1810,"end_column":46,"positive":false,"negative":true},{"start_line":1816,"start_column":12,"end_line":1816,"end_column":39,"positive":false,"negative":true},{"start_line":1825,"start_column":12,"end_line":1825,"end_column":29,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestParser {","        eof: bool,","    }","","    impl TestParser {","        fn is_eof(&self) -> bool {","            self.eof","        }","","        fn parse_set_class_range(&self) -> Result<ast::ClassSetItem> {","            if self.is_eof() {","                panic!(\"Unexpected EOF encountered.\"); // Trigger panic","            }","","            Ok(ast::ClassSetItem::Empty(Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 0, line: 1, column: 2 })))","        }","    }","","    let parser = TestParser { eof: true };","    parser.parse_set_class_range();","}"],[{"start_line":1800,"start_column":12,"end_line":1800,"end_column":25,"positive":false,"negative":false},{"start_line":1808,"start_column":12,"end_line":1808,"end_column":30,"positive":false,"negative":false},{"start_line":1809,"start_column":16,"end_line":1809,"end_column":46,"positive":false,"negative":false},{"start_line":1810,"start_column":16,"end_line":1810,"end_column":46,"positive":false,"negative":false},{"start_line":1816,"start_column":12,"end_line":1816,"end_column":39,"positive":false,"negative":false},{"start_line":1825,"start_column":12,"end_line":1825,"end_column":29,"positive":false,"negative":false}]],[["{","    struct TestParser;","    ","    impl Borrow<Parser> for TestParser {","        fn borrow(&self) -> &Parser {","            // Provide a mock Parser object if needed.","            unimplemented!()","        }","    }","","    let parser = ParserI {","        parser: TestParser,","        pattern: \"a-b\",","    };","    ","    let result = parser.parse_set_class_range();","    assert!(result.is_ok());","","    if let Ok(ast::ClassSetItem::Range(range)) = result {","        assert_eq!(range.start.c, 'a');","        assert_eq!(range.end.c, 'b');","    }","}"],[{"start_line":1800,"start_column":12,"end_line":1800,"end_column":25,"positive":false,"negative":true},{"start_line":1808,"start_column":12,"end_line":1808,"end_column":30,"positive":false,"negative":true},{"start_line":1809,"start_column":16,"end_line":1809,"end_column":46,"positive":false,"negative":true},{"start_line":1810,"start_column":16,"end_line":1810,"end_column":46,"positive":false,"negative":true},{"start_line":1816,"start_column":12,"end_line":1816,"end_column":39,"positive":false,"negative":true},{"start_line":1825,"start_column":12,"end_line":1825,"end_column":29,"positive":false,"negative":false}]],[["{","    struct TestParser {","        eof: bool,","    }","","    impl Borrow<Parser> for TestParser {","        fn borrow(&self) -> &Parser {","            unimplemented!()","        }","    }","","    impl TestParser {","        fn is_eof(&self) -> bool {","            self.eof","        }","    }","    ","    let parser = ParserI {","        parser: TestParser { eof: true },","        pattern: \"a-\",","    };","","    let result = parser.parse_set_class_range();","    assert!(result.is_err());","}"],[{"start_line":1800,"start_column":12,"end_line":1800,"end_column":25,"positive":false,"negative":true},{"start_line":1808,"start_column":12,"end_line":1808,"end_column":30,"positive":false,"negative":true},{"start_line":1809,"start_column":16,"end_line":1809,"end_column":46,"positive":false,"negative":true},{"start_line":1810,"start_column":16,"end_line":1810,"end_column":46,"positive":false,"negative":true},{"start_line":1816,"start_column":12,"end_line":1816,"end_column":39,"positive":false,"negative":true},{"start_line":1825,"start_column":12,"end_line":1825,"end_column":29,"positive":false,"negative":false}]],[["{","    struct TestParser;","","    impl Borrow<Parser> for TestParser {","        fn borrow(&self) -> &Parser {","            unimplemented!()","        }","    }","","    let parser = ParserI {","        parser: TestParser,","        pattern: \"b-a\", // Invalid range where start > end","    };","","    let result = parser.parse_set_class_range();","    assert!(result.is_err());","    // Check specific error kind for ClassRangeInvalid if possible.","}"],[{"start_line":1800,"start_column":12,"end_line":1800,"end_column":25,"positive":false,"negative":true},{"start_line":1808,"start_column":12,"end_line":1808,"end_column":30,"positive":false,"negative":true},{"start_line":1809,"start_column":16,"end_line":1809,"end_column":46,"positive":false,"negative":true},{"start_line":1810,"start_column":16,"end_line":1810,"end_column":46,"positive":false,"negative":true},{"start_line":1816,"start_column":12,"end_line":1816,"end_column":39,"positive":false,"negative":true},{"start_line":1825,"start_column":12,"end_line":1825,"end_column":29,"positive":false,"negative":false}]]]}