{"function_name":"regex_syntax::hir::literal::repeat_range_literals","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":21,"tests_lines":[27,27,27,22,9,10,10,10,11,11,11,11,10,16,17,17,17,17,42,33,33],"oracles":21,"oracles_compiled":4,"oracles_compiled_rate":19.047619047619047,"tests_compiled":4,"tests_compiled_rate":19.047619047619047,"oracles_run":4,"oracles_passed":1,"oracles_passed_rate":25.0,"tests_run":4,"tests_passed":1,"tests_passed_rate":25.0,"lines":30,"lines_covered":28,"lines_coveraged_rate":93.33333333333333,"branches":10,"branches_covered":7,"branches_coverage_rate":70.0,"codes_lines":[813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,843],"codes_lines_covered":[[["{","    let e = Hir::empty(); // Assume Hir::empty creates an empty Hir","    let min = 0;","    let max = Some(3);","    let greedy = true;","    let mut lits = Literals::empty(); // Assume Literals::empty creates an empty Literals","","    let mut output = Vec::new();","    let f = |hir: &Hir, literals: &mut Literals| {","        output.push(hir.clone());","    };","","    repeat_range_literals(&e, min, max, greedy, &mut lits, f);","    ","    assert_eq!(output.len(), 1); // We expect f to be called once since min is 0","}"],[813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,843]],[["{","    let e = Hir::empty(); // Assume Hir::empty creates an empty Hir","    let min = 2; // min > 0","    let max = Some(5); // max is a bound greater than min","    let greedy = false;","    let mut lits = Literals::empty(); // Assume Literals::empty creates an empty Literals","    lits.set_limit_size(5);  // Assume setting the limit size allows for multiple repetitions","","    let mut output = Vec::new();","    let f = |hir: &Hir, literals: &mut Literals| {","        output.push(hir.clone());","    };","","    repeat_range_literals(&e, min, max, greedy, &mut lits, f);","    ","    assert_eq!(output.len(), 2); // We expect f to be called twice since min is 2","}"],[813,814,815,816,817,818,819,820,821,831,832,833,834,835,837,839,840,841,843]],[["{","    let e = Hir::empty(); // Assume Hir::empty creates an empty Hir","    let min = 3; // min > 0","    let max = Some(5); // max bounds the range","    let greedy = true;","    let mut lits = Literals::empty(); // Assume Literals::empty creates an empty Literals","    lits.set_limit_size(3); // Set to 3 to match min, allowing for no more than min repetitions","","    let mut output = Vec::new();","    let f = |hir: &Hir, literals: &mut Literals| {","        output.push(hir.clone());","    };","","    repeat_range_literals(&e, min, max, greedy, &mut lits, f);","    ","    assert_eq!(output.len(), 3); // Expect f to be called 3 times since n (3) == min","}"],[813,814,815,816,817,818,819,820,821,831,832,833,834,835,837,839,840,841,843]],[["{","    let e = Hir::empty(); // Assume Hir::empty creates an empty Hir","    let min = 2; // min > 0","    let max = Some(2); // Set max to equal min","    let greedy = false;","    let mut lits = Literals::empty(); // Assume Literals::empty creates an empty Literals","    lits.set_limit_size(3); // Set limit size larger than min","","    let mut output = Vec::new();","    let f = |hir: &Hir, literals: &mut Literals| {","        output.push(hir.clone());","    };","","    repeat_range_literals(&e, min, max, greedy, &mut lits, f);","    ","    assert_eq!(output.len(), 2); // We expect f to be called twice since min equals max","}"],[813,814,815,816,817,818,819,820,821,831,832,833,834,835,837,839,841,843]]],"codes_branches":[{"start_line":821,"start_column":8,"end_line":821,"end_column":16,"positive":true,"negative":true},{"start_line":831,"start_column":12,"end_line":831,"end_column":19,"positive":true,"negative":false},{"start_line":835,"start_column":16,"end_line":835,"end_column":32,"positive":false,"negative":true},{"start_line":835,"start_column":36,"end_line":835,"end_column":57,"positive":false,"negative":true},{"start_line":839,"start_column":12,"end_line":839,"end_column":45,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let e = Hir::empty(); // Assume Hir::empty creates an empty Hir","    let min = 0;","    let max = Some(3);","    let greedy = true;","    let mut lits = Literals::empty(); // Assume Literals::empty creates an empty Literals","","    let mut output = Vec::new();","    let f = |hir: &Hir, literals: &mut Literals| {","        output.push(hir.clone());","    };","","    repeat_range_literals(&e, min, max, greedy, &mut lits, f);","    ","    assert_eq!(output.len(), 1); // We expect f to be called once since min is 0","}"],[{"start_line":821,"start_column":8,"end_line":821,"end_column":16,"positive":true,"negative":false},{"start_line":831,"start_column":12,"end_line":831,"end_column":19,"positive":false,"negative":false},{"start_line":835,"start_column":16,"end_line":835,"end_column":32,"positive":false,"negative":false},{"start_line":835,"start_column":36,"end_line":835,"end_column":57,"positive":false,"negative":false},{"start_line":839,"start_column":12,"end_line":839,"end_column":45,"positive":false,"negative":false}]],[["{","    let e = Hir::empty(); // Assume Hir::empty creates an empty Hir","    let min = 2; // min > 0","    let max = Some(5); // max is a bound greater than min","    let greedy = false;","    let mut lits = Literals::empty(); // Assume Literals::empty creates an empty Literals","    lits.set_limit_size(5);  // Assume setting the limit size allows for multiple repetitions","","    let mut output = Vec::new();","    let f = |hir: &Hir, literals: &mut Literals| {","        output.push(hir.clone());","    };","","    repeat_range_literals(&e, min, max, greedy, &mut lits, f);","    ","    assert_eq!(output.len(), 2); // We expect f to be called twice since min is 2","}"],[{"start_line":821,"start_column":8,"end_line":821,"end_column":16,"positive":false,"negative":true},{"start_line":831,"start_column":12,"end_line":831,"end_column":19,"positive":true,"negative":false},{"start_line":835,"start_column":16,"end_line":835,"end_column":32,"positive":false,"negative":true},{"start_line":835,"start_column":36,"end_line":835,"end_column":57,"positive":false,"negative":true},{"start_line":839,"start_column":12,"end_line":839,"end_column":45,"positive":true,"negative":false}]],[["{","    let e = Hir::empty(); // Assume Hir::empty creates an empty Hir","    let min = 3; // min > 0","    let max = Some(5); // max bounds the range","    let greedy = true;","    let mut lits = Literals::empty(); // Assume Literals::empty creates an empty Literals","    lits.set_limit_size(3); // Set to 3 to match min, allowing for no more than min repetitions","","    let mut output = Vec::new();","    let f = |hir: &Hir, literals: &mut Literals| {","        output.push(hir.clone());","    };","","    repeat_range_literals(&e, min, max, greedy, &mut lits, f);","    ","    assert_eq!(output.len(), 3); // Expect f to be called 3 times since n (3) == min","}"],[{"start_line":821,"start_column":8,"end_line":821,"end_column":16,"positive":false,"negative":true},{"start_line":831,"start_column":12,"end_line":831,"end_column":19,"positive":true,"negative":false},{"start_line":835,"start_column":16,"end_line":835,"end_column":32,"positive":false,"negative":true},{"start_line":835,"start_column":36,"end_line":835,"end_column":57,"positive":false,"negative":true},{"start_line":839,"start_column":12,"end_line":839,"end_column":45,"positive":true,"negative":false}]],[["{","    let e = Hir::empty(); // Assume Hir::empty creates an empty Hir","    let min = 2; // min > 0","    let max = Some(2); // Set max to equal min","    let greedy = false;","    let mut lits = Literals::empty(); // Assume Literals::empty creates an empty Literals","    lits.set_limit_size(3); // Set limit size larger than min","","    let mut output = Vec::new();","    let f = |hir: &Hir, literals: &mut Literals| {","        output.push(hir.clone());","    };","","    repeat_range_literals(&e, min, max, greedy, &mut lits, f);","    ","    assert_eq!(output.len(), 2); // We expect f to be called twice since min equals max","}"],[{"start_line":821,"start_column":8,"end_line":821,"end_column":16,"positive":false,"negative":true},{"start_line":831,"start_column":12,"end_line":831,"end_column":19,"positive":true,"negative":false},{"start_line":835,"start_column":16,"end_line":835,"end_column":32,"positive":false,"negative":true},{"start_line":835,"start_column":36,"end_line":835,"end_column":57,"positive":false,"negative":true},{"start_line":839,"start_column":12,"end_line":839,"end_column":45,"positive":false,"negative":true}]]]}