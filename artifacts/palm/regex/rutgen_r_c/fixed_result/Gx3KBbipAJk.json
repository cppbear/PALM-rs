{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::pop_group","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":9,"tests_lines":[24,22,26,23,44,27,53,73,51],"oracles":9,"oracles_compiled":1,"oracles_compiled_rate":11.11111111111111,"tests_compiled":1,"tests_compiled_rate":11.11111111111111,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":35,"lines_covered":9,"lines_coveraged_rate":25.71428571428571,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[737,740,741,742,743,744,745,747,748,749,750,753,754,755,756,761,762,763,764,767,768,769,770,771,772,773,774,775,776,777,778,779,781,782,783],"codes_lines_covered":[[["{","    let group_concat = ast::Concat {","        span: ast::Span {","            start: ast::Position { offset: 0, line: 1, column: 1 },","            end: ast::Position { offset: 1, line: 1, column: 2 },","        },","        asts: Vec::new(),","    };","","    let parser = Parser {","        pos: Cell::new(ast::Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(Vec::new()),","        stack_group: RefCell::new(Vec::new()),","        stack_class: RefCell::new(Vec::new()),","        capture_names: RefCell::new(Vec::new()),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI { parser: &parser, pattern: \")\" };","","    let _ = parser_instance.pop_group(group_concat);","}"],[737,740,741,743,761,762,763,764,783]]],"codes_branches":[],"codes_branches_covered":[[["{","    let group_concat = ast::Concat {","        span: ast::Span {","            start: ast::Position { offset: 0, line: 1, column: 1 },","            end: ast::Position { offset: 1, line: 1, column: 2 },","        },","        asts: Vec::new(),","    };","","    let parser = Parser {","        pos: Cell::new(ast::Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(Vec::new()),","        stack_group: RefCell::new(Vec::new()),","        stack_class: RefCell::new(Vec::new()),","        capture_names: RefCell::new(Vec::new()),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI { parser: &parser, pattern: \")\" };","","    let _ = parser_instance.pop_group(group_concat);","}"],[]]]}