{"function_name":"regex::re_bytes::re_bytes::Regex::captures_len","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/re_bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[33,33,38,33],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[638,639,640],"codes_lines_covered":[[["{","    struct MockExecReadOnly {","        captures: Vec<Option<String>>,","    }","","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","","    impl MockExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.ro.captures","        }","    }","","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn captures_len(&self) -> usize {","            self.0.capture_names().len()","        }","    }","","    let exec_ro = MockExecReadOnly {","        captures: Vec::new(),","    };","    let mock_exec = MockExec {","        ro: Arc::new(exec_ro),","    };","    let regex = MockRegex(mock_exec);","","    assert_eq!(regex.captures_len(), 0);","}"],[]],[["{","    struct MockExecReadOnly {","        captures: Vec<Option<String>>,","    }","","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","","    impl MockExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.ro.captures","        }","    }","","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn captures_len(&self) -> usize {","            self.0.capture_names().len()","        }","    }","","    let exec_ro = MockExecReadOnly {","        captures: vec![Some(\"first_capture\".to_string())],","    };","    let mock_exec = MockExec {","        ro: Arc::new(exec_ro),","    };","    let regex = MockRegex(mock_exec);","","    assert_eq!(regex.captures_len(), 1);","}"],[]],[["{","    struct MockExecReadOnly {","        captures: Vec<Option<String>>,","    }","","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","","    impl MockExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.ro.captures","        }","    }","","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn captures_len(&self) -> usize {","            self.0.capture_names().len()","        }","    }","","    let exec_ro = MockExecReadOnly {","        captures: vec![","            Some(\"first_capture\".to_string()),","            Some(\"second_capture\".to_string()),","            None,","            Some(\"third_capture\".to_string()),","        ],","    };","    let mock_exec = MockExec {","        ro: Arc::new(exec_ro),","    };","    let regex = MockRegex(mock_exec);","","    assert_eq!(regex.captures_len(), 4);","}"],[]],[["{","    struct MockExecReadOnly {","        captures: Vec<Option<String>>,","    }","","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","","    impl MockExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.ro.captures","        }","    }","","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn captures_len(&self) -> usize {","            self.0.capture_names().len()","        }","    }","","    let exec_ro = MockExecReadOnly {","        captures: vec![None, None, None],","    };","    let mock_exec = MockExec {","        ro: Arc::new(exec_ro),","    };","    let regex = MockRegex(mock_exec);","","    assert_eq!(regex.captures_len(), 3);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MockExecReadOnly {","        captures: Vec<Option<String>>,","    }","","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","","    impl MockExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.ro.captures","        }","    }","","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn captures_len(&self) -> usize {","            self.0.capture_names().len()","        }","    }","","    let exec_ro = MockExecReadOnly {","        captures: Vec::new(),","    };","    let mock_exec = MockExec {","        ro: Arc::new(exec_ro),","    };","    let regex = MockRegex(mock_exec);","","    assert_eq!(regex.captures_len(), 0);","}"],[]],[["{","    struct MockExecReadOnly {","        captures: Vec<Option<String>>,","    }","","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","","    impl MockExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.ro.captures","        }","    }","","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn captures_len(&self) -> usize {","            self.0.capture_names().len()","        }","    }","","    let exec_ro = MockExecReadOnly {","        captures: vec![Some(\"first_capture\".to_string())],","    };","    let mock_exec = MockExec {","        ro: Arc::new(exec_ro),","    };","    let regex = MockRegex(mock_exec);","","    assert_eq!(regex.captures_len(), 1);","}"],[]],[["{","    struct MockExecReadOnly {","        captures: Vec<Option<String>>,","    }","","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","","    impl MockExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.ro.captures","        }","    }","","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn captures_len(&self) -> usize {","            self.0.capture_names().len()","        }","    }","","    let exec_ro = MockExecReadOnly {","        captures: vec![","            Some(\"first_capture\".to_string()),","            Some(\"second_capture\".to_string()),","            None,","            Some(\"third_capture\".to_string()),","        ],","    };","    let mock_exec = MockExec {","        ro: Arc::new(exec_ro),","    };","    let regex = MockRegex(mock_exec);","","    assert_eq!(regex.captures_len(), 4);","}"],[]],[["{","    struct MockExecReadOnly {","        captures: Vec<Option<String>>,","    }","","    struct MockExec {","        ro: Arc<MockExecReadOnly>,","    }","","    impl MockExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.ro.captures","        }","    }","","    struct MockRegex(MockExec);","","    impl MockRegex {","        fn captures_len(&self) -> usize {","            self.0.capture_names().len()","        }","    }","","    let exec_ro = MockExecReadOnly {","        captures: vec![None, None, None],","    };","    let mock_exec = MockExec {","        ro: Arc::new(exec_ro),","    };","    let regex = MockRegex(mock_exec);","","    assert_eq!(regex.captures_len(), 3);","}"],[]]]}