{"function_name":"regex::compile::compile::ByteClassSet::set_range","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/compile.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":11,"tests_lines":[6,9,4,4,5,6,4,11,11,11,12],"oracles":11,"oracles_compiled":9,"oracles_compiled_rate":81.81818181818183,"tests_compiled":9,"tests_compiled_rate":81.81818181818183,"oracles_run":9,"oracles_passed":7,"oracles_passed_rate":77.77777777777779,"tests_run":9,"tests_passed":7,"tests_passed_rate":77.77777777777779,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1052,1053,1054,1055,1056,1057,1058],"codes_lines_covered":[[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(1, 1);","    assert_eq!(byte_class_set.0[0], true);","    assert_eq!(byte_class_set.0[1], true);","}"],[1052,1053,1054,1055,1056,1057,1058]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(2, 5);","    assert_eq!(byte_class_set.0[1], true);","    assert_eq!(byte_class_set.0[2], true);","    assert_eq!(byte_class_set.0[3], true);","    assert_eq!(byte_class_set.0[4], true);","    assert_eq!(byte_class_set.0[5], true);","}"],[1052,1053,1054,1055,1056,1057,1058]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(2, 1);","}"],[1052,1053]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(0, 0);","}"],[1052,1053,1054,1056,1057,1058]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(5, 5);","    assert!(byte_class_set.0[5 as usize]); // Ensure the exact index for start and end is set.","}"],[1052,1053,1054,1055,1056,1057,1058]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(0, 5);","    assert!(!byte_class_set.0[0]); // Ensure that index 0 is NOT set.","    assert!(byte_class_set.0[5 as usize]); // Ensure that index 5 is set.","}"],[1052,1053,1054,1056,1057,1058]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(6, 5); // start > end","}"],[1052,1053]],[["{","    let mut byte_class_set = ByteClassSet::new();","    let start: u8 = 5;","    let end: u8 = 5;","","    // This should not panic and should only set the specific index","    byte_class_set.set_range(start, end);","    ","    // Check if the specific index is set to true","    assert!(byte_class_set.0[start as usize] == true, \"Byte at index 5 should be set to true\");","}"],[1052,1053,1054,1055,1056,1057,1058]],[["{","    let mut byte_class_set = ByteClassSet::new();","    let start: u8 = 1;","    let end: u8 = 3;","","    // This should not panic and should set the byte classes correctly","    byte_class_set.set_range(start, end);","    ","    // After setting the range, the specified bytes should be 'true'","    assert!(byte_class_set.0[0] == true, \"Byte at index 0 should be set to true\");","    assert!(byte_class_set.0[3] == true, \"Byte at index 3 should be set to true\");","}"],[1052,1053,1054,1055,1056,1057,1058]]],"codes_branches":[{"start_line":1054,"start_column":12,"end_line":1054,"end_column":21,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(1, 1);","    assert_eq!(byte_class_set.0[0], true);","    assert_eq!(byte_class_set.0[1], true);","}"],[{"start_line":1054,"start_column":12,"end_line":1054,"end_column":21,"positive":true,"negative":false}]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(2, 5);","    assert_eq!(byte_class_set.0[1], true);","    assert_eq!(byte_class_set.0[2], true);","    assert_eq!(byte_class_set.0[3], true);","    assert_eq!(byte_class_set.0[4], true);","    assert_eq!(byte_class_set.0[5], true);","}"],[{"start_line":1054,"start_column":12,"end_line":1054,"end_column":21,"positive":true,"negative":false}]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(2, 1);","}"],[{"start_line":1054,"start_column":12,"end_line":1054,"end_column":21,"positive":false,"negative":false}]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(0, 0);","}"],[{"start_line":1054,"start_column":12,"end_line":1054,"end_column":21,"positive":false,"negative":true}]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(5, 5);","    assert!(byte_class_set.0[5 as usize]); // Ensure the exact index for start and end is set.","}"],[{"start_line":1054,"start_column":12,"end_line":1054,"end_column":21,"positive":true,"negative":false}]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(0, 5);","    assert!(!byte_class_set.0[0]); // Ensure that index 0 is NOT set.","    assert!(byte_class_set.0[5 as usize]); // Ensure that index 5 is set.","}"],[{"start_line":1054,"start_column":12,"end_line":1054,"end_column":21,"positive":false,"negative":true}]],[["{","    let mut byte_class_set = ByteClassSet::new();","    byte_class_set.set_range(6, 5); // start > end","}"],[{"start_line":1054,"start_column":12,"end_line":1054,"end_column":21,"positive":false,"negative":false}]],[["{","    let mut byte_class_set = ByteClassSet::new();","    let start: u8 = 5;","    let end: u8 = 5;","","    // This should not panic and should only set the specific index","    byte_class_set.set_range(start, end);","    ","    // Check if the specific index is set to true","    assert!(byte_class_set.0[start as usize] == true, \"Byte at index 5 should be set to true\");","}"],[{"start_line":1054,"start_column":12,"end_line":1054,"end_column":21,"positive":true,"negative":false}]],[["{","    let mut byte_class_set = ByteClassSet::new();","    let start: u8 = 1;","    let end: u8 = 3;","","    // This should not panic and should set the byte classes correctly","    byte_class_set.set_range(start, end);","    ","    // After setting the range, the specified bytes should be 'true'","    assert!(byte_class_set.0[0] == true, \"Byte at index 0 should be set to true\");","    assert!(byte_class_set.0[3] == true, \"Byte at index 3 should be set to true\");","}"],[{"start_line":1054,"start_column":12,"end_line":1054,"end_column":21,"positive":true,"negative":false}]]]}