{"function_name":"regex::re_unicode::re_unicode::Regex::capture_names","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/re_unicode.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":3,"tests_lines":[27,27,27],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[692,693,694],"codes_lines_covered":[[["{","    struct TestExec {","        captures: Vec<Option<String>>,","    }","    ","    impl TestExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.captures","        }","    }","    ","    struct TestRegex(TestExec);","    ","    impl TestRegex {","        fn capture_names(&self) -> CaptureNames {","            CaptureNames(self.0.capture_names().iter())","        }","    }","","    let test_exec = TestExec { captures: Vec::new() };","    let test_regex = TestRegex(test_exec);","    ","    let capture_names_iter = test_regex.capture_names();","    let captured_names: Vec<_> = capture_names_iter.0.cloned().collect();","    ","    assert_eq!(captured_names, Vec::<Option<String>>::new());","}"],[]],[["{","    struct TestExec {","        captures: Vec<Option<String>>,","    }","    ","    impl TestExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.captures","        }","    }","    ","    struct TestRegex(TestExec);","    ","    impl TestRegex {","        fn capture_names(&self) -> CaptureNames {","            CaptureNames(self.0.capture_names().iter())","        }","    }","","    let test_exec = TestExec { captures: vec![Some(\"name1\".to_string())] };","    let test_regex = TestRegex(test_exec);","    ","    let capture_names_iter = test_regex.capture_names();","    let captured_names: Vec<_> = capture_names_iter.0.cloned().collect();","    ","    assert_eq!(captured_names, vec![Some(\"name1\".to_string())]);","}"],[]],[["{","    struct TestExec {","        captures: Vec<Option<String>>,","    }","    ","    impl TestExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.captures","        }","    }","    ","    struct TestRegex(TestExec);","    ","    impl TestRegex {","        fn capture_names(&self) -> CaptureNames {","            CaptureNames(self.0.capture_names().iter())","        }","    }","","    let test_exec = TestExec { captures: vec![Some(\"name1\".to_string()), Some(\"name2\".to_string()), None] };","    let test_regex = TestRegex(test_exec);","    ","    let capture_names_iter = test_regex.capture_names();","    let captured_names: Vec<_> = capture_names_iter.0.cloned().collect();","    ","    assert_eq!(captured_names, vec![Some(\"name1\".to_string()), Some(\"name2\".to_string()), None]);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestExec {","        captures: Vec<Option<String>>,","    }","    ","    impl TestExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.captures","        }","    }","    ","    struct TestRegex(TestExec);","    ","    impl TestRegex {","        fn capture_names(&self) -> CaptureNames {","            CaptureNames(self.0.capture_names().iter())","        }","    }","","    let test_exec = TestExec { captures: Vec::new() };","    let test_regex = TestRegex(test_exec);","    ","    let capture_names_iter = test_regex.capture_names();","    let captured_names: Vec<_> = capture_names_iter.0.cloned().collect();","    ","    assert_eq!(captured_names, Vec::<Option<String>>::new());","}"],[]],[["{","    struct TestExec {","        captures: Vec<Option<String>>,","    }","    ","    impl TestExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.captures","        }","    }","    ","    struct TestRegex(TestExec);","    ","    impl TestRegex {","        fn capture_names(&self) -> CaptureNames {","            CaptureNames(self.0.capture_names().iter())","        }","    }","","    let test_exec = TestExec { captures: vec![Some(\"name1\".to_string())] };","    let test_regex = TestRegex(test_exec);","    ","    let capture_names_iter = test_regex.capture_names();","    let captured_names: Vec<_> = capture_names_iter.0.cloned().collect();","    ","    assert_eq!(captured_names, vec![Some(\"name1\".to_string())]);","}"],[]],[["{","    struct TestExec {","        captures: Vec<Option<String>>,","    }","    ","    impl TestExec {","        fn capture_names(&self) -> &[Option<String>] {","            &self.captures","        }","    }","    ","    struct TestRegex(TestExec);","    ","    impl TestRegex {","        fn capture_names(&self) -> CaptureNames {","            CaptureNames(self.0.capture_names().iter())","        }","    }","","    let test_exec = TestExec { captures: vec![Some(\"name1\".to_string()), Some(\"name2\".to_string()), None] };","    let test_regex = TestRegex(test_exec);","    ","    let capture_names_iter = test_regex.capture_names();","    let captured_names: Vec<_> = capture_names_iter.0.cloned().collect();","    ","    assert_eq!(captured_names, vec![Some(\"name1\".to_string()), Some(\"name2\".to_string()), None]);","}"],[]]]}