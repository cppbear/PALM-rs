{"function_name":"regex::exec::exec::ExecNoSync<'c>::find_nfa","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/exec.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[41,42,42,34],"oracles":4,"oracles_compiled":2,"oracles_compiled_rate":50.0,"tests_compiled":2,"tests_compiled_rate":50.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":13,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[852,853,854,855,856,857,858,859,860,861,862,865,867],"codes_lines_covered":[[["{","    struct MockExecReadOnly {","        nfa_len: usize,","    }","    ","    impl MockExecReadOnly {","        fn new(nfa_len: usize) -> Self {","            MockExecReadOnly { nfa_len }","        }","    }","","    struct MockExecNoSync<'c> {","        ro: &'c MockExecReadOnly,","    }","","    impl<'c> MockExecNoSync<'c> {","        fn exec_nfa(&self, _ty: MatchNfaType, _matches: &mut [bool], slots: &mut [Slot], _quit_after_match: bool, _text: &[u8], _start: usize) -> bool {","            // Simulate a successful NFA execution that sets slots[0] and slots[1]","            slots[0] = Some(0);","            slots[1] = Some(3);","            true","        }","","        fn find_nfa(&self, ty: MatchNfaType, text: &[u8], start: usize) -> Option<(usize, usize)> {","            let mut slots = [None, None];","            if self.exec_nfa(ty, &mut [false], &mut slots, false, text, start) {","                match (slots[0], slots[1]) {","                    (Some(s), Some(e)) => Some((s, e)),","                    _ => None,","                }","            } else {","                None","            }","        }","    }","","    let exec_read_only = MockExecReadOnly::new(10);","    let exec_no_sync = MockExecNoSync { ro: &exec_read_only };","    ","    let result = exec_no_sync.find_nfa(MatchNfaType::Auto, b\"hello world\", 0);","    assert_eq!(result, Some((0, 3)));","}"],[]],[["{","    struct MockExecReadOnly {","        nfa_len: usize,","    }","","    impl MockExecReadOnly {","        fn new(nfa_len: usize) -> Self {","            MockExecReadOnly { nfa_len }","        }","    }","","    struct MockExecNoSync<'c> {","        ro: &'c MockExecReadOnly,","    }","","    impl<'c> MockExecNoSync<'c> {","        fn exec_nfa(&self, _ty: MatchNfaType, _matches: &mut [bool], slots: &mut [Slot], _quit_after_match: bool, _text: &[u8], _start: usize) -> bool {","            // Simulate a scenario where NFA execution does not produce matches","            slots[0] = None;","            slots[1] = None;","            false","        }","","        fn find_nfa(&self, ty: MatchNfaType, text: &[u8], start: usize) -> Option<(usize, usize)> {","            let mut slots = [None, None];","            if self.exec_nfa(ty, &mut [false], &mut slots, false, text, start) {","                match (slots[0], slots[1]) {","                    (Some(s), Some(e)) => Some((s, e)),","                    _ => None,","                }","            } else {","                None","            }","        }","    }","","    let exec_read_only = MockExecReadOnly::new(10);","    let exec_no_sync = MockExecNoSync { ro: &exec_read_only };","    ","    let result = exec_no_sync.find_nfa(MatchNfaType::Auto, b\"hello world\", 0);","    assert_eq!(result, None);","}"],[]]],"codes_branches":[{"start_line":859,"start_column":12,"end_line":859,"end_column":75,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockExecReadOnly {","        nfa_len: usize,","    }","    ","    impl MockExecReadOnly {","        fn new(nfa_len: usize) -> Self {","            MockExecReadOnly { nfa_len }","        }","    }","","    struct MockExecNoSync<'c> {","        ro: &'c MockExecReadOnly,","    }","","    impl<'c> MockExecNoSync<'c> {","        fn exec_nfa(&self, _ty: MatchNfaType, _matches: &mut [bool], slots: &mut [Slot], _quit_after_match: bool, _text: &[u8], _start: usize) -> bool {","            // Simulate a successful NFA execution that sets slots[0] and slots[1]","            slots[0] = Some(0);","            slots[1] = Some(3);","            true","        }","","        fn find_nfa(&self, ty: MatchNfaType, text: &[u8], start: usize) -> Option<(usize, usize)> {","            let mut slots = [None, None];","            if self.exec_nfa(ty, &mut [false], &mut slots, false, text, start) {","                match (slots[0], slots[1]) {","                    (Some(s), Some(e)) => Some((s, e)),","                    _ => None,","                }","            } else {","                None","            }","        }","    }","","    let exec_read_only = MockExecReadOnly::new(10);","    let exec_no_sync = MockExecNoSync { ro: &exec_read_only };","    ","    let result = exec_no_sync.find_nfa(MatchNfaType::Auto, b\"hello world\", 0);","    assert_eq!(result, Some((0, 3)));","}"],[{"start_line":859,"start_column":12,"end_line":859,"end_column":75,"positive":false,"negative":false}]],[["{","    struct MockExecReadOnly {","        nfa_len: usize,","    }","","    impl MockExecReadOnly {","        fn new(nfa_len: usize) -> Self {","            MockExecReadOnly { nfa_len }","        }","    }","","    struct MockExecNoSync<'c> {","        ro: &'c MockExecReadOnly,","    }","","    impl<'c> MockExecNoSync<'c> {","        fn exec_nfa(&self, _ty: MatchNfaType, _matches: &mut [bool], slots: &mut [Slot], _quit_after_match: bool, _text: &[u8], _start: usize) -> bool {","            // Simulate a scenario where NFA execution does not produce matches","            slots[0] = None;","            slots[1] = None;","            false","        }","","        fn find_nfa(&self, ty: MatchNfaType, text: &[u8], start: usize) -> Option<(usize, usize)> {","            let mut slots = [None, None];","            if self.exec_nfa(ty, &mut [false], &mut slots, false, text, start) {","                match (slots[0], slots[1]) {","                    (Some(s), Some(e)) => Some((s, e)),","                    _ => None,","                }","            } else {","                None","            }","        }","    }","","    let exec_read_only = MockExecReadOnly::new(10);","    let exec_no_sync = MockExecNoSync { ro: &exec_read_only };","    ","    let result = exec_no_sync.find_nfa(MatchNfaType::Auto, b\"hello world\", 0);","    assert_eq!(result, None);","}"],[{"start_line":859,"start_column":12,"end_line":859,"end_column":75,"positive":false,"negative":false}]]]}