{"function_name":"regex::literal::literal::LiteralSearcher::iter","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":10,"tests_lines":[48,46,37,34,26,42,21,27,25,24],"oracles":10,"oracles_compiled":6,"oracles_compiled_rate":60.0,"tests_compiled":6,"tests_compiled_rate":60.0,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":12,"lines_covered":6,"lines_coveraged_rate":50.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[138,139,140,141,142,143,144,145,146,148,149,152],"codes_lines_covered":[[["{","    // Create a BoyerMooreSearch instance with a simple pattern","    let pattern = vec![b'a', b'b', b'c'];","    let skip_table = vec![0; 256];","    let guard = b'a';","    let guard_reverse_idx = 0;","    let md2_shift = 1;","","    let boyer_moore_search = BoyerMooreSearch {","        pattern,","        skip_table,","        guard,","        guard_reverse_idx,","        md2_shift,","    };","","    // Create a Matcher instance with BoyerMoore","    let matcher = Matcher::BoyerMoore(boyer_moore_search);","","    // Create a LiteralSearcher instance using the Matcher","    let literal_searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(vec![]),","        lcs: FreqyPacked::new(vec![]),","        matcher,","    };","","    // Call the iter method and match against expected output","    if let LiteralIter::Single(ref result) = literal_searcher.iter() {","        assert_eq!(result, &vec![b'a', b'b', b'c']);","    } else {","        panic!(\"Expected LiteralIter::Single with the BoyerMoore pattern\");","    }","}"],[138,139,143,152]],[["{","    let pattern = vec![b'a', b'b', b'c'];","    let rare1 = b'a';","    let rare1i = 0;","    let rare2 = b'b';","    let rare2i = 1;","    let freqy_packed = FreqyPacked {","        pat: pattern.clone(),","        char_len: 3,","        rare1,","        rare1i,","        rare2,","        rare2i,","    };","","    let matcher = Matcher::FreqyPacked(freqy_packed);","    let lits = Literals::empty(); // Assuming a method exists to create an empty Literals.","    let searcher = LiteralSearcher::new(lits, matcher);","","    match searcher.iter() {","        LiteralIter::Single(pat) => {","            assert_eq!(pat, &pattern);","        },","        _ => panic!(\"Expected LiteralIter::Single, got something else.\"),","    }","}"],[138,139,142,152]],[["{","    // Create an instance of SingleByteSet for our test","    let sset = SingleByteSet {","        sparse: vec![false; 256],  // As an example, creating a dense representation","        dense: vec![b'a', b'b', b'c'],  // Some example byte literals","        complete: true,","        all_ascii: true,","    };","","    // Create an instance of LiteralSearcher with Matcher::Bytes","    let searcher = LiteralSearcher {","        complete: true,","        lcp: FreqyPacked {","            pat: vec![],","            char_len: 0,","            rare1: 0,","            rare1i: 0,","            rare2: 0,","            rare2i: 0,","        },","        lcs: FreqyPacked {","            pat: vec![],","            char_len: 0,","            rare1: 0,","            rare1i: 0,","            rare2: 0,","            rare2i: 0,","        },","        matcher: Matcher::Bytes(sset.clone()),  // Using the created SingleByteSet","    };","","    // Invoke the method under test","    let iter = searcher.iter();","","    // Check that the result matches the expected output","    match iter {","        LiteralIter::Bytes(bytes) => {","            assert_eq!(bytes, &sset.dense);","        },","        _ => panic!(\"Expected LiteralIter::Bytes, got a different variant\"),","    }","}"],[138,139,141,152]],[["{","    struct STestBytes {","        dense: Vec<u8>,","    }","    ","    let single_byte_set = SingleByteSet {","        sparse: vec![false; 256],","        dense: b\"abc\".to_vec(),","        complete: true,","        all_ascii: true,","    };","    ","    let matcher = Matcher::Bytes(single_byte_set);","    let searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(b\"abc\".to_vec()),","        lcs: FreqyPacked::new(b\"abc\".to_vec()),","        matcher,","    };","    ","    let result = searcher.iter();","    if let LiteralIter::Bytes(slice) = result {","        assert_eq!(slice, b\"abc\");","    } else {","        panic!(\"Expected LiteralIter::Bytes, found a different variant.\");","    }","}"],[138,139,141,152]],[["{","    let freqy_packed = FreqyPacked {","        pat: b\"abc\".to_vec(),","        char_len: 3,","        rare1: b'a',","        rare1i: 0,","        rare2: b'b',","        rare2i: 1,","    };","    ","    let matcher = Matcher::FreqyPacked(freqy_packed);","    let searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(b\"abc\".to_vec()),","        lcs: FreqyPacked::new(b\"abc\".to_vec()),","        matcher,","    };","    ","    let result = searcher.iter();","    if let LiteralIter::Single(slice) = result {","        assert_eq!(slice, b\"abc\");","    } else {","        panic!(\"Expected LiteralIter::Single, found a different variant.\");","    }","}"],[138,139,142,152]],[["{","    let boyer_moore = BoyerMooreSearch {","        pattern: b\"abc\".to_vec(),","        skip_table: vec![0; 256],","        guard: b'a',","        guard_reverse_idx: 0,","        md2_shift: 1,","    };","    ","    let matcher = Matcher::BoyerMoore(boyer_moore);","    let searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(b\"abc\".to_vec()),","        lcs: FreqyPacked::new(b\"abc\".to_vec()),","        matcher,","    };","    ","    let result = searcher.iter();","    if let LiteralIter::Single(slice) = result {","        assert_eq!(slice, b\"abc\");","    } else {","        panic!(\"Expected LiteralIter::Single, found a different variant.\");","    }","}"],[138,139,143,152]]],"codes_branches":[],"codes_branches_covered":[[["{","    // Create a BoyerMooreSearch instance with a simple pattern","    let pattern = vec![b'a', b'b', b'c'];","    let skip_table = vec![0; 256];","    let guard = b'a';","    let guard_reverse_idx = 0;","    let md2_shift = 1;","","    let boyer_moore_search = BoyerMooreSearch {","        pattern,","        skip_table,","        guard,","        guard_reverse_idx,","        md2_shift,","    };","","    // Create a Matcher instance with BoyerMoore","    let matcher = Matcher::BoyerMoore(boyer_moore_search);","","    // Create a LiteralSearcher instance using the Matcher","    let literal_searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(vec![]),","        lcs: FreqyPacked::new(vec![]),","        matcher,","    };","","    // Call the iter method and match against expected output","    if let LiteralIter::Single(ref result) = literal_searcher.iter() {","        assert_eq!(result, &vec![b'a', b'b', b'c']);","    } else {","        panic!(\"Expected LiteralIter::Single with the BoyerMoore pattern\");","    }","}"],[]],[["{","    let pattern = vec![b'a', b'b', b'c'];","    let rare1 = b'a';","    let rare1i = 0;","    let rare2 = b'b';","    let rare2i = 1;","    let freqy_packed = FreqyPacked {","        pat: pattern.clone(),","        char_len: 3,","        rare1,","        rare1i,","        rare2,","        rare2i,","    };","","    let matcher = Matcher::FreqyPacked(freqy_packed);","    let lits = Literals::empty(); // Assuming a method exists to create an empty Literals.","    let searcher = LiteralSearcher::new(lits, matcher);","","    match searcher.iter() {","        LiteralIter::Single(pat) => {","            assert_eq!(pat, &pattern);","        },","        _ => panic!(\"Expected LiteralIter::Single, got something else.\"),","    }","}"],[]],[["{","    // Create an instance of SingleByteSet for our test","    let sset = SingleByteSet {","        sparse: vec![false; 256],  // As an example, creating a dense representation","        dense: vec![b'a', b'b', b'c'],  // Some example byte literals","        complete: true,","        all_ascii: true,","    };","","    // Create an instance of LiteralSearcher with Matcher::Bytes","    let searcher = LiteralSearcher {","        complete: true,","        lcp: FreqyPacked {","            pat: vec![],","            char_len: 0,","            rare1: 0,","            rare1i: 0,","            rare2: 0,","            rare2i: 0,","        },","        lcs: FreqyPacked {","            pat: vec![],","            char_len: 0,","            rare1: 0,","            rare1i: 0,","            rare2: 0,","            rare2i: 0,","        },","        matcher: Matcher::Bytes(sset.clone()),  // Using the created SingleByteSet","    };","","    // Invoke the method under test","    let iter = searcher.iter();","","    // Check that the result matches the expected output","    match iter {","        LiteralIter::Bytes(bytes) => {","            assert_eq!(bytes, &sset.dense);","        },","        _ => panic!(\"Expected LiteralIter::Bytes, got a different variant\"),","    }","}"],[]],[["{","    struct STestBytes {","        dense: Vec<u8>,","    }","    ","    let single_byte_set = SingleByteSet {","        sparse: vec![false; 256],","        dense: b\"abc\".to_vec(),","        complete: true,","        all_ascii: true,","    };","    ","    let matcher = Matcher::Bytes(single_byte_set);","    let searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(b\"abc\".to_vec()),","        lcs: FreqyPacked::new(b\"abc\".to_vec()),","        matcher,","    };","    ","    let result = searcher.iter();","    if let LiteralIter::Bytes(slice) = result {","        assert_eq!(slice, b\"abc\");","    } else {","        panic!(\"Expected LiteralIter::Bytes, found a different variant.\");","    }","}"],[]],[["{","    let freqy_packed = FreqyPacked {","        pat: b\"abc\".to_vec(),","        char_len: 3,","        rare1: b'a',","        rare1i: 0,","        rare2: b'b',","        rare2i: 1,","    };","    ","    let matcher = Matcher::FreqyPacked(freqy_packed);","    let searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(b\"abc\".to_vec()),","        lcs: FreqyPacked::new(b\"abc\".to_vec()),","        matcher,","    };","    ","    let result = searcher.iter();","    if let LiteralIter::Single(slice) = result {","        assert_eq!(slice, b\"abc\");","    } else {","        panic!(\"Expected LiteralIter::Single, found a different variant.\");","    }","}"],[]],[["{","    let boyer_moore = BoyerMooreSearch {","        pattern: b\"abc\".to_vec(),","        skip_table: vec![0; 256],","        guard: b'a',","        guard_reverse_idx: 0,","        md2_shift: 1,","    };","    ","    let matcher = Matcher::BoyerMoore(boyer_moore);","    let searcher = LiteralSearcher {","        complete: false,","        lcp: FreqyPacked::new(b\"abc\".to_vec()),","        lcs: FreqyPacked::new(b\"abc\".to_vec()),","        matcher,","    };","    ","    let result = searcher.iter();","    if let LiteralIter::Single(slice) = result {","        assert_eq!(slice, b\"abc\");","    } else {","        panic!(\"Expected LiteralIter::Single, found a different variant.\");","    }","}"],[]]]}