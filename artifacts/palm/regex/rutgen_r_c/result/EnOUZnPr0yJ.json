{"function_name":"regex::compile::compile::Compiler::c_class","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/compile.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":10,"tests_lines":[5,17,17,18,5,6,6,9,14,27],"oracles":10,"oracles_compiled":6,"oracles_compiled_rate":60.0,"tests_compiled":6,"tests_compiled_rate":60.0,"oracles_run":6,"oracles_passed":5,"oracles_passed_rate":83.33333333333334,"tests_run":6,"tests_passed":5,"tests_passed_rate":83.33333333333334,"lines":14,"lines_covered":14,"lines_coveraged_rate":100.0,"branches":6,"branches_covered":5,"branches_coverage_rate":83.33333333333334,"codes_lines":[420,421,422,423,424,425,426,428,429,430,431,433,435,437],"codes_lines_covered":[[["{","    let mut compiler = Compiler::new();","    let empty_ranges: Vec<hir::ClassUnicodeRange> = vec![];","    let _ = compiler.c_class(&empty_ranges);","}"],[420,421]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_class(&[]);","    assert!(result.is_err());","}"],[420,421]],[["{","    let mut compiler = Compiler::new().bytes(true);","    let ranges = vec![hir::ClassUnicodeRange::new('a', 'z')];","    let result = compiler.c_class(&ranges);","    assert!(result.is_ok());","}"],[420,421,422,423,424,425,426,437]],[["{","    let mut compiler = Compiler::new();","    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a')];","    let result = compiler.c_class(&ranges);","    assert!(result.is_ok());","}"],[420,421,422,428,429,430,431,435,437]],[["{","    let mut compiler = Compiler::new();","    let ranges = vec![","        hir::ClassUnicodeRange::new('a', 'c'),","        hir::ClassUnicodeRange::new('e', 'g'),","    ];","    let result = compiler.c_class(&ranges);","    assert!(result.is_ok());","}"],[420,421,422,428,429,430,433,435,437]],[["{","    use syntax::hir::{ClassUnicodeRange};","","    let mut compiler = Compiler::new();","    compiler.compiled.is_bytes = false; // Ensure uses_bytes() returns false","","    let ranges = vec![ClassUnicodeRange::new('a', 'a')]; // Single character range","    let result = compiler.c_class(&ranges);","","    assert!(result.is_ok());","","    if let Ok(patch) = result {","        assert_eq!(patch.entry, 0); // The entry is at the start","        // Ensure the hole is for character 'a'","        if let Hole::One(hole_index) = patch.hole {","            if let MaybeInst::Uncompiled(InstHole::Char { c }) = compiler.insts[hole_index] {","                assert_eq!(c, 'a');","            } else {","                panic!(\"Expected hole to be a Char instruction for 'a'\");","            }","        } else {","            panic!(\"Expected hole to be of type One\");","        }","    } else {","        panic!(\"Expected result to be Ok\");","    }","}"],[420,421,422,428,429,430,431,435,437]]],"codes_branches":[{"start_line":422,"start_column":12,"end_line":422,"end_column":38,"positive":true,"negative":true},{"start_line":430,"start_column":27,"end_line":430,"end_column":44,"positive":true,"negative":true},{"start_line":430,"start_column":48,"end_line":430,"end_column":74,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    let mut compiler = Compiler::new();","    let empty_ranges: Vec<hir::ClassUnicodeRange> = vec![];","    let _ = compiler.c_class(&empty_ranges);","}"],[{"start_line":422,"start_column":12,"end_line":422,"end_column":38,"positive":false,"negative":false},{"start_line":430,"start_column":27,"end_line":430,"end_column":44,"positive":false,"negative":false},{"start_line":430,"start_column":48,"end_line":430,"end_column":74,"positive":false,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_class(&[]);","    assert!(result.is_err());","}"],[{"start_line":422,"start_column":12,"end_line":422,"end_column":38,"positive":false,"negative":false},{"start_line":430,"start_column":27,"end_line":430,"end_column":44,"positive":false,"negative":false},{"start_line":430,"start_column":48,"end_line":430,"end_column":74,"positive":false,"negative":false}]],[["{","    let mut compiler = Compiler::new().bytes(true);","    let ranges = vec![hir::ClassUnicodeRange::new('a', 'z')];","    let result = compiler.c_class(&ranges);","    assert!(result.is_ok());","}"],[{"start_line":422,"start_column":12,"end_line":422,"end_column":38,"positive":true,"negative":false},{"start_line":430,"start_column":27,"end_line":430,"end_column":44,"positive":false,"negative":false},{"start_line":430,"start_column":48,"end_line":430,"end_column":74,"positive":false,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a')];","    let result = compiler.c_class(&ranges);","    assert!(result.is_ok());","}"],[{"start_line":422,"start_column":12,"end_line":422,"end_column":38,"positive":false,"negative":true},{"start_line":430,"start_column":27,"end_line":430,"end_column":44,"positive":true,"negative":false},{"start_line":430,"start_column":48,"end_line":430,"end_column":74,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let ranges = vec![","        hir::ClassUnicodeRange::new('a', 'c'),","        hir::ClassUnicodeRange::new('e', 'g'),","    ];","    let result = compiler.c_class(&ranges);","    assert!(result.is_ok());","}"],[{"start_line":422,"start_column":12,"end_line":422,"end_column":38,"positive":false,"negative":true},{"start_line":430,"start_column":27,"end_line":430,"end_column":44,"positive":false,"negative":true},{"start_line":430,"start_column":48,"end_line":430,"end_column":74,"positive":false,"negative":false}]],[["{","    use syntax::hir::{ClassUnicodeRange};","","    let mut compiler = Compiler::new();","    compiler.compiled.is_bytes = false; // Ensure uses_bytes() returns false","","    let ranges = vec![ClassUnicodeRange::new('a', 'a')]; // Single character range","    let result = compiler.c_class(&ranges);","","    assert!(result.is_ok());","","    if let Ok(patch) = result {","        assert_eq!(patch.entry, 0); // The entry is at the start","        // Ensure the hole is for character 'a'","        if let Hole::One(hole_index) = patch.hole {","            if let MaybeInst::Uncompiled(InstHole::Char { c }) = compiler.insts[hole_index] {","                assert_eq!(c, 'a');","            } else {","                panic!(\"Expected hole to be a Char instruction for 'a'\");","            }","        } else {","            panic!(\"Expected hole to be of type One\");","        }","    } else {","        panic!(\"Expected result to be Ok\");","    }","}"],[{"start_line":422,"start_column":12,"end_line":422,"end_column":38,"positive":false,"negative":true},{"start_line":430,"start_column":27,"end_line":430,"end_column":44,"positive":true,"negative":false},{"start_line":430,"start_column":48,"end_line":430,"end_column":74,"positive":true,"negative":false}]]]}