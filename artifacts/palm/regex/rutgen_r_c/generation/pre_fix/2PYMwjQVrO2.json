{
  "name": "regex_debug::escape_unicode",
  "name_with_impl": "regex_debug::escape_unicode",
  "mod_info": {
    "name": "",
    "loc": "regex-debug/src/main.rs:1:1:328:2"
  },
  "visible": false,
  "loc": "regex-debug/src/main.rs:290:1:313:2",
  "fn_tests": [
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Err(_) is true\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = &[0xFF, 0xFE, 0xFD]; // Invalid UTF-8 sequence",
                  "    let expected_output = \"\\\\xff\\\\xfe\\\\xfd\"; // Expectation for escape_bytes",
                  "",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"hello\"; // Valid UTF-8 with no whitespace",
                  "    let expected_output = \"hello\"; // No spaces to escape, should be same as input",
                  "",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = &[0xF0, 0x9F, 0x8C, 0x80]; // Valid UTF-8 for ðŸŒˆ (Rainbow)",
                  "    let expected_output = \"ðŸŒˆ\"; // No spaces, output should remain as is",
                  "",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: c in show.chars() is true\n",
        "// constraint: c.is_whitespace() is true\n",
        "// constraint: c as u32 <= 0x7F is true, with bound c as u32 == 0x7F\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"Hello World\"; // Valid UTF-8 with no non-whitespace characters",
                  "    let expected = \"Hello World\".to_string();",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"Hello \\t World\\n\"; // Valid UTF-8 including whitespace characters (tab, newline)",
                  "    let expected = \"Hello \\u{0009} World\\u{000A}\".to_string(); // Tabs and newlines escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"   \\t\\n \"; // Valid UTF-8 made of whitespace characters",
                  "    let expected = \"\\u{0020}\\u{0009}\\u{000A}\\u{0020}\".to_string(); // All whitespace characters escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = &[0xFF, 0xFE, 0xFD]; // Invalid UTF-8 bytes",
                  "    let expected = \"\\\\xff\\\\xfe\\\\xfd\".to_string(); // Bytes are escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"~\"; // One character at boundary of valid UTF-8",
                  "    let expected = \"~\".to_string(); // Normal output for a character outside the whitespace range",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: c in show.chars() is true\n",
        "// constraint: c.is_whitespace() is true\n",
        "// constraint: c as u32 <= 0x7F is false\n",
        "// constraint: c as u32 <= 0xFFFF is true, with bound c as u32 == 0xFFFF\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\" \\t\\n\\r\"; // All whitespace characters",
                  "    let expected = String::from(r\"\\ \"); // Space should be escaped",
                  "    assert_eq!(escape_unicode(input), expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello, \\nWorld!\"; // Contains newline",
                  "    let expected = String::from(\"Hello, \\u{000A}World!\"); // Newline should be escaped",
                  "    assert_eq!(escape_unicode(input), expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = [0xFF, 0xFE]; // UTF-16 encoding for characters beyond ASCII",
                  "    let expected = String::from(r\"\\u{00ff}\\u{00fe}\"); // Characters should be escaped",
                  "    assert_eq!(escape_unicode(&input), expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = &[0xF0, 0x9F, 0x92, 0xA9]; // Emoji character: ðŸ’©",
                  "    let expected = String::from(r\"\\U{0001f4a9}\"); // High unicode character should be escaped",
                  "    assert_eq!(escape_unicode(input), expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"abcXYZ\"; // No whitespace",
                  "    let expected = String::from(\"abcXYZ\"); // Output remains unchanged",
                  "    assert_eq!(escape_unicode(input), expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = &[0xFF, 0xFE, 0xFD]; // Invalid UTF-8 bytes",
                  "    let expected = String::from(r\"\\xff\\xfe\\xfd\"); // Should escape bytes",
                  "    assert_eq!(escape_unicode(input), expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: c in show.chars() is true\n",
        "// constraint: c.is_whitespace() is true\n",
        "// constraint: c as u32 <= 0x7F is false\n",
        "// constraint: c as u32 <= 0xFFFF is false\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"\\n\\xA0\";",
                  "    let expected = r\"\\u{00a0}\"; // Non-breaking space (0xA0) is greater than 0x7F and 0xFFFF",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"\\xF0\\x9F\\x98\\x80\"; // U+1F600 (grinning face)",
                  "    let expected = r\"\\U{0001f600}\";",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello \\n\\xA3\"; // Includes whitespace and high unicode (0xA3 is the pound sign)",
                  "    let expected = \"Hello \".to_string() + r\"\\u{00a3}\"; // Space remains as is, pound sign escapes",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"\";",
                  "    let expected = \"\"; // Empty input should return empty string",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"abc\\xA3def\"; // Contains characters that are not whitespace",
                  "    let expected = \"abc\".to_string() + r\"\\u{00a3}\" + \"def\"; // Pound sign escapes but others remain the same",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: c in show.chars() is true\n",
        "// constraint: c.is_whitespace() is false\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let bytes: &[u8] = b\"Hello World\";",
                  "    let escaped = escape_unicode(bytes);",
                  "    assert_eq!(escaped, \"Hello World\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let bytes: &[u8] = b\"Hello \\t World\\n\";",
                  "    let escaped = escape_unicode(bytes);",
                  "    assert_eq!(escaped, \"Hello \\t World\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    // Testing with non-ASCII characters",
                  "    let bytes: &[u8] = \"ÐŸÑ€Ð¸Ð²ÐµÑ‚\".as_bytes();",
                  "    let escaped = escape_unicode(bytes);",
                  "    assert_eq!(escaped, \"ÐŸÑ€Ð¸Ð²ÐµÑ‚\"); // Non-whitespace characters remain unchanged",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    // Testing with non-ASCII whitespace (U+3000 is a full-width space)",
                  "    let bytes: &[u8] = &[0xE3, 0x80, 0x80]; // Full-width space",
                  "    let escaped = escape_unicode(bytes);",
                  "    assert_eq!(escaped, r\"\\u{3000}\"); // It's a whitespace, so it should be escaped",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    // Testing with a character that exceeds 0xFFFF",
                  "    let bytes: &[u8] = \"ð €€\".as_bytes(); // U+20000",
                  "    let escaped = escape_unicode(bytes);",
                  "    assert_eq!(escaped, r\"\\U{00020000}\"); // Should be escaped as long unicode",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let bytes: &[u8] = \"A \\u{3000}\".as_bytes(); // \"A\" followed by a full-width space",
                  "    let escaped = escape_unicode(bytes);",
                  "    assert_eq!(escaped, \"A \\u{3000}\"); // Non-whitespace characters remain unchanged",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let bytes: &[u8] = b\"Line1\\n\\nLine2\\t   \";",
                  "    let escaped = escape_unicode(bytes);",
                  "    assert_eq!(escaped, \"Line1\\n\\nLine2\\t   \"); // Only whitespace characters should be preserved",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello World!\";",
                  "    let expected = String::from(\"Hello World!\");",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello\\tWorld!\";",
                  "    let expected = String::from(\"Hello\\tWorld!\");",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = \"Hello \\u{2603} World!\".as_bytes(); // Unicode Snowman",
                  "    let expected = String::from(\"Hello \\u{2603} World!\");",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = \"Hello \\u{00A0}World!\".as_bytes(); // Non-breaking space",
                  "    let expected = String::from(\"Hello \\u{00A0}World!\");",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"HelloWorld!\";",
                  "    let expected = String::from(\"HelloWorld!\");",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"\\xFF\"; // Invalid UTF-8",
                  "    let expected = escape_bytes(input); // Will trigger fallback to escape_bytes",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}