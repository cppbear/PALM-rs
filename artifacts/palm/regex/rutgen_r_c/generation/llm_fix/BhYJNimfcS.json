{
  "name": "regex_syntax::hir::literal::<hir::literal::Literals as std::fmt::Debug>::fmt",
  "name_with_impl": "regex_syntax::hir::literal::{impl#1}::fmt",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:27:1:27:17"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/literal/mod.rs:870:5:876:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use std::fmt;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    use std::fmt;",
                  "",
                  "    #[derive(Clone, Eq, PartialEq)]",
                  "    struct Literals {",
                  "        lits: Vec<Literal>,",
                  "        limit_size: usize,",
                  "        limit_class: usize,",
                  "    }",
                  "",
                  "    #[derive(Clone, Debug, Eq, PartialEq)]",
                  "    enum Literal {",
                  "        Unicode(char),",
                  "        Byte(u8),",
                  "    }",
                  "",
                  "    impl fmt::Debug for Literals {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            f.debug_struct(\"Literals\")",
                  "                .field(\"lits\", &self.lits)",
                  "                .field(\"limit_size\", &self.limit_size)",
                  "                .field(\"limit_class\", &self.limit_class)",
                  "                .finish()",
                  "        }",
                  "    }",
                  "",
                  "    // Test with empty `Literals`",
                  "    let empty_literals = Literals {",
                  "        lits: vec![],",
                  "        limit_size: 0,",
                  "        limit_class: 0,",
                  "    };",
                  "    let output_empty = format!(\"{:?}\", empty_literals);",
                  "    assert_eq!(output_empty, \"Literals { lits: [], limit_size: 0, limit_class: 0 }\");",
                  "",
                  "    // Test with various literals",
                  "    let literals_with_unicode = Literals {",
                  "        lits: vec![Literal::Unicode('a'), Literal::Unicode('b')],",
                  "        limit_size: 2,",
                  "        limit_class: 1,",
                  "    };",
                  "    let output_unicode = format!(\"{:?}\", literals_with_unicode);",
                  "    assert_eq!(output_unicode, \"Literals { lits: [Unicode('a'), Unicode('b')], limit_size: 2, limit_class: 1 }\");",
                  "",
                  "    let literals_with_bytes = Literals {",
                  "        lits: vec![Literal::Byte(1), Literal::Byte(255)],",
                  "        limit_size: 2,",
                  "        limit_class: 1,",
                  "    };",
                  "    let output_bytes = format!(\"{:?}\", literals_with_bytes);",
                  "    assert_eq!(output_bytes, \"Literals { lits: [Byte(1), Byte(255)], limit_size: 2, limit_class: 1 }\");",
                  "",
                  "    // Test with mixed literals",
                  "    let mixed_literals = Literals {",
                  "        lits: vec![Literal::Unicode('c'), Literal::Byte(2), Literal::Unicode('d')],",
                  "        limit_size: 3,",
                  "        limit_class: 2,",
                  "    };",
                  "    let output_mixed = format!(\"{:?}\", mixed_literals);",
                  "    assert_eq!(output_mixed, \"Literals { lits: [Unicode('c'), Byte(2), Unicode('d')], limit_size: 3, limit_class: 2 }\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}