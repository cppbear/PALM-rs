{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/visitor.rs\n// crate name is regex_syntax\nuse std::fmt;\nuse ast::{self, Ast};\nstruct HeapVisitor<'a> {\n    /// A stack of `Ast` nodes. This is roughly analogous to the call stack\n    /// used in a typical recursive visitor.\n    stack: Vec<(&'a Ast, Frame<'a>)>,\n    /// Similar to the `Ast` stack above, but is used only for character\n    /// classes. In particular, character classes embed their own mini\n    /// recursive syntax.\n    stack_class: Vec<(ClassInduct<'a>, ClassFrame<'a>)>,\n}\nenum Frame<'a> {\n    /// A stack frame allocated just before descending into a repetition\n    /// operator's child node.\n    Repetition(&'a ast::Repetition),\n    /// A stack frame allocated just before descending into a group's child\n    /// node.\n    Group(&'a ast::Group),\n    /// The stack frame used while visiting every child node of a concatenation\n    /// of expressions.\n    Concat {\n        /// The child node we are currently visiting.\n        head: &'a Ast,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Ast],\n    },\n    /// The stack frame used while visiting every child node of an alternation\n    /// of expressions.\n    Alternation {\n        /// The child node we are currently visiting.\n        head: &'a Ast,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Ast],\n    },\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Ast {\n    /// An empty regex that matches everything.\n    Empty(Span),\n    /// A set of flags, e.g., `(?is)`.\n    Flags(SetFlags),\n    /// A single character literal, which includes escape sequences.\n    Literal(Literal),\n    /// The \"any character\" class.\n    Dot(Span),\n    /// A single zero-width assertion.\n    Assertion(Assertion),\n    /// A single character class. This includes all forms of character classes\n    /// except for `.`. e.g., `\\d`, `\\pN`, `[a-z]` and `[[:alpha:]]`.\n    Class(Class),\n    /// A repetition operator applied to an arbitrary regular expression.\n    Repetition(Repetition),\n    /// A grouped regular expression.\n    Group(Group),\n    /// An alternation of regular expressions.\n    Alternation(Alternation),\n    /// A concatenation of regular expressions.\n    Concat(Concat),\n}\nenum Frame<'a> {\n    /// A stack frame allocated just before descending into a repetition\n    /// operator's child node.\n    Repetition(&'a hir::Repetition),\n    /// A stack frame allocated just before descending into a group's child\n    /// node.\n    Group(&'a hir::Group),\n    /// The stack frame used while visiting every child node of a concatenation\n    /// of expressions.\n    Concat {\n        /// The child node we are currently visiting.\n        head: &'a Hir,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Hir],\n    },\n    /// The stack frame used while visiting every child node of an alternation\n    /// of expressions.\n    Alternation {\n        /// The child node we are currently visiting.\n        head: &'a Hir,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Hir],\n    },\n}\nenum ClassFrame<'a> {\n    /// The stack frame used while visiting every child node of a union of\n    /// character class items.\n    Union {\n        /// The child node we are currently visiting.\n        head: &'a ast::ClassSetItem,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [ast::ClassSetItem],\n    },\n    /// The stack frame used while a binary class operation.\n    Binary { op: &'a ast::ClassSetBinaryOp },\n    /// A stack frame allocated just before descending into a binary operator's\n    /// left hand child node.\n    BinaryLHS {\n        op: &'a ast::ClassSetBinaryOp,\n        lhs: &'a ast::ClassSet,\n        rhs: &'a ast::ClassSet,\n    },\n    /// A stack frame allocated just before descending into a binary operator's\n    /// right hand child node.\n    BinaryRHS { op: &'a ast::ClassSetBinaryOp, rhs: &'a ast::ClassSet },\n}\nenum ClassInduct<'a> {\n    Item(&'a ast::ClassSetItem),\n    BinaryOp(&'a ast::ClassSetBinaryOp),\n}\nimpl<'a> HeapVisitor<'a> {\n    fn new() -> HeapVisitor<'a> {}\n    fn visit<V: Visitor>(\n        &mut self,\n        mut ast: &'a Ast,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err> {\n        self.stack.clear();\n        self.stack_class.clear();\n        visitor.start();\n        loop {\n            visitor.visit_pre(ast)?;\n            if let Some(x) = self.induct(ast, &mut visitor)? {\n                let child = x.child();\n                self.stack.push((ast, x));\n                ast = child;\n                continue;\n            }\n            visitor.visit_post(ast)?;\n            loop {\n                let (post_ast, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    ast = x.child();\n                    self.stack.push((post_ast, x));\n                    break;\n                }\n                visitor.visit_post(post_ast)?;\n            }\n        }\n    }\n    fn induct<V: Visitor>(\n        &mut self,\n        ast: &'a Ast,\n        visitor: &mut V,\n    ) -> Result<Option<Frame<'a>>, V::Err> {}\n    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Group(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }\n    fn visit_class<V: Visitor>(\n        &mut self,\n        ast: &'a ast::ClassBracketed,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {}\n    fn visit_class_pre<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {}\n    fn visit_class_post<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {}\n    fn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>> {}\n    fn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>> {}\n}\nimpl<'a> Frame<'a> {\n    fn child(&self) -> &'a Ast {\n        match *self {\n            Frame::Repetition(rep) => &rep.ast,\n            Frame::Group(group) => &group.ast,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }\n}\n\nThe function to be tested is presented as follows:\nfn visit<V: Visitor>(\n    &mut self,\n    mut ast: &'a Ast,\n    mut visitor: V,\n) -> Result<V::Output, V::Err> {\n    self.stack.clear();\n    self.stack_class.clear();\n\n    visitor.start();\n    loop {\n        visitor.visit_pre(ast)?;\n        if let Some(x) = self.induct(ast, &mut visitor)? {\n            let child = x.child();\n            self.stack.push((ast, x));\n            ast = child;\n            continue;\n        }\n        // No induction means we have a base case, so we can post visit\n        // it now.\n        visitor.visit_post(ast)?;\n\n        // At this point, we now try to pop our call stack until it is\n        // either empty or we hit another inductive case.\n        loop {\n            let (post_ast, frame) = match self.stack.pop() {\n                None => return visitor.finish(),\n                Some((post_ast, frame)) => (post_ast, frame),\n            };\n            // If this is a concat/alternate, then we might have additional\n            // inductive steps to process.\n            if let Some(x) = self.pop(frame) {\n                if let Frame::Alternation {..} = x {\n                    visitor.visit_alternation_in()?;\n                }\n                ast = x.child();\n                self.stack.push((post_ast, x));\n                break;\n            }\n            // Otherwise, we've finished visiting all the child nodes for\n            // this AST, so we can post visit it now.\n            visitor.visit_post(post_ast)?;\n        }\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}