{"function_name":"fastrand::Rng::fill","tests":11,"tests_lines":[29,29,28,6,6,6,8,5,39,34,37],"oracles":11,"oracles_compiled":6,"oracles_compiled_rate":54.54545454545454,"tests_compiled":6,"tests_compiled_rate":54.54545454545454,"oracles_run":6,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":6,"tests_passed":0,"tests_passed_rate":0.0,"lines":20,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[537,538,539,540,541,542,543,544,545,547,548,549,550,551,552,553,554,555,556,557],"codes_lines_covered":[[["{","    struct Rng {","        seed: u64,","    }","","    impl Rng {","        fn gen_u64(&self) -> u64 {","            self.seed","        }","","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = Rng { seed: 42 };","    let mut data = [0u8; 16]; // Multiple of 8","    rng.fill(&mut data);","    assert_eq!(data, [42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42]);","}"],[]],[["{","    struct Rng {","        seed: u64,","    }","","    impl Rng {","        fn gen_u64(&self) -> u64 {","            self.seed","        }","","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = Rng { seed: 100 };","    let mut data = [0u8; 10]; // Length not a multiple of 8","    rng.fill(&mut data);","    assert_eq!(data, [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]);","}"],[]],[["{","    struct Rng {","        seed: u64,","    }","","    impl Rng {","        fn gen_u64(&self) -> u64 {","            self.seed","        }","","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = Rng { seed: 200 };","    let mut data: &mut [u8] = &mut [];","    rng.fill(data); // This should panic.","}"],[]],[["{","    struct Random {","        state: u64,","    }","","    impl Random {","        pub fn new(state: u64) -> Self {","            Random { state }","        }","","        pub fn gen_u64(&mut self) -> u64 {","            self.state += 1;","            self.state","        }","","        pub fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut random = Random::new(0);","    let mut buffer = [0u8; 9]; // 8 bytes for one full u64, and 1 byte for remainder","    random.fill(&mut buffer);","","    // Check that the first 8 bytes are filled with incremented values","    assert_eq!(&buffer[0..8], &0u64.to_ne_bytes());","    // Check that the last byte is filled from the next generated value","    assert_eq!(buffer[8], 1u64.to_ne_bytes()[0]);","}"],[]],[["{","    struct Random {","        state: u64,","    }","","    impl Random {","        pub fn new(state: u64) -> Self {","            Random { state }","        }","","        pub fn gen_u64(&mut self) -> u64 {","            self.state += 1;","            self.state","        }","","        pub fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut random = Random::new(0);","    let mut invalid_buffer = [0u8; 7]; // Buffer that cannot be chunked into 8 bytes","    random.fill(&mut invalid_buffer); // This should panic","}"],[]],[["{","    struct Random {","        state: u64,","    }","","    impl Random {","        pub fn new(state: u64) -> Self {","            Random { state }","        }","","        pub fn gen_u64(&mut self) -> u64 {","            self.state += 1;","            self.state","        }","","        pub fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut random = Random::new(0);","    let mut buffer = [0u8; 8]; // Exactly one u64","    random.fill(&mut buffer);","","    // Check that the buffer is filled with incremented values","    assert_eq!(buffer, 0u64.to_ne_bytes());","}"],[]]],"codes_branches":[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct Rng {","        seed: u64,","    }","","    impl Rng {","        fn gen_u64(&self) -> u64 {","            self.seed","        }","","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = Rng { seed: 42 };","    let mut data = [0u8; 16]; // Multiple of 8","    rng.fill(&mut data);","    assert_eq!(data, [42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42]);","}"],[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Rng {","        seed: u64,","    }","","    impl Rng {","        fn gen_u64(&self) -> u64 {","            self.seed","        }","","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = Rng { seed: 100 };","    let mut data = [0u8; 10]; // Length not a multiple of 8","    rng.fill(&mut data);","    assert_eq!(data, [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]);","}"],[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Rng {","        seed: u64,","    }","","    impl Rng {","        fn gen_u64(&self) -> u64 {","            self.seed","        }","","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = Rng { seed: 200 };","    let mut data: &mut [u8] = &mut [];","    rng.fill(data); // This should panic.","}"],[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Random {","        state: u64,","    }","","    impl Random {","        pub fn new(state: u64) -> Self {","            Random { state }","        }","","        pub fn gen_u64(&mut self) -> u64 {","            self.state += 1;","            self.state","        }","","        pub fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut random = Random::new(0);","    let mut buffer = [0u8; 9]; // 8 bytes for one full u64, and 1 byte for remainder","    random.fill(&mut buffer);","","    // Check that the first 8 bytes are filled with incremented values","    assert_eq!(&buffer[0..8], &0u64.to_ne_bytes());","    // Check that the last byte is filled from the next generated value","    assert_eq!(buffer[8], 1u64.to_ne_bytes()[0]);","}"],[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Random {","        state: u64,","    }","","    impl Random {","        pub fn new(state: u64) -> Self {","            Random { state }","        }","","        pub fn gen_u64(&mut self) -> u64 {","            self.state += 1;","            self.state","        }","","        pub fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut random = Random::new(0);","    let mut invalid_buffer = [0u8; 7]; // Buffer that cannot be chunked into 8 bytes","    random.fill(&mut invalid_buffer); // This should panic","}"],[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Random {","        state: u64,","    }","","    impl Random {","        pub fn new(state: u64) -> Self {","            Random { state }","        }","","        pub fn gen_u64(&mut self) -> u64 {","            self.state += 1;","            self.state","        }","","        pub fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut random = Random::new(0);","    let mut buffer = [0u8; 8]; // Exactly one u64","    random.fill(&mut buffer);","","    // Check that the buffer is filled with incremented values","    assert_eq!(buffer, 0u64.to_ne_bytes());","}"],[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}]]]}