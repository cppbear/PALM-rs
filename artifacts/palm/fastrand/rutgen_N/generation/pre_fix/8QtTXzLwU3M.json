{
  "name": "fastrand::Rng::fill",
  "name_with_impl": "fastrand::{impl#2}::fill",
  "mod_info": {
    "name": "",
    "loc": "src/lib.rs:1:1:689:2"
  },
  "visible": true,
  "loc": "src/lib.rs:537:5:557:6",
  "fn_tests": [
    {
      "chain_id": 0,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct RNG;",
                  "",
                  "    impl RNG {",
                  "        fn gen_u64(&self) -> u64 {",
                  "            0 // Return a constant for simplicity in this test",
                  "        }",
                  "        ",
                  "        fn fill(&mut self, slice: &mut [u8]) {",
                  "            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());",
                  "            for chunk in chunks.by_ref() {",
                  "                let n = self.gen_u64().to_ne_bytes();",
                  "                chunk.copy_from_slice(&n);",
                  "            }",
                  "",
                  "            let remainder = chunks.into_remainder();",
                  "            if !remainder.is_empty() {",
                  "                let n = self.gen_u64().to_ne_bytes();",
                  "                remainder.copy_from_slice(&n[..remainder.len()]);",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut rng = RNG;",
                  "    let mut data: [u8; 0] = [];",
                  "    rng.fill(&mut data);",
                  "    assert!(data.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct RNG;",
                  "",
                  "    impl RNG {",
                  "        fn gen_u64(&self) -> u64 {",
                  "            0b01010101_01010101_01010101_01010101_01010101_01010101_01010101_01010101 // 0x5555555555555555",
                  "        }",
                  "        ",
                  "        fn fill(&mut self, slice: &mut [u8]) {",
                  "            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());",
                  "            for chunk in chunks.by_ref() {",
                  "                let n = self.gen_u64().to_ne_bytes();",
                  "                chunk.copy_from_slice(&n);",
                  "            }",
                  "",
                  "            let remainder = chunks.into_remainder();",
                  "            if !remainder.is_empty() {",
                  "                let n = self.gen_u64().to_ne_bytes();",
                  "                remainder.copy_from_slice(&n[..remainder.len()]);",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut rng = RNG;",
                  "    let mut data: [u8; 5] = [0; 5];",
                  "    rng.fill(&mut data);",
                  "    assert_eq!(data, [85, 85, 85, 85, 85]); // Each byte should be 0x55",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct RNG;",
                  "",
                  "    impl RNG {",
                  "        fn gen_u64(&self) -> u64 {",
                  "            0b11110000_11110000_11110000_11110000_11110000_11110000_11110000_11110000 // 0xF0F0F0F0F0F0F0F0",
                  "        }",
                  "        ",
                  "        fn fill(&mut self, slice: &mut [u8]) {",
                  "            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());",
                  "            for chunk in chunks.by_ref() {",
                  "                let n = self.gen_u64().to_ne_bytes();",
                  "                chunk.copy_from_slice(&n);",
                  "            }",
                  "",
                  "            let remainder = chunks.into_remainder();",
                  "            if !remainder.is_empty() {",
                  "                let n = self.gen_u64().to_ne_bytes();",
                  "                remainder.copy_from_slice(&n[..remainder.len()]);",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut rng = RNG;",
                  "    let mut data: [u8; 8] = [0; 8];",
                  "    rng.fill(&mut data);",
                  "    assert_eq!(data, [240, 240, 240, 240, 240, 240, 240, 240]); // Each byte should be 0xF0",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct RNG;",
                  "",
                  "    impl RNG {",
                  "        fn gen_u64(&self) -> u64 {",
                  "            0b10101010_10101010_10101010_10101010_10101010_10101010_10101010_10101010 // 0xAAAAAAAAAAAAAAAA",
                  "        }",
                  "        ",
                  "        fn fill(&mut self, slice: &mut [u8]) {",
                  "            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());",
                  "            for chunk in chunks.by_ref() {",
                  "                let n = self.gen_u64().to_ne_bytes();",
                  "                chunk.copy_from_slice(&n);",
                  "            }",
                  "",
                  "            let remainder = chunks.into_remainder();",
                  "            if !remainder.is_empty() {",
                  "                let n = self.gen_u64().to_ne_bytes();",
                  "                remainder.copy_from_slice(&n[..remainder.len()]);",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut rng = RNG;",
                  "    let mut data: [u8; 12] = [0; 12];",
                  "    rng.fill(&mut data);",
                  "    assert_eq!(data[..8], [170, 170, 170, 170, 170, 170, 170, 170]); // First 8 bytes 0xAA",
                  "    assert_eq!(data[8..], [170, 170, 0, 0]); // Last 4 bytes should be 0xAA, and filled from next u64",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}