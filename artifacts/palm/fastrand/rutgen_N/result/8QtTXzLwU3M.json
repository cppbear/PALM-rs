{"function_name":"fastrand::Rng::fill","tests":4,"tests_lines":[28,28,28,29],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":20,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[537,538,539,540,541,542,543,544,545,547,548,549,550,551,552,553,554,555,556,557],"codes_lines_covered":[[["{","    struct RNG;","","    impl RNG {","        fn gen_u64(&self) -> u64 {","            0 // Return a constant for simplicity in this test","        }","        ","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = RNG;","    let mut data: [u8; 0] = [];","    rng.fill(&mut data);","    assert!(data.is_empty());","}"],[]],[["{","    struct RNG;","","    impl RNG {","        fn gen_u64(&self) -> u64 {","            0b01010101_01010101_01010101_01010101_01010101_01010101_01010101_01010101 // 0x5555555555555555","        }","        ","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = RNG;","    let mut data: [u8; 5] = [0; 5];","    rng.fill(&mut data);","    assert_eq!(data, [85, 85, 85, 85, 85]); // Each byte should be 0x55","}"],[]],[["{","    struct RNG;","","    impl RNG {","        fn gen_u64(&self) -> u64 {","            0b11110000_11110000_11110000_11110000_11110000_11110000_11110000_11110000 // 0xF0F0F0F0F0F0F0F0","        }","        ","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = RNG;","    let mut data: [u8; 8] = [0; 8];","    rng.fill(&mut data);","    assert_eq!(data, [240, 240, 240, 240, 240, 240, 240, 240]); // Each byte should be 0xF0","}"],[]],[["{","    struct RNG;","","    impl RNG {","        fn gen_u64(&self) -> u64 {","            0b10101010_10101010_10101010_10101010_10101010_10101010_10101010_10101010 // 0xAAAAAAAAAAAAAAAA","        }","        ","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = RNG;","    let mut data: [u8; 12] = [0; 12];","    rng.fill(&mut data);","    assert_eq!(data[..8], [170, 170, 170, 170, 170, 170, 170, 170]); // First 8 bytes 0xAA","    assert_eq!(data[8..], [170, 170, 0, 0]); // Last 4 bytes should be 0xAA, and filled from next u64","}"],[]]],"codes_branches":[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct RNG;","","    impl RNG {","        fn gen_u64(&self) -> u64 {","            0 // Return a constant for simplicity in this test","        }","        ","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = RNG;","    let mut data: [u8; 0] = [];","    rng.fill(&mut data);","    assert!(data.is_empty());","}"],[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}]],[["{","    struct RNG;","","    impl RNG {","        fn gen_u64(&self) -> u64 {","            0b01010101_01010101_01010101_01010101_01010101_01010101_01010101_01010101 // 0x5555555555555555","        }","        ","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = RNG;","    let mut data: [u8; 5] = [0; 5];","    rng.fill(&mut data);","    assert_eq!(data, [85, 85, 85, 85, 85]); // Each byte should be 0x55","}"],[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}]],[["{","    struct RNG;","","    impl RNG {","        fn gen_u64(&self) -> u64 {","            0b11110000_11110000_11110000_11110000_11110000_11110000_11110000_11110000 // 0xF0F0F0F0F0F0F0F0","        }","        ","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = RNG;","    let mut data: [u8; 8] = [0; 8];","    rng.fill(&mut data);","    assert_eq!(data, [240, 240, 240, 240, 240, 240, 240, 240]); // Each byte should be 0xF0","}"],[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}]],[["{","    struct RNG;","","    impl RNG {","        fn gen_u64(&self) -> u64 {","            0b10101010_10101010_10101010_10101010_10101010_10101010_10101010_10101010 // 0xAAAAAAAAAAAAAAAA","        }","        ","        fn fill(&mut self, slice: &mut [u8]) {","            let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());","            for chunk in chunks.by_ref() {","                let n = self.gen_u64().to_ne_bytes();","                chunk.copy_from_slice(&n);","            }","","            let remainder = chunks.into_remainder();","            if !remainder.is_empty() {","                let n = self.gen_u64().to_ne_bytes();","                remainder.copy_from_slice(&n[..remainder.len()]);","            }","        }","    }","","    let mut rng = RNG;","    let mut data: [u8; 12] = [0; 12];","    rng.fill(&mut data);","    assert_eq!(data[..8], [170, 170, 170, 170, 170, 170, 170, 170]); // First 8 bytes 0xAA","    assert_eq!(data[8..], [170, 170, 0, 0]); // Last 4 bytes should be 0xAA, and filled from next u64","}"],[{"start_line":550,"start_column":12,"end_line":550,"end_column":33,"positive":false,"negative":false}]]]}