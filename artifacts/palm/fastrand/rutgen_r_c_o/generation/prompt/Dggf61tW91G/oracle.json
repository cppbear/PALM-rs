{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/lib.rs\n// crate name is fastrand\nuse core::convert::{TryFrom, TryInto};\nuse core::ops::{Bound, RangeBounds};\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n#[cfg(feature = \"std\")]\npub use global_rng::*;\nmacro_rules! rng_integer {\n    ($t:tt, $unsigned_t:tt, $gen:tt, $mod:tt, $doc:tt) => {\n        #[doc = $doc] #[doc = \"\"] #[doc = \" Panics if the range is empty.\"] #[inline] pub\n        fn $t (& mut self, range : impl RangeBounds <$t >) -> $t { let panic_empty_range\n        = || { panic!(\"empty range: {:?}..{:?}\", range.start_bound(), range.end_bound())\n        }; let low = match range.start_bound() { Bound::Unbounded => core::$t ::MIN,\n        Bound::Included(& x) => x, Bound::Excluded(& x) => x.checked_add(1)\n        .unwrap_or_else(panic_empty_range), }; let high = match range.end_bound() {\n        Bound::Unbounded => core::$t ::MAX, Bound::Included(& x) => x, Bound::Excluded(&\n        x) => x.checked_sub(1).unwrap_or_else(panic_empty_range), }; if low > high {\n        panic_empty_range(); } if low == core::$t ::MIN && high == core::$t ::MAX { self\n        .$gen () as $t } else { let len = high.wrapping_sub(low).wrapping_add(1); low\n        .wrapping_add(self.$mod (len as $unsigned_t as _) as $t) } }\n    };\n}\n#[derive(Debug, PartialEq, Eq)]\npub struct Rng(u64);\nimpl Rng {\n    #[inline]\n    #[must_use = \"this creates a new instance of `Rng`; if you want to initialize the thread-local generator, use `fastrand::seed()` instead\"]\n    pub fn with_seed(seed: u64) -> Self {\n        Rng(seed)\n    }\n    #[inline]\n    #[must_use = \"this creates a new instance of `Rng`\"]\n    pub fn fork(&mut self) -> Self {\n        Rng::with_seed(self.gen_u64())\n    }\n    #[inline]\n    pub fn alphabetic(&mut self) -> char {}\n    #[inline]\n    pub fn alphanumeric(&mut self) -> char {}\n    #[inline]\n    pub fn bool(&mut self) -> bool {\n        self.u8(..) % 2 == 0\n    }\n    #[inline]\n    pub fn digit(&mut self, base: u32) -> char {}\n    pub fn f32(&mut self) -> f32 {\n        let b = 32;\n        let f = core::f32::MANTISSA_DIGITS - 1;\n        f32::from_bits((1 << (b - 2)) - (1 << f) + (self.u32(..) >> (b - f))) - 1.0\n    }\n    pub fn f64(&mut self) -> f64 {\n        let b = 64;\n        let f = core::f64::MANTISSA_DIGITS - 1;\n        f64::from_bits((1 << (b - 2)) - (1 << f) + (self.u64(..) >> (b - f))) - 1.0\n    }\n    #[cfg(feature = \"alloc\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"alloc\")))]\n    pub fn choose_multiple<I: IntoIterator>(\n        &mut self,\n        source: I,\n        amount: usize,\n    ) -> Vec<I::Item> {}\n    #[inline]\n    pub fn lowercase(&mut self) -> char {}\n    #[inline]\n    pub fn seed(&mut self, seed: u64) {}\n    #[inline]\n    pub fn get_seed(&self) -> u64 {}\n    #[inline]\n    pub fn choice<I>(&mut self, iter: I) -> Option<I::Item>\n    where\n        I: IntoIterator,\n        I::IntoIter: ExactSizeIterator,\n    {}\n    #[inline]\n    pub fn shuffle<T>(&mut self, slice: &mut [T]) {}\n    #[inline]\n    pub fn fill(&mut self, slice: &mut [u8]) {}\n    #[inline]\n    pub fn uppercase(&mut self) -> char {}\n    #[inline]\n    pub fn char(&mut self, range: impl RangeBounds<char>) -> char {\n        let panic_empty_range = || {\n            panic!(\"empty range: {:?}..{:?}\", range.start_bound(), range.end_bound())\n        };\n        let surrogate_start = 0xd800u32;\n        let surrogate_len = 0x800u32;\n        let low = match range.start_bound() {\n            Bound::Unbounded => 0u8 as char,\n            Bound::Included(&x) => x,\n            Bound::Excluded(&x) => {\n                let scalar = if x as u32 == surrogate_start - 1 {\n                    surrogate_start + surrogate_len\n                } else {\n                    x as u32 + 1\n                };\n                char::try_from(scalar).unwrap_or_else(|_| panic_empty_range())\n            }\n        };\n        let high = match range.end_bound() {\n            Bound::Unbounded => core::char::MAX,\n            Bound::Included(&x) => x,\n            Bound::Excluded(&x) => {\n                let scalar = if x as u32 == surrogate_start + surrogate_len {\n                    surrogate_start - 1\n                } else {\n                    (x as u32).wrapping_sub(1)\n                };\n                char::try_from(scalar).unwrap_or_else(|_| panic_empty_range())\n            }\n        };\n        if low > high {\n            panic_empty_range();\n        }\n        let gap = if (low as u32) < surrogate_start && (high as u32) >= surrogate_start {\n            surrogate_len\n        } else {\n            0\n        };\n        let range = high as u32 - low as u32 - gap;\n        let mut val = self.u32(0..=range) + low as u32;\n        if val >= surrogate_start {\n            val += gap;\n        }\n        val.try_into().unwrap()\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Generates a random `char` in the given range.\n///\n/// Panics if the range is empty.\npub fn char(&mut self, range: impl RangeBounds<char>) -> char {\n    let panic_empty_range = || {\n        panic!(\n            \"empty range: {:?}..{:?}\",\n            range.start_bound(),\n            range.end_bound()\n        )\n    };\n\n    let surrogate_start = 0xd800u32;\n    let surrogate_len = 0x800u32;\n\n    let low = match range.start_bound() {\n        Bound::Unbounded => 0u8 as char,\n        Bound::Included(&x) => x,\n        Bound::Excluded(&x) => {\n            let scalar = if x as u32 == surrogate_start - 1 {\n                surrogate_start + surrogate_len\n            } else {\n                x as u32 + 1\n            };\n            char::try_from(scalar).unwrap_or_else(|_| panic_empty_range())\n        }\n    };\n\n    let high = match range.end_bound() {\n        Bound::Unbounded => core::char::MAX,\n        Bound::Included(&x) => x,\n        Bound::Excluded(&x) => {\n            let scalar = if x as u32 == surrogate_start + surrogate_len {\n                surrogate_start - 1\n            } else {\n                (x as u32).wrapping_sub(1)\n            };\n            char::try_from(scalar).unwrap_or_else(|_| panic_empty_range())\n        }\n    };\n\n    if low > high {\n        panic_empty_range();\n    }\n\n    let gap = if (low as u32) < surrogate_start && (high as u32) >= surrogate_start {\n        surrogate_len\n    } else {\n        0\n    };\n    let range = high as u32 - low as u32 - gap;\n    let mut val = self.u32(0..=range) + low as u32;\n    if val >= surrogate_start {\n        val += gap;\n    }\n    val.try_into().unwrap()\n}\n",
  "depend_pt": ""
}