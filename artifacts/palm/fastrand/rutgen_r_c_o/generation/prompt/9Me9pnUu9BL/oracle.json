{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/lib.rs\n// crate name is fastrand\nuse core::convert::{TryFrom, TryInto};\nuse core::ops::{Bound, RangeBounds};\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n#[cfg(feature = \"std\")]\npub use global_rng::*;\nmacro_rules! rng_integer {\n    ($t:tt, $unsigned_t:tt, $gen:tt, $mod:tt, $doc:tt) => {\n        #[doc = $doc] #[doc = \"\"] #[doc = \" Panics if the range is empty.\"] #[inline] pub\n        fn $t (& mut self, range : impl RangeBounds <$t >) -> $t { let panic_empty_range\n        = || { panic!(\"empty range: {:?}..{:?}\", range.start_bound(), range.end_bound())\n        }; let low = match range.start_bound() { Bound::Unbounded => core::$t ::MIN,\n        Bound::Included(& x) => x, Bound::Excluded(& x) => x.checked_add(1)\n        .unwrap_or_else(panic_empty_range), }; let high = match range.end_bound() {\n        Bound::Unbounded => core::$t ::MAX, Bound::Included(& x) => x, Bound::Excluded(&\n        x) => x.checked_sub(1).unwrap_or_else(panic_empty_range), }; if low > high {\n        panic_empty_range(); } if low == core::$t ::MIN && high == core::$t ::MAX { self\n        .$gen () as $t } else { let len = high.wrapping_sub(low).wrapping_add(1); low\n        .wrapping_add(self.$mod (len as $unsigned_t as _) as $t) } }\n    };\n}\n#[derive(Debug, PartialEq, Eq)]\npub struct Rng(u64);\nimpl Rng {\n    #[inline]\n    fn gen_u32(&mut self) -> u32 {}\n    #[inline]\n    fn gen_u64(&mut self) -> u64 {}\n    #[inline]\n    fn gen_u128(&mut self) -> u128 {\n        (u128::from(self.gen_u64()) << 64) | u128::from(self.gen_u64())\n    }\n    #[inline]\n    fn gen_mod_u32(&mut self, n: u32) -> u32 {}\n    #[inline]\n    fn gen_mod_u64(&mut self, n: u64) -> u64 {}\n    #[inline]\n    fn gen_mod_u128(&mut self, n: u128) -> u128 {\n        let mut r = self.gen_u128();\n        let mut hi = mul_high_u128(r, n);\n        let mut lo = r.wrapping_mul(n);\n        if lo < n {\n            let t = n.wrapping_neg() % n;\n            while lo < t {\n                r = self.gen_u128();\n                hi = mul_high_u128(r, n);\n                lo = r.wrapping_mul(n);\n            }\n        }\n        hi\n    }\n}\n#[inline]\nfn mul_high_u128(a: u128, b: u128) -> u128 {\n    let a_lo = a as u64 as u128;\n    let a_hi = (a >> 64) as u64 as u128;\n    let b_lo = b as u64 as u128;\n    let b_hi = (b >> 64) as u64 as u128;\n    let carry = (a_lo * b_lo) >> 64;\n    let carry = ((a_hi * b_lo) as u64 as u128 + (a_lo * b_hi) as u64 as u128 + carry)\n        >> 64;\n    a_hi * b_hi + ((a_hi * b_lo) >> 64) + ((a_lo * b_hi) >> 64) + carry\n}\n\nThe function to be tested is presented as follows:\n/// Generates a random `u128` in `0..n`.\nfn gen_mod_u128(&mut self, n: u128) -> u128 {\n    // Adapted from: https://lemire.me/blog/2016/06/30/fast-random-shuffling/\n    let mut r = self.gen_u128();\n    let mut hi = mul_high_u128(r, n);\n    let mut lo = r.wrapping_mul(n);\n    if lo < n {\n        let t = n.wrapping_neg() % n;\n        while lo < t {\n            r = self.gen_u128();\n            hi = mul_high_u128(r, n);\n            lo = r.wrapping_mul(n);\n        }\n    }\n    hi\n}\n",
  "depend_pt": ""
}