{"function_name":"fastrand::Rng::gen_mod_u32","tests":12,"tests_lines":[5,5,4,7,5,5,4,5,10,31,31,30],"oracles":12,"oracles_compiled":11,"oracles_compiled_rate":91.66666666666666,"tests_compiled":11,"tests_compiled_rate":91.66666666666666,"oracles_run":11,"oracles_passed":8,"oracles_passed_rate":72.72727272727273,"tests_run":11,"tests_passed":8,"tests_passed_rate":72.72727272727273,"lines":15,"lines_covered":11,"lines_coveraged_rate":73.33333333333333,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[170,171,172,173,174,175,176,177,178,179,180,181,182,183,184],"codes_lines_covered":[[["{","    let mut rng = Rng(0);","    let result = rng.gen_mod_u32(10);","    assert!(result < 10);","}"],[170,171,172,173,174,175,182,183,184]],[["{","    let mut rng = Rng(0);","    let result = rng.gen_mod_u32(1);","    assert_eq!(result, 0);","}"],[170,171,172,173,174,175,182,183,184]],[["{","    let mut rng = Rng(0);","    let result = rng.gen_mod_u32(0); // Should panic when n is zero as lo < n fails","}"],[170,171,172,173,174,175,182,183,184]],[["{","    let mut rng = Rng(1);","    // In this edge case, we will simulate the scenario where lo == t","    // Here we can assert that the output still remains in the conditions defined","    let result = rng.gen_mod_u32(1);","    assert_eq!(result, 0);","}"],[170,171,172,173,174,175,182,183,184]],[["{","    let mut rng = Rng(1);","    let result = rng.gen_mod_u32(10);","    assert!(result < 10);","}"],[170,171,172,173,174,175,182,183,184]],[["{","    let mut rng = Rng(2);","    let result = rng.gen_mod_u32(1);","    assert_eq!(result, 0);","}"],[170,171,172,173,174,175,182,183,184]],[["{","    let mut rng = Rng(3);","    let _ = rng.gen_mod_u32(u32::MAX);","}"],[170,171,172,173,174,175,176,177,183,184]],[["{","    let mut rng = Rng(4);","    let result = rng.gen_mod_u32(u32::MAX);","    assert!(result < u32::MAX);","}"],[170,171,172,173,174,175,176,177,183,184]],[["{","    struct TestRng(u64);","","    impl TestRng {","        fn gen_u32(&mut self) -> u32 {","            // This will simulate an RNG that produces the maximum number possible below 'n'.","            u32::MAX","        }","","        #[inline]","        fn gen_mod_u32(&mut self, n: u32) -> u32 {","            let mut r = self.gen_u32();","            let mut hi = mul_high_u32(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u32();","                    hi = mul_high_u32(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng(0);","    let n = 1; // Test with the smallest value for `n`","    let result = rng.gen_mod_u32(n);","    assert_eq!(result, 0); // Since lo will equal n, expect hi to be 0","}"],[]],[["{","    struct TestRng(u64);","","    impl TestRng {","        fn gen_u32(&mut self) -> u32 {","            // Simulate RNG returning low values close to the maximum of `n`.","            2 // to ensure lo < n condition.","        }","","        #[inline]","        fn gen_mod_u32(&mut self, n: u32) -> u32 {","            let mut r = self.gen_u32();","            let mut hi = mul_high_u32(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u32();","                    hi = mul_high_u32(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng(0);","    let n = 4; // Test with a larger value for `n`","    let result = rng.gen_mod_u32(n);","    assert_eq!(result, 0); // Expect hi to resolve logically based on our test RNG implementation","}"],[]],[["{","    struct TestRng(u64);","","    impl TestRng {","        fn gen_u32(&mut self) -> u32 {","            // Forcing a panic condition","            0","        }","","        #[inline]","        fn gen_mod_u32(&mut self, n: u32) -> u32 {","            let mut r = self.gen_u32();","            let mut hi = mul_high_u32(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u32();","                    hi = mul_high_u32(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng(0);","    let n = 0; // Setting `n` to 0 should induce a panic in logic","    rng.gen_mod_u32(n);","}"],[]]],"codes_branches":[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":true,"negative":true},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    let mut rng = Rng(0);","    let result = rng.gen_mod_u32(10);","    assert!(result < 10);","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":false,"negative":true},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(0);","    let result = rng.gen_mod_u32(1);","    assert_eq!(result, 0);","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":false,"negative":true},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(0);","    let result = rng.gen_mod_u32(0); // Should panic when n is zero as lo < n fails","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":false,"negative":true},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(1);","    // In this edge case, we will simulate the scenario where lo == t","    // Here we can assert that the output still remains in the conditions defined","    let result = rng.gen_mod_u32(1);","    assert_eq!(result, 0);","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":false,"negative":true},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(1);","    let result = rng.gen_mod_u32(10);","    assert!(result < 10);","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":false,"negative":true},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(2);","    let result = rng.gen_mod_u32(1);","    assert_eq!(result, 0);","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":false,"negative":true},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(3);","    let _ = rng.gen_mod_u32(u32::MAX);","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":true,"negative":false},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":true}]],[["{","    let mut rng = Rng(4);","    let result = rng.gen_mod_u32(u32::MAX);","    assert!(result < u32::MAX);","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":true,"negative":false},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":true}]],[["{","    struct TestRng(u64);","","    impl TestRng {","        fn gen_u32(&mut self) -> u32 {","            // This will simulate an RNG that produces the maximum number possible below 'n'.","            u32::MAX","        }","","        #[inline]","        fn gen_mod_u32(&mut self, n: u32) -> u32 {","            let mut r = self.gen_u32();","            let mut hi = mul_high_u32(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u32();","                    hi = mul_high_u32(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng(0);","    let n = 1; // Test with the smallest value for `n`","    let result = rng.gen_mod_u32(n);","    assert_eq!(result, 0); // Since lo will equal n, expect hi to be 0","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":false,"negative":false},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":false}]],[["{","    struct TestRng(u64);","","    impl TestRng {","        fn gen_u32(&mut self) -> u32 {","            // Simulate RNG returning low values close to the maximum of `n`.","            2 // to ensure lo < n condition.","        }","","        #[inline]","        fn gen_mod_u32(&mut self, n: u32) -> u32 {","            let mut r = self.gen_u32();","            let mut hi = mul_high_u32(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u32();","                    hi = mul_high_u32(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng(0);","    let n = 4; // Test with a larger value for `n`","    let result = rng.gen_mod_u32(n);","    assert_eq!(result, 0); // Expect hi to resolve logically based on our test RNG implementation","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":false,"negative":false},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":false}]],[["{","    struct TestRng(u64);","","    impl TestRng {","        fn gen_u32(&mut self) -> u32 {","            // Forcing a panic condition","            0","        }","","        #[inline]","        fn gen_mod_u32(&mut self, n: u32) -> u32 {","            let mut r = self.gen_u32();","            let mut hi = mul_high_u32(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u32();","                    hi = mul_high_u32(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng(0);","    let n = 0; // Setting `n` to 0 should induce a panic in logic","    rng.gen_mod_u32(n);","}"],[{"start_line":175,"start_column":12,"end_line":175,"end_column":18,"positive":false,"negative":false},{"start_line":177,"start_column":19,"end_line":177,"end_column":25,"positive":false,"negative":false}]]]}