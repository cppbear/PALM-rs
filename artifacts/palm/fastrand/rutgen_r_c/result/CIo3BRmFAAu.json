{"function_name":"fastrand::Rng::gen_mod_u64","tests":12,"tests_lines":[5,6,6,5,8,8,8,10,7,40,39,40],"oracles":12,"oracles_compiled":12,"oracles_compiled_rate":100.0,"tests_compiled":12,"tests_compiled_rate":100.0,"oracles_run":12,"oracles_passed":10,"oracles_passed_rate":83.33333333333334,"tests_run":12,"tests_passed":10,"tests_passed_rate":83.33333333333334,"lines":15,"lines_covered":11,"lines_coveraged_rate":73.33333333333333,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[188,189,190,191,192,193,194,195,196,197,198,199,200,201,202],"codes_lines_covered":[[["{","    let mut rng = Rng(1234567890);","    let result = rng.gen_mod_u64(100);","    assert!(result < 100);","}"],[188,189,190,191,192,193,200,201,202]],[["{","    let mut rng = Rng(9876543210);","    let result = rng.gen_mod_u64(50);","    assert!(result < 50);","    assert!(result >= 0); // ensure it does not return a negative value","}"],[188,189,190,191,192,193,200,201,202]],[["{","    let mut rng = Rng(1111111111);","    // Testing with a value ensuring lo < t","    let result = rng.gen_mod_u64(10);","    assert!(result < 10);","}"],[188,189,190,191,192,193,200,201,202]],[["{","    let mut rng = Rng(2222222222);","    let result = rng.gen_mod_u64(1);","    assert_eq!(result, 0); // The only possible value in the range 0..1 is 0","}"],[188,189,190,191,192,193,200,201,202]],[["{","    let mut rng = Rng(0);","    let n: u64 = 10;","    ","    // Invoke the method and expect to receive a return value in range [0..n)","    let result = rng.gen_mod_u64(n);","    assert!(result < n);","}"],[188,189,190,191,192,193,200,201,202]],[["{","    let mut rng = Rng(1);","    let n: u64 = u64::MAX;","","    // Invoke the method and expect to receive a return value in range [0..n)","    let result = rng.gen_mod_u64(n);","    assert!(result < n);","}"],[188,189,190,191,192,193,194,195,201,202]],[["{","    let mut rng = Rng(2);","    let n: u64 = 20;","","    // Invoke the method and expect to receive a return value in range [0..n)","    let result = rng.gen_mod_u64(n);","    assert!(result < n);","}"],[188,189,190,191,192,193,200,201,202]],[["{","    let mut rng = Rng(3);","    let n: u64 = 16;","","    // Ensure that lo < n is maintained","    for _ in 0..100 {","        let result = rng.gen_mod_u64(n);","        assert!(result < n);","    }","}"],[188,189,190,191,192,193,200,201,202]],[["{","    let mut rng = Rng(4);","    let n: u64 = 0;","","    // This should trigger a panic as `0` is not valid input for the range constraint","    let _ = rng.gen_mod_u64(n);","}"],[188,189,190,191,192,193,200,201,202]],[["{","    struct TestRng {","        state: u64,","    }","","    impl TestRng {","        fn new(seed: u64) -> Self {","            Self { state: seed }","        }","","        fn gen_u64(&mut self) -> u64 {","            const WY_CONST_0: u64 = 0x2d35_8dcc_aa6c_78a5;","            const WY_CONST_1: u64 = 0x8bb8_4b93_962e_acc9;","            let s = self.state.wrapping_add(WY_CONST_0);","            self.state = s;","            let t = u128::from(s) * u128::from(s ^ WY_CONST_1);","            (t as u64) ^ (t >> 64) as u64","        }","","        fn gen_mod_u64(&mut self, n: u64) -> u64 {","            let mut r = self.gen_u64();","            let mut hi = mul_high_u64(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u64();","                    hi = mul_high_u64(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng::new(42);","    let n = 42; // Setting n to a value","    let hi = rng.gen_mod_u64(n);","    assert!(hi < n); // Expecting a proper high value less than n","}"],[]],[["{","    struct TestRng {","        state: u64,","    }","","    impl TestRng {","        fn new(seed: u64) -> Self {","            Self { state: seed }","        }","","        fn gen_u64(&mut self) -> u64 {","            const WY_CONST_0: u64 = 0x2d35_8dcc_aa6c_78a5;","            const WY_CONST_1: u64 = 0x8bb8_4b93_962e_acc9;","            let s = self.state.wrapping_add(WY_CONST_0);","            self.state = s;","            let t = u128::from(s) * u128::from(s ^ WY_CONST_1);","            (t as u64) ^ (t >> 64) as u64","        }","","        fn gen_mod_u64(&mut self, n: u64) -> u64 {","            let mut r = self.gen_u64();","            let mut hi = mul_high_u64(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u64();","                    hi = mul_high_u64(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng::new(0);","    let n = 0; // Setting to 0, which should trigger a panic due to empty range","    rng.gen_mod_u64(n);","}"],[]],[["{","    struct TestRng {","        state: u64,","    }","","    impl TestRng {","        fn new(seed: u64) -> Self {","            Self { state: seed }","        }","","        fn gen_u64(&mut self) -> u64 {","            const WY_CONST_0: u64 = 0x2d35_8dcc_aa6c_78a5;","            const WY_CONST_1: u64 = 0x8bb8_4b93_962e_acc9;","            let s = self.state.wrapping_add(WY_CONST_0);","            self.state = s;","            let t = u128::from(s) * u128::from(s ^ WY_CONST_1);","            (t as u64) ^ (t >> 64) as u64","        }","","        fn gen_mod_u64(&mut self, n: u64) -> u64 {","            let mut r = self.gen_u64();","            let mut hi = mul_high_u64(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u64();","                    hi = mul_high_u64(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng::new(1);","    let n = 1; // Setting n to 1","    let hi = rng.gen_mod_u64(n);","    assert!(hi < n); // Expecting a proper high value less than n","}"],[]]],"codes_branches":[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":true,"negative":true},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    let mut rng = Rng(1234567890);","    let result = rng.gen_mod_u64(100);","    assert!(result < 100);","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":true},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(9876543210);","    let result = rng.gen_mod_u64(50);","    assert!(result < 50);","    assert!(result >= 0); // ensure it does not return a negative value","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":true},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(1111111111);","    // Testing with a value ensuring lo < t","    let result = rng.gen_mod_u64(10);","    assert!(result < 10);","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":true},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(2222222222);","    let result = rng.gen_mod_u64(1);","    assert_eq!(result, 0); // The only possible value in the range 0..1 is 0","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":true},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(0);","    let n: u64 = 10;","    ","    // Invoke the method and expect to receive a return value in range [0..n)","    let result = rng.gen_mod_u64(n);","    assert!(result < n);","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":true},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(1);","    let n: u64 = u64::MAX;","","    // Invoke the method and expect to receive a return value in range [0..n)","    let result = rng.gen_mod_u64(n);","    assert!(result < n);","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":true,"negative":false},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":true}]],[["{","    let mut rng = Rng(2);","    let n: u64 = 20;","","    // Invoke the method and expect to receive a return value in range [0..n)","    let result = rng.gen_mod_u64(n);","    assert!(result < n);","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":true},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(3);","    let n: u64 = 16;","","    // Ensure that lo < n is maintained","    for _ in 0..100 {","        let result = rng.gen_mod_u64(n);","        assert!(result < n);","    }","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":true},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(4);","    let n: u64 = 0;","","    // This should trigger a panic as `0` is not valid input for the range constraint","    let _ = rng.gen_mod_u64(n);","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":true},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]],[["{","    struct TestRng {","        state: u64,","    }","","    impl TestRng {","        fn new(seed: u64) -> Self {","            Self { state: seed }","        }","","        fn gen_u64(&mut self) -> u64 {","            const WY_CONST_0: u64 = 0x2d35_8dcc_aa6c_78a5;","            const WY_CONST_1: u64 = 0x8bb8_4b93_962e_acc9;","            let s = self.state.wrapping_add(WY_CONST_0);","            self.state = s;","            let t = u128::from(s) * u128::from(s ^ WY_CONST_1);","            (t as u64) ^ (t >> 64) as u64","        }","","        fn gen_mod_u64(&mut self, n: u64) -> u64 {","            let mut r = self.gen_u64();","            let mut hi = mul_high_u64(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u64();","                    hi = mul_high_u64(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng::new(42);","    let n = 42; // Setting n to a value","    let hi = rng.gen_mod_u64(n);","    assert!(hi < n); // Expecting a proper high value less than n","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":false},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]],[["{","    struct TestRng {","        state: u64,","    }","","    impl TestRng {","        fn new(seed: u64) -> Self {","            Self { state: seed }","        }","","        fn gen_u64(&mut self) -> u64 {","            const WY_CONST_0: u64 = 0x2d35_8dcc_aa6c_78a5;","            const WY_CONST_1: u64 = 0x8bb8_4b93_962e_acc9;","            let s = self.state.wrapping_add(WY_CONST_0);","            self.state = s;","            let t = u128::from(s) * u128::from(s ^ WY_CONST_1);","            (t as u64) ^ (t >> 64) as u64","        }","","        fn gen_mod_u64(&mut self, n: u64) -> u64 {","            let mut r = self.gen_u64();","            let mut hi = mul_high_u64(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u64();","                    hi = mul_high_u64(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng::new(0);","    let n = 0; // Setting to 0, which should trigger a panic due to empty range","    rng.gen_mod_u64(n);","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":false},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]],[["{","    struct TestRng {","        state: u64,","    }","","    impl TestRng {","        fn new(seed: u64) -> Self {","            Self { state: seed }","        }","","        fn gen_u64(&mut self) -> u64 {","            const WY_CONST_0: u64 = 0x2d35_8dcc_aa6c_78a5;","            const WY_CONST_1: u64 = 0x8bb8_4b93_962e_acc9;","            let s = self.state.wrapping_add(WY_CONST_0);","            self.state = s;","            let t = u128::from(s) * u128::from(s ^ WY_CONST_1);","            (t as u64) ^ (t >> 64) as u64","        }","","        fn gen_mod_u64(&mut self, n: u64) -> u64 {","            let mut r = self.gen_u64();","            let mut hi = mul_high_u64(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u64();","                    hi = mul_high_u64(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng::new(1);","    let n = 1; // Setting n to 1","    let hi = rng.gen_mod_u64(n);","    assert!(hi < n); // Expecting a proper high value less than n","}"],[{"start_line":193,"start_column":12,"end_line":193,"end_column":18,"positive":false,"negative":false},{"start_line":195,"start_column":19,"end_line":195,"end_column":25,"positive":false,"negative":false}]]]}