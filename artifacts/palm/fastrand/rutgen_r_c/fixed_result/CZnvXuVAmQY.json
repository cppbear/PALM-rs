{"function_name":"fastrand::global_rng::with_rng","tests":5,"tests_lines":[10,5,9,10,11],"oracles":5,"oracles_compiled":4,"oracles_compiled_rate":80.0,"tests_compiled":4,"tests_compiled_rate":80.0,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":4,"tests_passed":2,"tests_passed_rate":50.0,"lines":9,"lines_covered":9,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[36,37,38,39,40,41,42,43,44],"codes_lines_covered":[[["{","    let result = with_rng(|rng| {","        // Since the function is implementing a simple operation on Rng and doesn't produce","        // a return value directly, we'll simulate a check.","        let mut value = rng.0; // Access the inner value for the sake of the test","        value += 1; // Mutate the value to verify function is usable","        value","    });","    assert!(result > 0); // Checking that the return value is modified correctly","}"],[36,37,38,39,40,41,42,43,44]],[["{","    with_rng(|rng| {","        let _: u8 = rng.0 as u8; // Accessing but not performing any valid operations should panic","    });","}"],[36,37,38,39,40,41,42,43,44]],[["{","   let lower_bound: u64 = 0;  ","   let upper_bound: u64 = 255; // Maximum value for u8. We will test the boundaries.  ","   let random_u8 = with_rng(|rng| {  ","       // Assuming rng has a method that can generate random numbers in a range.  ","       rng.0 // In the original context, we would need to call a method that uses the bounds.  ","   }) as u64;  ","   assert!(random_u8 >= lower_bound && random_u8 <= upper_bound);  ","}"],[36,37,38,39,40,41,42,43,44]],[["{","    let results: Vec<u8> = (0..10).map(|_| {","        with_rng(|rng| {","            rng.0 as u8 // Again simulating a call","        })","    }).collect();","    for result in results {","        assert!(result > 0); // Validate that all calls succeeded","    }","}"],[36,37,38,39,40,41,42,43,44]]],"codes_branches":[],"codes_branches_covered":[[["{","    let result = with_rng(|rng| {","        // Since the function is implementing a simple operation on Rng and doesn't produce","        // a return value directly, we'll simulate a check.","        let mut value = rng.0; // Access the inner value for the sake of the test","        value += 1; // Mutate the value to verify function is usable","        value","    });","    assert!(result > 0); // Checking that the return value is modified correctly","}"],[]],[["{","    with_rng(|rng| {","        let _: u8 = rng.0 as u8; // Accessing but not performing any valid operations should panic","    });","}"],[]],[["{","   let lower_bound: u64 = 0;  ","   let upper_bound: u64 = 255; // Maximum value for u8. We will test the boundaries.  ","   let random_u8 = with_rng(|rng| {  ","       // Assuming rng has a method that can generate random numbers in a range.  ","       rng.0 // In the original context, we would need to call a method that uses the bounds.  ","   }) as u64;  ","   assert!(random_u8 >= lower_bound && random_u8 <= upper_bound);  ","}"],[]],[["{","    let results: Vec<u8> = (0..10).map(|_| {","        with_rng(|rng| {","            rng.0 as u8 // Again simulating a call","        })","    }).collect();","    for result in results {","        assert!(result > 0); // Validate that all calls succeeded","    }","}"],[]]]}