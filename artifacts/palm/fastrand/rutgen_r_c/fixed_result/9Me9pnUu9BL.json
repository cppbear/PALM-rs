{"function_name":"fastrand::Rng::gen_mod_u128","tests":7,"tests_lines":[5,8,6,9,43,32,30],"oracles":7,"oracles_compiled":7,"oracles_compiled_rate":100.0,"tests_compiled":7,"tests_compiled_rate":100.0,"oracles_run":7,"oracles_passed":5,"oracles_passed_rate":71.42857142857143,"tests_run":7,"tests_passed":5,"tests_passed_rate":71.42857142857143,"lines":15,"lines_covered":11,"lines_coveraged_rate":73.33333333333333,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[206,207,208,209,210,211,212,213,214,215,216,217,218,219,220],"codes_lines_covered":[[["{","    let mut rng = Rng(12345);","    let result = rng.gen_mod_u128(100);","    assert!(result < 100);","}"],[206,207,208,209,210,211,218,219,220]],[["{","    let mut rng = Rng(54321);","    // Assuming gen_u128 generates a value that wraps around to 0","    // In practice, you'll replace this with a specific mechanism to achieve `lo < t`.","    let n = 100;","    let result = rng.gen_mod_u128(n);","    assert!(result < n);","}"],[206,207,208,209,210,211,218,219,220]],[["{","    let mut rng = Rng(98765);","    // This calls for a scenario where `lo` would end up being equal to `t`.","    let n = u128::MAX; // This should create conditions that trigger a panic","    let _ = rng.gen_mod_u128(n);","}"],[206,207,208,209,210,211,212,213,219,220]],[["{","    let mut rng = Rng(67890);","    // Adjust the random generator setup or seed to create conditions where","    // `lo` does not end up being less than `t`.","    let n = 1000;","    let result = rng.gen_mod_u128(n);","    // Here we assume that `hi` must not equal the max boundary to keep `lo < t` false","    assert!(result < n);","}"],[206,207,208,209,210,211,218,219,220]],[["{","    struct TestRng {","        seed: u64,","    }","","    impl TestRng {","       fn gen_u128(&mut self) -> u128 {  ","           self.seed = self.seed.wrapping_mul(0x5DEECE66D).wrapping_add(0xB);  ","           (self.seed >> 16).into()  ","       }  ","        ","        fn gen_mod_u128(&mut self, n: u128) -> u128 {","            let mut r = self.gen_u128();","            let mut hi = mul_high_u128(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u128();","                    hi = mul_high_u128(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng { seed: 12345 };","    ","    // Test where lo < n is true","    let n: u128 = 100; // n is greater than 0, so lo < n holds","    let result = rng.gen_mod_u128(n);","    assert!(result < n, \"Expected result to be less than n\");","","    // Test where lo < t is false, with bound lo == t","   let new_n: u128 = 100; // Setting n for the testing  ","   rng.seed = 2; // Seed modified to tune the output  ","","    let result = rng.gen_mod_u128(new_n);","    ","    // Check that the value of hi is returned correctly","    assert!(result < new_n, \"Expected result to be less than new_n\");","}"],[]],[["{","    struct TestRng(u64);","    ","    impl TestRng {","        #[inline]","        fn gen_u128(&mut self) -> u128 {","            1 // Return a constant value to control the output ","        }","","        #[inline]","        fn gen_mod_u128(&mut self, n: u128) -> u128 {","            let mut r = self.gen_u128();","            let mut hi = mul_high_u128(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u128();","                    hi = mul_high_u128(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng(0);","    let n = 1; // lo == n for this case","    let result = rng.gen_mod_u128(n);","    ","    assert_eq!(result, 0); // Since hi should be zero when lo == n","}"],[]],[["{","    struct TestRng(u64);","    ","    impl TestRng {","        #[inline]","        fn gen_u128(&mut self) -> u128 {","            1 // Return a constant value to control the output ","        }","","        #[inline]","        fn gen_mod_u128(&mut self, n: u128) -> u128 {","            let mut r = self.gen_u128();","            let mut hi = mul_high_u128(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u128();","                    hi = mul_high_u128(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng(0);","    let n = 0; // This will cause an invalid range condition","    rng.gen_mod_u128(n);","}"],[]]],"codes_branches":[{"start_line":211,"start_column":12,"end_line":211,"end_column":18,"positive":true,"negative":true},{"start_line":213,"start_column":19,"end_line":213,"end_column":25,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    let mut rng = Rng(12345);","    let result = rng.gen_mod_u128(100);","    assert!(result < 100);","}"],[{"start_line":211,"start_column":12,"end_line":211,"end_column":18,"positive":false,"negative":true},{"start_line":213,"start_column":19,"end_line":213,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(54321);","    // Assuming gen_u128 generates a value that wraps around to 0","    // In practice, you'll replace this with a specific mechanism to achieve `lo < t`.","    let n = 100;","    let result = rng.gen_mod_u128(n);","    assert!(result < n);","}"],[{"start_line":211,"start_column":12,"end_line":211,"end_column":18,"positive":false,"negative":true},{"start_line":213,"start_column":19,"end_line":213,"end_column":25,"positive":false,"negative":false}]],[["{","    let mut rng = Rng(98765);","    // This calls for a scenario where `lo` would end up being equal to `t`.","    let n = u128::MAX; // This should create conditions that trigger a panic","    let _ = rng.gen_mod_u128(n);","}"],[{"start_line":211,"start_column":12,"end_line":211,"end_column":18,"positive":true,"negative":false},{"start_line":213,"start_column":19,"end_line":213,"end_column":25,"positive":false,"negative":true}]],[["{","    let mut rng = Rng(67890);","    // Adjust the random generator setup or seed to create conditions where","    // `lo` does not end up being less than `t`.","    let n = 1000;","    let result = rng.gen_mod_u128(n);","    // Here we assume that `hi` must not equal the max boundary to keep `lo < t` false","    assert!(result < n);","}"],[{"start_line":211,"start_column":12,"end_line":211,"end_column":18,"positive":false,"negative":true},{"start_line":213,"start_column":19,"end_line":213,"end_column":25,"positive":false,"negative":false}]],[["{","    struct TestRng {","        seed: u64,","    }","","    impl TestRng {","       fn gen_u128(&mut self) -> u128 {  ","           self.seed = self.seed.wrapping_mul(0x5DEECE66D).wrapping_add(0xB);  ","           (self.seed >> 16).into()  ","       }  ","        ","        fn gen_mod_u128(&mut self, n: u128) -> u128 {","            let mut r = self.gen_u128();","            let mut hi = mul_high_u128(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u128();","                    hi = mul_high_u128(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng { seed: 12345 };","    ","    // Test where lo < n is true","    let n: u128 = 100; // n is greater than 0, so lo < n holds","    let result = rng.gen_mod_u128(n);","    assert!(result < n, \"Expected result to be less than n\");","","    // Test where lo < t is false, with bound lo == t","   let new_n: u128 = 100; // Setting n for the testing  ","   rng.seed = 2; // Seed modified to tune the output  ","","    let result = rng.gen_mod_u128(new_n);","    ","    // Check that the value of hi is returned correctly","    assert!(result < new_n, \"Expected result to be less than new_n\");","}"],[{"start_line":211,"start_column":12,"end_line":211,"end_column":18,"positive":false,"negative":false},{"start_line":213,"start_column":19,"end_line":213,"end_column":25,"positive":false,"negative":false}]],[["{","    struct TestRng(u64);","    ","    impl TestRng {","        #[inline]","        fn gen_u128(&mut self) -> u128 {","            1 // Return a constant value to control the output ","        }","","        #[inline]","        fn gen_mod_u128(&mut self, n: u128) -> u128 {","            let mut r = self.gen_u128();","            let mut hi = mul_high_u128(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u128();","                    hi = mul_high_u128(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng(0);","    let n = 1; // lo == n for this case","    let result = rng.gen_mod_u128(n);","    ","    assert_eq!(result, 0); // Since hi should be zero when lo == n","}"],[{"start_line":211,"start_column":12,"end_line":211,"end_column":18,"positive":false,"negative":false},{"start_line":213,"start_column":19,"end_line":213,"end_column":25,"positive":false,"negative":false}]],[["{","    struct TestRng(u64);","    ","    impl TestRng {","        #[inline]","        fn gen_u128(&mut self) -> u128 {","            1 // Return a constant value to control the output ","        }","","        #[inline]","        fn gen_mod_u128(&mut self, n: u128) -> u128 {","            let mut r = self.gen_u128();","            let mut hi = mul_high_u128(r, n);","            let mut lo = r.wrapping_mul(n);","            if lo < n {","                let t = n.wrapping_neg() % n;","                while lo < t {","                    r = self.gen_u128();","                    hi = mul_high_u128(r, n);","                    lo = r.wrapping_mul(n);","                }","            }","            hi","        }","    }","","    let mut rng = TestRng(0);","    let n = 0; // This will cause an invalid range condition","    rng.gen_mod_u128(n);","}"],[{"start_line":211,"start_column":12,"end_line":211,"end_column":18,"positive":false,"negative":false},{"start_line":213,"start_column":19,"end_line":213,"end_column":25,"positive":false,"negative":false}]]]}