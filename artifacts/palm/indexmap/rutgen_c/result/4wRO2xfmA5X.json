{"function_name":"indexmap::map::map::IndexMap<K, V, S>::swap_indices","tests":3,"tests_lines":[32,21,31],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1354,1355,1356],"codes_lines_covered":[[["{","    struct TestMap {","        data: IndexMap<u32, u32, RandomState>,","    }","","    impl TestMap {","        fn new() -> Self {","            let mut data = IndexMap::new();","            data.insert(1, 10);","            data.insert(2, 20);","            data.insert(3, 30);","            TestMap { data }","        }","        ","        fn swap(&mut self, a: usize, b: usize) {","            self.data.swap_indices(a, b);","        }","","        fn get(&self, index: usize) -> Option<(&u32, &u32)> {","            self.data.get_index(index)","        }","    }","","    let mut map = TestMap::new();","    assert_eq!(map.get(0), Some((&1, &10)));","    assert_eq!(map.get(1), Some((&2, &20)));","","    map.swap(0, 1);","    ","    assert_eq!(map.get(0), Some((&2, &20)));","    assert_eq!(map.get(1), Some((&1, &10)));","}"],[1354,1355,1356]],[["{","    struct TestMap {","        data: IndexMap<u32, u32, RandomState>,","    }","","    impl TestMap {","        fn new() -> Self {","            let mut data = IndexMap::new();","            data.insert(1, 10);","            data.insert(2, 20);","            TestMap { data }","        }","        ","        fn swap(&mut self, a: usize, b: usize) {","            self.data.swap_indices(a, b);","        }","    }","","    let mut map = TestMap::new();","    map.swap(0, 2); // This should panic because index 2 is out of bounds","}"],[1354,1355,1356]],[["{","    struct TestMap {","        data: IndexMap<u32, u32, RandomState>,","    }","","    impl TestMap {","        fn new() -> Self {","            let mut data = IndexMap::new();","            data.insert(1, 10);","            data.insert(2, 20);","            TestMap { data }","        }","        ","        fn swap(&mut self, a: usize, b: usize) {","            self.data.swap_indices(a, b);","        }","","        fn get(&self, index: usize) -> Option<(&u32, &u32)> {","            self.data.get_index(index)","        }","    }","","    let mut map = TestMap::new();","    assert_eq!(map.get(0), Some((&1, &10)));","    assert_eq!(map.get(1), Some((&2, &20)));","","    map.swap(0, 0); // Swapping the same index","    ","    assert_eq!(map.get(0), Some((&1, &10)));","    assert_eq!(map.get(1), Some((&2, &20)));","}"],[1354,1355,1356]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestMap {","        data: IndexMap<u32, u32, RandomState>,","    }","","    impl TestMap {","        fn new() -> Self {","            let mut data = IndexMap::new();","            data.insert(1, 10);","            data.insert(2, 20);","            data.insert(3, 30);","            TestMap { data }","        }","        ","        fn swap(&mut self, a: usize, b: usize) {","            self.data.swap_indices(a, b);","        }","","        fn get(&self, index: usize) -> Option<(&u32, &u32)> {","            self.data.get_index(index)","        }","    }","","    let mut map = TestMap::new();","    assert_eq!(map.get(0), Some((&1, &10)));","    assert_eq!(map.get(1), Some((&2, &20)));","","    map.swap(0, 1);","    ","    assert_eq!(map.get(0), Some((&2, &20)));","    assert_eq!(map.get(1), Some((&1, &10)));","}"],[]],[["{","    struct TestMap {","        data: IndexMap<u32, u32, RandomState>,","    }","","    impl TestMap {","        fn new() -> Self {","            let mut data = IndexMap::new();","            data.insert(1, 10);","            data.insert(2, 20);","            TestMap { data }","        }","        ","        fn swap(&mut self, a: usize, b: usize) {","            self.data.swap_indices(a, b);","        }","    }","","    let mut map = TestMap::new();","    map.swap(0, 2); // This should panic because index 2 is out of bounds","}"],[]],[["{","    struct TestMap {","        data: IndexMap<u32, u32, RandomState>,","    }","","    impl TestMap {","        fn new() -> Self {","            let mut data = IndexMap::new();","            data.insert(1, 10);","            data.insert(2, 20);","            TestMap { data }","        }","        ","        fn swap(&mut self, a: usize, b: usize) {","            self.data.swap_indices(a, b);","        }","","        fn get(&self, index: usize) -> Option<(&u32, &u32)> {","            self.data.get_index(index)","        }","    }","","    let mut map = TestMap::new();","    assert_eq!(map.get(0), Some((&1, &10)));","    assert_eq!(map.get(1), Some((&2, &20)));","","    map.swap(0, 0); // Swapping the same index","    ","    assert_eq!(map.get(0), Some((&1, &10)));","    assert_eq!(map.get(1), Some((&2, &20)));","}"],[]]]}