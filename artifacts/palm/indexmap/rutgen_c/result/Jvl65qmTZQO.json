{"function_name":"indexmap::map::map::IndexMap<K, V, S>::swap_remove_entry","tests":4,"tests_lines":[19,17,15,23],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":8,"lines_covered":8,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[876,877,878,879,880,881,882,884],"codes_lines_covered":[[["{","    use std::collections::hash_map::RandomState;","    use std::hash::BuildHasher;","","    struct TestMap {","        map: IndexMap<i32, String, RandomState>,","    }","","    let mut test_map = TestMap {","        map: IndexMap::with_hasher(RandomState::new()),","    };","    test_map.map.insert(1, \"one\".to_string());","    test_map.map.insert(2, \"two\".to_string());","    test_map.map.insert(3, \"three\".to_string());","","    let result = test_map.map.swap_remove_entry(&2);","    assert_eq!(result, Some((2, \"two\".to_string())));","    assert!(test_map.map.get(&2).is_none());","}"],[876,877,878,879,880,881,884]],[["{","    use std::collections::hash_map::RandomState;","    use std::hash::BuildHasher;","","    struct TestMap {","        map: IndexMap<i32, String, RandomState>,","    }","","    let mut test_map = TestMap {","        map: IndexMap::with_hasher(RandomState::new()),","    };","    test_map.map.insert(1, \"one\".to_string());","    test_map.map.insert(2, \"two\".to_string());","","    let result = test_map.map.swap_remove_entry(&3);","    assert_eq!(result, None);","}"],[876,877,878,879,880,882,884]],[["{","    use std::collections::hash_map::RandomState;","    use std::hash::BuildHasher;","","    struct TestMap {","        map: IndexMap<i32, String, RandomState>,","    }","","    let mut test_map = TestMap {","        map: IndexMap::with_hasher(RandomState::new()),","    };","","    let result = test_map.map.swap_remove_entry(&1);","    assert_eq!(result, None);","}"],[876,877,878,879,880,882,884]],[["{","    use std::collections::hash_map::RandomState;","    use std::hash::BuildHasher;","","    struct TestMap {","        map: IndexMap<i32, String, RandomState>,","    }","","    let mut test_map = TestMap {","        map: IndexMap::with_hasher(RandomState::new()),","    };","    test_map.map.insert(1, \"one\".to_string());","    test_map.map.insert(2, \"two\".to_string());","    test_map.map.insert(3, \"three\".to_string());","","    let first_result = test_map.map.swap_remove_entry(&1);","    assert_eq!(first_result, Some((1, \"one\".to_string())));","    assert!(test_map.map.get(&1).is_none());","","    let second_result = test_map.map.swap_remove_entry(&3);","    assert_eq!(second_result, Some((3, \"three\".to_string())));","    assert!(test_map.map.get(&3).is_none());","}"],[876,877,878,879,880,881,884]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::collections::hash_map::RandomState;","    use std::hash::BuildHasher;","","    struct TestMap {","        map: IndexMap<i32, String, RandomState>,","    }","","    let mut test_map = TestMap {","        map: IndexMap::with_hasher(RandomState::new()),","    };","    test_map.map.insert(1, \"one\".to_string());","    test_map.map.insert(2, \"two\".to_string());","    test_map.map.insert(3, \"three\".to_string());","","    let result = test_map.map.swap_remove_entry(&2);","    assert_eq!(result, Some((2, \"two\".to_string())));","    assert!(test_map.map.get(&2).is_none());","}"],[]],[["{","    use std::collections::hash_map::RandomState;","    use std::hash::BuildHasher;","","    struct TestMap {","        map: IndexMap<i32, String, RandomState>,","    }","","    let mut test_map = TestMap {","        map: IndexMap::with_hasher(RandomState::new()),","    };","    test_map.map.insert(1, \"one\".to_string());","    test_map.map.insert(2, \"two\".to_string());","","    let result = test_map.map.swap_remove_entry(&3);","    assert_eq!(result, None);","}"],[]],[["{","    use std::collections::hash_map::RandomState;","    use std::hash::BuildHasher;","","    struct TestMap {","        map: IndexMap<i32, String, RandomState>,","    }","","    let mut test_map = TestMap {","        map: IndexMap::with_hasher(RandomState::new()),","    };","","    let result = test_map.map.swap_remove_entry(&1);","    assert_eq!(result, None);","}"],[]],[["{","    use std::collections::hash_map::RandomState;","    use std::hash::BuildHasher;","","    struct TestMap {","        map: IndexMap<i32, String, RandomState>,","    }","","    let mut test_map = TestMap {","        map: IndexMap::with_hasher(RandomState::new()),","    };","    test_map.map.insert(1, \"one\".to_string());","    test_map.map.insert(2, \"two\".to_string());","    test_map.map.insert(3, \"three\".to_string());","","    let first_result = test_map.map.swap_remove_entry(&1);","    assert_eq!(first_result, Some((1, \"one\".to_string())));","    assert!(test_map.map.get(&1).is_none());","","    let second_result = test_map.map.swap_remove_entry(&3);","    assert_eq!(second_result, Some((3, \"three\".to_string())));","    assert!(test_map.map.get(&3).is_none());","}"],[]]]}