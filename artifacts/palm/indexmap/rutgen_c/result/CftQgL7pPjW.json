{"function_name":"indexmap::set::set::IndexSet<T, S>::swap_indices","tests":3,"tests_lines":[26,21,21],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1069,1070,1071],"codes_lines_covered":[[["{","    struct TestSet {","        data: Vec<usize>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { data: vec![1, 2, 3, 4] }","        }","","        fn swap_indices(&mut self, a: usize, b: usize) {","            let len = self.data.len();","            assert!(a < len);","            assert!(b < len);","            self.data.swap(a, b);","        }","","        fn as_slice(&self) -> &[usize] {","            &self.data","        }","    }","","    let mut set = TestSet::new();","    set.swap_indices(0, 2);","    assert_eq!(set.as_slice(), &[3, 2, 1, 4]);","}"],[]],[["{","    struct TestSet {","        data: Vec<usize>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { data: vec![1, 2, 3] }","        }","","        fn swap_indices(&mut self, a: usize, b: usize) {","            let len = self.data.len();","            assert!(a < len);","            assert!(b < len);","            self.data.swap(a, b);","        }","    }","","    let mut set = TestSet::new();","    set.swap_indices(3, 1);","}"],[]],[["{","    struct TestSet {","        data: Vec<usize>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { data: vec![1, 2, 3] }","        }","","        fn swap_indices(&mut self, a: usize, b: usize) {","            let len = self.data.len();","            assert!(a < len);","            assert!(b < len);","            self.data.swap(a, b);","        }","    }","","    let mut set = TestSet::new();","    set.swap_indices(0, 3);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestSet {","        data: Vec<usize>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { data: vec![1, 2, 3, 4] }","        }","","        fn swap_indices(&mut self, a: usize, b: usize) {","            let len = self.data.len();","            assert!(a < len);","            assert!(b < len);","            self.data.swap(a, b);","        }","","        fn as_slice(&self) -> &[usize] {","            &self.data","        }","    }","","    let mut set = TestSet::new();","    set.swap_indices(0, 2);","    assert_eq!(set.as_slice(), &[3, 2, 1, 4]);","}"],[]],[["{","    struct TestSet {","        data: Vec<usize>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { data: vec![1, 2, 3] }","        }","","        fn swap_indices(&mut self, a: usize, b: usize) {","            let len = self.data.len();","            assert!(a < len);","            assert!(b < len);","            self.data.swap(a, b);","        }","    }","","    let mut set = TestSet::new();","    set.swap_indices(3, 1);","}"],[]],[["{","    struct TestSet {","        data: Vec<usize>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { data: vec![1, 2, 3] }","        }","","        fn swap_indices(&mut self, a: usize, b: usize) {","            let len = self.data.len();","            assert!(a < len);","            assert!(b < len);","            self.data.swap(a, b);","        }","    }","","    let mut set = TestSet::new();","    set.swap_indices(0, 3);","}"],[]]]}