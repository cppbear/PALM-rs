{"function_name":"indexmap::map::map::IndexMap<K, V, S>::sort_unstable_keys","tests":2,"tests_lines":[27,23],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1052,1053,1054,1055,1056,1057,1058,1059],"codes_lines_covered":[[["{","    struct TestMap {","        entries: Vec<(i32, i32)>,","    }","","    impl TestMap {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            TestMap { entries }","        }","","        fn sort_unstable_keys(&mut self) {","            self.entries.sort_unstable_by(|a, b| a.0.cmp(&b.0));","        }","","        fn as_slice(&self) -> &[(i32, i32)] {","            &self.entries","        }","    }","","    let mut map = TestMap::new(vec![(3, 100), (1, 200), (2, 300)]);","    map.sort_unstable_keys();","    assert_eq!(map.as_slice(), &[(1, 200), (2, 300), (3, 100)]);","","    let mut map_with_duplicates = TestMap::new(vec![(3, 100), (1, 200), (2, 300), (2, 400)]);","    map_with_duplicates.sort_unstable_keys();","    assert_eq!(map_with_duplicates.as_slice(), &[(1, 200), (2, 300), (2, 400), (3, 100)]);","}"],[]],[["{","    struct TestMap {","        entries: Vec<(i32, i32)>,","    }","","    impl TestMap {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            TestMap { entries }","        }","","        fn sort_unstable_keys(&mut self) {","            self.entries.sort_unstable_by(|a, b| a.0.cmp(&b.0));","        }","","        fn as_slice(&self) -> &[(i32, i32)] {","            &self.entries","        }","    }","","    let mut empty_map = TestMap::new(vec![]);","    empty_map.sort_unstable_keys();","    assert_eq!(empty_map.as_slice(), &[]);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestMap {","        entries: Vec<(i32, i32)>,","    }","","    impl TestMap {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            TestMap { entries }","        }","","        fn sort_unstable_keys(&mut self) {","            self.entries.sort_unstable_by(|a, b| a.0.cmp(&b.0));","        }","","        fn as_slice(&self) -> &[(i32, i32)] {","            &self.entries","        }","    }","","    let mut map = TestMap::new(vec![(3, 100), (1, 200), (2, 300)]);","    map.sort_unstable_keys();","    assert_eq!(map.as_slice(), &[(1, 200), (2, 300), (3, 100)]);","","    let mut map_with_duplicates = TestMap::new(vec![(3, 100), (1, 200), (2, 300), (2, 400)]);","    map_with_duplicates.sort_unstable_keys();","    assert_eq!(map_with_duplicates.as_slice(), &[(1, 200), (2, 300), (2, 400), (3, 100)]);","}"],[]],[["{","    struct TestMap {","        entries: Vec<(i32, i32)>,","    }","","    impl TestMap {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            TestMap { entries }","        }","","        fn sort_unstable_keys(&mut self) {","            self.entries.sort_unstable_by(|a, b| a.0.cmp(&b.0));","        }","","        fn as_slice(&self) -> &[(i32, i32)] {","            &self.entries","        }","    }","","    let mut empty_map = TestMap::new(vec![]);","    empty_map.sort_unstable_keys();","    assert_eq!(empty_map.as_slice(), &[]);","}"],[]]]}