{"function_name":"indexmap::set::set::IndexSet<T, S>::with_capacity_and_hasher","tests":4,"tests_lines":[13,13,13,12],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[176,177,178,179,180],"codes_lines_covered":[[["{","    use std::collections::hash_map::RandomState;","","    struct TestHasher {","        state: RandomState,","    }","","    let hasher = TestHasher { state: RandomState::new() };","    let index_set: super::IndexSet<i32, TestHasher> = super::IndexSet::with_capacity_and_hasher(0, hasher);","    ","    assert_eq!(index_set.capacity(), 0);","    assert!(index_set.is_empty());","}"],[176,177,178,179,180]],[["{","    use std::collections::hash_map::RandomState;","","    struct TestHasher {","        state: RandomState,","    }","","    let hasher = TestHasher { state: RandomState::new() };","    let index_set: super::IndexSet<i32, TestHasher> = super::IndexSet::with_capacity_and_hasher(10, hasher);","    ","    assert_eq!(index_set.capacity(), 10);","    assert!(index_set.is_empty());","}"],[176,177,178,179,180]],[["{","    use std::collections::hash_map::RandomState;","","    struct TestHasher {","        state: RandomState,","    }","","    let hasher = TestHasher { state: RandomState::new() };","    let index_set: super::IndexSet<i32, TestHasher> = super::IndexSet::with_capacity_and_hasher(5, hasher);","    ","    assert_eq!(index_set.capacity(), 5);","    assert!(index_set.is_empty());","}"],[176,177,178,179,180]],[["{","    use std::collections::hash_map::RandomState;","","    struct TestHasher {","        state: RandomState,","    }","","    let hasher = TestHasher { state: RandomState::new() };","    ","    // Assuming the function cannot handle a negative value, we assert a panic here.","    let _index_set: super::IndexSet<i32, TestHasher> = super::IndexSet::with_capacity_and_hasher(usize::MAX, hasher);","}"],[176,177,178,179,180]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::collections::hash_map::RandomState;","","    struct TestHasher {","        state: RandomState,","    }","","    let hasher = TestHasher { state: RandomState::new() };","    let index_set: super::IndexSet<i32, TestHasher> = super::IndexSet::with_capacity_and_hasher(0, hasher);","    ","    assert_eq!(index_set.capacity(), 0);","    assert!(index_set.is_empty());","}"],[]],[["{","    use std::collections::hash_map::RandomState;","","    struct TestHasher {","        state: RandomState,","    }","","    let hasher = TestHasher { state: RandomState::new() };","    let index_set: super::IndexSet<i32, TestHasher> = super::IndexSet::with_capacity_and_hasher(10, hasher);","    ","    assert_eq!(index_set.capacity(), 10);","    assert!(index_set.is_empty());","}"],[]],[["{","    use std::collections::hash_map::RandomState;","","    struct TestHasher {","        state: RandomState,","    }","","    let hasher = TestHasher { state: RandomState::new() };","    let index_set: super::IndexSet<i32, TestHasher> = super::IndexSet::with_capacity_and_hasher(5, hasher);","    ","    assert_eq!(index_set.capacity(), 5);","    assert!(index_set.is_empty());","}"],[]],[["{","    use std::collections::hash_map::RandomState;","","    struct TestHasher {","        state: RandomState,","    }","","    let hasher = TestHasher { state: RandomState::new() };","    ","    // Assuming the function cannot handle a negative value, we assert a panic here.","    let _index_set: super::IndexSet<i32, TestHasher> = super::IndexSet::with_capacity_and_hasher(usize::MAX, hasher);","}"],[]]]}