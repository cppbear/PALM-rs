{"function_name":"indexmap::set::set::IndexSet<T, S>::shift_remove_index","tests":3,"tests_lines":[35,33,32],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1045,1046,1047],"codes_lines_covered":[[["{","    struct TestIndexSet {","        elements: Vec<i32>,","        map: IndexMap<i32, (), RandomState>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            // Assuming IndexMap's new accepts a Vec and initializes the map","            TestIndexSet {","                elements: elements.clone(),","                map: IndexMap::new(),","            }","        }","","        fn len(&self) -> usize {","            self.elements.len()","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<i32> {","            if index < self.len() {","                let removed = self.elements.remove(index);","                // Simulate map operation here, dropping the value","                Some(removed)","            } else {","                None","            }","        }","    }","    ","    let mut index_set = TestIndexSet::new(vec![1, 2, 3, 4]);","    let removed = index_set.shift_remove_index(1);","    assert_eq!(removed, Some(2));","    assert_eq!(index_set.elements, vec![1, 3, 4]);","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","        map: IndexMap<i32, (), RandomState>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet {","                elements: elements.clone(),","                map: IndexMap::new(),","            }","        }","","        fn len(&self) -> usize {","            self.elements.len()","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<i32> {","            if index < self.len() {","                let removed = self.elements.remove(index);","                // Simulate map operation here","                Some(removed)","            } else {","                None","            }","        }","    }","","    let mut index_set = TestIndexSet::new(vec![1, 2, 3, 4]);","    let removed = index_set.shift_remove_index(4);","    assert_eq!(removed, None);","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","        map: IndexMap<i32, (), RandomState>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet {","                elements: elements.clone(),","                map: IndexMap::new(),","            }","        }","","        fn len(&self) -> usize {","            self.elements.len()","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<i32> {","            if index < self.len() {","                let removed = self.elements.remove(index);","                Some(removed)","            } else {","                None","            }","        }","    }","    ","    let mut index_set = TestIndexSet::new(vec![]);","    let removed = index_set.shift_remove_index(0);","    assert_eq!(removed, None);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestIndexSet {","        elements: Vec<i32>,","        map: IndexMap<i32, (), RandomState>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            // Assuming IndexMap's new accepts a Vec and initializes the map","            TestIndexSet {","                elements: elements.clone(),","                map: IndexMap::new(),","            }","        }","","        fn len(&self) -> usize {","            self.elements.len()","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<i32> {","            if index < self.len() {","                let removed = self.elements.remove(index);","                // Simulate map operation here, dropping the value","                Some(removed)","            } else {","                None","            }","        }","    }","    ","    let mut index_set = TestIndexSet::new(vec![1, 2, 3, 4]);","    let removed = index_set.shift_remove_index(1);","    assert_eq!(removed, Some(2));","    assert_eq!(index_set.elements, vec![1, 3, 4]);","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","        map: IndexMap<i32, (), RandomState>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet {","                elements: elements.clone(),","                map: IndexMap::new(),","            }","        }","","        fn len(&self) -> usize {","            self.elements.len()","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<i32> {","            if index < self.len() {","                let removed = self.elements.remove(index);","                // Simulate map operation here","                Some(removed)","            } else {","                None","            }","        }","    }","","    let mut index_set = TestIndexSet::new(vec![1, 2, 3, 4]);","    let removed = index_set.shift_remove_index(4);","    assert_eq!(removed, None);","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","        map: IndexMap<i32, (), RandomState>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet {","                elements: elements.clone(),","                map: IndexMap::new(),","            }","        }","","        fn len(&self) -> usize {","            self.elements.len()","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<i32> {","            if index < self.len() {","                let removed = self.elements.remove(index);","                Some(removed)","            } else {","                None","            }","        }","    }","    ","    let mut index_set = TestIndexSet::new(vec![]);","    let removed = index_set.shift_remove_index(0);","    assert_eq!(removed, None);","}"],[]]]}