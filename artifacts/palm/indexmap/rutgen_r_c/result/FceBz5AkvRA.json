{"function_name":"indexmap::set::set::IndexSet<T, S>::binary_search_by","tests":5,"tests_lines":[23,23,23,23,25],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":3,"oracles_passed_rate":60.0,"tests_run":5,"tests_passed":3,"tests_passed_rate":60.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[932,933,934,935,936,937],"codes_lines_covered":[[["{","    struct TestIndexSet {","        elements: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet { elements }","        }","        ","        fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>","        where","            F: FnMut(&i32) -> Ordering,","        {","            let slice = &self.elements;","            slice.binary_search_by(f)","        }","    }","","    let set = TestIndexSet::new(vec![1, 3, 5, 7, 9]);","","    assert_eq!(set.binary_search_by(|&x| x.cmp(&5)), Ok(2));","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet { elements }","        }","        ","        fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>","        where","            F: FnMut(&i32) -> Ordering,","        {","            let slice = &self.elements;","            slice.binary_search_by(f)","        }","    }","","    let set = TestIndexSet::new(vec![1, 3, 5, 7, 9]);","","    assert_eq!(set.binary_search_by(|&x| x.cmp(&6)), Err(3));","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet { elements }","        }","        ","        fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>","        where","            F: FnMut(&i32) -> Ordering,","        {","            let slice = &self.elements;","            slice.binary_search_by(f)","        }","    }","","    let set = TestIndexSet::new(vec![]);","    ","    let _ = set.binary_search_by(|&x| x.cmp(&1)); // This should panic, as the slice is empty and there is no existing element to compare with.","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet { elements }","        }","        ","        fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>","        where","            F: FnMut(&i32) -> Ordering,","        {","            let slice = &self.elements;","            slice.binary_search_by(f)","        }","    }","","    let set = TestIndexSet::new(vec![-3, -1, 0, 1, 3]);","","    assert_eq!(set.binary_search_by(|&x| x.cmp(&-2)), Err(2));","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet { elements }","        }","        ","        fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>","        where","            F: FnMut(&i32) -> Ordering,","        {","            let slice = &self.elements;","            slice.binary_search_by(f)","        }","    }","","    let set = TestIndexSet::new(vec![1, 2, 3, 4, 5]);","","    assert_eq!(set.binary_search_by(|&x| x.cmp(&1)), Ok(0)); // First element","    assert_eq!(set.binary_search_by(|&x| x.cmp(&5)), Ok(4)); // Last element","    assert_eq!(set.binary_search_by(|&x| x.cmp(&6)), Err(5)); // Out of bounds, should insert at the end","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestIndexSet {","        elements: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet { elements }","        }","        ","        fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>","        where","            F: FnMut(&i32) -> Ordering,","        {","            let slice = &self.elements;","            slice.binary_search_by(f)","        }","    }","","    let set = TestIndexSet::new(vec![1, 3, 5, 7, 9]);","","    assert_eq!(set.binary_search_by(|&x| x.cmp(&5)), Ok(2));","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet { elements }","        }","        ","        fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>","        where","            F: FnMut(&i32) -> Ordering,","        {","            let slice = &self.elements;","            slice.binary_search_by(f)","        }","    }","","    let set = TestIndexSet::new(vec![1, 3, 5, 7, 9]);","","    assert_eq!(set.binary_search_by(|&x| x.cmp(&6)), Err(3));","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet { elements }","        }","        ","        fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>","        where","            F: FnMut(&i32) -> Ordering,","        {","            let slice = &self.elements;","            slice.binary_search_by(f)","        }","    }","","    let set = TestIndexSet::new(vec![]);","    ","    let _ = set.binary_search_by(|&x| x.cmp(&1)); // This should panic, as the slice is empty and there is no existing element to compare with.","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet { elements }","        }","        ","        fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>","        where","            F: FnMut(&i32) -> Ordering,","        {","            let slice = &self.elements;","            slice.binary_search_by(f)","        }","    }","","    let set = TestIndexSet::new(vec![-3, -1, 0, 1, 3]);","","    assert_eq!(set.binary_search_by(|&x| x.cmp(&-2)), Err(2));","}"],[]],[["{","    struct TestIndexSet {","        elements: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new(elements: Vec<i32>) -> Self {","            TestIndexSet { elements }","        }","        ","        fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>","        where","            F: FnMut(&i32) -> Ordering,","        {","            let slice = &self.elements;","            slice.binary_search_by(f)","        }","    }","","    let set = TestIndexSet::new(vec![1, 2, 3, 4, 5]);","","    assert_eq!(set.binary_search_by(|&x| x.cmp(&1)), Ok(0)); // First element","    assert_eq!(set.binary_search_by(|&x| x.cmp(&5)), Ok(4)); // Last element","    assert_eq!(set.binary_search_by(|&x| x.cmp(&6)), Err(5)); // Out of bounds, should insert at the end","}"],[]]]}