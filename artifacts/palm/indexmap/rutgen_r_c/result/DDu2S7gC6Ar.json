{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::replace_full","tests":8,"tests_lines":[20,19,24,29,22,20,17,17],"oracles":8,"oracles_compiled":6,"oracles_compiled_rate":75.0,"tests_compiled":6,"tests_compiled_rate":75.0,"oracles_run":6,"oracles_passed":4,"oracles_passed_rate":66.66666666666666,"tests_run":6,"tests_passed":4,"tests_passed_rate":66.66666666666666,"lines":27,"lines_covered":27,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,381,382,383,384,385,386,389],"codes_lines_covered":[[["{","    struct TestMap {","        core: IndexMapCore<usize, usize>","    }","    ","    impl TestMap {","        fn new() -> Self {","            TestMap {","                core: IndexMapCore::new(),","            }","        }","","        fn replace_full(&mut self, hash: HashValue, key: usize, value: usize) -> (usize, Option<(usize, usize)>) {","            self.core.replace_full(hash, key, value)","        }","    }","    ","    let mut map = TestMap::new();","    let hash = HashValue(1);","    let (index, previous) = map.replace_full(hash, 10, 100);","    ","    assert_eq!(index, 0);","    assert_eq!(previous, None);","}"],[360,361,362,363,364,365,366,367,368,369,370,371,381,382,383,384,385,386,389]],[["{","    struct TestMap {","        core: IndexMapCore<usize, usize>","    }","    ","    impl TestMap {","        fn new() -> Self {","            TestMap {","                core: IndexMapCore::new(),","            }","        }","","        fn replace_full(&mut self, hash: HashValue, key: usize, value: usize) -> (usize, Option<(usize, usize)>) {","            self.core.replace_full(hash, key, value)","        }","    }","    ","    let mut map = TestMap::new();","    let hash = HashValue(1);","    ","    // Insert new entry first","    map.replace_full(hash, 10, 100);","    ","    // Replace existing entry","    let (index, previous) = map.replace_full(hash, 10, 200);","    ","    assert_eq!(index, 0);","    assert_eq!(previous, Some((10, 100)));","}"],[360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,381,382,383,384,385,386,389]],[["{","    struct TestMap {","        core: IndexMapCore<usize, usize>","    }","    ","    impl TestMap {","        fn new() -> Self {","            TestMap {","                core: IndexMapCore::new(),","            }","        }","","        fn replace_full(&mut self, hash: HashValue, key: usize, value: usize) -> (usize, Option<(usize, usize)>) {","            self.core.replace_full(hash, key, value)","        }","    }","    ","    let mut map = TestMap::new();","    let hash = HashValue(2); // Use a different hash to trigger panic for vacuum entry access","    let (index, previous) = map.replace_full(hash, 10, 100);","    assert_eq!(index, 0);","}"],[360,361,362,363,364,365,366,367,368,369,370,371,381,382,383,384,385,386,389]],[["{","    struct SimpleEquivalent;","    impl Equivalent<usize> for SimpleEquivalent {","        fn equivalent(&self, _: &usize) -> bool {","            true","        }","    }","","    let mut map: IndexMapCore<usize, String> = IndexMapCore::new();","    let hash_value = HashValue(42);","    ","    // Initially insert one entry","    map.replace_full(hash_value, 1, \"initial\".to_string());","","    // Replace entry with a new value","    let (index, old_entry) = map.replace_full(hash_value, 1, \"updated\".to_string());","","    assert_eq!(index, 0);","    assert_eq!(old_entry, Some((1, \"initial\".to_string())));","}"],[360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,381,382,383,384,385,386,389]],[["{","    struct SimpleEquivalent;","    impl Equivalent<usize> for SimpleEquivalent {","        fn equivalent(&self, _: &usize) -> bool {","            true","        }","    }","","    let mut map: IndexMapCore<usize, String> = IndexMapCore::new();","    let hash_value = HashValue(42);","    ","    // Try to replace a non-existing entry","    let (index, old_entry) = map.replace_full(hash_value, 2, \"new\".to_string());","","    assert_eq!(index, 0);","    assert_eq!(old_entry, None);","}"],[360,361,362,363,364,365,366,367,368,369,370,371,381,382,383,384,385,386,389]],[["{","    struct SimpleEquivalent;","    impl Equivalent<usize> for SimpleEquivalent {","        fn equivalent(&self, _: &usize) -> bool {","            false","        }","    }","","    let mut map: IndexMapCore<usize, String> = IndexMapCore::new();","    let hash_value = HashValue(42);","","    // This will create a new entry","    map.replace_full(hash_value, 1, \"initial\".to_string());","","    // Change the condition to access a nonexistent entry, which should trigger a panic","    map.replace_full(hash_value, 2, \"next\".to_string());","}"],[360,361,362,363,364,365,366,367,368,369,370,371,381,382,383,384,385,386,389]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestMap {","        core: IndexMapCore<usize, usize>","    }","    ","    impl TestMap {","        fn new() -> Self {","            TestMap {","                core: IndexMapCore::new(),","            }","        }","","        fn replace_full(&mut self, hash: HashValue, key: usize, value: usize) -> (usize, Option<(usize, usize)>) {","            self.core.replace_full(hash, key, value)","        }","    }","    ","    let mut map = TestMap::new();","    let hash = HashValue(1);","    let (index, previous) = map.replace_full(hash, 10, 100);","    ","    assert_eq!(index, 0);","    assert_eq!(previous, None);","}"],[]],[["{","    struct TestMap {","        core: IndexMapCore<usize, usize>","    }","    ","    impl TestMap {","        fn new() -> Self {","            TestMap {","                core: IndexMapCore::new(),","            }","        }","","        fn replace_full(&mut self, hash: HashValue, key: usize, value: usize) -> (usize, Option<(usize, usize)>) {","            self.core.replace_full(hash, key, value)","        }","    }","    ","    let mut map = TestMap::new();","    let hash = HashValue(1);","    ","    // Insert new entry first","    map.replace_full(hash, 10, 100);","    ","    // Replace existing entry","    let (index, previous) = map.replace_full(hash, 10, 200);","    ","    assert_eq!(index, 0);","    assert_eq!(previous, Some((10, 100)));","}"],[]],[["{","    struct TestMap {","        core: IndexMapCore<usize, usize>","    }","    ","    impl TestMap {","        fn new() -> Self {","            TestMap {","                core: IndexMapCore::new(),","            }","        }","","        fn replace_full(&mut self, hash: HashValue, key: usize, value: usize) -> (usize, Option<(usize, usize)>) {","            self.core.replace_full(hash, key, value)","        }","    }","    ","    let mut map = TestMap::new();","    let hash = HashValue(2); // Use a different hash to trigger panic for vacuum entry access","    let (index, previous) = map.replace_full(hash, 10, 100);","    assert_eq!(index, 0);","}"],[]],[["{","    struct SimpleEquivalent;","    impl Equivalent<usize> for SimpleEquivalent {","        fn equivalent(&self, _: &usize) -> bool {","            true","        }","    }","","    let mut map: IndexMapCore<usize, String> = IndexMapCore::new();","    let hash_value = HashValue(42);","    ","    // Initially insert one entry","    map.replace_full(hash_value, 1, \"initial\".to_string());","","    // Replace entry with a new value","    let (index, old_entry) = map.replace_full(hash_value, 1, \"updated\".to_string());","","    assert_eq!(index, 0);","    assert_eq!(old_entry, Some((1, \"initial\".to_string())));","}"],[]],[["{","    struct SimpleEquivalent;","    impl Equivalent<usize> for SimpleEquivalent {","        fn equivalent(&self, _: &usize) -> bool {","            true","        }","    }","","    let mut map: IndexMapCore<usize, String> = IndexMapCore::new();","    let hash_value = HashValue(42);","    ","    // Try to replace a non-existing entry","    let (index, old_entry) = map.replace_full(hash_value, 2, \"new\".to_string());","","    assert_eq!(index, 0);","    assert_eq!(old_entry, None);","}"],[]],[["{","    struct SimpleEquivalent;","    impl Equivalent<usize> for SimpleEquivalent {","        fn equivalent(&self, _: &usize) -> bool {","            false","        }","    }","","    let mut map: IndexMapCore<usize, String> = IndexMapCore::new();","    let hash_value = HashValue(42);","","    // This will create a new entry","    map.replace_full(hash_value, 1, \"initial\".to_string());","","    // Change the condition to access a nonexistent entry, which should trigger a panic","    map.replace_full(hash_value, 2, \"next\".to_string());","}"],[]]]}