{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::split_splice","tests":5,"tests_lines":[16,7,9,13,11],"oracles":5,"oracles_compiled":1,"oracles_compiled_rate":20.0,"tests_compiled":1,"tests_compiled_rate":20.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":13,"lines_covered":13,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[226,227,228,229,230,231,232,233,234,235,236,237,238],"codes_lines_covered":[[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    ","    let (split, iter) = map.split_splice(0..0);","    ","    assert_eq!(split.entries.len(), 0);","    let drained: Vec<_> = iter.collect();","    assert_eq!(drained.len(), 0);","}"],[226,227,228,229,230,231,232,233,234,235,236,237,238]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    ","    let (split, iter) = map.split_splice(0..0);","    ","    assert_eq!(split.entries.len(), 0);","    let drained: Vec<_> = iter.collect();","    assert_eq!(drained.len(), 0);","}"],[]]]}