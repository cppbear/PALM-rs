{"function_name":"indexmap::set::set::IndexSet<T, S>::shift_insert","tests":6,"tests_lines":[8,8,8,8,8,6],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":6,"tests_compiled_rate":100.0,"oracles_run":6,"oracles_passed":2,"oracles_passed_rate":33.33333333333333,"tests_run":6,"tests_passed":2,"tests_passed_rate":33.33333333333333,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[490,491,492],"codes_lines_covered":[[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Inserting a new value at a valid index","    assert_eq!(set.get_index_of(&'*'), None);","    assert_eq!(set.shift_insert(10, '*'), true);","    assert_eq!(set.get_index_of(&'*'), Some(10));","}"],[490,491,492]],[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Moving the value 'a' up to 10 will shift others down","    assert_eq!(set.shift_insert(10, 'a'), false);","    assert_eq!(set.get_index_of(&'a'), Some(10));","    assert_eq!(set.get_index_of(&'*'), Some(9));","}"],[490,491,492]],[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Moving the value 'z' down to 9 will shift others up","    assert_eq!(set.shift_insert(9, 'z'), false);","    assert_eq!(set.get_index_of(&'z'), Some(9));","    assert_eq!(set.get_index_of(&'*'), Some(10));","}"],[490,491,492]],[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Moving to len-1, should not move existing value","    assert_eq!(set.len(), 27);","    assert_eq!(set.shift_insert(set.len() - 1, '*'), false);","    assert_eq!(set.get_index_of(&'*'), Some(26));","}"],[]],[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Insert a new value at the end","    assert_eq!(set.shift_insert(set.len(), '+'), true);","    assert_eq!(set.get_index_of(&'+'), Some(27));","    assert_eq!(set.len(), 28);","}"],[490,491,492]],[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Invalid index for moving an existing value","    set.shift_insert(set.len(), 'a');","}"],[490,491,492]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Inserting a new value at a valid index","    assert_eq!(set.get_index_of(&'*'), None);","    assert_eq!(set.shift_insert(10, '*'), true);","    assert_eq!(set.get_index_of(&'*'), Some(10));","}"],[]],[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Moving the value 'a' up to 10 will shift others down","    assert_eq!(set.shift_insert(10, 'a'), false);","    assert_eq!(set.get_index_of(&'a'), Some(10));","    assert_eq!(set.get_index_of(&'*'), Some(9));","}"],[]],[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Moving the value 'z' down to 9 will shift others up","    assert_eq!(set.shift_insert(9, 'z'), false);","    assert_eq!(set.get_index_of(&'z'), Some(9));","    assert_eq!(set.get_index_of(&'*'), Some(10));","}"],[]],[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Moving to len-1, should not move existing value","    assert_eq!(set.len(), 27);","    assert_eq!(set.shift_insert(set.len() - 1, '*'), false);","    assert_eq!(set.get_index_of(&'*'), Some(26));","}"],[]],[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Insert a new value at the end","    assert_eq!(set.shift_insert(set.len(), '+'), true);","    assert_eq!(set.get_index_of(&'+'), Some(27));","    assert_eq!(set.len(), 28);","}"],[]],[["{","    let mut set: super::IndexSet<char, std::collections::hash_map::RandomState> = ('a'..='z').collect();","    ","    // Invalid index for moving an existing value","    set.shift_insert(set.len(), 'a');","}"],[]]]}