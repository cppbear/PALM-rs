{"function_name":"indexmap::map::map::IndexMap<K, V, S>::first","tests":2,"tests_lines":[25,22],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1268,1269,1270],"codes_lines_covered":[[["{","    struct MockIndexMap {","        entries: Vec<Bucket<i32, String>>,","    }","","    impl MockIndexMap {","        fn as_entries(&self) -> &Vec<Bucket<i32, String>> {","            &self.entries","        }","","        fn first(&self) -> Option<(&i32, &String)> {","            self.as_entries().first().map(|bucket| (&bucket.key, &bucket.value))","        }","    }","","    let map = MockIndexMap {","        entries: vec![","            Bucket { hash: HashValue(1), key: 1, value: \"Value1\".to_string() },","            Bucket { hash: HashValue(2), key: 2, value: \"Value2\".to_string() },","        ],","    };","","    let result = map.first();","    assert_eq!(result, Some((&1, &\"Value1\".to_string())));","}"],[]],[["{","    struct MockIndexMap {","        entries: Vec<Bucket<i32, String>>,","    }","","    impl MockIndexMap {","        fn as_entries(&self) -> &Vec<Bucket<i32, String>> {","            &self.entries","        }","","        fn first(&self) -> Option<(&i32, &String)> {","            self.as_entries().first().map(|bucket| (&bucket.key, &bucket.value))","        }","    }","","    let map = MockIndexMap {","        entries: Vec::new(),","    };","","    let result = map.first();","    assert_eq!(result, None);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MockIndexMap {","        entries: Vec<Bucket<i32, String>>,","    }","","    impl MockIndexMap {","        fn as_entries(&self) -> &Vec<Bucket<i32, String>> {","            &self.entries","        }","","        fn first(&self) -> Option<(&i32, &String)> {","            self.as_entries().first().map(|bucket| (&bucket.key, &bucket.value))","        }","    }","","    let map = MockIndexMap {","        entries: vec![","            Bucket { hash: HashValue(1), key: 1, value: \"Value1\".to_string() },","            Bucket { hash: HashValue(2), key: 2, value: \"Value2\".to_string() },","        ],","    };","","    let result = map.first();","    assert_eq!(result, Some((&1, &\"Value1\".to_string())));","}"],[]],[["{","    struct MockIndexMap {","        entries: Vec<Bucket<i32, String>>,","    }","","    impl MockIndexMap {","        fn as_entries(&self) -> &Vec<Bucket<i32, String>> {","            &self.entries","        }","","        fn first(&self) -> Option<(&i32, &String)> {","            self.as_entries().first().map(|bucket| (&bucket.key, &bucket.value))","        }","    }","","    let map = MockIndexMap {","        entries: Vec::new(),","    };","","    let result = map.first();","    assert_eq!(result, None);","}"],[]]]}