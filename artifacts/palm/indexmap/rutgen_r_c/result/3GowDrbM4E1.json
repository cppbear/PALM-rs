{"function_name":"indexmap::set::set::IndexSet<T, S>::is_subset","tests":8,"tests_lines":[21,20,16,20,30,30,30,30],"oracles":8,"oracles_compiled":4,"oracles_compiled_rate":50.0,"tests_compiled":4,"tests_compiled_rate":50.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1221,1222,1223,1224,1225,1226],"codes_lines_covered":[[["{","    use std::collections::hash_map::RandomState;","    ","    struct MySet {","        elements: Vec<i32>,","        hasher: RandomState,","    }","    ","    impl MySet {","        fn new(elements: Vec<i32>) -> Self {","            MySet {","                elements,","                hasher: RandomState::new(),","            }","        }","        ","        fn as_index_set(&self) -> IndexSet<i32, RandomState> {","            let mut set = IndexSet::with_hasher(self.hasher.clone());","            for &elem in &self.elements {","                set.insert(elem);","            }","            set","        }","    }","","    let set_a = MySet::new(vec![1, 2, 3]).as_index_set();","    let set_b = MySet::new(vec![1, 2]).as_index_set(); // set_b is smaller than set_a","","    assert!(!set_a.is_subset(&set_b));","}"],[1221,1222,1223,1224,1225,1226]],[["{","    use std::collections::hash_map::RandomState;","","    struct MySet {","        elements: Vec<i32>,","        hasher: RandomState,","    }","    ","    impl MySet {","        fn new(elements: Vec<i32>) -> Self {","            MySet {","                elements,","                hasher: RandomState::new(),","            }","        }","        ","        fn as_index_set(&self) -> IndexSet<i32, RandomState> {","            let mut set = IndexSet::with_hasher(self.hasher.clone());","            for &elem in &self.elements {","                set.insert(elem);","            }","            set","        }","    }","","    let set_a = MySet::new(vec![1, 2, 3]).as_index_set();","    let set_b = MySet::new(vec![]).as_index_set(); // set_b is empty","","    assert!(!set_a.is_subset(&set_b));","}"],[1221,1222,1223,1224,1225,1226]],[["{","    use std::collections::hash_map::RandomState;","","    struct MySet {","        elements: Vec<i32>,","        hasher: RandomState,","    }","    ","    impl MySet {","        fn new(elements: Vec<i32>) -> Self {","            MySet {","                elements,","                hasher: RandomState::new(),","            }","        }","        ","        fn as_index_set(&self) -> IndexSet<i32, RandomState> {","            let mut set = IndexSet::with_hasher(self.hasher.clone());","            for &elem in &self.elements {","                set.insert(elem);","            }","            set","        }","    }","","    let set_a = MySet::new(vec![1, 2, 3]).as_index_set();","    let set_b = MySet::new(vec![1, 2, 3]).as_index_set(); // set_b is equal to set_a","","    assert!(set_a.is_subset(&set_b));","}"],[1221,1222,1223,1224,1225,1226]],[["{","    use std::collections::hash_map::RandomState;","","    struct MySet {","        elements: Vec<i32>,","        hasher: RandomState,","    }","    ","    impl MySet {","        fn new(elements: Vec<i32>) -> Self {","            MySet {","                elements,","                hasher: RandomState::new(),","            }","        }","        ","        fn as_index_set(&self) -> IndexSet<i32, RandomState> {","            let mut set = IndexSet::with_hasher(self.hasher.clone());","            for &elem in &self.elements {","                set.insert(elem);","            }","            set","        }","    }","","    let set_a = MySet::new(vec![1, 2]).as_index_set();","    let set_b = MySet::new(vec![1, 2, 3]).as_index_set(); // set_b contains all elements of set_a","","    assert!(set_a.is_subset(&set_b));","}"],[1221,1222,1223,1224,1225,1226]]],"codes_branches":[{"start_line":1225,"start_column":9,"end_line":1225,"end_column":34,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    use std::collections::hash_map::RandomState;","    ","    struct MySet {","        elements: Vec<i32>,","        hasher: RandomState,","    }","    ","    impl MySet {","        fn new(elements: Vec<i32>) -> Self {","            MySet {","                elements,","                hasher: RandomState::new(),","            }","        }","        ","        fn as_index_set(&self) -> IndexSet<i32, RandomState> {","            let mut set = IndexSet::with_hasher(self.hasher.clone());","            for &elem in &self.elements {","                set.insert(elem);","            }","            set","        }","    }","","    let set_a = MySet::new(vec![1, 2, 3]).as_index_set();","    let set_b = MySet::new(vec![1, 2]).as_index_set(); // set_b is smaller than set_a","","    assert!(!set_a.is_subset(&set_b));","}"],[{"start_line":1225,"start_column":9,"end_line":1225,"end_column":34,"positive":false,"negative":true}]],[["{","    use std::collections::hash_map::RandomState;","","    struct MySet {","        elements: Vec<i32>,","        hasher: RandomState,","    }","    ","    impl MySet {","        fn new(elements: Vec<i32>) -> Self {","            MySet {","                elements,","                hasher: RandomState::new(),","            }","        }","        ","        fn as_index_set(&self) -> IndexSet<i32, RandomState> {","            let mut set = IndexSet::with_hasher(self.hasher.clone());","            for &elem in &self.elements {","                set.insert(elem);","            }","            set","        }","    }","","    let set_a = MySet::new(vec![1, 2, 3]).as_index_set();","    let set_b = MySet::new(vec![]).as_index_set(); // set_b is empty","","    assert!(!set_a.is_subset(&set_b));","}"],[{"start_line":1225,"start_column":9,"end_line":1225,"end_column":34,"positive":false,"negative":true}]],[["{","    use std::collections::hash_map::RandomState;","","    struct MySet {","        elements: Vec<i32>,","        hasher: RandomState,","    }","    ","    impl MySet {","        fn new(elements: Vec<i32>) -> Self {","            MySet {","                elements,","                hasher: RandomState::new(),","            }","        }","        ","        fn as_index_set(&self) -> IndexSet<i32, RandomState> {","            let mut set = IndexSet::with_hasher(self.hasher.clone());","            for &elem in &self.elements {","                set.insert(elem);","            }","            set","        }","    }","","    let set_a = MySet::new(vec![1, 2, 3]).as_index_set();","    let set_b = MySet::new(vec![1, 2, 3]).as_index_set(); // set_b is equal to set_a","","    assert!(set_a.is_subset(&set_b));","}"],[{"start_line":1225,"start_column":9,"end_line":1225,"end_column":34,"positive":true,"negative":false}]],[["{","    use std::collections::hash_map::RandomState;","","    struct MySet {","        elements: Vec<i32>,","        hasher: RandomState,","    }","    ","    impl MySet {","        fn new(elements: Vec<i32>) -> Self {","            MySet {","                elements,","                hasher: RandomState::new(),","            }","        }","        ","        fn as_index_set(&self) -> IndexSet<i32, RandomState> {","            let mut set = IndexSet::with_hasher(self.hasher.clone());","            for &elem in &self.elements {","                set.insert(elem);","            }","            set","        }","    }","","    let set_a = MySet::new(vec![1, 2]).as_index_set();","    let set_b = MySet::new(vec![1, 2, 3]).as_index_set(); // set_b contains all elements of set_a","","    assert!(set_a.is_subset(&set_b));","}"],[{"start_line":1225,"start_column":9,"end_line":1225,"end_column":34,"positive":true,"negative":false}]]]}