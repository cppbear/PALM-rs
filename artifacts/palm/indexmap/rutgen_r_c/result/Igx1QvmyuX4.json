{"function_name":"indexmap::map::map::IndexMap<K, V, S>::get_range","tests":8,"tests_lines":[23,26,29,25,24,40,39,42],"oracles":8,"oracles_compiled":2,"oracles_compiled_rate":25.0,"tests_compiled":2,"tests_compiled_rate":25.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1247,1248,1249,1250,1251],"codes_lines_covered":[[["{","    struct TestMap {","        entries: Vec<Bucket<i32, i32>>,","    }","","    impl TestMap {","        fn as_entries(&self) -> &[Bucket<i32, i32>] {","            &self.entries","        }","","        fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Slice<i32, i32>> {","            let entries = self.as_entries();","            let range = try_simplify_range(range, entries.len())?;","            entries.get(range).map(Slice::from_slice)","        }","    }","","    let test_map = TestMap { entries: vec![] };","","    // Test with an out-of-bounds range","    assert!(test_map.get_range(1..3).is_none());","    assert!(test_map.get_range(0..1).is_none());","}"],[]],[["{","    struct TestMap {","        entries: Vec<Bucket<i32, i32>>,","    }","","    impl TestMap {","        fn as_entries(&self) -> &[Bucket<i32, i32>] {","            &self.entries","        }","","        fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Slice<i32, i32>> {","            let entries = self.as_entries();","            let range = try_simplify_range(range, entries.len())?;","            entries.get(range).map(Slice::from_slice)","        }","    }","","    let test_map = TestMap { entries: vec![] };","","    // Ensure all invalid conditions are tested without panics","    assert!(test_map.get_range(0..10).is_none());","    assert!(test_map.get_range(5..10).is_none());","    assert!(test_map.get_range(5..=5).is_none());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestMap {","        entries: Vec<Bucket<i32, i32>>,","    }","","    impl TestMap {","        fn as_entries(&self) -> &[Bucket<i32, i32>] {","            &self.entries","        }","","        fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Slice<i32, i32>> {","            let entries = self.as_entries();","            let range = try_simplify_range(range, entries.len())?;","            entries.get(range).map(Slice::from_slice)","        }","    }","","    let test_map = TestMap { entries: vec![] };","","    // Test with an out-of-bounds range","    assert!(test_map.get_range(1..3).is_none());","    assert!(test_map.get_range(0..1).is_none());","}"],[]],[["{","    struct TestMap {","        entries: Vec<Bucket<i32, i32>>,","    }","","    impl TestMap {","        fn as_entries(&self) -> &[Bucket<i32, i32>] {","            &self.entries","        }","","        fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Slice<i32, i32>> {","            let entries = self.as_entries();","            let range = try_simplify_range(range, entries.len())?;","            entries.get(range).map(Slice::from_slice)","        }","    }","","    let test_map = TestMap { entries: vec![] };","","    // Ensure all invalid conditions are tested without panics","    assert!(test_map.get_range(0..10).is_none());","    assert!(test_map.get_range(5..10).is_none());","    assert!(test_map.get_range(5..=5).is_none());","}"],[]]]}