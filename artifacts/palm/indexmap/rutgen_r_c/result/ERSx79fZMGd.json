{"function_name":"indexmap::map::core::insert_bulk_no_grow","tests":4,"tests_lines":[38,33,18,19],"oracles":4,"oracles_compiled":2,"oracles_compiled_rate":50.0,"tests_compiled":2,"tests_compiled_rate":50.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[83,84,85,86,87,88],"codes_lines_covered":[[["{","    use hashbrown::hash_table::HashTable;","","    struct TestBucket {","        hash: HashValue,","        key: usize,","        value: usize,","    }","","    let mut indices: Indices = HashTable::with_capacity(2); // Initial capacity of 2","    let entries: Vec<Bucket<usize, usize>> = vec![","        Bucket { hash: HashValue(1), key: 1, value: 10 },","        Bucket { hash: HashValue(2), key: 2, value: 20 },","        // This would cause panic as it exceeds the available capacity (2) - length (0) < entries length (2)","    ];","","    insert_bulk_no_grow(&mut indices, &entries);","}"],[83,84,85,86,87,88]],[["{","    use hashbrown::hash_table::HashTable;","","    struct TestBucket {","        hash: HashValue,","        key: usize,","        value: usize,","    }","","    let mut indices: Indices = HashTable::with_capacity(4); // Initial capacity of 4","    let entries: Vec<Bucket<usize, usize>> = vec![","        Bucket { hash: HashValue(1), key: 1, value: 10 },","        Bucket { hash: HashValue(2), key: 2, value: 20 },","    ];","","    // Successfully insert entries without panicking","    insert_bulk_no_grow(&mut indices, &entries);","    assert_eq!(indices.len(), 2); // Verifying that the entries were inserted successfully","}"],[83,84,85,86,87,88]]],"codes_branches":[],"codes_branches_covered":[[["{","    use hashbrown::hash_table::HashTable;","","    struct TestBucket {","        hash: HashValue,","        key: usize,","        value: usize,","    }","","    let mut indices: Indices = HashTable::with_capacity(2); // Initial capacity of 2","    let entries: Vec<Bucket<usize, usize>> = vec![","        Bucket { hash: HashValue(1), key: 1, value: 10 },","        Bucket { hash: HashValue(2), key: 2, value: 20 },","        // This would cause panic as it exceeds the available capacity (2) - length (0) < entries length (2)","    ];","","    insert_bulk_no_grow(&mut indices, &entries);","}"],[]],[["{","    use hashbrown::hash_table::HashTable;","","    struct TestBucket {","        hash: HashValue,","        key: usize,","        value: usize,","    }","","    let mut indices: Indices = HashTable::with_capacity(4); // Initial capacity of 4","    let entries: Vec<Bucket<usize, usize>> = vec![","        Bucket { hash: HashValue(1), key: 1, value: 10 },","        Bucket { hash: HashValue(2), key: 2, value: 20 },","    ];","","    // Successfully insert entries without panicking","    insert_bulk_no_grow(&mut indices, &entries);","    assert_eq!(indices.len(), 2); // Verifying that the entries were inserted successfully","}"],[]]]}