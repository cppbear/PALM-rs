{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::split_splice","tests":5,"tests_lines":[16,7,9,13,11],"oracles":5,"oracles_compiled":4,"oracles_compiled_rate":80.0,"tests_compiled":4,"tests_compiled_rate":80.0,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":4,"tests_passed":2,"tests_passed_rate":50.0,"lines":13,"lines_covered":13,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[226,227,228,229,230,231,232,233,234,235,236,237,238],"codes_lines_covered":[[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(2), key: 2, value: 30 });  ","   ","    let (split, iter) = map.split_splice(1..2);","    ","    assert_eq!(split.entries.len(), 2);","    assert_eq!(split.entries[0].key, 1);","    assert_eq!(split.entries[1].key, 2);","    ","    let drained: Vec<_> = iter.collect();","    assert_eq!(drained.len(), 1);","    assert_eq!(drained[0].key, 1);","}"],[226,227,228,229,230,231,232,233,234,235,236,237,238]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 10 });","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 20 });","   ","   let _ = map.split_splice(0..3);","}"],[226,227,228,229,230,231,232,233,234,235,236,237,238]],[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    ","    let (split, iter) = map.split_splice(0..0);","    ","    assert_eq!(split.entries.len(), 0);","    let drained: Vec<_> = iter.collect();","    assert_eq!(drained.len(), 0);","}"],[226,227,228,229,230,231,232,233,234,235,236,237,238]],[["   {","       let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","       map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 10 });","       map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 20 });","   ","    let (split, iter) = map.split_splice(0..2);","    ","    assert_eq!(split.entries.len(), 0);","    let drained: Vec<_> = iter.collect();","    assert_eq!(drained.len(), 2);","    assert_eq!(drained[0].key, 0);","    assert_eq!(drained[1].key, 1);","}"],[226,227,228,229,230,231,232,233,234,235,236,237,238]]],"codes_branches":[],"codes_branches_covered":[[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(2), key: 2, value: 30 });  ","   ","    let (split, iter) = map.split_splice(1..2);","    ","    assert_eq!(split.entries.len(), 2);","    assert_eq!(split.entries[0].key, 1);","    assert_eq!(split.entries[1].key, 2);","    ","    let drained: Vec<_> = iter.collect();","    assert_eq!(drained.len(), 1);","    assert_eq!(drained[0].key, 1);","}"],[]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 10 });","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 20 });","   ","   let _ = map.split_splice(0..3);","}"],[]],[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    ","    let (split, iter) = map.split_splice(0..0);","    ","    assert_eq!(split.entries.len(), 0);","    let drained: Vec<_> = iter.collect();","    assert_eq!(drained.len(), 0);","}"],[]],[["   {","       let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","       map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 10 });","       map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 20 });","   ","    let (split, iter) = map.split_splice(0..2);","    ","    assert_eq!(split.entries.len(), 0);","    let drained: Vec<_> = iter.collect();","    assert_eq!(drained.len(), 2);","    assert_eq!(drained[0].key, 0);","    assert_eq!(drained[1].key, 1);","}"],[]]]}