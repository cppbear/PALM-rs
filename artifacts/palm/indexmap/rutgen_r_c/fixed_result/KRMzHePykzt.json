{"function_name":"indexmap::map::map::IndexMap<K, V, S>::get","tests":4,"tests_lines":[15,16,43,43],"oracles":4,"oracles_compiled":1,"oracles_compiled_rate":25.0,"tests_compiled":1,"tests_compiled_rate":25.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":9,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[711,712,713,714,715,716,717,719,721],"codes_lines_covered":[[["{","    struct TestIndexMap {","        entries: Vec<Bucket<String, i32>>,","    }","","    impl TestIndexMap {","        fn new() -> Self {","            TestIndexMap {","                entries: vec![","                    Bucket { hash: HashValue(1), key: \"key1\".to_string(), value: 10 },","                    Bucket { hash: HashValue(2), key: \"key2\".to_string(), value: 20 },","                ],","            }","        }","","        fn as_entries(&self) -> &[Bucket<String, i32>] {","            &self.entries","        }","","       fn get_index_of<Q>(&self, key: &Q) -> Option<usize>","       where","           Q: ?Sized + Hash + AsRef<str>,","       {","           self.entries.iter().position(|b| &b.key == key.as_ref())","        }","","       fn get<Q>(&self, key: &Q) -> Option<&i32>","       where","           Q: ?Sized + Hash + AsRef<str>,","        {","            if let Some(i) = self.get_index_of(key) {","                let entry = &self.as_entries()[i];","                Some(&entry.value)","            } else {","                None","            }","        }","    }","","    let index_map = TestIndexMap::new();","    let result = index_map.get(&\"key1\");","    assert_eq!(result, Some(&10));","}"],[]]],"codes_branches":[{"start_line":715,"start_column":16,"end_line":715,"end_column":23,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestIndexMap {","        entries: Vec<Bucket<String, i32>>,","    }","","    impl TestIndexMap {","        fn new() -> Self {","            TestIndexMap {","                entries: vec![","                    Bucket { hash: HashValue(1), key: \"key1\".to_string(), value: 10 },","                    Bucket { hash: HashValue(2), key: \"key2\".to_string(), value: 20 },","                ],","            }","        }","","        fn as_entries(&self) -> &[Bucket<String, i32>] {","            &self.entries","        }","","       fn get_index_of<Q>(&self, key: &Q) -> Option<usize>","       where","           Q: ?Sized + Hash + AsRef<str>,","       {","           self.entries.iter().position(|b| &b.key == key.as_ref())","        }","","       fn get<Q>(&self, key: &Q) -> Option<&i32>","       where","           Q: ?Sized + Hash + AsRef<str>,","        {","            if let Some(i) = self.get_index_of(key) {","                let entry = &self.as_entries()[i];","                Some(&entry.value)","            } else {","                None","            }","        }","    }","","    let index_map = TestIndexMap::new();","    let result = index_map.get(&\"key1\");","    assert_eq!(result, Some(&10));","}"],[{"start_line":715,"start_column":16,"end_line":715,"end_column":23,"positive":false,"negative":false}]]]}