{"function_name":"indexmap::set::set::IndexSet<T, S>::sort_unstable_by","tests":4,"tests_lines":[41,32,41,35],"oracles":4,"oracles_compiled":3,"oracles_compiled_rate":75.0,"tests_compiled":3,"tests_compiled_rate":75.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[875,876,877,878,879,880],"codes_lines_covered":[[["{","    struct TestSet {","        map: IndexMap<i32, (), RandomState>, // assuming RandomState is used for hash building","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet {","                map: IndexMap::new(),","            }","        }","","        fn add(&mut self, value: i32) {","            self.map.insert(value, ());","        }","","       fn sort_unstable_by<F>(&mut self, mut cmp: F)","       where","           F: FnMut(&i32, &i32) -> Ordering,","       {","           self.map.sort_unstable_by(move |a, _, b, _| cmp(a, b));","       }","","        fn as_vec(&self) -> Vec<i32> {","            self.map.keys().cloned().collect()","        }","    }","","    let mut set = TestSet::new();","","    set.add(3);","    set.add(1);","    set.add(4);","    set.add(2);","","    set.sort_unstable_by(|a, b| a.cmp(b));","","    let sorted_values = set.as_vec();","","    assert_eq!(sorted_values, vec![1, 2, 3, 4]);","}"],[]],[["{","    struct TestSet {","        map: IndexMap<i32, (), RandomState>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet {","                map: IndexMap::new(),","            }","        }","","       fn sort_unstable_by<F>(&mut self, mut cmp: F)","       where","           F: FnMut(&i32, &i32) -> Ordering,","       {","           self.map.sort_unstable_by(move |a, _, b, _| cmp(a, b));","        }","","        fn as_vec(&self) -> Vec<i32> {","            self.map.keys().cloned().collect()","        }","    }","","    let mut set = TestSet::new();","","    set.sort_unstable_by(|a, b| a.cmp(b));","","    let sorted_values = set.as_vec();","","    assert_eq!(sorted_values, vec![]);","}"],[]],[["{","    struct TestSet {","        map: IndexMap<i32, (), RandomState>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet {","                map: IndexMap::new(),","            }","        }","","        fn add(&mut self, value: i32) {","            self.map.insert(value, ());","        }","","       fn sort_unstable_by<F>(&mut self, mut cmp: F)","       where","           F: FnMut(&i32, &i32) -> Ordering,","       {","           self.map.sort_unstable_by(move |a, _, b, _| cmp(a, b));","       }","","        fn as_vec(&self) -> Vec<i32> {","            self.map.keys().cloned().collect()","        }","    }","","    let mut set = TestSet::new();","","    set.add(4);","    set.add(3);","    set.add(2);","    set.add(1);","","    set.sort_unstable_by(|a, b| b.cmp(a));","","    let sorted_values = set.as_vec();","","    assert_eq!(sorted_values, vec![4, 3, 2, 1]);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestSet {","        map: IndexMap<i32, (), RandomState>, // assuming RandomState is used for hash building","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet {","                map: IndexMap::new(),","            }","        }","","        fn add(&mut self, value: i32) {","            self.map.insert(value, ());","        }","","       fn sort_unstable_by<F>(&mut self, mut cmp: F)","       where","           F: FnMut(&i32, &i32) -> Ordering,","       {","           self.map.sort_unstable_by(move |a, _, b, _| cmp(a, b));","       }","","        fn as_vec(&self) -> Vec<i32> {","            self.map.keys().cloned().collect()","        }","    }","","    let mut set = TestSet::new();","","    set.add(3);","    set.add(1);","    set.add(4);","    set.add(2);","","    set.sort_unstable_by(|a, b| a.cmp(b));","","    let sorted_values = set.as_vec();","","    assert_eq!(sorted_values, vec![1, 2, 3, 4]);","}"],[]],[["{","    struct TestSet {","        map: IndexMap<i32, (), RandomState>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet {","                map: IndexMap::new(),","            }","        }","","       fn sort_unstable_by<F>(&mut self, mut cmp: F)","       where","           F: FnMut(&i32, &i32) -> Ordering,","       {","           self.map.sort_unstable_by(move |a, _, b, _| cmp(a, b));","        }","","        fn as_vec(&self) -> Vec<i32> {","            self.map.keys().cloned().collect()","        }","    }","","    let mut set = TestSet::new();","","    set.sort_unstable_by(|a, b| a.cmp(b));","","    let sorted_values = set.as_vec();","","    assert_eq!(sorted_values, vec![]);","}"],[]],[["{","    struct TestSet {","        map: IndexMap<i32, (), RandomState>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet {","                map: IndexMap::new(),","            }","        }","","        fn add(&mut self, value: i32) {","            self.map.insert(value, ());","        }","","       fn sort_unstable_by<F>(&mut self, mut cmp: F)","       where","           F: FnMut(&i32, &i32) -> Ordering,","       {","           self.map.sort_unstable_by(move |a, _, b, _| cmp(a, b));","       }","","        fn as_vec(&self) -> Vec<i32> {","            self.map.keys().cloned().collect()","        }","    }","","    let mut set = TestSet::new();","","    set.add(4);","    set.add(3);","    set.add(2);","    set.add(1);","","    set.sort_unstable_by(|a, b| b.cmp(a));","","    let sorted_values = set.as_vec();","","    assert_eq!(sorted_values, vec![4, 3, 2, 1]);","}"],[]]]}