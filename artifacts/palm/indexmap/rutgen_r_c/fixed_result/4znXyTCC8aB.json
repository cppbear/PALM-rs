{"function_name":"indexmap::map::core::map::core::RefMut<'a, K, V>::shift_insert_unique","tests":6,"tests_lines":[23,13,20,17,20,40],"oracles":6,"oracles_compiled":2,"oracles_compiled_rate":33.33333333333333,"tests_compiled":2,"tests_compiled_rate":33.33333333333333,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":18,"lines_covered":11,"lines_coveraged_rate":61.111111111111114,"branches":4,"branches_covered":1,"branches_coverage_rate":25.0,"codes_lines":[569,570,571,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587],"codes_lines_covered":[[["{","   let mut indices = hash_table::HashTable::new();","   let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(1);","   // Fill the entries to capacity","   entries.push(Bucket { hash: HashValue(1), key: 0, value: 10 });","   let index = entries.len();","   let hash = HashValue(2);","   let key = 1;","   let value = 20;","   ","   // Manually set capacity to current length for testing panic","   entries.reserve(1);","   {","       let mut ref_mut = RefMut::new(&mut indices, &mut entries);","       ref_mut.shift_insert_unique(index, hash, key, value); // This should panic","   }","}"],[569,570,571]],[["{","   let mut indices = hash_table::HashTable::new();","   let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(2);","   let index = entries.len();","   ","   // Fill one entry","   entries.push(Bucket { hash: HashValue(1), key: 0, value: 10 });","   ","   let mut ref_mut = RefMut::new(&mut indices, &mut entries);","   ","   // Index is within current length (not at capacity)","   let hash = HashValue(2);","   let key = 1;","   let value = 20;","   ","   ref_mut.shift_insert_unique(index, hash, key, value);","   ","   assert_eq!(entries.len(), 2);","    assert_eq!(entries[1].value, value);","}"],[569,570,571,573,574,575,580,581,585,586,587]]],"codes_branches":[{"start_line":581,"start_column":12,"end_line":581,"end_column":57,"positive":false,"negative":true},{"start_line":578,"start_column":24,"end_line":578,"end_column":33,"positive":false,"negative":false}],"codes_branches_covered":[[["{","   let mut indices = hash_table::HashTable::new();","   let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(1);","   // Fill the entries to capacity","   entries.push(Bucket { hash: HashValue(1), key: 0, value: 10 });","   let index = entries.len();","   let hash = HashValue(2);","   let key = 1;","   let value = 20;","   ","   // Manually set capacity to current length for testing panic","   entries.reserve(1);","   {","       let mut ref_mut = RefMut::new(&mut indices, &mut entries);","       ref_mut.shift_insert_unique(index, hash, key, value); // This should panic","   }","}"],[{"start_line":581,"start_column":12,"end_line":581,"end_column":57,"positive":false,"negative":false},{"start_line":578,"start_column":24,"end_line":578,"end_column":33,"positive":false,"negative":false}]],[["{","   let mut indices = hash_table::HashTable::new();","   let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(2);","   let index = entries.len();","   ","   // Fill one entry","   entries.push(Bucket { hash: HashValue(1), key: 0, value: 10 });","   ","   let mut ref_mut = RefMut::new(&mut indices, &mut entries);","   ","   // Index is within current length (not at capacity)","   let hash = HashValue(2);","   let key = 1;","   let value = 20;","   ","   ref_mut.shift_insert_unique(index, hash, key, value);","   ","   assert_eq!(entries.len(), 2);","    assert_eq!(entries[1].value, value);","}"],[{"start_line":581,"start_column":12,"end_line":581,"end_column":57,"positive":false,"negative":true},{"start_line":578,"start_column":24,"end_line":578,"end_column":33,"positive":false,"negative":false}]]]}