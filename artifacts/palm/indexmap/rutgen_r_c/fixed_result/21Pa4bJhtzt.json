{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::reserve","tests":4,"tests_lines":[11,12,44,43],"oracles":4,"oracles_compiled":3,"oracles_compiled_rate":75.0,"tests_compiled":3,"tests_compiled_rate":75.0,"oracles_run":3,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":3,"tests_passed":0,"tests_passed_rate":0.0,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[249,250,251,252,253,254,255],"codes_lines_covered":[[["{","    let mut map = IndexMapCore::<usize, usize>::with_capacity(5);","    ","    // Initially, the length is 0, so capacity is 5.","    // We attempt to reserve more than the remaining capacity","    let additional = 6;","    map.reserve(additional);","","    // Now we check the length after reserving","    assert!(map.len() >= additional);","}"],[249,250,251,252,253,254,255]],[["{","    let mut map = IndexMapCore::<usize, usize>::with_capacity(10);","    ","    // Initially, the length is 0, capacity is 10","    let additional = 11;","    ","    // This should not panic","    map.reserve(additional);","    ","    // Check that the map can now hold more than its initial capacity","    assert!(map.len() >= additional);","}"],[249,250,251,252,253,254,255]],[["{","    struct TestEntries {","        entries: Vec<Bucket<usize, String>>,","    }","    ","    impl TestEntries {","        fn new() -> Self {","            Self { entries: Vec::new() }","        }","        ","        fn with_capacity(capacity: usize) -> Self {","            Self { entries: Vec::with_capacity(capacity) }","        }","","        fn capacity(&self) -> usize {","            self.entries.capacity()","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","        ","        fn reserve(&mut self, additional: usize) {","            self.entries.reserve(additional);","        }","    }","","    let mut index_map = IndexMapCore::<usize, String>::with_capacity(10);","    ","    // Fill the entries to capacity","    index_map.entries = TestEntries::with_capacity(5).entries;","    ","    // Ensure entries.length == capacity","    assert_eq!(index_map.entries.len(), index_map.entries.capacity());","","    // Reserve with additional == 0 should not trigger growth","    index_map.reserve(0);","    assert_eq!(index_map.entries.len(), 0);","    assert_eq!(index_map.entries.capacity(), 5);","    ","    // Next, we reserve an additional equal to the current free capacity which is zero","    index_map.reserve(0);","    assert_eq!(index_map.entries.len(), index_map.entries.capacity());","}"],[]]],"codes_branches":[{"start_line":252,"start_column":12,"end_line":252,"end_column":69,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    let mut map = IndexMapCore::<usize, usize>::with_capacity(5);","    ","    // Initially, the length is 0, so capacity is 5.","    // We attempt to reserve more than the remaining capacity","    let additional = 6;","    map.reserve(additional);","","    // Now we check the length after reserving","    assert!(map.len() >= additional);","}"],[{"start_line":252,"start_column":12,"end_line":252,"end_column":69,"positive":true,"negative":false}]],[["{","    let mut map = IndexMapCore::<usize, usize>::with_capacity(10);","    ","    // Initially, the length is 0, capacity is 10","    let additional = 11;","    ","    // This should not panic","    map.reserve(additional);","    ","    // Check that the map can now hold more than its initial capacity","    assert!(map.len() >= additional);","}"],[{"start_line":252,"start_column":12,"end_line":252,"end_column":69,"positive":true,"negative":false}]],[["{","    struct TestEntries {","        entries: Vec<Bucket<usize, String>>,","    }","    ","    impl TestEntries {","        fn new() -> Self {","            Self { entries: Vec::new() }","        }","        ","        fn with_capacity(capacity: usize) -> Self {","            Self { entries: Vec::with_capacity(capacity) }","        }","","        fn capacity(&self) -> usize {","            self.entries.capacity()","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","        ","        fn reserve(&mut self, additional: usize) {","            self.entries.reserve(additional);","        }","    }","","    let mut index_map = IndexMapCore::<usize, String>::with_capacity(10);","    ","    // Fill the entries to capacity","    index_map.entries = TestEntries::with_capacity(5).entries;","    ","    // Ensure entries.length == capacity","    assert_eq!(index_map.entries.len(), index_map.entries.capacity());","","    // Reserve with additional == 0 should not trigger growth","    index_map.reserve(0);","    assert_eq!(index_map.entries.len(), 0);","    assert_eq!(index_map.entries.capacity(), 5);","    ","    // Next, we reserve an additional equal to the current free capacity which is zero","    index_map.reserve(0);","    assert_eq!(index_map.entries.len(), index_map.entries.capacity());","}"],[{"start_line":252,"start_column":12,"end_line":252,"end_column":69,"positive":false,"negative":false}]]]}