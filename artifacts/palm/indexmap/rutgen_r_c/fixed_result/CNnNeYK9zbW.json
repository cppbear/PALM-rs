{"function_name":"indexmap::map::map::IndexMap<K, V, S>::get_full_mut","tests":1,"tests_lines":[47],"oracles":1,"oracles_compiled":1,"oracles_compiled_rate":100.0,"tests_compiled":1,"tests_compiled_rate":100.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":9,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[781,782,783,784,785,786,787,789,791],"codes_lines_covered":[[["{","    struct TestEntry {","        key: String,","        value: i32,","    }","","    struct TestIndexMap {","        entries: Vec<TestEntry>,","    }","","    impl TestIndexMap {","        fn new() -> Self {","            Self {","                entries: Vec::new(),","            }","        }","","        fn get_index_of<Q>(&self, key: &Q) -> Option<usize>","        where","            Q: ?Sized + Hash + Equivalent<String>,","        {","            None // Simulates that the key is not found","        }","","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            &mut self.entries","        }","        ","        pub fn get_full_mut<Q>(&mut self, key: &Q) -> Option<(usize, &String, &mut i32)>","        where","            Q: ?Sized + Hash + Equivalent<String>,","        {","            if let Some(i) = self.get_index_of(key) {","                let entry = &mut self.as_entries_mut()[i];","                Some((i, &entry.key, &mut entry.value))","            } else {","                None","            }","        }","    }","","    let mut map = TestIndexMap::new();","    let key_to_test = \"non_existent_key\".to_string();","","    let result = map.get_full_mut(&key_to_test);","    assert!(result.is_none());","}"],[]]],"codes_branches":[{"start_line":785,"start_column":16,"end_line":785,"end_column":23,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestEntry {","        key: String,","        value: i32,","    }","","    struct TestIndexMap {","        entries: Vec<TestEntry>,","    }","","    impl TestIndexMap {","        fn new() -> Self {","            Self {","                entries: Vec::new(),","            }","        }","","        fn get_index_of<Q>(&self, key: &Q) -> Option<usize>","        where","            Q: ?Sized + Hash + Equivalent<String>,","        {","            None // Simulates that the key is not found","        }","","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            &mut self.entries","        }","        ","        pub fn get_full_mut<Q>(&mut self, key: &Q) -> Option<(usize, &String, &mut i32)>","        where","            Q: ?Sized + Hash + Equivalent<String>,","        {","            if let Some(i) = self.get_index_of(key) {","                let entry = &mut self.as_entries_mut()[i];","                Some((i, &entry.key, &mut entry.value))","            } else {","                None","            }","        }","    }","","    let mut map = TestIndexMap::new();","    let key_to_test = \"non_existent_key\".to_string();","","    let result = map.get_full_mut(&key_to_test);","    assert!(result.is_none());","}"],[{"start_line":785,"start_column":16,"end_line":785,"end_column":23,"positive":false,"negative":false}]]]}