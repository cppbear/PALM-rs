{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::get_index_of","tests":4,"tests_lines":[16,15,12,13],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":4,"tests_passed":2,"tests_passed_rate":50.0,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[319,320,321,322,323,324,325],"codes_lines_covered":[[["{","    struct KeyEquivalent(usize);","    impl Equivalent<usize> for KeyEquivalent {","        fn equivalent(&self, other: &usize) -> bool {","            self.0 == *other","        }","    }","","    let mut map: IndexMapCore<usize, &'static str> = IndexMapCore::new();","    map.push_entry(HashValue(1), 1, \"one\");","    map.push_entry(HashValue(2), 2, \"two\");","    map.push_entry(HashValue(3), 3, \"three\");","","    let index = map.get_index_of(HashValue(2), &KeyEquivalent(2));","    assert_eq!(index, Some(1));","}"],[]],[["{","    struct KeyEquivalent(usize);","    impl Equivalent<usize> for KeyEquivalent {","        fn equivalent(&self, other: &usize) -> bool {","            self.0 == *other","        }","    }","","    let mut map: IndexMapCore<usize, &'static str> = IndexMapCore::new();","    map.push_entry(HashValue(1), 1, \"one\");","    map.push_entry(HashValue(2), 2, \"two\");","","    let index = map.get_index_of(HashValue(3), &KeyEquivalent(3));","    assert_eq!(index, None);","}"],[]],[["{","    struct KeyEquivalent(usize);","    impl Equivalent<usize> for KeyEquivalent {","        fn equivalent(&self, other: &usize) -> bool {","            self.0 == *other","        }","    }","","    let map: IndexMapCore<usize, &'static str> = IndexMapCore::new();","    let index = map.get_index_of(HashValue(1), &KeyEquivalent(1));","    assert_eq!(index, None);","}"],[319,320,321,322,323,324,325]],[["{","    struct KeyEquivalent(usize);","    impl Equivalent<usize> for KeyEquivalent {","        fn equivalent(&self, other: &usize) -> bool {","            self.0 == *other","        }","    }","","    let mut map: IndexMapCore<usize, &'static str> = IndexMapCore::new();","    map.push_entry(HashValue(1), 1, \"one\");","    map.push_entry(HashValue(2), 2, \"two\");","    map.split_off(3);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct KeyEquivalent(usize);","    impl Equivalent<usize> for KeyEquivalent {","        fn equivalent(&self, other: &usize) -> bool {","            self.0 == *other","        }","    }","","    let mut map: IndexMapCore<usize, &'static str> = IndexMapCore::new();","    map.push_entry(HashValue(1), 1, \"one\");","    map.push_entry(HashValue(2), 2, \"two\");","    map.push_entry(HashValue(3), 3, \"three\");","","    let index = map.get_index_of(HashValue(2), &KeyEquivalent(2));","    assert_eq!(index, Some(1));","}"],[]],[["{","    struct KeyEquivalent(usize);","    impl Equivalent<usize> for KeyEquivalent {","        fn equivalent(&self, other: &usize) -> bool {","            self.0 == *other","        }","    }","","    let mut map: IndexMapCore<usize, &'static str> = IndexMapCore::new();","    map.push_entry(HashValue(1), 1, \"one\");","    map.push_entry(HashValue(2), 2, \"two\");","","    let index = map.get_index_of(HashValue(3), &KeyEquivalent(3));","    assert_eq!(index, None);","}"],[]],[["{","    struct KeyEquivalent(usize);","    impl Equivalent<usize> for KeyEquivalent {","        fn equivalent(&self, other: &usize) -> bool {","            self.0 == *other","        }","    }","","    let map: IndexMapCore<usize, &'static str> = IndexMapCore::new();","    let index = map.get_index_of(HashValue(1), &KeyEquivalent(1));","    assert_eq!(index, None);","}"],[]],[["{","    struct KeyEquivalent(usize);","    impl Equivalent<usize> for KeyEquivalent {","        fn equivalent(&self, other: &usize) -> bool {","            self.0 == *other","        }","    }","","    let mut map: IndexMapCore<usize, &'static str> = IndexMapCore::new();","    map.push_entry(HashValue(1), 1, \"one\");","    map.push_entry(HashValue(2), 2, \"two\");","    map.split_off(3);","}"],[]]]}