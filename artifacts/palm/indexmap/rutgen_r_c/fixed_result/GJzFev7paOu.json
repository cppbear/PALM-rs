{"function_name":"indexmap::map::map::IndexMap<K, V, S>::drain","tests":5,"tests_lines":[5,8,7,6,11],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[303,304,305,306,307,308],"codes_lines_covered":[[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(0, RandomState::new());","    let drain = map.drain(..);","    assert!(drain.as_slice().is_empty());","}"],[303,304,305,306,307,308]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(3, RandomState::new());","    map.insert(1, 10);","    map.insert(2, 20);","    map.insert(3, 30);","    let drain = map.drain(..);","    assert_eq!(drain.as_slice().len(), 3);","}"],[303,304,305,306,307,308]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(3, RandomState::new());","    map.insert(1, 10);","    map.insert(2, 20);","    map.insert(3, 30);","    let _ = map.drain(2..5); // Start is valid, but end is out of bounds.","}"],[303,304,305,306,307,308]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(3, RandomState::new());","    map.insert(1, 10);","    map.insert(2, 20);","    let _ = map.drain(2..1); // Start is greater than end.","}"],[303,304,305,306,307,308]],[["{","   let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(5, RandomState::new());","   map.insert(1, 10);","   map.insert(2, 20);","   map.insert(3, 30);","   map.insert(4, 40);","   map.insert(5, 50);","   let drain: Vec<_> = map.drain(1..3).collect(); // Drain items at index 1 and 2 into a Vec.","   assert_eq!(drain.len(), 2);","   assert!(map.len() == 3); // Remaining items should be 3.","}"],[303,304,305,306,307,308]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(0, RandomState::new());","    let drain = map.drain(..);","    assert!(drain.as_slice().is_empty());","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(3, RandomState::new());","    map.insert(1, 10);","    map.insert(2, 20);","    map.insert(3, 30);","    let drain = map.drain(..);","    assert_eq!(drain.as_slice().len(), 3);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(3, RandomState::new());","    map.insert(1, 10);","    map.insert(2, 20);","    map.insert(3, 30);","    let _ = map.drain(2..5); // Start is valid, but end is out of bounds.","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(3, RandomState::new());","    map.insert(1, 10);","    map.insert(2, 20);","    let _ = map.drain(2..1); // Start is greater than end.","}"],[]],[["{","   let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(5, RandomState::new());","   map.insert(1, 10);","   map.insert(2, 20);","   map.insert(3, 30);","   map.insert(4, 40);","   map.insert(5, 50);","   let drain: Vec<_> = map.drain(1..3).collect(); // Drain items at index 1 and 2 into a Vec.","   assert_eq!(drain.len(), 2);","   assert!(map.len() == 3); // Remaining items should be 3.","}"],[]]]}