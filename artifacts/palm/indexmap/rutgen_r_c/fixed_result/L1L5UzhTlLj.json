{"function_name":"indexmap::set::set::IndexSet<T, S>::try_reserve","tests":4,"tests_lines":[13,12,13,13],"oracles":4,"oracles_compiled":3,"oracles_compiled_rate":75.0,"tests_compiled":3,"tests_compiled_rate":75.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[300,301,302],"codes_lines_covered":[[["{","   struct TestHasher;","   impl BuildHasher for TestHasher {","       type Hasher = std::collections::hash_map::DefaultHasher; // Changed to a valid hasher type","       fn build_hasher(&self) -> Self::Hasher {","           std::collections::hash_map::DefaultHasher::new() // Use DefaultHasher","       }","   }","","    let mut index_set = IndexSet::<u32, TestHasher>::with_capacity_and_hasher(5, TestHasher);","    let result = index_set.try_reserve(3);","    assert!(result.is_ok());","}"],[300,301,302]],[["{","   struct TestHasher;","   impl BuildHasher for TestHasher {","       type Hasher = std::collections::hash_map::DefaultHasher;","       fn build_hasher(&self) -> Self::Hasher {","           std::collections::hash_map::DefaultHasher::new()","       }","   }","","    let mut index_set = IndexSet::<u32, TestHasher>::with_capacity_and_hasher(2, TestHasher);","    let result = index_set.try_reserve(4);","    assert!(result.is_ok());","}"],[300,301,302]],[["{","   struct TestHasher;","   impl BuildHasher for TestHasher {","       type Hasher = std::collections::hash_map::DefaultHasher;","       fn build_hasher(&self) -> Self::Hasher {","           std::collections::hash_map::DefaultHasher::new()","       }","   }","","    let mut index_set = IndexSet::<u32, TestHasher>::with_capacity_and_hasher(5, TestHasher);","    let result = index_set.try_reserve(0);","    assert!(result.is_ok());","}"],[300,301,302]]],"codes_branches":[],"codes_branches_covered":[[["{","   struct TestHasher;","   impl BuildHasher for TestHasher {","       type Hasher = std::collections::hash_map::DefaultHasher; // Changed to a valid hasher type","       fn build_hasher(&self) -> Self::Hasher {","           std::collections::hash_map::DefaultHasher::new() // Use DefaultHasher","       }","   }","","    let mut index_set = IndexSet::<u32, TestHasher>::with_capacity_and_hasher(5, TestHasher);","    let result = index_set.try_reserve(3);","    assert!(result.is_ok());","}"],[]],[["{","   struct TestHasher;","   impl BuildHasher for TestHasher {","       type Hasher = std::collections::hash_map::DefaultHasher;","       fn build_hasher(&self) -> Self::Hasher {","           std::collections::hash_map::DefaultHasher::new()","       }","   }","","    let mut index_set = IndexSet::<u32, TestHasher>::with_capacity_and_hasher(2, TestHasher);","    let result = index_set.try_reserve(4);","    assert!(result.is_ok());","}"],[]],[["{","   struct TestHasher;","   impl BuildHasher for TestHasher {","       type Hasher = std::collections::hash_map::DefaultHasher;","       fn build_hasher(&self) -> Self::Hasher {","           std::collections::hash_map::DefaultHasher::new()","       }","   }","","    let mut index_set = IndexSet::<u32, TestHasher>::with_capacity_and_hasher(5, TestHasher);","    let result = index_set.try_reserve(0);","    assert!(result.is_ok());","}"],[]]]}