{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::drain","tests":4,"tests_lines":[15,8,8,7],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":8,"lines_covered":8,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[187,188,189,190,191,192,193,194],"codes_lines_covered":[[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   // Manually populating the entries to ensure we have a scenario to drain  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });  ","   index_map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 1 });  ","   index_map.entries.push(Bucket { hash: HashValue(2), key: 2, value: 2 });  "," ","   let drained: Vec<Bucket<usize, usize>> = index_map.drain(1..3).collect();  "," ","   assert_eq!(drained.len(), 2);  ","   assert_eq!(drained[0].key, 1);  ","   assert_eq!(drained[1].key, 2);  ","   assert_eq!(index_map.entries.len(), 1);  ","   assert_eq!(index_map.entries[0].key, 0);  ","}"],[187,188,189,190,191,192,193,194]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });","   index_map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 1 });","   ","   // This should panic as we're trying to access an index out of bounds","   index_map.drain(3..4);","}"],[187,188,189,190,191,192,193,194]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });  ","   index_map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 1 });  ","   ","   // This should panic as we're trying to access an end index out of bounds  ","   index_map.drain(0..0);  ","}"],[187,188,189,190,191,192,193,194]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });","","   // This should panic as the start is greater than the end","   index_map.drain(1..0);","}"],[187,188,189,190,191,192,193,194]]],"codes_branches":[],"codes_branches_covered":[[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   // Manually populating the entries to ensure we have a scenario to drain  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });  ","   index_map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 1 });  ","   index_map.entries.push(Bucket { hash: HashValue(2), key: 2, value: 2 });  "," ","   let drained: Vec<Bucket<usize, usize>> = index_map.drain(1..3).collect();  "," ","   assert_eq!(drained.len(), 2);  ","   assert_eq!(drained[0].key, 1);  ","   assert_eq!(drained[1].key, 2);  ","   assert_eq!(index_map.entries.len(), 1);  ","   assert_eq!(index_map.entries[0].key, 0);  ","}"],[]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });","   index_map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 1 });","   ","   // This should panic as we're trying to access an index out of bounds","   index_map.drain(3..4);","}"],[]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });  ","   index_map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 1 });  ","   ","   // This should panic as we're trying to access an end index out of bounds  ","   index_map.drain(0..0);  ","}"],[]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });","","   // This should panic as the start is greater than the end","   index_map.drain(1..0);","}"],[]]]}