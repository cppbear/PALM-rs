{"function_name":"indexmap::map::map::IndexMap<K, V, S>::insert_before","tests":12,"tests_lines":[17,16,20,12,19,13,13,9,20,31,32,43],"oracles":12,"oracles_compiled":8,"oracles_compiled_rate":66.66666666666666,"tests_compiled":8,"tests_compiled_rate":66.66666666666666,"oracles_run":8,"oracles_passed":8,"oracles_passed_rate":100.0,"tests_run":8,"tests_passed":8,"tests_passed_rate":100.0,"lines":21,"lines_covered":18,"lines_coveraged_rate":85.71428571428571,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[499,500,501,502,503,504,507,508,509,510,511,512,513,514,515,516,517,519,520,521,524],"codes_lines_covered":[[["{","   use std::collections::hash_map::RandomState;","","","    let mut map: IndexMap<char, ()> = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', ());","    map.insert('b', ());","    map.insert('c', ());","","    // Initial length of the map is 3 (containing 'a', 'b', 'c')","    // Inserting before index 2 where 'b' is located","    let (index, old_value) = map.insert_before(2, 'b', ());","    ","    assert_eq!(old_value, Some(())); // Should return the old value of 'b'","    assert_eq!(index, 1); // 'b' should move to index 1","    assert_eq!(map.len(), 3); // The length of the map remains the same","    assert_eq!(map.get_index_of(&'b'), Some(1)); // 'b' is now at index 1","    assert_eq!(map.get_index_of(&'a'), Some(0)); // 'a' is still at index 0","    assert_eq!(map.get_index_of(&'c'), Some(2)); // 'c' moves to index 2","}"],[499,500,501,502,503,507,508,509,510,511,512,513,514,515,516,517,524]],[["{","   use std::collections::hash_map::RandomState;  ","   // use indexmap::IndexMap;  ","","    let mut map: IndexMap<char, ()> = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', ());","    map.insert('b', ());","    map.insert('c', ());","    ","    // Inserting before index 1 where 'b' is located","    let (index, old_value) = map.insert_before(1, 'a', ());","    ","    assert_eq!(old_value, Some(())); // Should return the old value of 'a'","    assert_eq!(index, 0); // 'a' is at index 0, it moves to the same index","    assert_eq!(map.len(), 3); // The length of the map remains the same","    assert_eq!(map.get_index_of(&'a'), Some(0)); // 'a' remains at index 0","    assert_eq!(map.get_index_of(&'b'), Some(1)); // 'b' moves down to index 1","    assert_eq!(map.get_index_of(&'c'), Some(2)); // 'c' is still at index 2","}"],[499,500,501,502,503,507,508,509,510,511,512,513,514,515,516,517,524]],[["{","    let mut map = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', 1);","    map.insert('b', 2);","    map.insert('c', 3);","    ","    // Insert an occupied key at the same index as its current position","    let (index, old_value) = map.insert_before(1, 'b', 20);","    ","    assert_eq!(index, 1);","    assert_eq!(old_value, Some(2)); // Old value for key 'b'","    assert_eq!(map.get(&'b'), Some(&20)); // New value for key 'b'","}"],[499,500,501,502,503,507,508,509,514,515,516,517,524]],[["{","    let mut map = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', 1);","    map.insert('b', 2);","    map.insert('c', 3);","    ","    // Move the occupied key down in the map","    let (index, old_value) = map.insert_before(2, 'a', 10);","    ","    assert_eq!(index, 1); // 'a' moves to index 1","    assert_eq!(old_value, Some(1)); // Old value for key 'a'","    assert_eq!(map.get(&'a'), Some(&10)); // New value for key 'a'","}"],[499,500,501,502,503,507,508,509,510,511,512,513,514,515,516,517,524]],[["{","    let mut map = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', 1);","    map.insert('b', 2);","    map.insert('c', 3);","    ","    // Attempt to insert with index out of bounds","    let _ = map.insert_before(4, 'd', 4);","}"],[499,500,501,502,503,504]],[["{","    let mut map = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', 1);","    map.insert('b', 2);","    map.insert('c', 3);","    ","    // Insert key 'b' at its current position, which should not change its position","    let (index, old_value) = map.insert_before(1, 'b', 20);","    ","    assert_eq!(index, 1);","    assert_eq!(old_value, Some(2)); // Old value for key 'b'","    assert_eq!(map.get(&'b'), Some(&20)); // New value for key 'b'","    ","    // Inserting 'c' before 'b' should adjust its position","    let (index2, old_value2) = map.insert_before(1, 'c', 30);","    ","    assert_eq!(index2, 1); // 'c' moves to index 1","    assert_eq!(old_value2, Some(3)); // Old value for key 'c'","    assert_eq!(map.get(&'c'), Some(&30)); // New value for key 'c'","}"],[499,500,501,502,503,507,508,509,514,515,516,517,524]],[["{","    struct TestMap {","        entries: Vec<(char, ())>,","    }","","    impl TestMap {","        fn new() -> Self {","            TestMap { entries: vec![] }","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn insert_before(&mut self, index: usize, key: char, value: ()) -> (usize, Option<()>) {","            let len = self.len();","            assert!(","                index <= len,","                \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"","            );","            self.entries.insert(index, (key, value));","            (index, None)","        }","    }","","    let mut test_map = TestMap::new();","    test_map.insert_before(1, 'a', ()); // This should not panic as the map is empty","","    // Now this will cause panic since the index is out of bounds (index 2 for length 1)","    test_map.insert_before(2, 'b', ());","}"],[]],[["{","    struct TestMap {","        entries: Vec<(char, ())>,","    }","","    impl TestMap {","        fn new() -> Self {","            TestMap { entries: vec![] }","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn insert_before(&mut self, index: usize, key: char, value: ()) -> (usize, Option<()>) {","            let len = self.len();","            assert!(","                index <= len,","                \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"","            );","            self.entries.insert(index, (key, value));","            (index, None)","        }","    }","","    let mut test_map = TestMap::new();","    test_map.insert_before(0, 'a', ());","    let (index, old_value) = test_map.insert_before(1, 'b', ());","    ","    assert_eq!(index, 1);","    assert_eq!(old_value, None);","}"],[]]],"codes_branches":[{"start_line":509,"start_column":20,"end_line":509,"end_column":41,"positive":true,"negative":true}],"codes_branches_covered":[[["{","   use std::collections::hash_map::RandomState;","","","    let mut map: IndexMap<char, ()> = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', ());","    map.insert('b', ());","    map.insert('c', ());","","    // Initial length of the map is 3 (containing 'a', 'b', 'c')","    // Inserting before index 2 where 'b' is located","    let (index, old_value) = map.insert_before(2, 'b', ());","    ","    assert_eq!(old_value, Some(())); // Should return the old value of 'b'","    assert_eq!(index, 1); // 'b' should move to index 1","    assert_eq!(map.len(), 3); // The length of the map remains the same","    assert_eq!(map.get_index_of(&'b'), Some(1)); // 'b' is now at index 1","    assert_eq!(map.get_index_of(&'a'), Some(0)); // 'a' is still at index 0","    assert_eq!(map.get_index_of(&'c'), Some(2)); // 'c' moves to index 2","}"],[{"start_line":509,"start_column":20,"end_line":509,"end_column":41,"positive":true,"negative":false}]],[["{","   use std::collections::hash_map::RandomState;  ","   // use indexmap::IndexMap;  ","","    let mut map: IndexMap<char, ()> = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', ());","    map.insert('b', ());","    map.insert('c', ());","    ","    // Inserting before index 1 where 'b' is located","    let (index, old_value) = map.insert_before(1, 'a', ());","    ","    assert_eq!(old_value, Some(())); // Should return the old value of 'a'","    assert_eq!(index, 0); // 'a' is at index 0, it moves to the same index","    assert_eq!(map.len(), 3); // The length of the map remains the same","    assert_eq!(map.get_index_of(&'a'), Some(0)); // 'a' remains at index 0","    assert_eq!(map.get_index_of(&'b'), Some(1)); // 'b' moves down to index 1","    assert_eq!(map.get_index_of(&'c'), Some(2)); // 'c' is still at index 2","}"],[{"start_line":509,"start_column":20,"end_line":509,"end_column":41,"positive":true,"negative":false}]],[["{","    let mut map = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', 1);","    map.insert('b', 2);","    map.insert('c', 3);","    ","    // Insert an occupied key at the same index as its current position","    let (index, old_value) = map.insert_before(1, 'b', 20);","    ","    assert_eq!(index, 1);","    assert_eq!(old_value, Some(2)); // Old value for key 'b'","    assert_eq!(map.get(&'b'), Some(&20)); // New value for key 'b'","}"],[{"start_line":509,"start_column":20,"end_line":509,"end_column":41,"positive":false,"negative":true}]],[["{","    let mut map = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', 1);","    map.insert('b', 2);","    map.insert('c', 3);","    ","    // Move the occupied key down in the map","    let (index, old_value) = map.insert_before(2, 'a', 10);","    ","    assert_eq!(index, 1); // 'a' moves to index 1","    assert_eq!(old_value, Some(1)); // Old value for key 'a'","    assert_eq!(map.get(&'a'), Some(&10)); // New value for key 'a'","}"],[{"start_line":509,"start_column":20,"end_line":509,"end_column":41,"positive":true,"negative":false}]],[["{","    let mut map = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', 1);","    map.insert('b', 2);","    map.insert('c', 3);","    ","    // Attempt to insert with index out of bounds","    let _ = map.insert_before(4, 'd', 4);","}"],[{"start_line":509,"start_column":20,"end_line":509,"end_column":41,"positive":false,"negative":false}]],[["{","    let mut map = IndexMap::with_capacity_and_hasher(5, RandomState::new());","    map.insert('a', 1);","    map.insert('b', 2);","    map.insert('c', 3);","    ","    // Insert key 'b' at its current position, which should not change its position","    let (index, old_value) = map.insert_before(1, 'b', 20);","    ","    assert_eq!(index, 1);","    assert_eq!(old_value, Some(2)); // Old value for key 'b'","    assert_eq!(map.get(&'b'), Some(&20)); // New value for key 'b'","    ","    // Inserting 'c' before 'b' should adjust its position","    let (index2, old_value2) = map.insert_before(1, 'c', 30);","    ","    assert_eq!(index2, 1); // 'c' moves to index 1","    assert_eq!(old_value2, Some(3)); // Old value for key 'c'","    assert_eq!(map.get(&'c'), Some(&30)); // New value for key 'c'","}"],[{"start_line":509,"start_column":20,"end_line":509,"end_column":41,"positive":false,"negative":true}]],[["{","    struct TestMap {","        entries: Vec<(char, ())>,","    }","","    impl TestMap {","        fn new() -> Self {","            TestMap { entries: vec![] }","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn insert_before(&mut self, index: usize, key: char, value: ()) -> (usize, Option<()>) {","            let len = self.len();","            assert!(","                index <= len,","                \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"","            );","            self.entries.insert(index, (key, value));","            (index, None)","        }","    }","","    let mut test_map = TestMap::new();","    test_map.insert_before(1, 'a', ()); // This should not panic as the map is empty","","    // Now this will cause panic since the index is out of bounds (index 2 for length 1)","    test_map.insert_before(2, 'b', ());","}"],[{"start_line":509,"start_column":20,"end_line":509,"end_column":41,"positive":false,"negative":false}]],[["{","    struct TestMap {","        entries: Vec<(char, ())>,","    }","","    impl TestMap {","        fn new() -> Self {","            TestMap { entries: vec![] }","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn insert_before(&mut self, index: usize, key: char, value: ()) -> (usize, Option<()>) {","            let len = self.len();","            assert!(","                index <= len,","                \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"","            );","            self.entries.insert(index, (key, value));","            (index, None)","        }","    }","","    let mut test_map = TestMap::new();","    test_map.insert_before(0, 'a', ());","    let (index, old_value) = test_map.insert_before(1, 'b', ());","    ","    assert_eq!(index, 1);","    assert_eq!(old_value, None);","}"],[{"start_line":509,"start_column":20,"end_line":509,"end_column":41,"positive":false,"negative":false}]]]}