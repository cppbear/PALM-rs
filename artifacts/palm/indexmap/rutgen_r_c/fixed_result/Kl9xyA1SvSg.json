{"function_name":"indexmap::set::set::IndexSet<T, S>::move_index","tests":5,"tests_lines":[25,24,19,19,19],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1059,1060,1061],"codes_lines_covered":[[["{","    // Helper struct to mimic the functionality without external dependencies","    struct TestIndexSet {","        values: Vec<i32>,","    }","    ","    impl TestIndexSet {","        fn new() -> Self {","            TestIndexSet { values: vec![1, 2, 3, 4, 5] }","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            let value = self.values.remove(from);","            self.values.insert(to, value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.values","        }","    }","","    let mut set = TestIndexSet::new();","    set.move_index(2, 0);","    assert_eq!(set.as_slice(), &[3, 1, 2, 4, 5]);","}"],[]],[["{","    struct TestIndexSet {","        values: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new() -> Self {","            TestIndexSet { values: vec![1, 2, 3, 4, 5] }","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            let value = self.values.remove(from);","            self.values.insert(to, value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.values","        }","    }","","    let mut set = TestIndexSet::new();","    set.move_index(0, 3);","    assert_eq!(set.as_slice(), &[2, 3, 4, 1, 5]);","}"],[]],[["{","    struct TestIndexSet {","        values: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new() -> Self {","            TestIndexSet { values: vec![1, 2, 3, 4, 5] }","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            let value = self.values.remove(from);","            self.values.insert(to, value);","        }","    }","","    let mut set = TestIndexSet::new();","    set.move_index(5, 0); // Out of bounds access","}"],[]],[["{","    struct TestIndexSet {","        values: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new() -> Self {","            TestIndexSet { values: vec![1, 2, 3, 4, 5] }","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            let value = self.values.remove(from);","            self.values.insert(to, value);","        }","    }","","    let mut set = TestIndexSet::new();","    set.move_index(1, 10); // Out of bounds access","}"],[]],[["{","    struct TestIndexSet {","        values: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new() -> Self {","            TestIndexSet { values: vec![1, 2, 3, 4, 5] }","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            let value = self.values.remove(from);","            self.values.insert(to, value);","        }","    }","","    let mut set = TestIndexSet::new();","    set.move_index(10, 10); // Both indices out of bounds","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    // Helper struct to mimic the functionality without external dependencies","    struct TestIndexSet {","        values: Vec<i32>,","    }","    ","    impl TestIndexSet {","        fn new() -> Self {","            TestIndexSet { values: vec![1, 2, 3, 4, 5] }","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            let value = self.values.remove(from);","            self.values.insert(to, value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.values","        }","    }","","    let mut set = TestIndexSet::new();","    set.move_index(2, 0);","    assert_eq!(set.as_slice(), &[3, 1, 2, 4, 5]);","}"],[]],[["{","    struct TestIndexSet {","        values: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new() -> Self {","            TestIndexSet { values: vec![1, 2, 3, 4, 5] }","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            let value = self.values.remove(from);","            self.values.insert(to, value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.values","        }","    }","","    let mut set = TestIndexSet::new();","    set.move_index(0, 3);","    assert_eq!(set.as_slice(), &[2, 3, 4, 1, 5]);","}"],[]],[["{","    struct TestIndexSet {","        values: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new() -> Self {","            TestIndexSet { values: vec![1, 2, 3, 4, 5] }","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            let value = self.values.remove(from);","            self.values.insert(to, value);","        }","    }","","    let mut set = TestIndexSet::new();","    set.move_index(5, 0); // Out of bounds access","}"],[]],[["{","    struct TestIndexSet {","        values: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new() -> Self {","            TestIndexSet { values: vec![1, 2, 3, 4, 5] }","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            let value = self.values.remove(from);","            self.values.insert(to, value);","        }","    }","","    let mut set = TestIndexSet::new();","    set.move_index(1, 10); // Out of bounds access","}"],[]],[["{","    struct TestIndexSet {","        values: Vec<i32>,","    }","","    impl TestIndexSet {","        fn new() -> Self {","            TestIndexSet { values: vec![1, 2, 3, 4, 5] }","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            let value = self.values.remove(from);","            self.values.insert(to, value);","        }","    }","","    let mut set = TestIndexSet::new();","    set.move_index(10, 10); // Both indices out of bounds","}"],[]]]}