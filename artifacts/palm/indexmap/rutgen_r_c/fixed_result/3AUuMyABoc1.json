{"function_name":"indexmap::set::set::IndexSet<T, S>::sort_unstable","tests":6,"tests_lines":[23,28,30,30,30,30],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":6,"tests_compiled_rate":100.0,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[865,866,867,868,869,870],"codes_lines_covered":[[["{","    struct TestSet {","        map: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { map: vec![] }","        }","","        fn sort_unstable(&mut self) {","            self.map.sort_unstable();","        }","","        fn as_slice(&self) -> &[i32] {","            &self.map","        }","    }","","    let mut set = TestSet::new();","    set.sort_unstable();","    assert!(set.as_slice().is_empty());","}"],[]],[["{","    struct TestSet {","        map: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { map: vec![] }","        }","","        fn sort_unstable(&mut self) {","            self.map.sort_unstable();","        }","","        fn push(&mut self, value: i32) {","            self.map.push(value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.map","        }","    }","","    let mut set = TestSet::new();","    set.push(5);","    set.sort_unstable();","    assert_eq!(set.as_slice(), &[5]);","}"],[]],[["{","    struct TestSet {","        map: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { map: vec![] }","        }","","        fn sort_unstable(&mut self) {","            self.map.sort_unstable();","        }","","        fn push(&mut self, value: i32) {","            self.map.push(value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.map","        }","    }","","    let mut set = TestSet::new();","    set.push(3);","    set.push(1);","    set.push(2);","    set.sort_unstable();","    assert_eq!(set.as_slice(), &[1, 2, 3]);","}"],[]],[["{","    struct TestSet {","        map: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { map: vec![] }","        }","","        fn sort_unstable(&mut self) {","            self.map.sort_unstable();","        }","","        fn push(&mut self, value: i32) {","            self.map.push(value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.map","        }","    }","","    let mut set = TestSet::new();","    set.push(2);","    set.push(3);","    set.push(2);","    set.sort_unstable();","    assert_eq!(set.as_slice(), &[2, 2, 3]);","}"],[]],[["{","    struct TestSet {","        map: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { map: vec![] }","        }","","        fn sort_unstable(&mut self) {","            self.map.sort_unstable();","        }","","        fn push(&mut self, value: i32) {","            self.map.push(value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.map","        }","    }","","    let mut set = TestSet::new();","    set.push(-1);","    set.push(-3);","    set.push(-2);","    set.sort_unstable();","    assert_eq!(set.as_slice(), &[-3, -2, -1]);","}"],[]],[["{","   struct TestSet {","       map: Vec<f32>,","   }","","   impl TestSet {","       fn new() -> Self {","           TestSet { map: vec![] }","       }","       ","       fn sort_unstable(&mut self) {","           self.map.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());","       }","       ","       fn push(&mut self, value: f32) {","           self.map.push(value);","       }","       ","       fn as_slice(&self) -> &[f32] {","           &self.map","       }","   }","","   let mut set = TestSet::new();","   set.push(3.1);","   set.push(2.2);","   set.push(1.3);","   set.sort_unstable();","   assert_eq!(set.as_slice(), &[1.3, 2.2, 3.1]);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestSet {","        map: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { map: vec![] }","        }","","        fn sort_unstable(&mut self) {","            self.map.sort_unstable();","        }","","        fn as_slice(&self) -> &[i32] {","            &self.map","        }","    }","","    let mut set = TestSet::new();","    set.sort_unstable();","    assert!(set.as_slice().is_empty());","}"],[]],[["{","    struct TestSet {","        map: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { map: vec![] }","        }","","        fn sort_unstable(&mut self) {","            self.map.sort_unstable();","        }","","        fn push(&mut self, value: i32) {","            self.map.push(value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.map","        }","    }","","    let mut set = TestSet::new();","    set.push(5);","    set.sort_unstable();","    assert_eq!(set.as_slice(), &[5]);","}"],[]],[["{","    struct TestSet {","        map: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { map: vec![] }","        }","","        fn sort_unstable(&mut self) {","            self.map.sort_unstable();","        }","","        fn push(&mut self, value: i32) {","            self.map.push(value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.map","        }","    }","","    let mut set = TestSet::new();","    set.push(3);","    set.push(1);","    set.push(2);","    set.sort_unstable();","    assert_eq!(set.as_slice(), &[1, 2, 3]);","}"],[]],[["{","    struct TestSet {","        map: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { map: vec![] }","        }","","        fn sort_unstable(&mut self) {","            self.map.sort_unstable();","        }","","        fn push(&mut self, value: i32) {","            self.map.push(value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.map","        }","    }","","    let mut set = TestSet::new();","    set.push(2);","    set.push(3);","    set.push(2);","    set.sort_unstable();","    assert_eq!(set.as_slice(), &[2, 2, 3]);","}"],[]],[["{","    struct TestSet {","        map: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { map: vec![] }","        }","","        fn sort_unstable(&mut self) {","            self.map.sort_unstable();","        }","","        fn push(&mut self, value: i32) {","            self.map.push(value);","        }","","        fn as_slice(&self) -> &[i32] {","            &self.map","        }","    }","","    let mut set = TestSet::new();","    set.push(-1);","    set.push(-3);","    set.push(-2);","    set.sort_unstable();","    assert_eq!(set.as_slice(), &[-3, -2, -1]);","}"],[]],[["{","   struct TestSet {","       map: Vec<f32>,","   }","","   impl TestSet {","       fn new() -> Self {","           TestSet { map: vec![] }","       }","       ","       fn sort_unstable(&mut self) {","           self.map.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());","       }","       ","       fn push(&mut self, value: f32) {","           self.map.push(value);","       }","       ","       fn as_slice(&self) -> &[f32] {","           &self.map","       }","   }","","   let mut set = TestSet::new();","   set.push(3.1);","   set.push(2.2);","   set.push(1.3);","   set.sort_unstable();","   assert_eq!(set.as_slice(), &[1.3, 2.2, 3.1]);","}"],[]]]}