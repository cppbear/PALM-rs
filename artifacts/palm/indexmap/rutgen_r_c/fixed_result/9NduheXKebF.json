{"function_name":"indexmap::set::mutable::<set::IndexSet<T, S> as set::mutable::MutableValues>::retain2","tests":4,"tests_lines":[15,20,19,19],"oracles":4,"oracles_compiled":1,"oracles_compiled_rate":25.0,"tests_compiled":1,"tests_compiled_rate":25.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[74,75,76,77,78,79],"codes_lines_covered":[[["{","  use crate::IndexMap;  ","  struct DummyHasher;  ","  impl BuildHasher for DummyHasher {  ","     type Hasher = std::collections::hash_map::DefaultHasher;  ","     fn build_hasher(&self) -> Self::Hasher {  ","         std::collections::hash_map::DefaultHasher::new()  ","     }  ","  }  ","  let mut index_set: IndexSet<i32, DummyHasher> = IndexSet { map: IndexMap::with_hasher(DummyHasher) };  "," ","   // Assuming a way to initialize values in IndexSet  ","   index_set.insert(1);  ","   index_set.insert(-1);  ","   index_set.insert(2);  "," ","   index_set.retain2(|value| *value > 0);  ","   ","   assert_eq!(index_set.map.core.len(), 2); // Expect two positive values  ","}"],[74,75,76,77,78,79]]],"codes_branches":[],"codes_branches_covered":[[["{","  use crate::IndexMap;  ","  struct DummyHasher;  ","  impl BuildHasher for DummyHasher {  ","     type Hasher = std::collections::hash_map::DefaultHasher;  ","     fn build_hasher(&self) -> Self::Hasher {  ","         std::collections::hash_map::DefaultHasher::new()  ","     }  ","  }  ","  let mut index_set: IndexSet<i32, DummyHasher> = IndexSet { map: IndexMap::with_hasher(DummyHasher) };  "," ","   // Assuming a way to initialize values in IndexSet  ","   index_set.insert(1);  ","   index_set.insert(-1);  ","   index_set.insert(2);  "," ","   index_set.retain2(|value| *value > 0);  ","   ","   assert_eq!(index_set.map.core.len(), 2); // Expect two positive values  ","}"],[]]]}