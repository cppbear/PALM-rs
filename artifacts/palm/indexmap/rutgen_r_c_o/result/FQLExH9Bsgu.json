{"function_name":"indexmap::map::map::IndexMap<K, V, S>::as_mut_slice","tests":26,"tests_lines":[8,8,9,9,9,11,11,11,11,11,11,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13],"oracles":5,"oracles_compiled":4,"oracles_compiled_rate":80.0,"tests_compiled":23,"tests_compiled_rate":88.46153846153845,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":23,"tests_passed":16,"tests_passed_rate":69.56521739130434,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1184,1185,1186],"codes_lines_covered":[[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let slice = map.as_mut_slice();","    assert!(slice.entries.len() > 0);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].key, 1);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].value, 10);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    assert!(_slice.entries.len() == 2);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    assert!(_slice.entries[0].key == 1);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    assert!(_slice.entries[0].value == 10);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    assert!(_slice.entries[1].key == 2);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    assert!(_slice.entries[1].value == 20);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert!(!slice.entries.is_empty());","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries.len(), 1024);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].key, 0);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].value, 0);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[1].key, 1);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[1].value, 10);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[1023].key, 1023);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[1023].value, 10230);","}"],[1184,1185,1186]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries.len(), 1_000_000);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].key, 0);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[999_999].key, 999_999);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].value.len(), 10);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[999_999].value.len(), 10);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert!(slice.entries[0].value[0] == 0);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert!(slice.entries[999_999].value[0] == 999_999);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let slice = map.as_mut_slice();","    assert!(slice.entries.len() > 0);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].key, 1);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].value, 10);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    assert!(_slice.entries.len() == 2);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    assert!(_slice.entries[0].key == 1);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    assert!(_slice.entries[0].value == 10);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    assert!(_slice.entries[1].key == 2);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let _slice = map.as_mut_slice();","    assert!(_slice.entries[1].value == 20);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert!(!slice.entries.is_empty());","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries.len(), 1024);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].key, 0);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].value, 0);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[1].key, 1);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[1].value, 10);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[1023].key, 1023);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","        map.insert(i, i * 10);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity(1024);","    for i in 0..1024 {","    map.insert(i, i * 10);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[1023].value, 10230);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries.len(), 1_000_000);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].key, 0);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[999_999].key, 999_999);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[0].value.len(), 10);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert_eq!(slice.entries[999_999].value.len(), 10);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert!(slice.entries[0].value[0] == 0);","}"],[]],[["{","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","        map.insert(i, vec![i; 10]);","    }","    let _slice = map.as_mut_slice();","    let mut map: IndexMap<i32, Vec<i32>, RandomState> = IndexMap::new();","    for i in 0..1_000_000 {","    map.insert(i, vec![i; 10]);","    }","    let slice = map.as_mut_slice();","    assert!(slice.entries[999_999].value[0] == 999_999);","}"],[]]]}