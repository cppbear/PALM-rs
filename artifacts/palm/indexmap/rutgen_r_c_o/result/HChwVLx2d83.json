{"function_name":"indexmap::map::iter::map::iter::Drain<'a, K, V>::as_slice","tests":21,"tests_lines":[9,9,9,9,9,9,17,17,17,17,17,17,17,9,9,9,9,9,9,9,9],"oracles":5,"oracles_compiled":1,"oracles_compiled_rate":20.0,"tests_compiled":2,"tests_compiled_rate":9.523809523809524,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[294,295,296],"codes_lines_covered":[[["{","    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();","    let drain = Drain::new(vec.drain(..));","    let _slice = drain.as_slice();","    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();","    let drain = Drain::new(vec.drain(..));","    let slice = drain.as_slice();","    assert!(slice.entries.is_empty());","}"],[294,295,296]],[["{","    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();","    let drain = Drain::new(vec.drain(..));","    let _slice = drain.as_slice();","    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();","    let drain = Drain::new(vec.drain(..));","    let slice = drain.as_slice();","    assert!(std::ptr::eq(slice.entries.as_ptr(), drain.iter.as_slice().as_ptr()));","}"],[294,295,296]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();","    let drain = Drain::new(vec.drain(..));","    let _slice = drain.as_slice();","    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();","    let drain = Drain::new(vec.drain(..));","    let slice = drain.as_slice();","    assert!(slice.entries.is_empty());","}"],[]],[["{","    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();","    let drain = Drain::new(vec.drain(..));","    let _slice = drain.as_slice();","    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();","    let drain = Drain::new(vec.drain(..));","    let slice = drain.as_slice();","    assert!(std::ptr::eq(slice.entries.as_ptr(), drain.iter.as_slice().as_ptr()));","}"],[]]]}