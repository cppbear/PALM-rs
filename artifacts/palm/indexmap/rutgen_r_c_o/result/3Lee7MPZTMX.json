{"function_name":"indexmap::set::set::IndexSet<T, S>::shift_remove_full","tests":32,"tests_lines":[13,13,13,13,13,11,6,8,8,10,10,13,13,13,17,17,17,17,17,17,10,10,10,10,10,9,9,25,26,26,26,26],"oracles":7,"oracles_compiled":7,"oracles_compiled_rate":100.0,"tests_compiled":32,"tests_compiled_rate":100.0,"oracles_run":7,"oracles_passed":7,"oracles_passed_rate":100.0,"tests_run":32,"tests_passed":29,"tests_passed_rate":90.625,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[792,793,794,795,796,797],"codes_lines_covered":[[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    assert_eq!(result, Some((1, 20)));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    assert_eq!(set.contains(&20), false);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    assert_eq!(set.get_index_of(&30), Some(1));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    assert_eq!(set.get_index_of(&10), Some(0));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    assert_eq!(set.get_index_of(&20), None);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    let result = set.shift_remove_full(&30);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    let result = set.shift_remove_full(&30);","    assert_eq!(result, None);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    assert_eq!(result, None);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    assert_eq!(result, Some((0, 10)));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    assert_eq!(set.contains(&10), false);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    set.insert(20);","    let result = set.shift_remove_full(&20);","    assert_eq!(result, Some((0, 20)));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    set.insert(20);","    let result = set.shift_remove_full(&20);","    assert_eq!(set.contains(&20), false);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    set.insert(20);","    let result = set.shift_remove_full(&20);","    set.insert(30);","    set.insert(40);","    let result = set.shift_remove_full(&30);","    assert_eq!(result, Some((0, 30)));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    set.insert(20);","    let result = set.shift_remove_full(&20);","    set.insert(30);","    set.insert(40);","    let result = set.shift_remove_full(&30);","    assert_eq!(set.contains(&30), false);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    set.insert(20);","    let result = set.shift_remove_full(&20);","    set.insert(30);","    set.insert(40);","    let result = set.shift_remove_full(&30);","    assert_eq!(set.get_index_of(&40), Some(0));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert_eq!(result1, Some((0, 10)));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert_eq!(result2, Some((1, 30)));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert_eq!(result3, Some((0, 20)));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert!(set.contains(&10) == false);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert!(set.contains(&30) == false);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert!(set.contains(&20) == false);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    let result = set.shift_remove_full(&1);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    assert_eq!(result, Some((0, 1)));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    let result = set.shift_remove_full(&1);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    assert_eq!(set.contains(&1), false);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    let result = set.shift_remove_full(&1);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    assert_eq!(set.contains(&2), true);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    let result = set.shift_remove_full(&1);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    assert_eq!(set.get_index_of(&2), Some(0));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    let result = set.shift_remove_full(&1);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    assert_eq!(set.get_index_of(&1), None);","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(50);","    let result = set.shift_remove_full(&50);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(50);","    let result = set.shift_remove_full(&50);","    assert_eq!(result, Some((0, 50)));","}"],[792,793,794,795,796,797]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(50);","    let result = set.shift_remove_full(&50);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(50);","    let result = set.shift_remove_full(&50);","    assert_eq!(set.contains(&50), false);","}"],[792,793,794,795,796,797]],[["{","    struct MyStruct {","        id: i32,","    }","    impl Hash for MyStruct {","        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","            self.id.hash(state);","        }","    }","    impl PartialEq for MyStruct {","        fn eq(&self, other: &Self) -> bool {","            self.id == other.id","        }","    }","    impl Eq for MyStruct {}","    ","    let mut set: IndexSet<MyStruct, RandomState> = IndexSet { map: IndexMap::new() };","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    assert!(result.is_some());","}"],[792,793,794,795,796,797]],[["{","    struct MyStruct {","        id: i32,","    }","    impl Hash for MyStruct {","        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","            self.id.hash(state);","        }","    }","    impl PartialEq for MyStruct {","        fn eq(&self, other: &Self) -> bool {","            self.id == other.id","        }","    }","    impl Eq for MyStruct {}","    ","    let mut set: IndexSet<MyStruct, RandomState> = IndexSet { map: IndexMap::new() };","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let (index, removed_value) = result.unwrap();","    assert_eq!(index, 0);","}"],[792,793,794,795,796,797]],[["{","    struct MyStruct {","        id: i32,","    }","    impl Hash for MyStruct {","        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","            self.id.hash(state);","        }","    }","    impl PartialEq for MyStruct {","        fn eq(&self, other: &Self) -> bool {","            self.id == other.id","        }","    }","    impl Eq for MyStruct {}","    ","    let mut set: IndexSet<MyStruct, RandomState> = IndexSet { map: IndexMap::new() };","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let (index, removed_value) = result.unwrap();","    assert_eq!(removed_value.id, 1);","}"],[792,793,794,795,796,797]],[["{","    struct MyStruct {","        id: i32,","    }","    impl Hash for MyStruct {","        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","            self.id.hash(state);","        }","    }","    impl PartialEq for MyStruct {","        fn eq(&self, other: &Self) -> bool {","            self.id == other.id","        }","    }","    impl Eq for MyStruct {}","    ","    let mut set: IndexSet<MyStruct, RandomState> = IndexSet { map: IndexMap::new() };","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let (index, removed_value) = result.unwrap();","    assert!(!set.contains(&MyStruct { id: 1 }));","}"],[792,793,794,795,796,797]],[["{","    struct MyStruct {","        id: i32,","    }","    impl Hash for MyStruct {","        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","            self.id.hash(state);","        }","    }","    impl PartialEq for MyStruct {","        fn eq(&self, other: &Self) -> bool {","            self.id == other.id","        }","    }","    impl Eq for MyStruct {}","    ","    let mut set: IndexSet<MyStruct, RandomState> = IndexSet { map: IndexMap::new() };","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let (index, removed_value) = result.unwrap();","    assert_eq!(set.len(), 0);","}"],[792,793,794,795,796,797]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    assert_eq!(result, Some((1, 20)));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    assert_eq!(set.contains(&20), false);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    assert_eq!(set.get_index_of(&30), Some(1));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    assert_eq!(set.get_index_of(&10), Some(0));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result = set.shift_remove_full(&20);","    assert_eq!(set.get_index_of(&20), None);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    let result = set.shift_remove_full(&30);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    let result = set.shift_remove_full(&30);","    assert_eq!(result, None);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    assert_eq!(result, None);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    assert_eq!(result, Some((0, 10)));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    assert_eq!(set.contains(&10), false);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    set.insert(20);","    let result = set.shift_remove_full(&20);","    assert_eq!(result, Some((0, 20)));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    set.insert(20);","    let result = set.shift_remove_full(&20);","    assert_eq!(set.contains(&20), false);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    set.insert(20);","    let result = set.shift_remove_full(&20);","    set.insert(30);","    set.insert(40);","    let result = set.shift_remove_full(&30);","    assert_eq!(result, Some((0, 30)));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    set.insert(20);","    let result = set.shift_remove_full(&20);","    set.insert(30);","    set.insert(40);","    let result = set.shift_remove_full(&30);","    assert_eq!(set.contains(&30), false);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    let result = set.shift_remove_full(&10);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    let result = set.shift_remove_full(&10);","    set.insert(20);","    let result = set.shift_remove_full(&20);","    set.insert(30);","    set.insert(40);","    let result = set.shift_remove_full(&30);","    assert_eq!(set.get_index_of(&40), Some(0));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert_eq!(result1, Some((0, 10)));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert_eq!(result2, Some((1, 30)));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert_eq!(result3, Some((0, 20)));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert!(set.contains(&10) == false);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert!(set.contains(&30) == false);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let _result1 = set.shift_remove_full(&10);","    let _result2 = set.shift_remove_full(&30);","    let _result3 = set.shift_remove_full(&20);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(10);","    set.insert(20);","    set.insert(30);","    let result1 = set.shift_remove_full(&10);","    let result2 = set.shift_remove_full(&30);","    let result3 = set.shift_remove_full(&20);","    assert!(set.contains(&20) == false);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    let result = set.shift_remove_full(&1);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    assert_eq!(result, Some((0, 1)));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    let result = set.shift_remove_full(&1);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    assert_eq!(set.contains(&1), false);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    let result = set.shift_remove_full(&1);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    assert_eq!(set.contains(&2), true);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    let result = set.shift_remove_full(&1);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    assert_eq!(set.get_index_of(&2), Some(0));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    let result = set.shift_remove_full(&1);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(1);","    set.insert(2);","    assert_eq!(set.get_index_of(&1), None);","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(50);","    let result = set.shift_remove_full(&50);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(50);","    let result = set.shift_remove_full(&50);","    assert_eq!(result, Some((0, 50)));","}"],[]],[["{","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(50);","    let result = set.shift_remove_full(&50);","    let mut set: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };","    set.insert(50);","    let result = set.shift_remove_full(&50);","    assert_eq!(set.contains(&50), false);","}"],[]],[["{","    struct MyStruct {","        id: i32,","    }","    impl Hash for MyStruct {","        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","            self.id.hash(state);","        }","    }","    impl PartialEq for MyStruct {","        fn eq(&self, other: &Self) -> bool {","            self.id == other.id","        }","    }","    impl Eq for MyStruct {}","    ","    let mut set: IndexSet<MyStruct, RandomState> = IndexSet { map: IndexMap::new() };","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    assert!(result.is_some());","}"],[]],[["{","    struct MyStruct {","        id: i32,","    }","    impl Hash for MyStruct {","        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","            self.id.hash(state);","        }","    }","    impl PartialEq for MyStruct {","        fn eq(&self, other: &Self) -> bool {","            self.id == other.id","        }","    }","    impl Eq for MyStruct {}","    ","    let mut set: IndexSet<MyStruct, RandomState> = IndexSet { map: IndexMap::new() };","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let (index, removed_value) = result.unwrap();","    assert_eq!(index, 0);","}"],[]],[["{","    struct MyStruct {","        id: i32,","    }","    impl Hash for MyStruct {","        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","            self.id.hash(state);","        }","    }","    impl PartialEq for MyStruct {","        fn eq(&self, other: &Self) -> bool {","            self.id == other.id","        }","    }","    impl Eq for MyStruct {}","    ","    let mut set: IndexSet<MyStruct, RandomState> = IndexSet { map: IndexMap::new() };","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let (index, removed_value) = result.unwrap();","    assert_eq!(removed_value.id, 1);","}"],[]],[["{","    struct MyStruct {","        id: i32,","    }","    impl Hash for MyStruct {","        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","            self.id.hash(state);","        }","    }","    impl PartialEq for MyStruct {","        fn eq(&self, other: &Self) -> bool {","            self.id == other.id","        }","    }","    impl Eq for MyStruct {}","    ","    let mut set: IndexSet<MyStruct, RandomState> = IndexSet { map: IndexMap::new() };","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let (index, removed_value) = result.unwrap();","    assert!(!set.contains(&MyStruct { id: 1 }));","}"],[]],[["{","    struct MyStruct {","        id: i32,","    }","    impl Hash for MyStruct {","        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","            self.id.hash(state);","        }","    }","    impl PartialEq for MyStruct {","        fn eq(&self, other: &Self) -> bool {","            self.id == other.id","        }","    }","    impl Eq for MyStruct {}","    ","    let mut set: IndexSet<MyStruct, RandomState> = IndexSet { map: IndexMap::new() };","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let item = MyStruct { id: 1 };","    set.insert(item);","    let result = set.shift_remove_full(&MyStruct { id: 1 });","    let (index, removed_value) = result.unwrap();","    assert_eq!(set.len(), 0);","}"],[]]]}