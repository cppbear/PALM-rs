{"function_name":"indexmap::map::map::IndexMap<K, V, S>::with_hasher","tests":17,"tests_lines":[9,9,9,9,17,19,19,19,19,6,7,7,7,8,14,14,14],"oracles":4,"oracles_compiled":2,"oracles_compiled_rate":50.0,"tests_compiled":6,"tests_compiled_rate":35.294117647058826,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":6,"tests_passed":3,"tests_passed_rate":50.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[201,202,203,204,205,206],"codes_lines_covered":[[["{","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert!(true);","}"],[201,202,203,204,205,206]],[["{","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert_eq!(map.core.len(), 0);","}"],[201,202,203,204,205,206]],[["{","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert_eq!(map.core.capacity(), 0);","}"],[201,202,203,204,205,206]],[["{","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert_eq!(map.len(), 0);","}"],[201,202,203,204,205,206]],[["{","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert_eq!(map.capacity(), 0);","}"],[201,202,203,204,205,206]],[["{","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert!(map.is_empty());","}"],[201,202,203,204,205,206]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert!(true);","}"],[]],[["{","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert_eq!(map.core.len(), 0);","}"],[]],[["{","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert_eq!(map.core.capacity(), 0);","}"],[]],[["{","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert_eq!(map.len(), 0);","}"],[]],[["{","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert_eq!(map.capacity(), 0);","}"],[]],[["{","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert!(map.is_empty());","}"],[]]]}