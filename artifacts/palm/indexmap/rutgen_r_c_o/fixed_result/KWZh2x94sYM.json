{"function_name":"indexmap::map::map::IndexMap<K, V, S>::with_hasher","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":17,"tests_lines":[15,15,15,15,23,25,25,25,25,12,13,13,13,14,20,20,20],"oracles":4,"oracles_compiled":2,"oracles_compiled_rate":50.0,"tests_compiled":6,"tests_compiled_rate":35.294117647058826,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":6,"tests_passed":3,"tests_passed_rate":50.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[201,202,203,204,205,206],"codes_lines_covered":[[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert!(true);","}"],[201,202,203,204,205,206]],[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert_eq!(map.core.len(), 0);","}"],[201,202,203,204,205,206]],[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert_eq!(map.core.capacity(), 0);","}"],[201,202,203,204,205,206]],[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert_eq!(map.len(), 0);","}"],[201,202,203,204,205,206]],[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert_eq!(map.capacity(), 0);","}"],[201,202,203,204,205,206]],[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert!(map.is_empty());","}"],[201,202,203,204,205,206]]],"codes_branches":[],"codes_branches_covered":[[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert!(true);","}"],[]],[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert_eq!(map.core.len(), 0);","}"],[]],[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    use std::collections::hash_map::RandomState;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hash_builder);","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","    assert_eq!(map.core.capacity(), 0);","}"],[]],[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert_eq!(map.len(), 0);","}"],[]],[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert_eq!(map.capacity(), 0);","}"],[]],[["{","#[should_panic]","fn test_with_hasher_out_of_bounds_capacity() {","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let _map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(n, hash_builder);","}","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    let n = (isize::MAX as usize) / std::mem::size_of::<Bucket<i32, i32>>() + 1;","    let hash_builder = RandomState::new();","    let map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());","    assert!(map.is_empty());","}"],[]]]}