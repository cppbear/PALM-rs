{"function_name":"indexmap::map::core::reserve_entries","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":33,"tests_lines":[15,14,14,14,14,14,14,14,15,13,13,14,14,11,17,17,12,12,10,11,11,20,20,19,20,19,20,20,20,20,20,21,21],"oracles":14,"oracles_compiled":14,"oracles_compiled_rate":100.0,"tests_compiled":31,"tests_compiled_rate":93.93939393939394,"oracles_run":14,"oracles_passed":11,"oracles_passed_rate":78.57142857142857,"tests_run":31,"tests_passed":21,"tests_passed_rate":67.74193548387096,"lines":10,"lines_covered":10,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[526,527,528,529,530,531,532,533,534,535],"codes_lines_covered":[[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 0;","    let try_capacity = entries.len() + 10; // len() is 0, so try_capacity is 10","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 0;","    let try_capacity = entries.len() + 10;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.len(), 0);","}"],[526,527,528,529,530,531,532,535]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5; // len() is 0, so try_capacity is 5","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5;","    assert_eq!(entries.len(), 0);","}"],[526,527,528,529,530,531,532,535]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5; // len() is 0, so try_capacity is 5","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5;","    assert!(entries.try_reserve_exact(5).is_ok());","}"],[526,527,528,529,530,531,532,535]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5; // len() is 0, so try_capacity is 5","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5;","    assert_eq!(entries.len(), 5);","}"],[526,527,528,529,530,531,532,535]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 5;","    let try_capacity = entries.len() + 10; // len() is 0, so try_capacity is 10","","    reserve_entries(&mut entries, additional, try_capacity);","    let additional = 5;","    let try_capacity = 10;","    let entries_length_after = entries.len();","    assert!(entries_length_after == 0);","}"],[526,527,528,529,530,531,532,535]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 5;","    let try_capacity = entries.len() + 10; // len() is 0, so try_capacity is 10","","    reserve_entries(&mut entries, additional, try_capacity);","    let additional = 5;","    let try_capacity = 10;","    let entries_length_after = entries.len();","    assert!(entries.len() >= additional);","}"],[526,527,528,529,530,531,532,535]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 5;","    let try_capacity = entries.len() + 10; // len() is 0, so try_capacity is 10","","    reserve_entries(&mut entries, additional, try_capacity);","    let additional = 5;","    let try_capacity = 10;","    let entries_length_after = entries.len();","    assert!(entries.len() <= try_capacity);","}"],[526,527,528,529,530,531,532,535]],[["{","   struct TestKey;  ","   struct TestValue;  "," ","   let mut entries: Entries<TestKey, TestValue> = vec![Bucket { hash: HashValue(0), key: TestKey, value: TestValue }];  ","   let additional = 1;  ","   let try_capacity = entries.len() + 5; // len() is 1, so try_capacity is 6  "," ","   reserve_entries(&mut entries, additional, try_capacity);  ","   let mut entries: Entries<TestKey, TestValue> = vec![Bucket { hash: HashValue(0), key: TestKey, value: TestValue }];  ","   let additional = 1;  ","   let try_capacity = entries.len() + 5;  ","   reserve_entries(&mut entries, additional, try_capacity);  ","   assert!(entries.len() >= 2);  ","}"],[526,527,528,529,530,531,532,535]],[["{","   struct TestKey;  ","   struct TestValue;  "," ","   let mut entries: Entries<TestKey, TestValue> = Vec::new();  ","   let additional = 1;  ","   let try_capacity = 1024; // Replace with a defined maximum capacity  "," ","   reserve_entries(&mut entries, additional, try_capacity);  ","   let try_capacity = 1024; // Replace with a defined maximum capacity  ","   let try_add = try_capacity - entries.len();  ","   assert!(try_add > additional);  ","}"],[526,527,528,529,530,531,532,535]],[["{","   struct TestKey;  ","   struct TestValue;  "," ","   let mut entries: Entries<TestKey, TestValue> = Vec::new();  ","   let additional = 1;  ","   const INDEXMAP_MAX_ENTRIES_CAPACITY: usize = 1024; // Example capacity definition  ","   let try_capacity = INDEXMAP_MAX_ENTRIES_CAPACITY;  "," ","   reserve_entries(&mut entries, additional, try_capacity);  ","   let try_capacity = INDEXMAP_MAX_ENTRIES_CAPACITY;  ","   let try_add = try_capacity - entries.len();  ","}"],[526,527,528,529,530,531,532,535]],[["{","   struct TestKey;","   struct TestValue;","","   const INDEXMAP_MAX_ENTRIES_CAPACITY: usize = usize::MAX; // Define the constant","   let mut entries: Entries<TestKey, TestValue> = Vec::new();","   let additional = 1;","   let try_capacity = INDEXMAP_MAX_ENTRIES_CAPACITY;","","   reserve_entries(&mut entries, additional, try_capacity);","   let try_capacity = INDEXMAP_MAX_ENTRIES_CAPACITY;","   let try_add = try_capacity - entries.len();","   reserve_entries(&mut entries, additional, try_capacity);","}"],[526,527,528,529,530,531,533,534,535]],[["{","   struct TestKey;","   struct TestValue;","","   let mut entries: Entries<TestKey, TestValue> = Vec::new();","   let additional = 1;","   const INDEXMAP_MAX_ENTRIES_CAPACITY: usize = 1024; // Defined with an appropriate value","   let try_capacity = INDEXMAP_MAX_ENTRIES_CAPACITY;","   ","   reserve_entries(&mut entries, additional, try_capacity);","   let try_add = try_capacity - entries.len();","   reserve_entries(&mut entries, additional, try_capacity);","   assert!(entries.try_reserve_exact(try_add).is_ok());","}"],[526,527,528,529,530,531,532,535]],[["{","   let mut entries: Entries<usize, usize> = vec![Bucket { hash: HashValue(0), key: 1, value: 10 }];  ","   let additional = 1;  ","   let try_capacity = entries.len() + additional + 1;  ","   reserve_entries(&mut entries, additional, try_capacity);  ","   let mut entries: Entries<usize, usize> = vec![Bucket { hash: HashValue(0), key: 1, value: 10 }];  ","   let additional = 1;  ","   let try_capacity = entries.len() + additional + 1;  ","   reserve_entries(&mut entries, additional, try_capacity);  ","   assert_eq!(entries.len(), 2);  ","}"],[526,527,528,529,530,531,532,535]],[["{","   let mut entries: Entries<usize, usize> = Vec::with_capacity(4);  ","   for i in 0..4 {  ","       entries.push(Bucket { hash: HashValue(0), key: i, value: i * 10 });  ","   }  ","   let additional = 2;  ","   let try_capacity = entries.len() + additional + 1;  ","   reserve_entries(&mut entries, additional, try_capacity);  ","   let mut entries: Entries<usize, usize> = Vec::with_capacity(4);  ","   for i in 0..4 {  ","       entries.push(Bucket { hash: HashValue(0), key: i, value: i * 10 });  ","   }  ","   let additional = 2;  ","   let try_capacity = entries.len() + additional + 1;  ","   reserve_entries(&mut entries, additional, try_capacity);  ","   assert!(entries.len() == 4);  ","}"],[526,527,528,529,530,531,532,535]],[["{","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional + 2;","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional + 2;","    let initial_length = entries.len();","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.len() == initial_length + additional);","}"],[526,527,528,529,530,531,532,535]],[["{","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional + 2;","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional + 2;","    let initial_length = entries.len();","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.try_reserve_exact(try_capacity - initial_length).is_err());","}"],[526,527,528,529,530,531,532,535]],[["{","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY; // assume it's a defined constant","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY;","    assert_eq!(entries.len(), 0);","}"],[526,527,528,529,530,531,533,534,535]],[["{","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY; // assume it's a defined constant","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY;","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.len() >= 1);","}"],[526,527,528,529,530,531,533,534,535]],[["{","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY; // assume it's a defined constant","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY;","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.len() <= IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.len(), additional);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.capacity() >= additional);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 0;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 0;","    let try_capacity = additional;","    assert_eq!(entries.len(), 0);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 0;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 0;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.len(), 0);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","    assert_eq!(entries.len(), 0);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.len(), additional);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.capacity() >= additional);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.capacity() <= IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","    let additional = 0;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","    let additional = 0;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.len(), 0);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","    let additional = 0;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","    let additional = 0;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.capacity(), IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","}"],[526,527,528,529,530,531,533,534,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(1000);","    let additional = 25;","    let try_capacity = 1024;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(1000);","    let additional = 25;","    let try_capacity = 1024;","    let initial_length = entries.len();","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.len() >= initial_length + additional);","}"],[526,527,528,529,530,531,532,535]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(1000);","    let additional = 25;","    let try_capacity = 1024;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(1000);","    let additional = 25;","    let try_capacity = 1024;","    let initial_length = entries.len();","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.len() <= IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","}"],[526,527,528,529,530,531,532,535]]],"codes_branches":[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 0;","    let try_capacity = entries.len() + 10; // len() is 0, so try_capacity is 10","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 0;","    let try_capacity = entries.len() + 10;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.len(), 0);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5; // len() is 0, so try_capacity is 5","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5;","    assert_eq!(entries.len(), 0);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5; // len() is 0, so try_capacity is 5","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5;","    assert!(entries.try_reserve_exact(5).is_ok());","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5; // len() is 0, so try_capacity is 5","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 1;","    let try_capacity = entries.len() + 5;","    assert_eq!(entries.len(), 5);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 5;","    let try_capacity = entries.len() + 10; // len() is 0, so try_capacity is 10","","    reserve_entries(&mut entries, additional, try_capacity);","    let additional = 5;","    let try_capacity = 10;","    let entries_length_after = entries.len();","    assert!(entries_length_after == 0);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 5;","    let try_capacity = entries.len() + 10; // len() is 0, so try_capacity is 10","","    reserve_entries(&mut entries, additional, try_capacity);","    let additional = 5;","    let try_capacity = 10;","    let entries_length_after = entries.len();","    assert!(entries.len() >= additional);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","    struct TestKey;","    struct TestValue;","","    let mut entries: Entries<TestKey, TestValue> = Vec::new();","    let additional = 5;","    let try_capacity = entries.len() + 10; // len() is 0, so try_capacity is 10","","    reserve_entries(&mut entries, additional, try_capacity);","    let additional = 5;","    let try_capacity = 10;","    let entries_length_after = entries.len();","    assert!(entries.len() <= try_capacity);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","   struct TestKey;  ","   struct TestValue;  "," ","   let mut entries: Entries<TestKey, TestValue> = vec![Bucket { hash: HashValue(0), key: TestKey, value: TestValue }];  ","   let additional = 1;  ","   let try_capacity = entries.len() + 5; // len() is 1, so try_capacity is 6  "," ","   reserve_entries(&mut entries, additional, try_capacity);  ","   let mut entries: Entries<TestKey, TestValue> = vec![Bucket { hash: HashValue(0), key: TestKey, value: TestValue }];  ","   let additional = 1;  ","   let try_capacity = entries.len() + 5;  ","   reserve_entries(&mut entries, additional, try_capacity);  ","   assert!(entries.len() >= 2);  ","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","   struct TestKey;  ","   struct TestValue;  "," ","   let mut entries: Entries<TestKey, TestValue> = Vec::new();  ","   let additional = 1;  ","   let try_capacity = 1024; // Replace with a defined maximum capacity  "," ","   reserve_entries(&mut entries, additional, try_capacity);  ","   let try_capacity = 1024; // Replace with a defined maximum capacity  ","   let try_add = try_capacity - entries.len();  ","   assert!(try_add > additional);  ","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","   struct TestKey;  ","   struct TestValue;  "," ","   let mut entries: Entries<TestKey, TestValue> = Vec::new();  ","   let additional = 1;  ","   const INDEXMAP_MAX_ENTRIES_CAPACITY: usize = 1024; // Example capacity definition  ","   let try_capacity = INDEXMAP_MAX_ENTRIES_CAPACITY;  "," ","   reserve_entries(&mut entries, additional, try_capacity);  ","   let try_capacity = INDEXMAP_MAX_ENTRIES_CAPACITY;  ","   let try_add = try_capacity - entries.len();  ","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","   struct TestKey;","   struct TestValue;","","   const INDEXMAP_MAX_ENTRIES_CAPACITY: usize = usize::MAX; // Define the constant","   let mut entries: Entries<TestKey, TestValue> = Vec::new();","   let additional = 1;","   let try_capacity = INDEXMAP_MAX_ENTRIES_CAPACITY;","","   reserve_entries(&mut entries, additional, try_capacity);","   let try_capacity = INDEXMAP_MAX_ENTRIES_CAPACITY;","   let try_add = try_capacity - entries.len();","   reserve_entries(&mut entries, additional, try_capacity);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":true}]],[["{","   struct TestKey;","   struct TestValue;","","   let mut entries: Entries<TestKey, TestValue> = Vec::new();","   let additional = 1;","   const INDEXMAP_MAX_ENTRIES_CAPACITY: usize = 1024; // Defined with an appropriate value","   let try_capacity = INDEXMAP_MAX_ENTRIES_CAPACITY;","   ","   reserve_entries(&mut entries, additional, try_capacity);","   let try_add = try_capacity - entries.len();","   reserve_entries(&mut entries, additional, try_capacity);","   assert!(entries.try_reserve_exact(try_add).is_ok());","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","   let mut entries: Entries<usize, usize> = vec![Bucket { hash: HashValue(0), key: 1, value: 10 }];  ","   let additional = 1;  ","   let try_capacity = entries.len() + additional + 1;  ","   reserve_entries(&mut entries, additional, try_capacity);  ","   let mut entries: Entries<usize, usize> = vec![Bucket { hash: HashValue(0), key: 1, value: 10 }];  ","   let additional = 1;  ","   let try_capacity = entries.len() + additional + 1;  ","   reserve_entries(&mut entries, additional, try_capacity);  ","   assert_eq!(entries.len(), 2);  ","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","   let mut entries: Entries<usize, usize> = Vec::with_capacity(4);  ","   for i in 0..4 {  ","       entries.push(Bucket { hash: HashValue(0), key: i, value: i * 10 });  ","   }  ","   let additional = 2;  ","   let try_capacity = entries.len() + additional + 1;  ","   reserve_entries(&mut entries, additional, try_capacity);  ","   let mut entries: Entries<usize, usize> = Vec::with_capacity(4);  ","   for i in 0..4 {  ","       entries.push(Bucket { hash: HashValue(0), key: i, value: i * 10 });  ","   }  ","   let additional = 2;  ","   let try_capacity = entries.len() + additional + 1;  ","   reserve_entries(&mut entries, additional, try_capacity);  ","   assert!(entries.len() == 4);  ","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional + 2;","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional + 2;","    let initial_length = entries.len();","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.len() == initial_length + additional);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional + 2;","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional + 2;","    let initial_length = entries.len();","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.try_reserve_exact(try_capacity - initial_length).is_err());","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY; // assume it's a defined constant","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY;","    assert_eq!(entries.len(), 0);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":true}]],[["{","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY; // assume it's a defined constant","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY;","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.len() >= 1);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":true}]],[["{","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY; // assume it's a defined constant","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 1;","    let try_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY;","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.len() <= IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":true}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.len(), additional);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":false,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 5;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.capacity() >= additional);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":false,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 0;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 0;","    let try_capacity = additional;","    assert_eq!(entries.len(), 0);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":false,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 0;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::new();","    let additional = 0;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.len(), 0);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":false,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","    assert_eq!(entries.len(), 0);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":false,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.len(), additional);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":false,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.capacity() >= additional);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":false,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(10);","    let additional = 10;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.capacity() <= IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":false,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","    let additional = 0;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","    let additional = 0;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.len(), 0);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":false,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","    let additional = 0;","    let try_capacity = additional;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","    let additional = 0;","    let try_capacity = additional;","    reserve_entries(&mut entries, additional, try_capacity);","    assert_eq!(entries.capacity(), IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":false,"negative":true},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":false,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(1000);","    let additional = 25;","    let try_capacity = 1024;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(1000);","    let additional = 25;","    let try_capacity = 1024;","    let initial_length = entries.len();","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.len() >= initial_length + additional);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]],[["{","#[derive(Debug)]","struct IndexMapCore<K, V> {","    _marker: std::marker::PhantomData<(K, V)>,","}","","impl<K, V> IndexMapCore<K, V> {","    const MAX_ENTRIES_CAPACITY: usize = 1024; // Example constant","}","    let mut entries: Entries<usize, usize> = Vec::with_capacity(1000);","    let additional = 25;","    let try_capacity = 1024;","","    reserve_entries(&mut entries, additional, try_capacity);","    let mut entries: Entries<usize, usize> = Vec::with_capacity(1000);","    let additional = 25;","    let try_capacity = 1024;","    let initial_length = entries.len();","    reserve_entries(&mut entries, additional, try_capacity);","    assert!(entries.len() <= IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","}"],[{"start_line":531,"start_column":8,"end_line":531,"end_column":28,"positive":true,"negative":false},{"start_line":531,"start_column":32,"end_line":531,"end_column":74,"positive":true,"negative":false}]]]}