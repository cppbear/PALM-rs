{"function_name":"indexmap::map::map::IndexMap<K, V, S>::sort_unstable_keys","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":27,"tests_lines":[7,11,13,15,17,8,8,8,8,13,13,13,13,13,13,13,13,13,12,12,12,12,12,15,15,15,15],"oracles":7,"oracles_compiled":5,"oracles_compiled_rate":71.42857142857143,"tests_compiled":13,"tests_compiled_rate":48.148148148148145,"oracles_run":5,"oracles_passed":2,"oracles_passed_rate":40.0,"tests_run":13,"tests_passed":6,"tests_passed_rate":46.15384615384615,"lines":8,"lines_covered":8,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1052,1053,1054,1055,1056,1057,1058,1059],"codes_lines_covered":[[["{","   let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","   map.sort_unstable_keys();","   // let map: IndexMap<i32, i32, RandomState> = IndexMap::new(); // Remove this line to avoid shadowing","   // map.sort_unstable_keys(); // Remove this line as it's not necessary","   map.insert(3, 30);","   map.insert(1, 10);","   map.insert(2, 20);","   map.sort_unstable_keys();","   map.insert(2, 25);","   map.sort_unstable_keys();","   assert_eq!(map.as_slice(), &[(1, 10), (2, 25), (3, 30)]);","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","   let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();  ","   map.sort_unstable_keys();  ","   // Removed the re-declaration of map to maintain mutability  ","   // map.sort_unstable_keys();  ","   map.insert(3, 30);  ","   map.insert(1, 10);  ","   map.insert(2, 20);  ","   map.sort_unstable_keys();  ","   map.insert(2, 25);  ","   map.sort_unstable_keys();  ","   map.insert(1, 15);  ","   map.sort_unstable_keys();  ","   assert_eq!(map.as_slice(), &[(1, 15), (2, 25), (3, 30)]);  ","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    assert_eq!(map.first(), Some((&5, &100)));","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    assert_eq!(map.last(), Some((&5, &100)));","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    assert_eq!(map.as_slice().len(), 1);","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    assert!(map.is_empty() == false);","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 200);","    map.insert(2, 150);","    map.insert(3, 400);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 200);","    map.insert(2, 150);","    map.insert(3, 400);","   let sorted_entries = map.as_slice();","   assert!(sorted_entries[0] <= sorted_entries[1]);","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(2, 100);","    map.insert(1, 200);","    map.insert(2, 300);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(2, 100);","    map.insert(1, 200);","    map.insert(2, 300);","    let sorted_keys: Vec<_> = map.as_slice().iter().map(|(k, _)| *k).collect();","    assert_eq!(sorted_keys, vec![1, 2, 2]);","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","        map.insert(i, i * 10);","    }","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","    map.insert(i, i * 10);","    }","    assert_eq!(map.first(), Some((&0, &0)));","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","        map.insert(i, i * 10);","    }","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","    map.insert(i, i * 10);","    }","    assert_eq!(map.last(), Some((&999, &9990)));","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","        map.insert(i, i * 10);","    }","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","    map.insert(i, i * 10);","    }","    assert_eq!(map.get_index(0), Some((&0, &0)));","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","        map.insert(i, i * 10);","    }","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","    map.insert(i, i * 10);","    }","    assert_eq!(map.get_index(999), Some((&999, &9990)));","}"],[1052,1053,1054,1055,1056,1057,1058,1059]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","        map.insert(i, i * 10);","    }","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","    map.insert(i, i * 10);","    }","    assert!(map.iter().enumerate().all(|(idx, (key, _))| *key == idx as i32));","}"],[1052,1053,1054,1055,1056,1057,1058,1059]]],"codes_branches":[],"codes_branches_covered":[[["{","   let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","   map.sort_unstable_keys();","   // let map: IndexMap<i32, i32, RandomState> = IndexMap::new(); // Remove this line to avoid shadowing","   // map.sort_unstable_keys(); // Remove this line as it's not necessary","   map.insert(3, 30);","   map.insert(1, 10);","   map.insert(2, 20);","   map.sort_unstable_keys();","   map.insert(2, 25);","   map.sort_unstable_keys();","   assert_eq!(map.as_slice(), &[(1, 10), (2, 25), (3, 30)]);","}"],[]],[["{","   let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();  ","   map.sort_unstable_keys();  ","   // Removed the re-declaration of map to maintain mutability  ","   // map.sort_unstable_keys();  ","   map.insert(3, 30);  ","   map.insert(1, 10);  ","   map.insert(2, 20);  ","   map.sort_unstable_keys();  ","   map.insert(2, 25);  ","   map.sort_unstable_keys();  ","   map.insert(1, 15);  ","   map.sort_unstable_keys();  ","   assert_eq!(map.as_slice(), &[(1, 15), (2, 25), (3, 30)]);  ","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    assert_eq!(map.first(), Some((&5, &100)));","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    assert_eq!(map.last(), Some((&5, &100)));","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    assert_eq!(map.as_slice().len(), 1);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(5, 100);","    assert!(map.is_empty() == false);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 200);","    map.insert(2, 150);","    map.insert(3, 400);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(1, 200);","    map.insert(2, 150);","    map.insert(3, 400);","   let sorted_entries = map.as_slice();","   assert!(sorted_entries[0] <= sorted_entries[1]);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(2, 100);","    map.insert(1, 200);","    map.insert(2, 300);","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    map.insert(2, 100);","    map.insert(1, 200);","    map.insert(2, 300);","    let sorted_keys: Vec<_> = map.as_slice().iter().map(|(k, _)| *k).collect();","    assert_eq!(sorted_keys, vec![1, 2, 2]);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","        map.insert(i, i * 10);","    }","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","    map.insert(i, i * 10);","    }","    assert_eq!(map.first(), Some((&0, &0)));","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","        map.insert(i, i * 10);","    }","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","    map.insert(i, i * 10);","    }","    assert_eq!(map.last(), Some((&999, &9990)));","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","        map.insert(i, i * 10);","    }","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","    map.insert(i, i * 10);","    }","    assert_eq!(map.get_index(0), Some((&0, &0)));","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","        map.insert(i, i * 10);","    }","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","    map.insert(i, i * 10);","    }","    assert_eq!(map.get_index(999), Some((&999, &9990)));","}"],[]],[["{","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","        map.insert(i, i * 10);","    }","    map.sort_unstable_keys();","    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();","    for i in (0..1000).rev() {","    map.insert(i, i * 10);","    }","    assert!(map.iter().enumerate().all(|(idx, (key, _))| *key == idx as i32));","}"],[]]]}