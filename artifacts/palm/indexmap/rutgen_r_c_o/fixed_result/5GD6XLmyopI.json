{"function_name":"indexmap::map::map::IndexMap<K, V, S>::append","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":50,"tests_lines":[14,14,16,16,16,16,16,16,18,14,14,15,15,17,17,18,18,18,15,18,18,18,18,14,14,14,16,16,17,17,17,17,17,14,14,16,16,16,18,18,20,20,21,21,23,23,23,23,23,23],"oracles":6,"oracles_compiled":4,"oracles_compiled_rate":66.66666666666666,"tests_compiled":25,"tests_compiled_rate":50.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":25,"tests_passed":24,"tests_passed_rate":96.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[682,683,684],"codes_lines_covered":[[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","    a.append(&mut b);","    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","    assert_eq!(a.len(), 2);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","    a.append(&mut b);","    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","    assert_eq!(b.len(), 2);","}"],[682,683,684]],[["{","   #[should_panic]","   fn test_append_with_invalid_state() {","       let mut a: IndexMap<i32, &str> = IndexMap::new();","       let mut b: IndexMap<i32, &str> = IndexMap::new();","       a.append(&mut b);","   } // Close invalid state test function","   test_append_with_invalid_state(); // Call the invalid state test","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","   a.append(&mut b);","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","  let _old_capacity = b.capacity();","  a.append(&mut b);","}"],[682,683,684]],[["{","   #[should_panic]","   fn test_append_with_invalid_state() {","       let mut a: IndexMap<i32, &str> = IndexMap::new();","       let mut b: IndexMap<i32, &str> = IndexMap::new();","       a.append(&mut b);","} ","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","   a.append(&mut b);","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","   let old_capacity = b.capacity();","   a.append(&mut b);","    assert_eq!(b.capacity(), old_capacity);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","   a.append(&mut b);","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]); // Changed to mutable","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]); // Changed to mutable","   let _old_capacity = b.capacity();  ","   a.append(&mut b);  ","   assert!(a.keys().eq(&[1, 2, 3, 4]));  ","}"],[682,683,684]],[["{","  #[should_panic]","  fn test_append_with_invalid_state() {","      let mut a: IndexMap<i32, &str> = IndexMap::new();","      let mut b: IndexMap<i32, &str> = IndexMap::new();","      a.append(&mut b);","  }","  test_append_with_invalid_state(); // Call the invalid state test here","  let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","  let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","  a.append(&mut b);","  let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","  let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","  let _old_capacity = b.capacity();","  a.append(&mut b);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","   a.append(&mut b);","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","  let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","  let _old_capacity = b.capacity();","  a.append(&mut b);","   assert_eq!(a[&4], \"d\");","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert!(a.len() == 0);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert!(b.len() == 0);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","    assert!(a.len() == 0);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","    assert!(b.len() == 0);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    assert!(a.len() == 1);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    assert!(b.len() == 0);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    assert!(b.is_empty());","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert_eq!(a.len(), 0);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert_eq!(b.len(), 0);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    assert_eq!(a.len(), 1);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    assert_eq!(b.len(), 2);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    assert_eq!(a.len(), 3);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    assert_eq!(b.len(), 0);","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    assert_eq!(a[&1], \"new\");","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    assert_eq!(a[&2], \"b\");","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    assert!(a.keys().eq(&[1, 2]));","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::with_capacity(100);","    let mut b = IndexMap::with_capacity(200);","    for i in 0..50 {","        a.insert(i, \"foo\");","        b.insert(i + 50, \"bar\");","    }","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert!(a.is_empty());","}"],[682,683,684]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::with_capacity(100);","    let mut b = IndexMap::with_capacity(200);","    for i in 0..50 {","        a.insert(i, \"foo\");","        b.insert(i + 50, \"bar\");","    }","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert!(b.is_empty());","}"],[682,683,684]]],"codes_branches":[],"codes_branches_covered":[[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","    a.append(&mut b);","    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","    assert_eq!(a.len(), 2);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","    a.append(&mut b);","    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","    assert_eq!(b.len(), 2);","}"],[]],[["{","   #[should_panic]","   fn test_append_with_invalid_state() {","       let mut a: IndexMap<i32, &str> = IndexMap::new();","       let mut b: IndexMap<i32, &str> = IndexMap::new();","       a.append(&mut b);","   } // Close invalid state test function","   test_append_with_invalid_state(); // Call the invalid state test","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","   a.append(&mut b);","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","  let _old_capacity = b.capacity();","  a.append(&mut b);","}"],[]],[["{","   #[should_panic]","   fn test_append_with_invalid_state() {","       let mut a: IndexMap<i32, &str> = IndexMap::new();","       let mut b: IndexMap<i32, &str> = IndexMap::new();","       a.append(&mut b);","} ","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","   a.append(&mut b);","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","   let old_capacity = b.capacity();","   a.append(&mut b);","    assert_eq!(b.capacity(), old_capacity);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","   a.append(&mut b);","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]); // Changed to mutable","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]); // Changed to mutable","   let _old_capacity = b.capacity();  ","   a.append(&mut b);  ","   assert!(a.keys().eq(&[1, 2, 3, 4]));  ","}"],[]],[["{","  #[should_panic]","  fn test_append_with_invalid_state() {","      let mut a: IndexMap<i32, &str> = IndexMap::new();","      let mut b: IndexMap<i32, &str> = IndexMap::new();","      a.append(&mut b);","  }","  test_append_with_invalid_state(); // Call the invalid state test here","  let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","  let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","  a.append(&mut b);","  let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","  let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","  let _old_capacity = b.capacity();","  a.append(&mut b);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","   let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","   a.append(&mut b);","   let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);","  let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);","  let _old_capacity = b.capacity();","  a.append(&mut b);","   assert_eq!(a[&4], \"d\");","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert!(a.len() == 0);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert!(b.len() == 0);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","    assert!(a.len() == 0);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","    assert!(b.len() == 0);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    assert!(a.len() == 1);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    assert!(b.len() == 0);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","    let mut a = IndexMap::from([(1, \"a\")]);","    let mut b = IndexMap::new();","    a.append(&mut b);","    assert!(b.is_empty());","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert_eq!(a.len(), 0);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert_eq!(b.len(), 0);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    assert_eq!(a.len(), 1);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    assert_eq!(b.len(), 2);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    assert_eq!(a.len(), 3);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    assert_eq!(b.len(), 0);","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    assert_eq!(a[&1], \"new\");","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    assert_eq!(a[&2], \"b\");","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    let mut a = IndexMap::from([(1, \"old\")]);","    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);","    a.append(&mut b);","    assert!(a.keys().eq(&[1, 2]));","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::with_capacity(100);","    let mut b = IndexMap::with_capacity(200);","    for i in 0..50 {","        a.insert(i, \"foo\");","        b.insert(i + 50, \"bar\");","    }","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert!(a.is_empty());","}"],[]],[["{","#[should_panic]","fn test_append_with_invalid_state() {","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    a.append(&mut b);","}","    let mut a = IndexMap::with_capacity(100);","    let mut b = IndexMap::with_capacity(200);","    for i in 0..50 {","        a.insert(i, \"foo\");","        b.insert(i + 50, \"bar\");","    }","    a.append(&mut b);","    let mut a: IndexMap<i32, &str> = IndexMap::new();","    let mut b: IndexMap<i32, &str> = IndexMap::new();","    assert!(b.is_empty());","}"],[]]]}