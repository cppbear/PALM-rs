{"function_name":"indexmap::map::map::IndexMap<K, V, S>::get_disjoint_mut","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":32,"tests_lines":[6,6,6,7,8,9,9,9,9,7,7,8,8,8,8,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7],"oracles":10,"oracles_compiled":4,"oracles_compiled_rate":40.0,"tests_compiled":8,"tests_compiled_rate":25.0,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":8,"tests_passed":5,"tests_passed_rate":62.5,"lines":13,"lines_covered":10,"lines_coveraged_rate":76.92307692307693,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[801,802,803,804,805,806,808,809,810,813,815,816,817],"codes_lines_covered":[[["{","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let _ = map.get_disjoint_mut([&1, &2, &2]);","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","  let _ = map.get_disjoint_mut([&1, &2, &2]);","  }));","  assert_eq!(result.err().unwrap().downcast_ref::<&str>(), Some(&\"duplicate keys found\"));","}"],[801,802,803,804,805,806,813]],[["{","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let _ = map.get_disjoint_mut([&3, &3]);","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","  let _ = map.get_disjoint_mut([&3, &3]);","  }));","  assert!(result.is_err());","}"],[801,802,803,804,805,806,813]],[["{","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let _ = map.get_disjoint_mut([&3, &3]);","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","  let _ = map.get_disjoint_mut([&3, &3]);","  }));","  assert_eq!(result.unwrap_err().downcast_ref::<&str>(), Some(&\"duplicate keys found\"));","}"],[801,802,803,804,805,806,813]],[["{","   let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","   let _result = map.get_disjoint_mut([&1, &2]);","   let indices = [&1, &2].map(|key| map.get_index_of(key));","   let disjoint_values = map.as_mut_slice().get_disjoint_opt_mut(indices);","   assert!(matches!(disjoint_values, Ok(_)));","}"],[801,802,803,804,805,806,815,816,817]],[["{","   let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","   let _result = map.get_disjoint_mut([&1, &2]);","   let indices = [&1, &2].map(|key| map.get_index_of(key));","   let disjoint_values = map.as_mut_slice().get_disjoint_opt_mut(indices);","   let result = map.get_disjoint_mut([&1, &2]);","   assert_eq!(result, [Some(&mut 'a'), Some(&mut 'b')]);","}"],[801,802,803,804,805,806,815,816,817]],[["{","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let _result = map.get_disjoint_mut([&1, &1]);","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let result = map.get_disjoint_mut([&1, &1]);","   assert!(result.is_empty());  // Ensure result is empty during panic","}"],[801,802,803,804,805,806,813]],[["{","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let _result = map.get_disjoint_mut([&1, &1]);","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let result = map.get_disjoint_mut([&1, &1]);","   assert_eq!(result, [None, None]);  // Check that both returned values are None since duplicate keys cause panic","}"],[801,802,803,804,805,806,813]],[["{","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let _result = map.get_disjoint_mut([&1, &1]);","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let result = map.get_disjoint_mut([&1, &1]);","   assert!(map.len() == 2);  // Verify that the original map length remains unchanged after panic.","}"],[801,802,803,804,805,806,813]]],"codes_branches":[],"codes_branches_covered":[[["{","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let _ = map.get_disjoint_mut([&1, &2, &2]);","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","  let _ = map.get_disjoint_mut([&1, &2, &2]);","  }));","  assert_eq!(result.err().unwrap().downcast_ref::<&str>(), Some(&\"duplicate keys found\"));","}"],[]],[["{","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let _ = map.get_disjoint_mut([&3, &3]);","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","  let _ = map.get_disjoint_mut([&3, &3]);","  }));","  assert!(result.is_err());","}"],[]],[["{","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let _ = map.get_disjoint_mut([&3, &3]);","  let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","  let _ = map.get_disjoint_mut([&3, &3]);","  }));","  assert_eq!(result.unwrap_err().downcast_ref::<&str>(), Some(&\"duplicate keys found\"));","}"],[]],[["{","   let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","   let _result = map.get_disjoint_mut([&1, &2]);","   let indices = [&1, &2].map(|key| map.get_index_of(key));","   let disjoint_values = map.as_mut_slice().get_disjoint_opt_mut(indices);","   assert!(matches!(disjoint_values, Ok(_)));","}"],[]],[["{","   let mut map = IndexMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);","   let _result = map.get_disjoint_mut([&1, &2]);","   let indices = [&1, &2].map(|key| map.get_index_of(key));","   let disjoint_values = map.as_mut_slice().get_disjoint_opt_mut(indices);","   let result = map.get_disjoint_mut([&1, &2]);","   assert_eq!(result, [Some(&mut 'a'), Some(&mut 'b')]);","}"],[]],[["{","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let _result = map.get_disjoint_mut([&1, &1]);","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let result = map.get_disjoint_mut([&1, &1]);","   assert!(result.is_empty());  // Ensure result is empty during panic","}"],[]],[["{","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let _result = map.get_disjoint_mut([&1, &1]);","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let result = map.get_disjoint_mut([&1, &1]);","   assert_eq!(result, [None, None]);  // Check that both returned values are None since duplicate keys cause panic","}"],[]],[["{","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let _result = map.get_disjoint_mut([&1, &1]);","   let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);","   let result = map.get_disjoint_mut([&1, &1]);","   assert!(map.len() == 2);  // Verify that the original map length remains unchanged after panic.","}"],[]]]}