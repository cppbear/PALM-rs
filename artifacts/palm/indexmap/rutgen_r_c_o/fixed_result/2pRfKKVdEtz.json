{"function_name":"indexmap::map::core::equivalent","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":8,"tests_lines":[21,24,23,35,35,32,25,25],"oracles":6,"oracles_compiled":3,"oracles_compiled_rate":50.0,"tests_compiled":4,"tests_compiled_rate":50.0,"oracles_run":3,"oracles_passed":1,"oracles_passed_rate":33.33333333333333,"tests_run":4,"tests_passed":1,"tests_passed_rate":25.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[55,56,57,58,59,60],"codes_lines_covered":[[["{","#[derive(Copy, Clone, Debug)]","struct MyKey {","    value: usize,","}","","   impl Equivalent<usize> for MyKey {  ","       fn equivalent(&self, key: &usize) -> bool {  ","           &self.value == key  ","       }  ","}","    let key = MyKey { value: 1 };","    let entries: Vec<Bucket<usize, usize>> = vec![];","    let func = equivalent(&key, &entries);","    let _result = func(&0); // Out of bounds, should not panic.","    let key = MyKey { value: 1 };","    let entries: Vec<Bucket<usize, usize>> = vec![];","    let func = equivalent(&key, &entries);","    let result = func(&0);","    assert_eq!(result, false);","}"],[55,56,57,58,59,60]],[["{","   #[derive(Copy, Clone, Debug, Default)]","   struct MyKey {","       value: usize,","   }","   ","   impl Equivalent<usize> for MyKey {","       fn equivalent(&self, key: &usize) -> bool {","           &self.value == key","       }","   }","   let key = MyKey { value: 1 };","   let entries = vec![Bucket {","       hash: HashValue(0),","       key: 2,","       value: 3,","   }];","   let func = equivalent(&key, &entries);","   let _result = func(&0); // Expected to return false.","   let key = MyKey { value: 1 };","   let entries = vec![Bucket { hash: HashValue(0), key: 2, value: 3 }];","   let func = equivalent(&key, &entries);","   assert_eq!(func(&0), false);","}"],[55,56,57,58,59,60]],[["{","   #[derive(Copy, Clone, Debug, Default)]  ","   struct MyKey {  ","       value: usize,  ","   }  "," ","   impl Equivalent<usize> for MyKey {  ","       fn equivalent(&self, key: &usize) -> bool {  ","           &self.value == key  ","       }  ","   }  ","   let key = MyKey { value: 1 };  ","   let entries = vec![Bucket {  ","       hash: HashValue(0), // Use a plain constructor for default  ","       key: 1,  ","       value: 2,  ","   }];  ","   let func = equivalent(&key, &entries);  ","   let _result = func(&1); // Out of bounds, should not panic.  ","   let key = MyKey { value: 1 };  ","   let entries = vec![Bucket { hash: HashValue(0), key: 1, value: 2 }]; // Use a plain constructor for default  ","   let func = equivalent(&key, &entries);  ","   let _result = func(&1);  ","   assert_eq!(_result, true);  ","}"],[55,56,57,58,59,60]],[["{","   #[derive(Copy, Clone, Debug)]  ","   struct MyKey {  ","       value: usize,  ","   }  "," ","   impl Equivalent<usize> for MyKey {  ","      fn equivalent(&self, key: &usize) -> bool {  ","          &self.value == key  ","      }  ","   }  ","       let key = MyKey { value: 1 };  ","       let entries = vec![Bucket {  ","           hash: HashValue(0), // Provide a default value  ","           key: 1,  ","           value: 2,  ","       }];  ","       let func = equivalent(&key, &entries);  ","       let _result = func(&1); // Out of bounds, should not panic.  ","       let key = MyKey { value: 1 };  ","       let entries = vec![Bucket { hash: HashValue(0), key: 1, value: 2 }];  ","    let func = equivalent(&key, &entries);","    let _result = func(&1);","    assert_eq!(func(&2), false);","}"],[55,56,57,58,59,60]]],"codes_branches":[],"codes_branches_covered":[[["{","#[derive(Copy, Clone, Debug)]","struct MyKey {","    value: usize,","}","","   impl Equivalent<usize> for MyKey {  ","       fn equivalent(&self, key: &usize) -> bool {  ","           &self.value == key  ","       }  ","}","    let key = MyKey { value: 1 };","    let entries: Vec<Bucket<usize, usize>> = vec![];","    let func = equivalent(&key, &entries);","    let _result = func(&0); // Out of bounds, should not panic.","    let key = MyKey { value: 1 };","    let entries: Vec<Bucket<usize, usize>> = vec![];","    let func = equivalent(&key, &entries);","    let result = func(&0);","    assert_eq!(result, false);","}"],[]],[["{","   #[derive(Copy, Clone, Debug, Default)]","   struct MyKey {","       value: usize,","   }","   ","   impl Equivalent<usize> for MyKey {","       fn equivalent(&self, key: &usize) -> bool {","           &self.value == key","       }","   }","   let key = MyKey { value: 1 };","   let entries = vec![Bucket {","       hash: HashValue(0),","       key: 2,","       value: 3,","   }];","   let func = equivalent(&key, &entries);","   let _result = func(&0); // Expected to return false.","   let key = MyKey { value: 1 };","   let entries = vec![Bucket { hash: HashValue(0), key: 2, value: 3 }];","   let func = equivalent(&key, &entries);","   assert_eq!(func(&0), false);","}"],[]],[["{","   #[derive(Copy, Clone, Debug, Default)]  ","   struct MyKey {  ","       value: usize,  ","   }  "," ","   impl Equivalent<usize> for MyKey {  ","       fn equivalent(&self, key: &usize) -> bool {  ","           &self.value == key  ","       }  ","   }  ","   let key = MyKey { value: 1 };  ","   let entries = vec![Bucket {  ","       hash: HashValue(0), // Use a plain constructor for default  ","       key: 1,  ","       value: 2,  ","   }];  ","   let func = equivalent(&key, &entries);  ","   let _result = func(&1); // Out of bounds, should not panic.  ","   let key = MyKey { value: 1 };  ","   let entries = vec![Bucket { hash: HashValue(0), key: 1, value: 2 }]; // Use a plain constructor for default  ","   let func = equivalent(&key, &entries);  ","   let _result = func(&1);  ","   assert_eq!(_result, true);  ","}"],[]],[["{","   #[derive(Copy, Clone, Debug)]  ","   struct MyKey {  ","       value: usize,  ","   }  "," ","   impl Equivalent<usize> for MyKey {  ","      fn equivalent(&self, key: &usize) -> bool {  ","          &self.value == key  ","      }  ","   }  ","       let key = MyKey { value: 1 };  ","       let entries = vec![Bucket {  ","           hash: HashValue(0), // Provide a default value  ","           key: 1,  ","           value: 2,  ","       }];  ","       let func = equivalent(&key, &entries);  ","       let _result = func(&1); // Out of bounds, should not panic.  ","       let key = MyKey { value: 1 };  ","       let entries = vec![Bucket { hash: HashValue(0), key: 1, value: 2 }];  ","    let func = equivalent(&key, &entries);","    let _result = func(&1);","    assert_eq!(func(&2), false);","}"],[]]]}