{"function_name":"indexmap::set::set::IndexSet<T, S>::swap_take","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/set.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":16,"tests_lines":[12,12,12,12,12,12,11,6,11,11,11,9,9,11,12,11],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":16,"tests_compiled_rate":100.0,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":16,"tests_passed":13,"tests_passed_rate":81.25,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[747,748,749,750,751,752],"codes_lines_covered":[[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert!(result.is_some());","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert_eq!(result.unwrap(), 2);","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert!(!index_set.contains(&2));","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert!(index_set.contains(&1));","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert!(index_set.contains(&3));","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert_eq!(index_set.len(), 2);","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    let result = index_set.swap_take(&3);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    let result = index_set.swap_take(&3);","    assert_eq!(result, None);","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    let result = index_set.swap_take(&1);","    let index_set: IndexSet<i32, RandomState> = IndexSet::new();","    assert_eq!(result, None);","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1); // Assume the set allows duplicates for this scenario","    let result = index_set.swap_take(&1);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1);","    let result = index_set.swap_take(&1);","    assert_eq!(result, Some(1));","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1); // Assume the set allows duplicates for this scenario","    let result = index_set.swap_take(&1);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1);","    let result = index_set.swap_take(&1);","    assert_eq!(index_set.contains(&1), false);","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1); // Assume the set allows duplicates for this scenario","    let result = index_set.swap_take(&1);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1);","    let result = index_set.swap_take(&1);","    assert_eq!(index_set.get_index_of(&1), None);","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(42);","    let result = index_set.swap_take(&42);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(42);","    let result = index_set.swap_take(&42);","    assert_eq!(result, Some(42));","}"],[747,748,749,750,751,752]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(42);","    let result = index_set.swap_take(&42);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(42);","    let result = index_set.swap_take(&42);","    assert!(!index_set.contains(&42));","}"],[747,748,749,750,751,752]],[["{","  #[derive(Hash, Eq, PartialEq)]","  struct NonHashable;","  ","  let mut index_set: IndexSet<NonHashable, RandomState> = IndexSet::new();","  index_set.insert(NonHashable);","   let result = index_set.swap_take(&NonHashable);","   let mut index_set: IndexSet<NonHashable, RandomState> = IndexSet::new();","   index_set.insert(NonHashable);","   assert!(result.is_some());","}"],[747,748,749,750,751,752]],[["{","  #[derive(Hash, Eq, PartialEq)]","  struct NonHashable;","   ","","","","","","","","}"],[]],[["{","  #[derive(Hash, Eq, PartialEq)]","  struct NonHashable;","  "," let mut index_set: IndexSet<NonHashable, RandomState> = IndexSet::new();"," index_set.insert(NonHashable);"," let _result = index_set.swap_take(&NonHashable);"," let mut index_set: IndexSet<NonHashable, RandomState> = IndexSet::new();"," index_set.insert(NonHashable);"," assert!(!index_set.contains(&NonHashable));","}"],[747,748,749,750,751,752]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert!(result.is_some());","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert_eq!(result.unwrap(), 2);","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert!(!index_set.contains(&2));","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert!(index_set.contains(&1));","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert!(index_set.contains(&3));","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    let result = index_set.swap_take(&2);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    index_set.insert(3);","    assert_eq!(index_set.len(), 2);","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    let result = index_set.swap_take(&3);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(2);","    let result = index_set.swap_take(&3);","    assert_eq!(result, None);","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    let result = index_set.swap_take(&1);","    let index_set: IndexSet<i32, RandomState> = IndexSet::new();","    assert_eq!(result, None);","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1); // Assume the set allows duplicates for this scenario","    let result = index_set.swap_take(&1);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1);","    let result = index_set.swap_take(&1);","    assert_eq!(result, Some(1));","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1); // Assume the set allows duplicates for this scenario","    let result = index_set.swap_take(&1);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1);","    let result = index_set.swap_take(&1);","    assert_eq!(index_set.contains(&1), false);","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1); // Assume the set allows duplicates for this scenario","    let result = index_set.swap_take(&1);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(1);","    index_set.insert(1);","    let result = index_set.swap_take(&1);","    assert_eq!(index_set.get_index_of(&1), None);","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(42);","    let result = index_set.swap_take(&42);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(42);","    let result = index_set.swap_take(&42);","    assert_eq!(result, Some(42));","}"],[]],[["{","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(42);","    let result = index_set.swap_take(&42);","    let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();","    index_set.insert(42);","    let result = index_set.swap_take(&42);","    assert!(!index_set.contains(&42));","}"],[]],[["{","  #[derive(Hash, Eq, PartialEq)]","  struct NonHashable;","  ","  let mut index_set: IndexSet<NonHashable, RandomState> = IndexSet::new();","  index_set.insert(NonHashable);","   let result = index_set.swap_take(&NonHashable);","   let mut index_set: IndexSet<NonHashable, RandomState> = IndexSet::new();","   index_set.insert(NonHashable);","   assert!(result.is_some());","}"],[]],[["{","  #[derive(Hash, Eq, PartialEq)]","  struct NonHashable;","   ","","","","","","","","}"],[]],[["{","  #[derive(Hash, Eq, PartialEq)]","  struct NonHashable;","  "," let mut index_set: IndexSet<NonHashable, RandomState> = IndexSet::new();"," index_set.insert(NonHashable);"," let _result = index_set.swap_take(&NonHashable);"," let mut index_set: IndexSet<NonHashable, RandomState> = IndexSet::new();"," index_set.insert(NonHashable);"," assert!(!index_set.contains(&NonHashable));","}"],[]]]}