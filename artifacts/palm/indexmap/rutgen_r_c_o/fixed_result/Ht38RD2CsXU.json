{"function_name":"indexmap::map::core::raw_entry_v1::map::core::raw_entry_v1::RawEntryBuilderMut<'a, K, V, S>::from_hash","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core/raw_entry_v1.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":20,"tests_lines":[13,13,13,11,11,11,11,11,15,15,15,15,42,42,43,42,36,36,36,36],"oracles":5,"oracles_compiled":3,"oracles_compiled_rate":60.0,"tests_compiled":7,"tests_compiled_rate":35.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":7,"tests_passed":6,"tests_passed_rate":85.71428571428571,"lines":17,"lines_covered":12,"lines_coveraged_rate":70.58823529411765,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,303],"codes_lines_covered":[[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |_: &i32| false;","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |_: &i32| false;","    let result = builder.from_hash(hash, is_match);","    assert!(matches!(result, RawEntryMut::Vacant(_)));","}"],[286,287,288,289,290,291,292,298,299,300,301,303]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |_: &i32| false;","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |_: &i32| false;","    let result = builder.from_hash(hash, is_match);","    assert!(if let RawEntryMut::Vacant(entry) = result { entry.map.entries.is_empty() } else { false });","}"],[286,287,288,289,290,291,292,298,299,300,301,303]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 3u64;","    let is_match = |_: &i32| false;","    let result = builder.from_hash(hash, is_match);","    let map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    assert!(matches!(result, RawEntryMut::Vacant(_)));","}"],[286,287,288,289,290,291,292,298,299,300,301,303]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64; // Assuming this hash corresponds to the key `1`","    let is_match = |k: &i32| *k != 1; // This will result in a false match on an existing key","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |k: &i32| *k != 1;","    let result = builder.from_hash(hash, is_match);","    assert!(matches!(result, RawEntryMut::Vacant(_)));","}"],[286,287,288,289,290,291,292,298,299,300,301,303]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64; // Assuming this hash corresponds to the key `1`","    let is_match = |k: &i32| *k != 1; // This will result in a false match on an existing key","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |k: &i32| *k != 1;","    let result = builder.from_hash(hash, is_match);","    assert!(matches!(result, RawEntryMut::Vacant(RawVacantEntryMut { map, hash_builder: _ })));","}"],[286,287,288,289,290,291,292,298,299,300,301,303]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64; // Assuming this hash corresponds to the key `1`","    let is_match = |k: &i32| *k != 1; // This will result in a false match on an existing key","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |k: &i32| *k != 1;","    let result = builder.from_hash(hash, is_match);","    assert!(map.core.entries.len() == 1);","}"],[286,287,288,289,290,291,292,298,299,300,301,303]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64; // Assuming this hash corresponds to the key `1`","    let is_match = |k: &i32| *k != 1; // This will result in a false match on an existing key","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |k: &i32| *k != 1;","    let result = builder.from_hash(hash, is_match);","    assert!(map.core.indices.is_empty());","}"],[286,287,288,289,290,291,292,298,299,300,301,303]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |_: &i32| false;","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |_: &i32| false;","    let result = builder.from_hash(hash, is_match);","    assert!(matches!(result, RawEntryMut::Vacant(_)));","}"],[]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |_: &i32| false;","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |_: &i32| false;","    let result = builder.from_hash(hash, is_match);","    assert!(if let RawEntryMut::Vacant(entry) = result { entry.map.entries.is_empty() } else { false });","}"],[]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 3u64;","    let is_match = |_: &i32| false;","    let result = builder.from_hash(hash, is_match);","    let map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    assert!(matches!(result, RawEntryMut::Vacant(_)));","}"],[]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64; // Assuming this hash corresponds to the key `1`","    let is_match = |k: &i32| *k != 1; // This will result in a false match on an existing key","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |k: &i32| *k != 1;","    let result = builder.from_hash(hash, is_match);","    assert!(matches!(result, RawEntryMut::Vacant(_)));","}"],[]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64; // Assuming this hash corresponds to the key `1`","    let is_match = |k: &i32| *k != 1; // This will result in a false match on an existing key","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |k: &i32| *k != 1;","    let result = builder.from_hash(hash, is_match);","    assert!(matches!(result, RawEntryMut::Vacant(RawVacantEntryMut { map, hash_builder: _ })));","}"],[]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64; // Assuming this hash corresponds to the key `1`","    let is_match = |k: &i32| *k != 1; // This will result in a false match on an existing key","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |k: &i32| *k != 1;","    let result = builder.from_hash(hash, is_match);","    assert!(map.core.entries.len() == 1);","}"],[]],[["{","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64; // Assuming this hash corresponds to the key `1`","    let is_match = |k: &i32| *k != 1; // This will result in a false match on an existing key","    let result = builder.from_hash(hash, is_match);","    let mut map: IndexMap<i32, i32, std::collections::hash_map::RandomState> = IndexMap::new();","    map.insert(1, 10);","    let builder = RawEntryBuilderMut { map: &mut map };","    let hash = 1u64;","    let is_match = |k: &i32| *k != 1;","    let result = builder.from_hash(hash, is_match);","    assert!(map.core.indices.is_empty());","}"],[]]]}