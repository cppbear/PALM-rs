{"function_name":"indexmap::set::set::IndexSet<T, S>::swap_remove_full","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/set.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":26,"tests_lines":[34,34,34,34,34,34,34,38,38,38,38,38,36,36,36,36,38,38,34,34,35,35,36,36,37,37],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":26,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":26,"tests_passed":26,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[778,779,780,781,782,783],"codes_lines_covered":[[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert!(result.is_some());","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(result.unwrap().0, 499);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(result.unwrap().1, 500);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert!(!set.elements.contains(&value_to_remove));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements.len(), 999);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements[499], 1000);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 1001;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 1001;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(result, None);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 {","    set.elements.push(i);","    }","    let value_to_remove = 1;","    let result = set.swap_remove_full(&value_to_remove);","    assert!(result.is_some());","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 {","    set.elements.push(i);","    }","    let value_to_remove = 1;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(result.unwrap(), (0, 1));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 {","    set.elements.push(i);","    }","    let value_to_remove = 1;","    let result = set.swap_remove_full(&value_to_remove);","    assert!(!set.elements.contains(&1));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 {","    set.elements.push(i);","    }","    let value_to_remove = 1;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements.len(), 999);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 {","    set.elements.push(i);","    }","    let value_to_remove = 1;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements[0], 1000);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(result, Some((999, 1000)));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements.len(), 999);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    assert!(!set.elements.contains(&1000));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements.last(), Some(&999));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    let value_to_remove_nonexistent = 1001;","    let result_nonexistent = set.swap_remove_full(&value_to_remove_nonexistent);","    assert_eq!(result_nonexistent, None);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    let value_to_remove_nonexistent = 1001;","    let result_nonexistent = set.swap_remove_full(&value_to_remove_nonexistent);","    assert_eq!(set.elements.len(), 999);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    assert_eq!(result, Some((0, 1)));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    assert_eq!(set.elements, vec![3, 2]);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    assert_eq!(result, Some((1, 2)));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    assert_eq!(set.elements, vec![3]);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    let result = set.swap_remove_full(&3);","    assert_eq!(result, Some((0, 3)));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    let result = set.swap_remove_full(&3);","    assert!(set.elements.is_empty());","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    let result = set.swap_remove_full(&3);","    let result = set.swap_remove_full(&4);","    assert_eq!(result, None);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    let result = set.swap_remove_full(&3);","    let result = set.swap_remove_full(&4);","    assert!(set.elements.is_empty());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert!(result.is_some());","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(result.unwrap().0, 499);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(result.unwrap().1, 500);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert!(!set.elements.contains(&value_to_remove));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements.len(), 999);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 500;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements[499], 1000);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 1001;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.extend(1..=1000);","    let value_to_remove = 1001;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(result, None);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 {","    set.elements.push(i);","    }","    let value_to_remove = 1;","    let result = set.swap_remove_full(&value_to_remove);","    assert!(result.is_some());","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 {","    set.elements.push(i);","    }","    let value_to_remove = 1;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(result.unwrap(), (0, 1));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 {","    set.elements.push(i);","    }","    let value_to_remove = 1;","    let result = set.swap_remove_full(&value_to_remove);","    assert!(!set.elements.contains(&1));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 {","    set.elements.push(i);","    }","    let value_to_remove = 1;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements.len(), 999);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 {","    set.elements.push(i);","    }","    let value_to_remove = 1;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements[0], 1000);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(result, Some((999, 1000)));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements.len(), 999);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    assert!(!set.elements.contains(&1000));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    assert_eq!(set.elements.last(), Some(&999));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    let value_to_remove_nonexistent = 1001;","    let result_nonexistent = set.swap_remove_full(&value_to_remove_nonexistent);","    assert_eq!(result_nonexistent, None);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    for i in 1..=1000 {","        set.elements.push(i);","    }","    let value_to_remove = 1000;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    for i in 1..=1000 { set.elements.push(i); }","    let value_to_remove = 1000;","    let result = set.swap_remove_full(&value_to_remove);","    let value_to_remove_nonexistent = 1001;","    let result_nonexistent = set.swap_remove_full(&value_to_remove_nonexistent);","    assert_eq!(set.elements.len(), 999);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    assert_eq!(result, Some((0, 1)));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    assert_eq!(set.elements, vec![3, 2]);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    assert_eq!(result, Some((1, 2)));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    assert_eq!(set.elements, vec![3]);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    let result = set.swap_remove_full(&3);","    assert_eq!(result, Some((0, 3)));","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    let result = set.swap_remove_full(&3);","    assert!(set.elements.is_empty());","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    let result = set.swap_remove_full(&3);","    let result = set.swap_remove_full(&4);","    assert_eq!(result, None);","}"],[]],[["{","    struct TestSet {","        elements: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { elements: vec![] }","        }","","        fn swap_remove_full(&mut self, value: &i32) -> Option<(usize, i32)> {","            if let Some(pos) = self.elements.iter().position(|x| x == value) {","                let last = self.elements.pop().unwrap();","                if pos != self.elements.len() {","                    self.elements[pos] = last;","                }","                Some((pos, value.clone()))","            } else {","                None","            }","        }","    }","","    let mut set = TestSet::new();","    let value_to_remove = 1;","","    let result = set.swap_remove_full(&value_to_remove);","    let mut set = TestSet::new();","    set.elements.push(1);","    set.elements.push(2);","    set.elements.push(3);","    let result = set.swap_remove_full(&1);","    let result = set.swap_remove_full(&2);","    let result = set.swap_remove_full(&3);","    let result = set.swap_remove_full(&4);","    assert!(set.elements.is_empty());","}"],[]]]}