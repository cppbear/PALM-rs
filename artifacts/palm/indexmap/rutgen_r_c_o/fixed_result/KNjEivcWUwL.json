{"function_name":"indexmap::map::map::IndexMap<K, V, S>::swap_remove","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":23,"tests_lines":[34,34,34,34,34,37,39,38,38,38,38,35,35,35,36,36,37,35,36,36,31,36,43],"oracles":7,"oracles_compiled":1,"oracles_compiled_rate":14.285714285714285,"tests_compiled":1,"tests_compiled_rate":4.3478260869565215,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[860,861,862,863,864,865],"codes_lines_covered":[[["{","#[derive(Debug)]","struct TestKey(String);","","#[derive(Debug)]","   #[derive(PartialEq)]  ","   struct TestValue(i32);  "," ","impl Hash for TestKey {","    fn hash<H: Hasher>(&self, state: &mut H) {","        self.0.hash(state);","    }","}","","impl PartialEq for TestKey {","    fn eq(&self, other: &Self) -> bool {","        self.0 == other.0","    }","}","","impl Eq for TestKey {}","","// impl Equivalent<TestKey> for TestKey {  ","//     fn equivalent(&self, other: &TestKey) -> bool {  ","//         self.eq(other)  ","//     }  ","// }  ","    let mut map = IndexMap::<TestKey, TestValue, RandomState>::new();","    map.insert(TestKey(\"key1\".into()), TestValue(1));","    map.insert(TestKey(\"key2\".into()), TestValue(2));","    map.insert(TestKey(\"key3\".into()), TestValue(3));","    let _ = map.swap_remove(&TestKey(\"key2\".into()));","    let mut map = IndexMap::<TestKey, TestValue, RandomState>::new();","    map.insert(TestKey(\"key1\".into()), TestValue(1));","    map.insert(TestKey(\"key2\".into()), TestValue(2));","    map.insert(TestKey(\"key3\".into()), TestValue(3));","    let removed_value = map.swap_remove(&TestKey(\"key2\".into()));","    assert_eq!(removed_value, Some(TestValue(2)));","}"],[860,861,862,863,864,865]]],"codes_branches":[],"codes_branches_covered":[[["{","#[derive(Debug)]","struct TestKey(String);","","#[derive(Debug)]","   #[derive(PartialEq)]  ","   struct TestValue(i32);  "," ","impl Hash for TestKey {","    fn hash<H: Hasher>(&self, state: &mut H) {","        self.0.hash(state);","    }","}","","impl PartialEq for TestKey {","    fn eq(&self, other: &Self) -> bool {","        self.0 == other.0","    }","}","","impl Eq for TestKey {}","","// impl Equivalent<TestKey> for TestKey {  ","//     fn equivalent(&self, other: &TestKey) -> bool {  ","//         self.eq(other)  ","//     }  ","// }  ","    let mut map = IndexMap::<TestKey, TestValue, RandomState>::new();","    map.insert(TestKey(\"key1\".into()), TestValue(1));","    map.insert(TestKey(\"key2\".into()), TestValue(2));","    map.insert(TestKey(\"key3\".into()), TestValue(3));","    let _ = map.swap_remove(&TestKey(\"key2\".into()));","    let mut map = IndexMap::<TestKey, TestValue, RandomState>::new();","    map.insert(TestKey(\"key1\".into()), TestValue(1));","    map.insert(TestKey(\"key2\".into()), TestValue(2));","    map.insert(TestKey(\"key3\".into()), TestValue(3));","    let removed_value = map.swap_remove(&TestKey(\"key2\".into()));","    assert_eq!(removed_value, Some(TestValue(2)));","}"],[]]]}