{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::retain_in_order","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":48,"tests_lines":[15,18,18,18,18,18,18,19,19,19,19,19,19,15,15,15,15,10,10,11,11,10,10,10,10,10,10,10,10,14,14,14,14,14,14,14,12,12,12,12,12,12,12,12,12,12,12,12],"oracles":10,"oracles_compiled":9,"oracles_compiled_rate":90.0,"tests_compiled":39,"tests_compiled_rate":81.25,"oracles_run":9,"oracles_passed":9,"oracles_passed_rate":100.0,"tests_run":39,"tests_passed":25,"tests_passed_rate":64.1025641025641,"lines":10,"lines_covered":9,"lines_coveraged_rate":90.0,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[497,498,499,500,501,502,503,504,505,506],"codes_lines_covered":[[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   ","  map.retain_in_order(|key, _value| {  ","      *key % 2 == 0 // Keep only even keys  ","  });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   assert_eq!(map.entries.len(), 2);","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   ","  map.retain_in_order(|key, _value| {  ","      *key % 2 == 0 // Keep only even keys  ","  });  ","  let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  map.indices = Indices::with_capacity(2);  ","  map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  map.retain_in_order(|key, _value| {  ","  *key % 2 == 0  ","  });  ","  assert_eq!(map.entries.len(), 1);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   ","  map.retain_in_order(|key, _value| {  ","      *key % 2 == 0 // Keep only even keys  ","  });  ","  let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  map.indices = Indices::with_capacity(2);  ","  map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  map.retain_in_order(|key, _value| {  ","  *key % 2 == 0  ","   });  ","   assert_eq!(map.entries[0].key, 2);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   ","  map.retain_in_order(|key, _value| {  ","      *key % 2 == 0 // Keep only even keys  ","  });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  map.retain_in_order(|key, _value| {  ","  *key % 2 == 0  ","  });  ","   assert_eq!(map.entries[0].value, 20);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   ","   map.retain_in_order(|key, value| {  ","       *key % 2 == 0 // Keep only even keys  ","   });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.retain_in_order(|key, value| {  ","   *key % 2 == 0  ","   });  ","   assert!(map.indices.len() > map.entries.len());  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(3);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.","   map.retain_in_order(|key, value| {","       *key < 2 // Keep keys less than 2","   });","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(3);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   assert_eq!(map.entries.len(), 3);","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","  map.retain_in_order(|key, _value| {  ","      *key < 2 // Keep keys less than 2  ","  });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  map.retain_in_order(|key, _value| { *key < 2 });  ","   assert_eq!(map.entries.len(), 2);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","  map.retain_in_order(|key, _value| {  ","      *key < 2 // Keep keys less than 2  ","  });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  map.retain_in_order(|key, _value| { *key < 2 });  ","  assert_eq!(map.entries[0].key, 1);  ","}  "],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","   map.retain_in_order(|key, value| {  ","       *key < 2 // Keep keys less than 2  ","   });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   map.retain_in_order(|key, value| { *key < 2 });  ","   assert_eq!(map.entries[1].key, 2);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","   map.retain_in_order(|key, value| {  ","       *key < 2 // Keep keys less than 2  ","   });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   map.retain_in_order(|key, value| { *key < 2 });  ","   assert!(map.entries.iter().all(|entry| entry.key < 2));  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","  map.retain_in_order(|key, _value| {  ","      *key < 2 // Keep keys less than 2  ","  });  ","  let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  map.indices = Indices::with_capacity(3);  ","  map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  map.retain_in_order(|key, _value| { *key < 2 });  ","   assert!(map.indices.len() > map.entries.len());  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","  map.retain_in_order(|key, _value| {  ","      *key < 2 // Keep keys less than 2  ","  });  ","  let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  map.indices = Indices::with_capacity(3);  ","  map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  map.retain_in_order(|key, _value| { *key < 2 });  ","  assert!(map.entries.len() < map.indices.len());  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });  ","   ","   map.retain_in_order(|key, value| {  ","       *key == 1 // Keep only the key 1  ","   });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });  ","   assert_eq!(map.entries.len(), 1);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","   ","   map.retain_in_order(|key, value| {","       *key == 1 // Keep only the key 1","   });","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","    assert_eq!(map.entries[0].key, 1);","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","   ","  map.retain_in_order(|key, _value| {","      *key == 1 // Keep only the key 1","  });","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","   assert_eq!(map.entries[0].value, 100);","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","   ","  map.retain_in_order(|key, _value| {","      *key == 1 // Keep only the key 1","  });","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","   assert!(map.indices.len() > map.entries.len());","}"],[497,498,499,500,501,502,503,505,506]],[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    // This will not panic because there are no entries.","    map.retain_in_order(|_key, _value| true);","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    map.entries = Vec::new();","    assert_eq!(map.entries.len(), 0);","}"],[497,498,499,500,501,502,503,505,506]],[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    // This will not panic because there are no entries.","    map.retain_in_order(|_key, _value| true);","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    map.entries = Vec::new();","    assert_eq!(map.indices.capacity(), 1);","}"],[497,498,499,500,501,502,503,505,506]],[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    // This will not panic because there are no entries.","    map.retain_in_order(|_key, _value| true);","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    map.entries = Vec::new();","    map.retain_in_order(|_key, _value| true);","    assert_eq!(map.entries.len(), 0);","}"],[497,498,499,500,501,502,503,505,506]],[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    // This will not panic because there are no entries.","    map.retain_in_order(|_key, _value| true);","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    map.entries = Vec::new();","    map.retain_in_order(|_key, _value| true);","    assert_eq!(map.indices.capacity(), 1);","}"],[497,498,499,500,501,502,503,505,506]],[["{","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    index_map.retain_in_order(|_, _| true);","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    assert_eq!(index_map.len(), 0);","}"],[497,498,499,500,501,502,503,505,506]],[["{","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    index_map.retain_in_order(|_, _| true);","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    assert_eq!(index_map.capacity(), 0);","}"],[497,498,499,500,501,502,503,505,506]],[["{","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    index_map.retain_in_order(|_, _| true);","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    assert_eq!(index_map.indices.len(), 0);","}"],[497,498,499,500,501,502,503,505,506]],[["{","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    index_map.retain_in_order(|_, _| true);","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    assert_eq!(index_map.entries.len(), 0);","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   assert_eq!(index_map.entries.len(), 1);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   assert_eq!(index_map.indices.len(), 1);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   assert_eq!(index_map.entries[0].key, 1);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   assert_eq!(index_map.entries[0].value, 10);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   assert_eq!(index_map.entries.len(), 3);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   assert_eq!(index_map.indices.len(), 3);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  index_map.retain_in_order(|key, _value| *key != 2);  ","  let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   assert_eq!(index_map.entries.len(), 3);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.indices = Indices::with_capacity(3);","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","  index_map.retain_in_order(|key, _value| *key != 2);  ","  let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   assert_eq!(index_map.indices.len(), 3);","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.indices = Indices::with_capacity(3);","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   index_map.retain_in_order(|key, value| *key != 2);","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.indices = Indices::with_capacity(3);","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   assert!(index_map.entries.iter().any(|entry| entry.key == 1 && entry.value == 10));","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   index_map.retain_in_order(|key, value| *key != 2);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   assert!(index_map.entries.iter().all(|entry| entry.key != 2));  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","  let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  index_map.indices = Indices::with_capacity(3);  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  index_map.retain_in_order(|key, _value| *key != 2);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.indices = Indices::with_capacity(3);","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   assert!(index_map.entries.iter().any(|entry| entry.key == 3 && entry.value == 30));","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   assert_eq!(index_map.entries.len(), 2);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   assert_eq!(index_map.indices.len(), 2);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   assert_eq!(index_map.entries[0].key, 10);  ","}"],[497,498,499,500,501,502,503,505,506]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","  index_map.retain_in_order(|_, _| true);  ","  let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  index_map.indices = Indices::with_capacity(2);  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","  assert_eq!(index_map.entries[0].value, 100);  ","}"],[497,498,499,500,501,502,503,505,506]]],"codes_branches":[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}],"codes_branches_covered":[[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   ","  map.retain_in_order(|key, _value| {  ","      *key % 2 == 0 // Keep only even keys  ","  });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   assert_eq!(map.entries.len(), 2);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   ","  map.retain_in_order(|key, _value| {  ","      *key % 2 == 0 // Keep only even keys  ","  });  ","  let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  map.indices = Indices::with_capacity(2);  ","  map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  map.retain_in_order(|key, _value| {  ","  *key % 2 == 0  ","  });  ","  assert_eq!(map.entries.len(), 1);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   ","  map.retain_in_order(|key, _value| {  ","      *key % 2 == 0 // Keep only even keys  ","  });  ","  let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  map.indices = Indices::with_capacity(2);  ","  map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  map.retain_in_order(|key, _value| {  ","  *key % 2 == 0  ","   });  ","   assert_eq!(map.entries[0].key, 2);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   ","  map.retain_in_order(|key, _value| {  ","      *key % 2 == 0 // Keep only even keys  ","  });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  map.retain_in_order(|key, _value| {  ","  *key % 2 == 0  ","  });  ","   assert_eq!(map.entries[0].value, 20);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   ","   map.retain_in_order(|key, value| {  ","       *key % 2 == 0 // Keep only even keys  ","   });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.retain_in_order(|key, value| {  ","   *key % 2 == 0  ","   });  ","   assert!(map.indices.len() > map.entries.len());  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(3);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.","   map.retain_in_order(|key, value| {","       *key < 2 // Keep keys less than 2","   });","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(3);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   assert_eq!(map.entries.len(), 3);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","  map.retain_in_order(|key, _value| {  ","      *key < 2 // Keep keys less than 2  ","  });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  map.retain_in_order(|key, _value| { *key < 2 });  ","   assert_eq!(map.entries.len(), 2);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","  map.retain_in_order(|key, _value| {  ","      *key < 2 // Keep keys less than 2  ","  });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  map.retain_in_order(|key, _value| { *key < 2 });  ","  assert_eq!(map.entries[0].key, 1);  ","}  "],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","   map.retain_in_order(|key, value| {  ","       *key < 2 // Keep keys less than 2  ","   });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   map.retain_in_order(|key, value| { *key < 2 });  ","   assert_eq!(map.entries[1].key, 2);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","   map.retain_in_order(|key, value| {  ","       *key < 2 // Keep keys less than 2  ","   });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   map.retain_in_order(|key, value| { *key < 2 });  ","   assert!(map.entries.iter().all(|entry| entry.key < 2));  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","  map.retain_in_order(|key, _value| {  ","      *key < 2 // Keep keys less than 2  ","  });  ","  let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  map.indices = Indices::with_capacity(3);  ","  map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  map.retain_in_order(|key, _value| { *key < 2 });  ","   assert!(map.indices.len() > map.entries.len());  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(3);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   ","   // This will not panic since self.entries.len() < self.indices.len() is true.  ","  map.retain_in_order(|key, _value| {  ","      *key < 2 // Keep keys less than 2  ","  });  ","  let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  map.indices = Indices::with_capacity(3);  ","  map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  map.retain_in_order(|key, _value| { *key < 2 });  ","  assert!(map.entries.len() < map.indices.len());  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });  ","   ","   map.retain_in_order(|key, value| {  ","       *key == 1 // Keep only the key 1  ","   });  ","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   map.indices = Indices::with_capacity(2);  ","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });  ","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });  ","   assert_eq!(map.entries.len(), 1);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","   ","   map.retain_in_order(|key, value| {","       *key == 1 // Keep only the key 1","   });","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","    assert_eq!(map.entries[0].key, 1);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","   ","  map.retain_in_order(|key, _value| {","      *key == 1 // Keep only the key 1","  });","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","   assert_eq!(map.entries[0].value, 100);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","   ","  map.retain_in_order(|key, _value| {","      *key == 1 // Keep only the key 1","  });","   let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","   map.indices = Indices::with_capacity(2);","   map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 100 });","   map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 200 });","   assert!(map.indices.len() > map.entries.len());","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    // This will not panic because there are no entries.","    map.retain_in_order(|_key, _value| true);","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    map.entries = Vec::new();","    assert_eq!(map.entries.len(), 0);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    // This will not panic because there are no entries.","    map.retain_in_order(|_key, _value| true);","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    map.entries = Vec::new();","    assert_eq!(map.indices.capacity(), 1);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    // This will not panic because there are no entries.","    map.retain_in_order(|_key, _value| true);","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    map.entries = Vec::new();","    map.retain_in_order(|_key, _value| true);","    assert_eq!(map.entries.len(), 0);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    // This will not panic because there are no entries.","    map.retain_in_order(|_key, _value| true);","    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();","    map.indices = Indices::with_capacity(1);","    map.entries = Vec::new();","    map.retain_in_order(|_key, _value| true);","    assert_eq!(map.indices.capacity(), 1);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    index_map.retain_in_order(|_, _| true);","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    assert_eq!(index_map.len(), 0);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    index_map.retain_in_order(|_, _| true);","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    assert_eq!(index_map.capacity(), 0);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    index_map.retain_in_order(|_, _| true);","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    assert_eq!(index_map.indices.len(), 0);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    index_map.retain_in_order(|_, _| true);","    let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","    index_map.indices = Indices::with_capacity(0);","    index_map.entries = Vec::new();","    assert_eq!(index_map.entries.len(), 0);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   assert_eq!(index_map.entries.len(), 1);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   assert_eq!(index_map.indices.len(), 1);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   assert_eq!(index_map.entries[0].key, 1);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(1);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   assert_eq!(index_map.entries[0].value, 10);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   assert_eq!(index_map.entries.len(), 3);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   assert_eq!(index_map.indices.len(), 3);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  index_map.retain_in_order(|key, _value| *key != 2);  ","  let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   assert_eq!(index_map.entries.len(), 3);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.indices = Indices::with_capacity(3);","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","  index_map.retain_in_order(|key, _value| *key != 2);  ","  let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   assert_eq!(index_map.indices.len(), 3);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.indices = Indices::with_capacity(3);","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   index_map.retain_in_order(|key, value| *key != 2);","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.indices = Indices::with_capacity(3);","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   assert!(index_map.entries.iter().any(|entry| entry.key == 1 && entry.value == 10));","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   index_map.retain_in_order(|key, value| *key != 2);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(3);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","   assert!(index_map.entries.iter().all(|entry| entry.key != 2));  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","  let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  index_map.indices = Indices::with_capacity(3);  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });  ","  index_map.retain_in_order(|key, _value| *key != 2);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();","   index_map.indices = Indices::with_capacity(3);","   index_map.entries.push(Bucket { hash: HashValue(0), key: 1, value: 10 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 2, value: 20 });","   index_map.entries.push(Bucket { hash: HashValue(0), key: 3, value: 30 });","   assert!(index_map.entries.iter().any(|entry| entry.key == 3 && entry.value == 30));","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   assert_eq!(index_map.entries.len(), 2);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   assert_eq!(index_map.indices.len(), 2);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   index_map.retain_in_order(|_, _| true);  ","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","   index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","   assert_eq!(index_map.entries[0].key, 10);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]],[["{","   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","   index_map.indices = Indices::with_capacity(2);  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","  index_map.retain_in_order(|_, _| true);  ","  let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ","  index_map.indices = Indices::with_capacity(2);  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 100 });  ","  index_map.entries.push(Bucket { hash: HashValue(0), key: 10, value: 200 });  ","  assert_eq!(index_map.entries[0].value, 100);  ","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":true}]]]}