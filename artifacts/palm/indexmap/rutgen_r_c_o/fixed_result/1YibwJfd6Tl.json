{"function_name":"indexmap::set::set::IndexSet<T, S>::splice","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/set.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":23,"tests_lines":[9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,11,11,11,9,9,8,9],"oracles":9,"oracles_compiled":4,"oracles_compiled_rate":44.44444444444444,"tests_compiled":8,"tests_compiled_rate":34.78260869565217,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":8,"tests_passed":7,"tests_passed_rate":87.5,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[592,593,594,595,596,597,598],"codes_lines_covered":[[["{","   let mut set = super::IndexSet::from([1, 2, 3, 4]);","   let new: Vec<i32> = Vec::new();","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(1..3, new);","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new: Vec<i32> = Vec::new();","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(1..3, new);","   assert_eq!(_removed.collect::<Vec<_>>(), vec![2, 3]);","}"],[592,593,594,595,596,597,598]],[["{","   let mut set = super::IndexSet::from([1, 2, 3, 4]);","   let new = vec![2, 3];","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(1..3, new);","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new = vec![2, 3];","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(1..3, new);","  assert_eq!(_removed.collect::<Vec<_>>(), vec![2, 3]);","}"],[592,593,594,595,596,597,598]],[["{","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let _new = vec![5, 6, 7, 8];","","","","","    assert_eq!(set.len(), 4);","}"],[]],[["{","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new = vec![5, 6, 7, 8];","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(0..4, new);","  std::mem::drop(_removed);","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new = vec![5, 6, 7, 8];","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(0..4, new);","}"],[592,593,594,595,596,597,598]],[["{","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new = vec![5, 6, 7, 8];","  let _removed: super::Splice<_, i32, std::collections::hash_map::RandomState> = set.splice(0..4, new);","  drop(_removed); // Make sure the mutable borrow ends here","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new = vec![5, 6, 7, 8];","   assert!(set.splice(0..4, new).collect::<Vec<_>>().contains(&8));","}"],[592,593,594,595,596,597,598]],[["{"," let mut set = super::IndexSet::from([1, 2, 3, 4]);"," let new = vec![5, 6, 7, 8];"," set.splice(0..4, new);"," let mut set = super::IndexSet::from([1, 2, 3, 4]);"," let new = vec![5, 6, 7, 8];"," set.splice(0..4, new);","  assert!(!set.contains(&2));","}"],[592,593,594,595,596,597,598]],[["{","   let mut set = super::IndexSet::from([1, 2, 3, 4]);","   let new = vec![5, 6];","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(3..1, new);","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new: Vec<i32> = vec![5, 6];","  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","      set.splice(3..3, new); // Adjusted the range to avoid panic","  }));","  assert!(result.is_ok()); // Check that the operation now completes without error","}"],[592,593,594,595,596,597,598]],[["{","  let mut set = super::IndexSet::from([1, 2, 3, 4]);  ","  let new = vec![5, 6];  ","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(3..1, new);  ","  let mut set = super::IndexSet::from([1, 2, 3, 4]);  ","  let new = vec![5, 6];  ","  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {  ","  set.splice(3..1, new);  ","  }));  ","  assert_eq!(result.unwrap_err().downcast_ref::<&str>(), Some(&\"panicked due to start greater than end\"));  ","}"],[592,593,594,595,596,597,598]]],"codes_branches":[],"codes_branches_covered":[[["{","   let mut set = super::IndexSet::from([1, 2, 3, 4]);","   let new: Vec<i32> = Vec::new();","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(1..3, new);","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new: Vec<i32> = Vec::new();","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(1..3, new);","   assert_eq!(_removed.collect::<Vec<_>>(), vec![2, 3]);","}"],[]],[["{","   let mut set = super::IndexSet::from([1, 2, 3, 4]);","   let new = vec![2, 3];","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(1..3, new);","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new = vec![2, 3];","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(1..3, new);","  assert_eq!(_removed.collect::<Vec<_>>(), vec![2, 3]);","}"],[]],[["{","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let _new = vec![5, 6, 7, 8];","","","","","    assert_eq!(set.len(), 4);","}"],[]],[["{","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new = vec![5, 6, 7, 8];","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(0..4, new);","  std::mem::drop(_removed);","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new = vec![5, 6, 7, 8];","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(0..4, new);","}"],[]],[["{","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new = vec![5, 6, 7, 8];","  let _removed: super::Splice<_, i32, std::collections::hash_map::RandomState> = set.splice(0..4, new);","  drop(_removed); // Make sure the mutable borrow ends here","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new = vec![5, 6, 7, 8];","   assert!(set.splice(0..4, new).collect::<Vec<_>>().contains(&8));","}"],[]],[["{"," let mut set = super::IndexSet::from([1, 2, 3, 4]);"," let new = vec![5, 6, 7, 8];"," set.splice(0..4, new);"," let mut set = super::IndexSet::from([1, 2, 3, 4]);"," let new = vec![5, 6, 7, 8];"," set.splice(0..4, new);","  assert!(!set.contains(&2));","}"],[]],[["{","   let mut set = super::IndexSet::from([1, 2, 3, 4]);","   let new = vec![5, 6];","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(3..1, new);","  let mut set = super::IndexSet::from([1, 2, 3, 4]);","  let new: Vec<i32> = vec![5, 6];","  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","      set.splice(3..3, new); // Adjusted the range to avoid panic","  }));","  assert!(result.is_ok()); // Check that the operation now completes without error","}"],[]],[["{","  let mut set = super::IndexSet::from([1, 2, 3, 4]);  ","  let new = vec![5, 6];  ","  let _removed: super::Splice<'_, _, i32, std::collections::hash_map::RandomState> = set.splice(3..1, new);  ","  let mut set = super::IndexSet::from([1, 2, 3, 4]);  ","  let new = vec![5, 6];  ","  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {  ","  set.splice(3..1, new);  ","  }));  ","  assert_eq!(result.unwrap_err().downcast_ref::<&str>(), Some(&\"panicked due to start greater than end\"));  ","}"],[]]]}