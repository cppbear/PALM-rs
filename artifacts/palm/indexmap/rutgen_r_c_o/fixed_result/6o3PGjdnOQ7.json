{"function_name":"indexmap::set::set::IndexSet<T, S>::drain","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/set.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":22,"tests_lines":[13,13,14,14,14,14,14,14,15,11,11,12,12,7,8,8,14,10,9,9,9,9],"oracles":6,"oracles_compiled":3,"oracles_compiled_rate":50.0,"tests_compiled":10,"tests_compiled_rate":45.45454545454545,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":10,"tests_passed":9,"tests_passed_rate":90.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[254,255,256,257,258,259],"codes_lines_covered":[[["{","   let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());  ","   set.insert(1);  ","   set.insert(2);  ","   set.insert(3);  ","   ","   let _drain = set.drain(0..2);  ","   let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());  ","   set.insert(1);  ","   set.insert(2);  ","   set.insert(3);  ","   assert_eq!(set.len(), 3);  ","}"],[254,255,256,257,258,259]],[["   {  ","       let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());  ","       set.insert(1);  ","       set.insert(2);  ","       set.insert(3);  ","       ","       let _drain = set.drain(0..2);  ","       let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());  ","       set.insert(1);  ","       set.insert(2);  ","       set.insert(3);  ","       assert!(!set.is_empty());  ","}"],[254,255,256,257,258,259]],[["{","  let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());","  set.insert(1);","  set.insert(2);","  set.insert(3);","  ","  let _drain = set.drain(0..2);","  // Create a new variable for the second set to avoid conflicts.","  let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());","  set2.insert(1);","  set2.insert(2);","  set2.insert(3);","  let _drain2 = set2.drain(0..2);","}"],[254,255,256,257,258,259]],[["{","  let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());","  set.insert(1);","  set.insert(2);","  set.insert(3);","  ","  let _drain = set.drain(0..2);","  drop(_drain); // Explicitly drop drain to release mutable borrow","  let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());","  set.insert(1);","  set.insert(2);","  set.insert(3);","  assert!(set.try_reserve(2).is_ok());","}"],[254,255,256,257,258,259]],[["{","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1);","   set.insert(2);","   ","   let _drain = set.drain(..);","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1);","   set.insert(2);","   assert!(!set.is_empty());","}"],[254,255,256,257,258,259]],[["{","  let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","  set.insert(1);  ","  set.insert(2);  ","  ","  let _drain = set.drain(..);  ","  drop(_drain);  ","  let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","  set.insert(1);  ","  set.insert(2);  ","  assert!(set.is_empty());  ","}"],[254,255,256,257,258,259]],[["{","    let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1); // Use the insert method to add the item","   ","   let _drain = set.drain(0..1);","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1); // Use the insert method to add the item","    assert_eq!(set.len(), 1);","}"],[254,255,256,257,258,259]],[["{","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","   set.insert(1);  ","   ","   let _drain = set.drain(0..1);  ","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","   set.insert(1);  ","   assert!(set.is_empty() == false);  ","}"],[254,255,256,257,258,259]],[["{","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1); // Use insert method instead of accessing private fields","   ","   let _drain = set.drain(0..1);","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1); // Use insert method instead of accessing private fields","    assert_eq!(_drain.as_slice().len(), 1);","}"],[254,255,256,257,258,259]],[["{","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","   set.insert(1);  ","   ","   let _drain = set.drain(0..1);  ","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","   set.insert(1);  ","   assert_eq!(set.capacity(), 3);  ","}"],[254,255,256,257,258,259]]],"codes_branches":[],"codes_branches_covered":[[["{","   let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());  ","   set.insert(1);  ","   set.insert(2);  ","   set.insert(3);  ","   ","   let _drain = set.drain(0..2);  ","   let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());  ","   set.insert(1);  ","   set.insert(2);  ","   set.insert(3);  ","   assert_eq!(set.len(), 3);  ","}"],[]],[["   {  ","       let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());  ","       set.insert(1);  ","       set.insert(2);  ","       set.insert(3);  ","       ","       let _drain = set.drain(0..2);  ","       let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());  ","       set.insert(1);  ","       set.insert(2);  ","       set.insert(3);  ","       assert!(!set.is_empty());  ","}"],[]],[["{","  let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());","  set.insert(1);","  set.insert(2);","  set.insert(3);","  ","  let _drain = set.drain(0..2);","  // Create a new variable for the second set to avoid conflicts.","  let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());","  set2.insert(1);","  set2.insert(2);","  set2.insert(3);","  let _drain2 = set2.drain(0..2);","}"],[]],[["{","  let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());","  set.insert(1);","  set.insert(2);","  set.insert(3);","  ","  let _drain = set.drain(0..2);","  drop(_drain); // Explicitly drop drain to release mutable borrow","  let mut set = IndexSet::with_capacity_and_hasher(5, RandomState::new());","  set.insert(1);","  set.insert(2);","  set.insert(3);","  assert!(set.try_reserve(2).is_ok());","}"],[]],[["{","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1);","   set.insert(2);","   ","   let _drain = set.drain(..);","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1);","   set.insert(2);","   assert!(!set.is_empty());","}"],[]],[["{","  let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","  set.insert(1);  ","  set.insert(2);  ","  ","  let _drain = set.drain(..);  ","  drop(_drain);  ","  let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","  set.insert(1);  ","  set.insert(2);  ","  assert!(set.is_empty());  ","}"],[]],[["{","    let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1); // Use the insert method to add the item","   ","   let _drain = set.drain(0..1);","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1); // Use the insert method to add the item","    assert_eq!(set.len(), 1);","}"],[]],[["{","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","   set.insert(1);  ","   ","   let _drain = set.drain(0..1);  ","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","   set.insert(1);  ","   assert!(set.is_empty() == false);  ","}"],[]],[["{","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1); // Use insert method instead of accessing private fields","   ","   let _drain = set.drain(0..1);","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());","   set.insert(1); // Use insert method instead of accessing private fields","    assert_eq!(_drain.as_slice().len(), 1);","}"],[]],[["{","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","   set.insert(1);  ","   ","   let _drain = set.drain(0..1);  ","   let mut set = IndexSet::with_capacity_and_hasher(3, RandomState::new());  ","   set.insert(1);  ","   assert_eq!(set.capacity(), 3);  ","}"],[]]]}