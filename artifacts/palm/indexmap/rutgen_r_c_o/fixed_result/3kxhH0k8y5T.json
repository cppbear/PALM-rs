{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::borrow_mut","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":23,"tests_lines":[7,7,7,7,7,7,10,14,15,15,15,16,17,17,10,10,15,15,15,11,17,18,19],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":12,"tests_compiled_rate":52.17391304347826,"oracles_run":6,"oracles_passed":3,"oracles_passed_rate":50.0,"tests_run":12,"tests_passed":4,"tests_passed_rate":33.33333333333333,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[152,153,154],"codes_lines_covered":[[["{","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::new();  ","   let _ref_mut = index_map.borrow_mut();  ","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::new();  ","   let _ref_mut = index_map.borrow_mut();  ","   assert_eq!(index_map.entries.len(), 0);  ","}"],[152,153,154]],[["{","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);  ","   let _ref_mut = index_map.borrow_mut();  ","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);  ","   let _ref_mut = index_map.borrow_mut();  ","   assert_eq!(index_map.indices.len(), 0);  ","}"],[152,153,154]],[["{","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);","   let _ref_mut = index_map.borrow_mut();","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);","   let _ref_mut = index_map.borrow_mut();","   assert!(index_map.borrow_mut().indices.is_empty());","}"],[152,153,154]],[["{","   let mut index_map = IndexMapCore::new();","   for i in 0..5 {","       let hash = HashValue(i as usize); // Use the tuple struct constructor directly","       index_map.push_entry(hash, i, i);","   }","   let _ref_mut = index_map.borrow_mut();","   let mut index_map = IndexMapCore::new();","   for i in 0..5 {","       let hash = HashValue(i as usize); // Use the tuple struct constructor directly","       index_map.push_entry(hash, i, i);","   }","   assert_eq!(index_map.len(), 5);","}"],[152,153,154]],[["{","   let mut index_map = IndexMapCore::new();","   for i in 0..5 {","       let hash = HashValue(i as usize); // Using the tuple struct constructor","       index_map.push_entry(hash, i, i);","   }","   let _ref_mut = index_map.borrow_mut();","   let mut index_map = IndexMapCore::new();","   for i in 0..5 {","       let hash = HashValue(i as usize); // Using the tuple struct constructor","       index_map.push_entry(hash, i, i);","   }","   let _ref_mut = index_map.borrow_mut();","   assert!(!_ref_mut.indices.is_empty());","}"],[152,153,154]],[["{","  let mut index_map = IndexMapCore::new();  ","  for i in 0..5 {  ","      let hash = HashValue(i as usize);  ","      index_map.push_entry(hash, i, i);  ","  }  ","  let _ref_mut = index_map.borrow_mut();  ","  let mut index_map = IndexMapCore::new();  ","  for i in 0..5 {  ","      let hash = HashValue(i as usize);  ","      index_map.push_entry(hash, i, i);  ","  }  ","  let _ref_mut = index_map.borrow_mut();  ","  assert!(!_ref_mut.entries.is_empty());  ","}"],[152,153,154]],[["{","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize);","       index_map.push_entry(hash, i, i);","   }","   index_map.clear();","   let _ref_mut = index_map.borrow_mut();","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize);","       index_map.push_entry(hash, i, i);","   }","   assert_eq!(index_map.len(), 3);","}"],[152,153,154]],[["{","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize); // Updated to use tuple struct constructor","       index_map.push_entry(hash, i, i);","   }","   index_map.clear();","   let _ref_mut = index_map.borrow_mut();","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize); // Updated to use tuple struct constructor","       index_map.push_entry(hash, i, i);","   }","   index_map.clear();","   assert_eq!(index_map.len(), 0);","}"],[152,153,154]],[["{","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize);","       index_map.push_entry(hash, i, i);","   }","   index_map.clear();","   let _ref_mut = index_map.borrow_mut();","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize);","       index_map.push_entry(hash, i, i);","   }","   index_map.clear();","   let _ref_mut = index_map.borrow_mut();","          assert!(std::ptr::eq(&*_ref_mut.indices as *const _, &index_map.indices as *const _));  ","}"],[152,153,154]],[["{","  let mut index_map = IndexMapCore::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","  for i in 0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY {","      let hash = HashValue(i);","      index_map.push_entry(hash, i, i);","  }","  let _ref_mut = index_map.borrow_mut();","  let mut index_map = IndexMapCore::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","  let hash_values: Vec<HashValue> = (0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY).map(|i| HashValue(i)).collect();","  for i in 0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY {","      index_map.push_entry(hash_values[i], i, i);","  }","  let ref_mut = index_map.borrow_mut();","   assert!(!ref_mut.indices.is_empty());","}"],[]],[["{","  let mut index_map = IndexMapCore::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","  for i in 0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY {","      let hash = HashValue(i);","      index_map.push_entry(hash, i, i);","  }","  let _ref_mut = index_map.borrow_mut();","  let mut index_map = IndexMapCore::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","  let hash_values: Vec<HashValue> = (0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY).map(|i| HashValue(i)).collect();","   for i in 0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY {","   index_map.push_entry(hash_values[i], i, i);","   }","   let ref_mut = index_map.borrow_mut();","    assert!(!ref_mut.entries.is_empty());","}"],[]],[["{","  let mut index_map = IndexMapCore::new();  ","  for i in 0..3 {  ","      let hash = HashValue(i as usize);  ","      index_map.push_entry(hash, i, i);  ","  }  ","  index_map.drain(0..2);  ","  let _ref_mut = index_map.borrow_mut(); // This might panic depending on how drain is implemented  ","  let mut index_map = IndexMapCore::new();  ","  let hash_0 = HashValue(0);  ","  let hash_1 = HashValue(1);  ","  let hash_2 = HashValue(2);  ","  index_map.push_entry(hash_0, 0, 0);  ","  index_map.push_entry(hash_1, 1, 1);  ","  index_map.push_entry(hash_2, 2, 2);  ","  index_map.drain(0..2);  ","   assert_eq!(index_map.len(), 1);  ","}"],[152,153,154]]],"codes_branches":[],"codes_branches_covered":[[["{","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::new();  ","   let _ref_mut = index_map.borrow_mut();  ","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::new();  ","   let _ref_mut = index_map.borrow_mut();  ","   assert_eq!(index_map.entries.len(), 0);  ","}"],[]],[["{","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);  ","   let _ref_mut = index_map.borrow_mut();  ","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);  ","   let _ref_mut = index_map.borrow_mut();  ","   assert_eq!(index_map.indices.len(), 0);  ","}"],[]],[["{","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);","   let _ref_mut = index_map.borrow_mut();","   let mut index_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);","   let _ref_mut = index_map.borrow_mut();","   assert!(index_map.borrow_mut().indices.is_empty());","}"],[]],[["{","   let mut index_map = IndexMapCore::new();","   for i in 0..5 {","       let hash = HashValue(i as usize); // Use the tuple struct constructor directly","       index_map.push_entry(hash, i, i);","   }","   let _ref_mut = index_map.borrow_mut();","   let mut index_map = IndexMapCore::new();","   for i in 0..5 {","       let hash = HashValue(i as usize); // Use the tuple struct constructor directly","       index_map.push_entry(hash, i, i);","   }","   assert_eq!(index_map.len(), 5);","}"],[]],[["{","   let mut index_map = IndexMapCore::new();","   for i in 0..5 {","       let hash = HashValue(i as usize); // Using the tuple struct constructor","       index_map.push_entry(hash, i, i);","   }","   let _ref_mut = index_map.borrow_mut();","   let mut index_map = IndexMapCore::new();","   for i in 0..5 {","       let hash = HashValue(i as usize); // Using the tuple struct constructor","       index_map.push_entry(hash, i, i);","   }","   let _ref_mut = index_map.borrow_mut();","   assert!(!_ref_mut.indices.is_empty());","}"],[]],[["{","  let mut index_map = IndexMapCore::new();  ","  for i in 0..5 {  ","      let hash = HashValue(i as usize);  ","      index_map.push_entry(hash, i, i);  ","  }  ","  let _ref_mut = index_map.borrow_mut();  ","  let mut index_map = IndexMapCore::new();  ","  for i in 0..5 {  ","      let hash = HashValue(i as usize);  ","      index_map.push_entry(hash, i, i);  ","  }  ","  let _ref_mut = index_map.borrow_mut();  ","  assert!(!_ref_mut.entries.is_empty());  ","}"],[]],[["{","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize);","       index_map.push_entry(hash, i, i);","   }","   index_map.clear();","   let _ref_mut = index_map.borrow_mut();","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize);","       index_map.push_entry(hash, i, i);","   }","   assert_eq!(index_map.len(), 3);","}"],[]],[["{","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize); // Updated to use tuple struct constructor","       index_map.push_entry(hash, i, i);","   }","   index_map.clear();","   let _ref_mut = index_map.borrow_mut();","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize); // Updated to use tuple struct constructor","       index_map.push_entry(hash, i, i);","   }","   index_map.clear();","   assert_eq!(index_map.len(), 0);","}"],[]],[["{","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize);","       index_map.push_entry(hash, i, i);","   }","   index_map.clear();","   let _ref_mut = index_map.borrow_mut();","   let mut index_map = IndexMapCore::new();","   for i in 0..3 {","       let hash = HashValue(i as usize);","       index_map.push_entry(hash, i, i);","   }","   index_map.clear();","   let _ref_mut = index_map.borrow_mut();","          assert!(std::ptr::eq(&*_ref_mut.indices as *const _, &index_map.indices as *const _));  ","}"],[]],[["{","  let mut index_map = IndexMapCore::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","  for i in 0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY {","      let hash = HashValue(i);","      index_map.push_entry(hash, i, i);","  }","  let _ref_mut = index_map.borrow_mut();","  let mut index_map = IndexMapCore::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","  let hash_values: Vec<HashValue> = (0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY).map(|i| HashValue(i)).collect();","  for i in 0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY {","      index_map.push_entry(hash_values[i], i, i);","  }","  let ref_mut = index_map.borrow_mut();","   assert!(!ref_mut.indices.is_empty());","}"],[]],[["{","  let mut index_map = IndexMapCore::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","  for i in 0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY {","      let hash = HashValue(i);","      index_map.push_entry(hash, i, i);","  }","  let _ref_mut = index_map.borrow_mut();","  let mut index_map = IndexMapCore::with_capacity(IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY);","  let hash_values: Vec<HashValue> = (0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY).map(|i| HashValue(i)).collect();","   for i in 0..IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY {","   index_map.push_entry(hash_values[i], i, i);","   }","   let ref_mut = index_map.borrow_mut();","    assert!(!ref_mut.entries.is_empty());","}"],[]],[["{","  let mut index_map = IndexMapCore::new();  ","  for i in 0..3 {  ","      let hash = HashValue(i as usize);  ","      index_map.push_entry(hash, i, i);  ","  }  ","  index_map.drain(0..2);  ","  let _ref_mut = index_map.borrow_mut(); // This might panic depending on how drain is implemented  ","  let mut index_map = IndexMapCore::new();  ","  let hash_0 = HashValue(0);  ","  let hash_1 = HashValue(1);  ","  let hash_2 = HashValue(2);  ","  index_map.push_entry(hash_0, 0, 0);  ","  index_map.push_entry(hash_1, 1, 1);  ","  index_map.push_entry(hash_2, 2, 2);  ","  index_map.drain(0..2);  ","   assert_eq!(index_map.len(), 1);  ","}"],[]]]}