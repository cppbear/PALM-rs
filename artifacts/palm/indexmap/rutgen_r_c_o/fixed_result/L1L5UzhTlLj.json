{"function_name":"indexmap::set::set::IndexSet<T, S>::try_reserve","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/set.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":9,"tests_lines":[11,12,12,14,11,13,12,12,14],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":6,"tests_compiled_rate":66.66666666666666,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":5,"tests_passed_rate":83.33333333333334,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[300,301,302],"codes_lines_covered":[[["{","  #[should_panic]","  fn test_try_reserve_negative() {","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","      let _result = index_set.try_reserve(usize::MAX);","  }","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","      let _result = index_set.try_reserve(0);","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","      assert!(index_set.try_reserve(usize::MAX).is_err());","}"],[300,301,302]],[["{","  #[should_panic]  ","  fn test_try_reserve_negative() {  ","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","      let _result = index_set.try_reserve(usize::MAX);  ","  }  ","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","       let _result = index_set.try_reserve(0);  ","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","       assert_eq!(index_set.try_reserve(0), Ok(()));  ","}"],[300,301,302]],[["{","   #[should_panic]","   fn test_try_reserve_negative() {","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","       let result = index_set.try_reserve(usize::MAX);","   }","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","       let result = index_set.try_reserve(5);","       // Removed unnecessary overflow attempt","       // let result = index_set.try_reserve(usize::MAX + 1);","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","       let result = index_set.try_reserve(5);","       assert!(result.is_ok());","}"],[300,301,302]],[["{"," #[should_panic]"," fn test_try_reserve_negative() {","     let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","     let _result = index_set.try_reserve(usize::MAX); // Changed to usize::MAX","  }","  test_try_reserve_negative(); // call the nested function here.","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(100, RandomState::new());","      let _result = index_set.try_reserve(1000);","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(100, RandomState::new());","      let _result = index_set.try_reserve(1000);","}"],[300,301,302]],[["{"," // #[should_panic]"," // fn test_try_reserve_negative() {"," //     let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());"," //     let _result = index_set.try_reserve(usize::MAX);"," // }"," let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());"," let _result = index_set.try_reserve(usize::MAX);"," let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());"," let _result = index_set.try_reserve(usize::MAX);"," assert_eq!(_result.is_err(), true);","}"],[300,301,302]],[["{","  #[should_panic]  ","  fn test_try_reserve_negative() {  ","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","      let _result = index_set.try_reserve(usize::MAX);  ","  }  ","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","      let _result = index_set.try_reserve(usize::MAX);  ","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","      let _result = index_set.try_reserve(usize::MAX);  ","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","       let result = index_set.try_reserve(usize::MAX);  ","       assert_eq!(result.is_ok(), true);  ","}"],[300,301,302]]],"codes_branches":[],"codes_branches_covered":[[["{","  #[should_panic]","  fn test_try_reserve_negative() {","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","      let _result = index_set.try_reserve(usize::MAX);","  }","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","      let _result = index_set.try_reserve(0);","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","      assert!(index_set.try_reserve(usize::MAX).is_err());","}"],[]],[["{","  #[should_panic]  ","  fn test_try_reserve_negative() {  ","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","      let _result = index_set.try_reserve(usize::MAX);  ","  }  ","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","       let _result = index_set.try_reserve(0);  ","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","       assert_eq!(index_set.try_reserve(0), Ok(()));  ","}"],[]],[["{","   #[should_panic]","   fn test_try_reserve_negative() {","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","       let result = index_set.try_reserve(usize::MAX);","   }","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","       let result = index_set.try_reserve(5);","       // Removed unnecessary overflow attempt","       // let result = index_set.try_reserve(usize::MAX + 1);","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","       let result = index_set.try_reserve(5);","       assert!(result.is_ok());","}"],[]],[["{"," #[should_panic]"," fn test_try_reserve_negative() {","     let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","     let _result = index_set.try_reserve(usize::MAX); // Changed to usize::MAX","  }","  test_try_reserve_negative(); // call the nested function here.","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(100, RandomState::new());","      let _result = index_set.try_reserve(1000);","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(100, RandomState::new());","      let _result = index_set.try_reserve(1000);","}"],[]],[["{"," // #[should_panic]"," // fn test_try_reserve_negative() {"," //     let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());"," //     let _result = index_set.try_reserve(usize::MAX);"," // }"," let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());"," let _result = index_set.try_reserve(usize::MAX);"," let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());"," let _result = index_set.try_reserve(usize::MAX);"," assert_eq!(_result.is_err(), true);","}"],[]],[["{","  #[should_panic]  ","  fn test_try_reserve_negative() {  ","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","      let _result = index_set.try_reserve(usize::MAX);  ","  }  ","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","      let _result = index_set.try_reserve(usize::MAX);  ","      let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","      let _result = index_set.try_reserve(usize::MAX);  ","       let mut index_set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());  ","       let result = index_set.try_reserve(usize::MAX);  ","       assert_eq!(result.is_ok(), true);  ","}"],[]]]}