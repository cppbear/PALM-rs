[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::new();",
          "    map.insert(1, 100);",
          "    map.insert(3, 300);",
          "    map.insert(2, 200);",
          "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[0], (&1, &100));"
          ],
          [
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[1], (&2, &200));"
          ],
          [
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[2], (&3, &300));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[0], (&1, &100));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[1], (&2, &200));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[2], (&3, &300));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::new();",
          "    map.insert(1, 100);",
          "    map.insert(3, 300);",
          "    map.insert(2, 200);",
          "    map.sort_by(|k1, v1, k2, v2| k2.cmp(k1));",
          "}"
        ],
        "oracles": [
          [
            "    let map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[0], (3, 300));"
          ],
          [
            "    let map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[1], (2, 200));"
          ],
          [
            "    let map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[2], (1, 100));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    map.sort_by(|k1, v1, k2, v2| k2.cmp(k1));",
            "    let map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[0], (3, 300));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    map.sort_by(|k1, v1, k2, v2| k2.cmp(k1));",
            "    let map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[1], (2, 200));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    map.sort_by(|k1, v1, k2, v2| k2.cmp(k1));",
            "    let map = IndexMap::new();",
            "    map.insert(1, 100);",
            "    map.insert(3, 300);",
            "    map.insert(2, 200);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[2], (1, 100));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::new();",
          "    map.insert(2, 100);",
          "    map.insert(2, 200);",
          "    map.insert(2, 300);",
          "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 100);",
            "    map.insert(2, 200);",
            "    map.insert(2, 300);",
            "    let expected = vec![(2, 300), (2, 200), (2, 100)];",
            "    let result: Vec<_> = map.into_iter().collect();",
            "    assert_eq!(result, expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 100);",
            "    map.insert(2, 200);",
            "    map.insert(2, 300);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 100);",
            "    map.insert(2, 200);",
            "    map.insert(2, 300);",
            "    let expected = vec![(2, 300), (2, 200), (2, 100)];",
            "    let result: Vec<_> = map.into_iter().collect();",
            "    assert_eq!(result, expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::new();",
          "    map.insert(2, 200);",
          "    map.insert(1, 300);",
          "    map.insert(3, 100);",
          "    map.sort_by(|k1, v1, k2, v2| {",
          "        if v1 == v2 {",
          "            k1.cmp(k2)",
          "        } else {",
          "            v1.cmp(v2)",
          "        }",
          "    });",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 200);",
            "    map.insert(1, 300);",
            "    map.insert(3, 100);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[0], (3, 100));"
          ],
          [
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 200);",
            "    map.insert(1, 300);",
            "    map.insert(3, 100);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[1], (2, 200));"
          ],
          [
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 200);",
            "    map.insert(1, 300);",
            "    map.insert(3, 100);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[2], (1, 300));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 200);",
            "    map.insert(1, 300);",
            "    map.insert(3, 100);",
            "    map.sort_by(|k1, v1, k2, v2| {",
            "        if v1 == v2 {",
            "            k1.cmp(k2)",
            "        } else {",
            "            v1.cmp(v2)",
            "        }",
            "    });",
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 200);",
            "    map.insert(1, 300);",
            "    map.insert(3, 100);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[0], (3, 100));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 200);",
            "    map.insert(1, 300);",
            "    map.insert(3, 100);",
            "    map.sort_by(|k1, v1, k2, v2| {",
            "        if v1 == v2 {",
            "            k1.cmp(k2)",
            "        } else {",
            "            v1.cmp(v2)",
            "        }",
            "    });",
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 200);",
            "    map.insert(1, 300);",
            "    map.insert(3, 100);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[1], (2, 200));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 200);",
            "    map.insert(1, 300);",
            "    map.insert(3, 100);",
            "    map.sort_by(|k1, v1, k2, v2| {",
            "        if v1 == v2 {",
            "            k1.cmp(k2)",
            "        } else {",
            "            v1.cmp(v2)",
            "        }",
            "    });",
            "    let mut map = IndexMap::new();",
            "    map.insert(2, 200);",
            "    map.insert(1, 300);",
            "    map.insert(3, 100);",
            "    let entries = map.as_slice();",
            "    assert_eq!(entries[2], (1, 300));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
          "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let sorted_keys: Vec<u32> = map.keys().cloned().collect();",
            "    assert_eq!(sorted_keys, vec![1, 2]);"
          ],
          [
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let sorted_keys: Vec<u32> = map.keys().cloned().collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.insert(2, 20);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    let sorted_values: Vec<u32> = map.values().cloned().collect();",
            "    assert_eq!(sorted_values, vec![10, 20, 30]);"
          ],
          [
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let sorted_keys: Vec<u32> = map.keys().cloned().collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.insert(2, 20);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    let sorted_values: Vec<u32> = map.values().cloned().collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2).then(k1.cmp(k2)));",
            "    let sorted_by_value_then_key: Vec<(u32, u32)> = map.iter().map(|(&k, &v)| (k, v)).collect();",
            "    assert_eq!(sorted_by_value_then_key, vec![(1, 10), (2, 20), (3, 30)]);"
          ],
          [
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let sorted_keys: Vec<u32> = map.keys().cloned().collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.insert(2, 20);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    let sorted_values: Vec<u32> = map.values().cloned().collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2).then(k1.cmp(k2)));",
            "    let sorted_by_value_then_key: Vec<(u32, u32)> = map.iter().map(|(&k, &v)| (k, v)).collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(5, 50);",
            "    map.insert(4, 40);",
            "    map.insert(3, 30);",
            "    map.sort_by(|_, v1, _, v2| v2.cmp(v1));",
            "    let sorted_values_desc: Vec<u32> = map.values().cloned().collect();",
            "    assert_eq!(sorted_values_desc, vec![50, 40, 30]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let sorted_keys: Vec<u32> = map.keys().cloned().collect();",
            "    assert_eq!(sorted_keys, vec![1, 2]);",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let sorted_keys: Vec<u32> = map.keys().cloned().collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.insert(2, 20);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    let sorted_values: Vec<u32> = map.values().cloned().collect();",
            "    assert_eq!(sorted_values, vec![10, 20, 30]);",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let sorted_keys: Vec<u32> = map.keys().cloned().collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.insert(2, 20);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    let sorted_values: Vec<u32> = map.values().cloned().collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2).then(k1.cmp(k2)));",
            "    let sorted_by_value_then_key: Vec<(u32, u32)> = map.iter().map(|(&k, &v)| (k, v)).collect();",
            "    assert_eq!(sorted_by_value_then_key, vec![(1, 10), (2, 20), (3, 30)]);",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));",
            "    let sorted_keys: Vec<u32> = map.keys().cloned().collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.insert(2, 20);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    let sorted_values: Vec<u32> = map.values().cloned().collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2).then(k1.cmp(k2)));",
            "    let sorted_by_value_then_key: Vec<(u32, u32)> = map.iter().map(|(&k, &v)| (k, v)).collect();",
            "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
            "    map.insert(5, 50);",
            "    map.insert(4, 40);",
            "    map.insert(3, 30);",
            "    map.sort_by(|_, v1, _, v2| v2.cmp(v1));",
            "    let sorted_values_desc: Vec<u32> = map.values().cloned().collect();",
            "    assert_eq!(sorted_values_desc, vec![50, 40, 30]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::with_capacity(10000);",
          "    for i in (0..10000).rev() {",
          "        map.insert(i, i);",
          "    }",
          "    map.sort_by(|k1, _, k2, _| k1.cmp(k2));",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::with_capacity(10000);",
            "    for i in (0..10000).rev() { map.insert(i, i); }",
            "    let sorted_keys: Vec<_> = (0..10000).collect();",
            "    assert_eq!(map.keys().cloned().collect::<Vec<_>>(), sorted_keys);"
          ],
          [
            "    let mut map = IndexMap::with_capacity(10000);",
            "    for i in (0..10000).rev() { map.insert(i, i); }",
            "    let sorted_keys: Vec<_> = (0..10000).collect();",
            "    assert!(map.iter().zip(map.iter().skip(1)).all(|((k1, _), (k2, _))| k1 <= k2));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::with_capacity(10000);",
            "    for i in (0..10000).rev() {",
            "        map.insert(i, i);",
            "    }",
            "    map.sort_by(|k1, _, k2, _| k1.cmp(k2));",
            "    let mut map = IndexMap::with_capacity(10000);",
            "    for i in (0..10000).rev() { map.insert(i, i); }",
            "    let sorted_keys: Vec<_> = (0..10000).collect();",
            "    assert_eq!(map.keys().cloned().collect::<Vec<_>>(), sorted_keys);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::with_capacity(10000);",
            "    for i in (0..10000).rev() {",
            "        map.insert(i, i);",
            "    }",
            "    map.sort_by(|k1, _, k2, _| k1.cmp(k2));",
            "    let mut map = IndexMap::with_capacity(10000);",
            "    for i in (0..10000).rev() { map.insert(i, i); }",
            "    let sorted_keys: Vec<_> = (0..10000).collect();",
            "    assert!(map.iter().zip(map.iter().skip(1)).all(|((k1, _), (k2, _))| k1 <= k2));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::new();",
          "    map.insert(5, 3);",
          "    map.insert(1, 5);",
          "    map.insert(3, 4);",
          "    map.insert(2, 2);",
          "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::new();",
            "    map.insert(5, 3);",
            "    map.insert(1, 5);",
            "    map.insert(3, 4);",
            "    map.insert(2, 2);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    assert_eq!(map.as_slice(), vec![(2, 2), (1, 5), (3, 4), (5, 3)]);"
          ],
          [
            "    let mut map = IndexMap::new();",
            "    map.insert(5, 3);",
            "    map.insert(1, 5);",
            "    map.insert(3, 4);",
            "    map.insert(2, 2);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    assert_eq!(map.first(), Some((&2, &2)));"
          ],
          [
            "    let mut map = IndexMap::new();",
            "    map.insert(5, 3);",
            "    map.insert(1, 5);",
            "    map.insert(3, 4);",
            "    map.insert(2, 2);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    assert_eq!(map.last(), Some((&5, &3)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(5, 3);",
            "    map.insert(1, 5);",
            "    map.insert(3, 4);",
            "    map.insert(2, 2);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    let mut map = IndexMap::new();",
            "    map.insert(5, 3);",
            "    map.insert(1, 5);",
            "    map.insert(3, 4);",
            "    map.insert(2, 2);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    assert_eq!(map.as_slice(), vec![(2, 2), (1, 5), (3, 4), (5, 3)]);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(5, 3);",
            "    map.insert(1, 5);",
            "    map.insert(3, 4);",
            "    map.insert(2, 2);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    let mut map = IndexMap::new();",
            "    map.insert(5, 3);",
            "    map.insert(1, 5);",
            "    map.insert(3, 4);",
            "    map.insert(2, 2);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    assert_eq!(map.first(), Some((&2, &2)));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::new();",
            "    map.insert(5, 3);",
            "    map.insert(1, 5);",
            "    map.insert(3, 4);",
            "    map.insert(2, 2);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    let mut map = IndexMap::new();",
            "    map.insert(5, 3);",
            "    map.insert(1, 5);",
            "    map.insert(3, 4);",
            "    map.insert(2, 2);",
            "    map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));",
            "    assert_eq!(map.last(), Some((&5, &3)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]