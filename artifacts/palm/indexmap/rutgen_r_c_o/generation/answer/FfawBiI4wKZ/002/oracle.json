[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Key(i32);",
          "    struct Value(String);",
          "    let mut entries = Entries::<Key, Value>::new();",
          "    ",
          "    let index = entries.insert(Key(1), Value(\"existing\".to_string()));",
          "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
          "",
          "    let result = occupied_entry.or_insert(Value(\"default\".to_string()));",
          "}"
        ],
        "oracles": [
          [
            "    let mut entries = Entries::<Key, Value>::new();",
            "    let index = entries.insert(Key(1), Value(\"existing\".to_string()));",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "    let result = occupied_entry.or_insert(Value(\"default\".to_string()));",
            "    assert_eq!(result, &mut Value(\"existing\".to_string()));"
          ],
          [
            "    let mut entries = Entries::<Key, Value>::new();",
            "    let index = entries.insert(Key(1), Value(\"existing\".to_string()));",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "    let result = occupied_entry.or_insert(Value(\"default\".to_string()));",
            "    assert_eq!(entries.get(&Key(1)), Some(&Value(\"existing\".to_string())));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "    ",
            "    let index = entries.insert(Key(1), Value(\"existing\".to_string()));",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "",
            "    let result = occupied_entry.or_insert(Value(\"default\".to_string()));",
            "    let mut entries = Entries::<Key, Value>::new();",
            "    let index = entries.insert(Key(1), Value(\"existing\".to_string()));",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "    let result = occupied_entry.or_insert(Value(\"default\".to_string()));",
            "    assert_eq!(result, &mut Value(\"existing\".to_string()));",
            "}"
          ],
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "    ",
            "    let index = entries.insert(Key(1), Value(\"existing\".to_string()));",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "",
            "    let result = occupied_entry.or_insert(Value(\"default\".to_string()));",
            "    let mut entries = Entries::<Key, Value>::new();",
            "    let index = entries.insert(Key(1), Value(\"existing\".to_string()));",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "    let result = occupied_entry.or_insert(Value(\"default\".to_string()));",
            "    assert_eq!(entries.get(&Key(1)), Some(&Value(\"existing\".to_string())));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Key(i32);",
          "    struct Value(String);",
          "    let mut entries = Entries::<Key, Value>::new();",
          "",
          "    let vacant_entry = Entry::Vacant(VacantEntry {",
          "        map: RefMut::new(&mut entries),",
          "        hash: HashValue::new(),",
          "        key: Key(2),",
          "    });",
          "",
          "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
          "}"
        ],
        "oracles": [
          [
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(2) });",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    assert_eq!(result, &mut Value(\"default\".to_string()));"
          ],
          [
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(2) });",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    assert!(entries.contains_key(&Key(2)));"
          ],
          [
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(2) });",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    assert_eq!(entries.get(&Key(2)).unwrap(), &Value(\"default\".to_string()));"
          ],
          [
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(2) });",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    assert_eq!(entries.len(), 1);"
          ],
          [
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(2) });",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    assert!(matches!(vacant_entry, Entry::Vacant(_)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "",
            "    let vacant_entry = Entry::Vacant(VacantEntry {",
            "        map: RefMut::new(&mut entries),",
            "        hash: HashValue::new(),",
            "        key: Key(2),",
            "    });",
            "",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(2) });",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    assert_eq!(result, &mut Value(\"default\".to_string()));",
            "}"
          ],
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "",
            "    let vacant_entry = Entry::Vacant(VacantEntry {",
            "        map: RefMut::new(&mut entries),",
            "        hash: HashValue::new(),",
            "        key: Key(2),",
            "    });",
            "",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(2) });",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    assert!(entries.contains_key(&Key(2)));",
            "}"
          ],
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "",
            "    let vacant_entry = Entry::Vacant(VacantEntry {",
            "        map: RefMut::new(&mut entries),",
            "        hash: HashValue::new(),",
            "        key: Key(2),",
            "    });",
            "",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(2) });",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    assert_eq!(entries.get(&Key(2)).unwrap(), &Value(\"default\".to_string()));",
            "}"
          ],
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "",
            "    let vacant_entry = Entry::Vacant(VacantEntry {",
            "        map: RefMut::new(&mut entries),",
            "        hash: HashValue::new(),",
            "        key: Key(2),",
            "    });",
            "",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(2) });",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    assert_eq!(entries.len(), 1);",
            "}"
          ],
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "",
            "    let vacant_entry = Entry::Vacant(VacantEntry {",
            "        map: RefMut::new(&mut entries),",
            "        hash: HashValue::new(),",
            "        key: Key(2),",
            "    });",
            "",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(2) });",
            "    let result = vacant_entry.or_insert(Value(\"default\".to_string()));",
            "    assert!(matches!(vacant_entry, Entry::Vacant(_)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Key(i32);",
          "    struct Value(String);",
          "    let mut entries = Entries::<Key, Value>::new();",
          "    ",
          "    let index = entries.insert(Key(3), Value(\"occupying\".to_string()));",
          "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
          "",
          "    let result = occupied_entry.or_insert(Value(\"fallback\".to_string()));",
          "}"
        ],
        "oracles": [
          [
            "    let key = Key(3);",
            "    let value = Value(\"occupying\".to_string());",
            "    let entries = Entries::<Key, Value>::new();",
            "    let index = entries.insert(key.clone(), value.clone());",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "    let result = occupied_entry.or_insert(Value(\"fallback\".to_string()));",
            "    assert_eq!(result, &mut value);"
          ],
          [
            "    let key = Key(3);",
            "    let value = Value(\"occupying\".to_string());",
            "    let entries = Entries::<Key, Value>::new();",
            "    let index = entries.insert(key.clone(), value.clone());",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "    let result = occupied_entry.or_insert(Value(\"fallback\".to_string()));",
            "    assert_eq!(entries.get(&key).unwrap(), &value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "    ",
            "    let index = entries.insert(Key(3), Value(\"occupying\".to_string()));",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "",
            "    let result = occupied_entry.or_insert(Value(\"fallback\".to_string()));",
            "    let key = Key(3);",
            "    let value = Value(\"occupying\".to_string());",
            "    let entries = Entries::<Key, Value>::new();",
            "    let index = entries.insert(key.clone(), value.clone());",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "    let result = occupied_entry.or_insert(Value(\"fallback\".to_string()));",
            "    assert_eq!(result, &mut value);",
            "}"
          ],
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "    ",
            "    let index = entries.insert(Key(3), Value(\"occupying\".to_string()));",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "",
            "    let result = occupied_entry.or_insert(Value(\"fallback\".to_string()));",
            "    let key = Key(3);",
            "    let value = Value(\"occupying\".to_string());",
            "    let entries = Entries::<Key, Value>::new();",
            "    let index = entries.insert(key.clone(), value.clone());",
            "    let occupied_entry = Entry::Occupied(OccupiedEntry::new(&mut entries, index));",
            "    let result = occupied_entry.or_insert(Value(\"fallback\".to_string()));",
            "    assert_eq!(entries.get(&key).unwrap(), &value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Key(i32);",
          "    struct Value(String);",
          "    let mut entries = Entries::<Key, Value>::new();",
          "",
          "    let vacant_entry = Entry::Vacant(VacantEntry {",
          "        map: RefMut::new(&mut entries),",
          "        hash: HashValue::new(),",
          "        key: Key(4),",
          "    });",
          "",
          "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
          "}"
        ],
        "oracles": [
          [
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(4) });",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    assert_eq!(result, &mut Value(\"custom default\".to_string()));"
          ],
          [
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(4) });",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    assert_eq!(entries.len(), 1);"
          ],
          [
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(4) });",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    assert_eq!(entries.get(&Key(4)).unwrap(), &Value(\"custom default\".to_string()));"
          ],
          [
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(4) });",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    assert!(entries.contains_key(&Key(4)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "",
            "    let vacant_entry = Entry::Vacant(VacantEntry {",
            "        map: RefMut::new(&mut entries),",
            "        hash: HashValue::new(),",
            "        key: Key(4),",
            "    });",
            "",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(4) });",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    assert_eq!(result, &mut Value(\"custom default\".to_string()));",
            "}"
          ],
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "",
            "    let vacant_entry = Entry::Vacant(VacantEntry {",
            "        map: RefMut::new(&mut entries),",
            "        hash: HashValue::new(),",
            "        key: Key(4),",
            "    });",
            "",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(4) });",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    assert_eq!(entries.len(), 1);",
            "}"
          ],
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "",
            "    let vacant_entry = Entry::Vacant(VacantEntry {",
            "        map: RefMut::new(&mut entries),",
            "        hash: HashValue::new(),",
            "        key: Key(4),",
            "    });",
            "",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(4) });",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    assert_eq!(entries.get(&Key(4)).unwrap(), &Value(\"custom default\".to_string()));",
            "}"
          ],
          [
            "{",
            "    struct Key(i32);",
            "    struct Value(String);",
            "    let mut entries = Entries::<Key, Value>::new();",
            "",
            "    let vacant_entry = Entry::Vacant(VacantEntry {",
            "        map: RefMut::new(&mut entries),",
            "        hash: HashValue::new(),",
            "        key: Key(4),",
            "    });",
            "",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    let vacant_entry = Entry::Vacant(VacantEntry { map: RefMut::new(&mut entries), hash: HashValue::new(), key: Key(4) });",
            "    let result = vacant_entry.or_insert(Value(\"custom default\".to_string()));",
            "    assert!(entries.contains_key(&Key(4)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]