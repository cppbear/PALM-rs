{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/map.rs\n// crate name is indexmap\npub use self::core::raw_entry_v1::{self, RawEntryApiV1};\npub use self::core::{Entry, IndexedEntry, OccupiedEntry, VacantEntry};\npub use self::iter::{\n    Drain, IntoIter, IntoKeys, IntoValues, Iter, IterMut, IterMut2, Keys, Splice, Values,\n    ValuesMut,\n};\npub use self::mutable::MutableEntryKey;\npub use self::mutable::MutableKeys;\npub use self::slice::Slice;\n#[cfg(feature = \"rayon\")]\npub use crate::rayon::map as rayon;\nuse ::core::cmp::Ordering;\nuse ::core::fmt;\nuse ::core::hash::{BuildHasher, Hash, Hasher};\nuse ::core::mem;\nuse ::core::ops::{Index, IndexMut, RangeBounds};\nuse alloc::boxed::Box;\nuse alloc::vec::Vec;\n#[cfg(feature = \"std\")]\nuse std::collections::hash_map::RandomState;\nuse self::core::IndexMapCore;\nuse crate::util::{third, try_simplify_range};\nuse crate::{\n    Bucket, Entries, Equivalent, GetDisjointMutError, HashValue, TryReserveError,\n};\npub trait MutableKeys: private::Sealed {\n    type Key;\n    type Value;\n    fn get_full_mut2<Q>(\n        &mut self,\n        key: &Q,\n    ) -> Option<(usize, &mut Self::Key, &mut Self::Value)>\n    where\n        Q: ?Sized + Hash + Equivalent<Self::Key>;\n    fn get_index_mut2(\n        &mut self,\n        index: usize,\n    ) -> Option<(&mut Self::Key, &mut Self::Value)>;\n    fn iter_mut2(&mut self) -> IterMut2<'_, Self::Key, Self::Value>;\n    fn retain2<F>(&mut self, keep: F)\n    where\n        F: FnMut(&mut Self::Key, &mut Self::Value) -> bool;\n}\npub trait RawEntryApiV1<K, V, S>: private::Sealed {\n    fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S>;\n    fn raw_entry_mut_v1(&mut self) -> RawEntryBuilderMut<'_, K, V, S>;\n}\ntrait Entries {\n    type Entry;\n    fn into_entries(self) -> Vec<Self::Entry>;\n    fn as_entries(&self) -> &[Self::Entry];\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry];\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]);\n}\n#[cfg(not(feature = \"std\"))]\npub struct IndexMap<K, V, S> {\n    pub(crate) core: IndexMapCore<K, V>,\n    hash_builder: S,\n}\npub struct OccupiedEntry<'a, K, V> {\n    entries: &'a mut Entries<K, V>,\n    index: hash_table::OccupiedEntry<'a, usize>,\n}\npub struct VacantEntry<'a, K, V> {\n    map: RefMut<'a, K, V>,\n    hash: HashValue,\n    key: K,\n}\n#[derive(Debug)]\npub(crate) struct IndexMapCore<K, V> {\n    /// indices mapping from the entry hash to its index.\n    indices: Indices,\n    /// entries is a dense vec maintaining entry order.\n    entries: Entries<K, V>,\n}\npub enum Entry<'a, K, V> {\n    /// Existing slot with equivalent key.\n    Occupied(OccupiedEntry<'a, K, V>),\n    /// Vacant slot (no equivalent key in the map).\n    Vacant(VacantEntry<'a, K, V>),\n}\nimpl<K, V, S> IndexMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {}\n    pub fn insert_full(&mut self, key: K, value: V) -> (usize, Option<V>) {}\n    pub fn insert_sorted(&mut self, key: K, value: V) -> (usize, Option<V>)\n    where\n        K: Ord,\n    {}\n    #[track_caller]\n    pub fn insert_before(\n        &mut self,\n        mut index: usize,\n        key: K,\n        value: V,\n    ) -> (usize, Option<V>) {}\n    #[track_caller]\n    pub fn shift_insert(&mut self, index: usize, key: K, value: V) -> Option<V> {\n        let len = self.len();\n        match self.entry(key) {\n            Entry::Occupied(mut entry) => {\n                assert!(\n                    index < len,\n                    \"index out of bounds: the len is {len} but the index is {index}\"\n                );\n                let old = mem::replace(entry.get_mut(), value);\n                entry.move_index(index);\n                Some(old)\n            }\n            Entry::Vacant(entry) => {\n                assert!(\n                    index <= len,\n                    \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"\n                );\n                entry.shift_insert(index, value);\n                None\n            }\n        }\n    }\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n        let hash = self.hash(&key);\n        self.core.entry(hash, key)\n    }\n    #[track_caller]\n    pub fn splice<R, I>(\n        &mut self,\n        range: R,\n        replace_with: I,\n    ) -> Splice<'_, I::IntoIter, K, V, S>\n    where\n        R: RangeBounds<usize>,\n        I: IntoIterator<Item = (K, V)>,\n    {}\n    pub fn append<S2>(&mut self, other: &mut IndexMap<K, V, S2>) {}\n}\nimpl<K, V, S> IndexMap<K, V, S> {\n    #[inline]\n    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {\n        if n == 0 {\n            Self::with_hasher(hash_builder)\n        } else {\n            IndexMap {\n                core: IndexMapCore::with_capacity(n),\n                hash_builder,\n            }\n        }\n    }\n    pub const fn with_hasher(hash_builder: S) -> Self {\n        IndexMap {\n            core: IndexMapCore::new(),\n            hash_builder,\n        }\n    }\n    pub fn capacity(&self) -> usize {}\n    pub fn hasher(&self) -> &S {}\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.core.len()\n    }\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    pub fn iter(&self) -> Iter<'_, K, V> {}\n    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {}\n    pub fn keys(&self) -> Keys<'_, K, V> {}\n    pub fn into_keys(self) -> IntoKeys<K, V> {}\n    pub fn values(&self) -> Values<'_, K, V> {}\n    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {}\n    pub fn into_values(self) -> IntoValues<K, V> {}\n    pub fn clear(&mut self) {}\n    pub fn truncate(&mut self, len: usize) {}\n    #[track_caller]\n    pub fn drain<R>(&mut self, range: R) -> Drain<'_, K, V>\n    where\n        R: RangeBounds<usize>,\n    {}\n    #[track_caller]\n    pub fn split_off(&mut self, at: usize) -> Self\n    where\n        S: Clone,\n    {\n        Self {\n            core: self.core.split_off(at),\n            hash_builder: self.hash_builder.clone(),\n        }\n    }\n    pub fn reserve(&mut self, additional: usize) {}\n    pub fn reserve_exact(&mut self, additional: usize) {}\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {}\n    pub fn try_reserve_exact(\n        &mut self,\n        additional: usize,\n    ) -> Result<(), TryReserveError> {}\n    pub fn shrink_to_fit(&mut self) {}\n    pub fn shrink_to(&mut self, min_capacity: usize) {}\n}\nimpl<'a, K, V> OccupiedEntry<'a, K, V> {\n    pub(crate) fn new(\n        entries: &'a mut Entries<K, V>,\n        index: hash_table::OccupiedEntry<'a, usize>,\n    ) -> Self {\n        Self { entries, index }\n    }\n    #[inline]\n    pub fn index(&self) -> usize {}\n    #[inline]\n    fn into_ref_mut(self) -> RefMut<'a, K, V> {}\n    pub fn key(&self) -> &K {}\n    pub(crate) fn key_mut(&mut self) -> &mut K {}\n    pub fn get(&self) -> &V {}\n    pub fn get_mut(&mut self) -> &mut V {\n        let index = self.index();\n        &mut self.entries[index].value\n    }\n    pub fn into_mut(self) -> &'a mut V {}\n    pub(super) fn into_muts(self) -> (&'a mut K, &'a mut V) {}\n    pub fn insert(&mut self, value: V) -> V {}\n    #[deprecated(\n        note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\"\n    )]\n    pub fn remove(self) -> V {}\n    pub fn swap_remove(self) -> V {}\n    pub fn shift_remove(self) -> V {}\n    #[deprecated(\n        note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\"\n    )]\n    pub fn remove_entry(self) -> (K, V) {}\n    pub fn swap_remove_entry(self) -> (K, V) {}\n    pub fn shift_remove_entry(self) -> (K, V) {}\n    #[track_caller]\n    pub fn move_index(self, to: usize) {\n        let index = self.index();\n        self.into_ref_mut().move_index(index, to);\n    }\n    pub fn swap_indices(self, other: usize) {}\n}\nimpl<'a, K, V> VacantEntry<'a, K, V> {\n    pub fn index(&self) -> usize {}\n    pub fn key(&self) -> &K {}\n    pub(crate) fn key_mut(&mut self) -> &mut K {}\n    pub fn into_key(self) -> K {}\n    pub fn insert(self, value: V) -> &'a mut V {}\n    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {}\n    pub fn insert_sorted(self, value: V) -> (usize, &'a mut V)\n    where\n        K: Ord,\n    {}\n    pub fn shift_insert(mut self, index: usize, value: V) -> &'a mut V {\n        self.map.shift_insert_unique(index, self.hash, self.key, value);\n        &mut self.map.entries[index].value\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Insert a key-value pair in the map at the given index.\n///\n/// If an equivalent key already exists in the map: the key remains and\n/// is moved to the given index in the map, its corresponding value is updated\n/// with `value`, and the older value is returned inside `Some(_)`.\n/// Note that existing entries **cannot** be moved to `index == map.len()`!\n/// (See [`insert_before`](Self::insert_before) for different behavior here.)\n///\n/// If no equivalent key existed in the map: the new key-value pair is\n/// inserted at the given index, and `None` is returned.\n///\n/// ***Panics*** if `index` is out of bounds.\n/// Valid indices are `0..map.len()` (exclusive) when moving an existing entry, or\n/// `0..=map.len()` (inclusive) when inserting a new key.\n///\n/// Computes in **O(n)** time (average).\n///\n/// See also [`entry`][Self::entry] if you want to insert *or* modify,\n/// perhaps only using the index for new entries with [`VacantEntry::shift_insert`].\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexMap;\n/// let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n///\n/// // The new key '*' goes exactly at the given index.\n/// assert_eq!(map.get_index_of(&'*'), None);\n/// assert_eq!(map.shift_insert(10, '*', ()), None);\n/// assert_eq!(map.get_index_of(&'*'), Some(10));\n///\n/// // Moving the key 'a' up to 10 will shift others down, including the '*' that was at 10.\n/// assert_eq!(map.shift_insert(10, 'a', ()), Some(()));\n/// assert_eq!(map.get_index_of(&'a'), Some(10));\n/// assert_eq!(map.get_index_of(&'*'), Some(9));\n///\n/// // Moving the key 'z' down to 9 will shift others up, including the '*' that was at 9.\n/// assert_eq!(map.shift_insert(9, 'z', ()), Some(()));\n/// assert_eq!(map.get_index_of(&'z'), Some(9));\n/// assert_eq!(map.get_index_of(&'*'), Some(10));\n///\n/// // Existing keys can move to len-1 at most, but new keys can insert at the endpoint.\n/// assert_eq!(map.len(), 27);\n/// assert_eq!(map.shift_insert(map.len() - 1, '*', ()), Some(()));\n/// assert_eq!(map.get_index_of(&'*'), Some(26));\n/// assert_eq!(map.shift_insert(map.len(), '+', ()), None);\n/// assert_eq!(map.get_index_of(&'+'), Some(27));\n/// assert_eq!(map.len(), 28);\n/// ```\n///\n/// ```should_panic\n/// use indexmap::IndexMap;\n/// let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n///\n/// // This is an invalid index for moving an existing key!\n/// map.shift_insert(map.len(), 'a', ());\n/// ```\npub fn shift_insert(&mut self, index: usize, key: K, value: V) -> Option<V> {\n    let len = self.len();\n    match self.entry(key) {\n        Entry::Occupied(mut entry) => {\n            assert!(\n                index < len,\n                \"index out of bounds: the len is {len} but the index is {index}\"\n            );\n\n            let old = mem::replace(entry.get_mut(), value);\n            entry.move_index(index);\n            Some(old)\n        }\n        Entry::Vacant(entry) => {\n            assert!(\n                index <= len,\n                \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"\n            );\n\n            entry.shift_insert(index, value);\n            None\n        }\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}