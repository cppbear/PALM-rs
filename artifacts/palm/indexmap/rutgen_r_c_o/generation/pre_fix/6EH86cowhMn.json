{
  "name": "indexmap::map::core::raw_entry_v1::map::core::raw_entry_v1::RawOccupiedEntryMut<'a, K, V, S>::into_key",
  "name_with_impl": "indexmap::map::core::raw_entry_v1::{impl#8}::into_key",
  "mod_info": {
    "name": "map::core::raw_entry_v1",
    "loc": "src/map/core.rs:12:1:12:22"
  },
  "visible": true,
  "loc": "src/map/core/raw_entry_v1.rs:433:5:436:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self.entries[index] is \n",
        "// expected return value/type: &mut self.entries[index].key\n"
      ],
      "input_infer": "1 <= index <= entries.len() - 1, K: any valid key type, entries: non-empty collection of Entries with keys of type K\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestEntries {",
                "        data: Vec<Bucket<String, i32>>,",
                "    }",
                "",
                "    impl Entries for TestEntries {",
                "        type Entry = Bucket<String, i32>;",
                "",
                "        fn into_entries(self) -> Vec<Self::Entry> {",
                "            self.data",
                "        }",
                "",
                "        fn as_entries(&self) -> &[Self::Entry] {",
                "            &self.data",
                "        }",
                "",
                "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                "            &mut self.data",
                "        }",
                "",
                "        fn with_entries<F>(&mut self, f: F)",
                "        where",
                "            F: FnOnce(&mut [Self::Entry]) {",
                "            f(&mut self.data);",
                "        }",
                "    }",
                "",
                "    let mut entries = TestEntries {",
                "        data: vec![",
                "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                "            Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 },",
                "        ],",
                "    };",
                "",
                "    let index = 0;",
                "    let occupied_entry = RawOccupiedEntryMut {",
                "        entries: &mut entries,",
                "        index: hash_table::OccupiedEntry::from_index(index),",
                "        hash_builder: PhantomData,",
                "    };",
                "",
                "    let key_mut = occupied_entry.into_key();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut entries = TestEntries { data: vec![Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 }] };",
                  "    let index = 0;",
                  "    let occupied_entry = RawOccupiedEntryMut { entries: &mut entries, index: hash_table::OccupiedEntry::from_index(index), hash_builder: PhantomData };",
                  "    let key_mut = occupied_entry.into_key();",
                  "    assert_eq!(key_mut, &mut entries.data[index].key);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestEntries {",
                  "        data: Vec<Bucket<String, i32>>,",
                  "    }",
                  "",
                  "    impl Entries for TestEntries {",
                  "        type Entry = Bucket<String, i32>;",
                  "",
                  "        fn into_entries(self) -> Vec<Self::Entry> {",
                  "            self.data",
                  "        }",
                  "",
                  "        fn as_entries(&self) -> &[Self::Entry] {",
                  "            &self.data",
                  "        }",
                  "",
                  "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                  "            &mut self.data",
                  "        }",
                  "",
                  "        fn with_entries<F>(&mut self, f: F)",
                  "        where",
                  "            F: FnOnce(&mut [Self::Entry]) {",
                  "            f(&mut self.data);",
                  "        }",
                  "    }",
                  "",
                  "    let mut entries = TestEntries {",
                  "        data: vec![",
                  "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                  "            Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 },",
                  "        ],",
                  "    };",
                  "",
                  "    let index = 0;",
                  "    let occupied_entry = RawOccupiedEntryMut {",
                  "        entries: &mut entries,",
                  "        index: hash_table::OccupiedEntry::from_index(index),",
                  "        hash_builder: PhantomData,",
                  "    };",
                  "",
                  "    let key_mut = occupied_entry.into_key();",
                  "    let mut entries = TestEntries { data: vec![Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 }] };",
                  "    let index = 0;",
                  "    let occupied_entry = RawOccupiedEntryMut { entries: &mut entries, index: hash_table::OccupiedEntry::from_index(index), hash_builder: PhantomData };",
                  "    let key_mut = occupied_entry.into_key();",
                  "    assert_eq!(key_mut, &mut entries.data[index].key);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:674:19\n    |\n674 |         data: Vec<Bucket<String, i32>>,\n    |                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0404]: expected trait, found type alias `Entries`\n   --> src/map/core/raw_entry_v1.rs:677:10\n    |\n677 |     impl Entries for TestEntries {\n    |          ^^^^^^^ type aliases cannot be used as traits\n    |\nhelp: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n   --> src/map/core.rs:25:1\n    |\n25  | trait Entries<K, V> = Vec<Bucket<K, V>>;\n    |\nhelp: consider importing this trait instead\n    |\n668 +    use crate::Entries;\n    |\n\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:678:22\n    |\n678 |         type Entry = Bucket<String, i32>;\n    |                      ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:701:13\n    |\n701 |             Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:702:13\n    |\n702 |             Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:714:48\n    |\n714 |     let mut entries = TestEntries { data: vec![Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: H...\n    |                                                ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:714:122\n    |\n714 | ...ue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 }] };\n    |                                                        ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nwarning: unused import: `ntest::timeout`\n   --> src/map/core/raw_entry_v1.rs:669:8\n    |\n669 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0404, E0412, E0422.\nFor more information about an error, try `rustc --explain E0404`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 7 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestEntries {",
                "        data: Vec<Bucket<String, i32>>,",
                "    }",
                "",
                "    impl Entries for TestEntries {",
                "        type Entry = Bucket<String, i32>;",
                "",
                "        fn into_entries(self) -> Vec<Self::Entry> {",
                "            self.data",
                "        }",
                "",
                "        fn as_entries(&self) -> &[Self::Entry] {",
                "            &self.data",
                "        }",
                "",
                "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                "            &mut self.data",
                "        }",
                "",
                "        fn with_entries<F>(&mut self, f: F)",
                "        where",
                "            F: FnOnce(&mut [Self::Entry]) {",
                "            f(&mut self.data);",
                "        }",
                "    }",
                "",
                "    let mut entries = TestEntries {",
                "        data: vec![",
                "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                "            Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 },",
                "        ],",
                "    };",
                "",
                "    let index = 1;",
                "    let occupied_entry = RawOccupiedEntryMut {",
                "        entries: &mut entries,",
                "        index: hash_table::OccupiedEntry::from_index(index),",
                "        hash_builder: PhantomData,",
                "    };",
                "",
                "    let key_mut = occupied_entry.into_key();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut entries = TestEntries { data: vec![Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 }] };",
                  "    let occupied_entry = RawOccupiedEntryMut { entries: &mut entries, index: hash_table::OccupiedEntry::from_index(1), hash_builder: PhantomData };",
                  "    let key_mut = occupied_entry.into_key();",
                  "    assert_eq!(key_mut, &mut entries.data[1].key);"
                ],
                [
                  "    let mut entries = TestEntries { data: vec![Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 }] };",
                  "    let occupied_entry = RawOccupiedEntryMut { entries: &mut entries, index: hash_table::OccupiedEntry::from_index(1), hash_builder: PhantomData };",
                  "    let key_mut = occupied_entry.into_key();",
                  "    assert_eq!(key_mut, &mut \"key2\".to_string());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestEntries {",
                  "        data: Vec<Bucket<String, i32>>,",
                  "    }",
                  "",
                  "    impl Entries for TestEntries {",
                  "        type Entry = Bucket<String, i32>;",
                  "",
                  "        fn into_entries(self) -> Vec<Self::Entry> {",
                  "            self.data",
                  "        }",
                  "",
                  "        fn as_entries(&self) -> &[Self::Entry] {",
                  "            &self.data",
                  "        }",
                  "",
                  "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                  "            &mut self.data",
                  "        }",
                  "",
                  "        fn with_entries<F>(&mut self, f: F)",
                  "        where",
                  "            F: FnOnce(&mut [Self::Entry]) {",
                  "            f(&mut self.data);",
                  "        }",
                  "    }",
                  "",
                  "    let mut entries = TestEntries {",
                  "        data: vec![",
                  "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                  "            Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 },",
                  "        ],",
                  "    };",
                  "",
                  "    let index = 1;",
                  "    let occupied_entry = RawOccupiedEntryMut {",
                  "        entries: &mut entries,",
                  "        index: hash_table::OccupiedEntry::from_index(index),",
                  "        hash_builder: PhantomData,",
                  "    };",
                  "",
                  "    let key_mut = occupied_entry.into_key();",
                  "    let mut entries = TestEntries { data: vec![Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 }] };",
                  "    let occupied_entry = RawOccupiedEntryMut { entries: &mut entries, index: hash_table::OccupiedEntry::from_index(1), hash_builder: PhantomData };",
                  "    let key_mut = occupied_entry.into_key();",
                  "    assert_eq!(key_mut, &mut entries.data[1].key);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestEntries {",
                  "        data: Vec<Bucket<String, i32>>,",
                  "    }",
                  "",
                  "    impl Entries for TestEntries {",
                  "        type Entry = Bucket<String, i32>;",
                  "",
                  "        fn into_entries(self) -> Vec<Self::Entry> {",
                  "            self.data",
                  "        }",
                  "",
                  "        fn as_entries(&self) -> &[Self::Entry] {",
                  "            &self.data",
                  "        }",
                  "",
                  "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                  "            &mut self.data",
                  "        }",
                  "",
                  "        fn with_entries<F>(&mut self, f: F)",
                  "        where",
                  "            F: FnOnce(&mut [Self::Entry]) {",
                  "            f(&mut self.data);",
                  "        }",
                  "    }",
                  "",
                  "    let mut entries = TestEntries {",
                  "        data: vec![",
                  "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                  "            Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 },",
                  "        ],",
                  "    };",
                  "",
                  "    let index = 1;",
                  "    let occupied_entry = RawOccupiedEntryMut {",
                  "        entries: &mut entries,",
                  "        index: hash_table::OccupiedEntry::from_index(index),",
                  "        hash_builder: PhantomData,",
                  "    };",
                  "",
                  "    let key_mut = occupied_entry.into_key();",
                  "    let mut entries = TestEntries { data: vec![Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 }] };",
                  "    let occupied_entry = RawOccupiedEntryMut { entries: &mut entries, index: hash_table::OccupiedEntry::from_index(1), hash_builder: PhantomData };",
                  "    let key_mut = occupied_entry.into_key();",
                  "    assert_eq!(key_mut, &mut \"key2\".to_string());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:674:19\n    |\n674 |         data: Vec<Bucket<String, i32>>,\n    |                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0404]: expected trait, found type alias `Entries`\n   --> src/map/core/raw_entry_v1.rs:677:10\n    |\n677 |     impl Entries for TestEntries {\n    |          ^^^^^^^ type aliases cannot be used as traits\n    |\nhelp: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n   --> src/map/core.rs:25:1\n    |\n25  | trait Entries<K, V> = Vec<Bucket<K, V>>;\n    |\nhelp: consider importing this trait instead\n    |\n668 +    use crate::Entries;\n    |\n\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:678:22\n    |\n678 |         type Entry = Bucket<String, i32>;\n    |                      ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:701:13\n    |\n701 |             Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:702:13\n    |\n702 |             Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:714:48\n    |\n714 |     let mut entries = TestEntries { data: vec![Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: H...\n    |                                                ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:714:122\n    |\n714 | ...ue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 }] };\n    |                                                        ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nwarning: unused import: `ntest::timeout`\n   --> src/map/core/raw_entry_v1.rs:669:8\n    |\n669 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0404, E0412, E0422.\nFor more information about an error, try `rustc --explain E0404`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 7 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:674:19\n    |\n674 |         data: Vec<Bucket<String, i32>>,\n    |                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0404]: expected trait, found type alias `Entries`\n   --> src/map/core/raw_entry_v1.rs:677:10\n    |\n677 |     impl Entries for TestEntries {\n    |          ^^^^^^^ type aliases cannot be used as traits\n    |\nhelp: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n   --> src/map/core.rs:25:1\n    |\n25  | trait Entries<K, V> = Vec<Bucket<K, V>>;\n    |\nhelp: consider importing this trait instead\n    |\n668 +    use crate::Entries;\n    |\n\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:678:22\n    |\n678 |         type Entry = Bucket<String, i32>;\n    |                      ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:701:13\n    |\n701 |             Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:702:13\n    |\n702 |             Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:714:48\n    |\n714 |     let mut entries = TestEntries { data: vec![Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: H...\n    |                                                ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:714:122\n    |\n714 | ...ue::default(), key: \"key1\".to_string(), value: 1 }, Bucket { hash: HashValue::default(), key: \"key2\".to_string(), value: 2 }] };\n    |                                                        ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nwarning: unused import: `ntest::timeout`\n   --> src/map/core/raw_entry_v1.rs:669:8\n    |\n669 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0404, E0412, E0422.\nFor more information about an error, try `rustc --explain E0404`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 7 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestEntries {",
                "        data: Vec<Bucket<String, i32>>,",
                "    }",
                "",
                "    impl Entries for TestEntries {",
                "        type Entry = Bucket<String, i32>;",
                "",
                "        fn into_entries(self) -> Vec<Self::Entry> {",
                "            self.data",
                "        }",
                "",
                "        fn as_entries(&self) -> &[Self::Entry] {",
                "            &self.data",
                "        }",
                "",
                "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                "            &mut self.data",
                "        }",
                "",
                "        fn with_entries<F>(&mut self, f: F)",
                "        where",
                "            F: FnOnce(&mut [Self::Entry]) {",
                "            f(&mut self.data);",
                "        }",
                "    }",
                "",
                "    let mut entries = TestEntries {",
                "        data: vec![",
                "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                "        ],",
                "    };",
                "",
                "    let index = 1; // Out of bounds",
                "    let occupied_entry = RawOccupiedEntryMut {",
                "        entries: &mut entries,",
                "        index: hash_table::OccupiedEntry::from_index(index),",
                "        hash_builder: PhantomData,",
                "    };",
                "",
                "    let key_mut = occupied_entry.into_key(); // This should panic",
                "}"
              ],
              "oracles": [
                [
                  "    let index = 1;",
                  "    assert_eq!(entries.as_entries().len(), 1);"
                ],
                [
                  "    let index = 1;",
                  "    assert!(std::panic::catch_unwind(|| { occupied_entry.into_key(); }).is_err());"
                ],
                [
                  "    let index = 1;",
                  "    assert!(occupied_entry.index() > entries.as_entries().len() - 1);"
                ],
                [
                  "    let index = 1;",
                  "    assert_eq!(occupied_entry.entries.as_entries()[0].key, \"key1\".to_string());"
                ],
                [
                  "    let index = 1;",
                  "    assert_eq!(occupied_entry.entries.as_entries()[0].value, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestEntries {",
                  "        data: Vec<Bucket<String, i32>>,",
                  "    }",
                  "",
                  "    impl Entries for TestEntries {",
                  "        type Entry = Bucket<String, i32>;",
                  "",
                  "        fn into_entries(self) -> Vec<Self::Entry> {",
                  "            self.data",
                  "        }",
                  "",
                  "        fn as_entries(&self) -> &[Self::Entry] {",
                  "            &self.data",
                  "        }",
                  "",
                  "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                  "            &mut self.data",
                  "        }",
                  "",
                  "        fn with_entries<F>(&mut self, f: F)",
                  "        where",
                  "            F: FnOnce(&mut [Self::Entry]) {",
                  "            f(&mut self.data);",
                  "        }",
                  "    }",
                  "",
                  "    let mut entries = TestEntries {",
                  "        data: vec![",
                  "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                  "        ],",
                  "    };",
                  "",
                  "    let index = 1; // Out of bounds",
                  "    let occupied_entry = RawOccupiedEntryMut {",
                  "        entries: &mut entries,",
                  "        index: hash_table::OccupiedEntry::from_index(index),",
                  "        hash_builder: PhantomData,",
                  "    };",
                  "",
                  "    let key_mut = occupied_entry.into_key(); // This should panic",
                  "    let index = 1;",
                  "    assert_eq!(entries.as_entries().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestEntries {",
                  "        data: Vec<Bucket<String, i32>>,",
                  "    }",
                  "",
                  "    impl Entries for TestEntries {",
                  "        type Entry = Bucket<String, i32>;",
                  "",
                  "        fn into_entries(self) -> Vec<Self::Entry> {",
                  "            self.data",
                  "        }",
                  "",
                  "        fn as_entries(&self) -> &[Self::Entry] {",
                  "            &self.data",
                  "        }",
                  "",
                  "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                  "            &mut self.data",
                  "        }",
                  "",
                  "        fn with_entries<F>(&mut self, f: F)",
                  "        where",
                  "            F: FnOnce(&mut [Self::Entry]) {",
                  "            f(&mut self.data);",
                  "        }",
                  "    }",
                  "",
                  "    let mut entries = TestEntries {",
                  "        data: vec![",
                  "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                  "        ],",
                  "    };",
                  "",
                  "    let index = 1; // Out of bounds",
                  "    let occupied_entry = RawOccupiedEntryMut {",
                  "        entries: &mut entries,",
                  "        index: hash_table::OccupiedEntry::from_index(index),",
                  "        hash_builder: PhantomData,",
                  "    };",
                  "",
                  "    let key_mut = occupied_entry.into_key(); // This should panic",
                  "    let index = 1;",
                  "    assert!(std::panic::catch_unwind(|| { occupied_entry.into_key(); }).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestEntries {",
                  "        data: Vec<Bucket<String, i32>>,",
                  "    }",
                  "",
                  "    impl Entries for TestEntries {",
                  "        type Entry = Bucket<String, i32>;",
                  "",
                  "        fn into_entries(self) -> Vec<Self::Entry> {",
                  "            self.data",
                  "        }",
                  "",
                  "        fn as_entries(&self) -> &[Self::Entry] {",
                  "            &self.data",
                  "        }",
                  "",
                  "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                  "            &mut self.data",
                  "        }",
                  "",
                  "        fn with_entries<F>(&mut self, f: F)",
                  "        where",
                  "            F: FnOnce(&mut [Self::Entry]) {",
                  "            f(&mut self.data);",
                  "        }",
                  "    }",
                  "",
                  "    let mut entries = TestEntries {",
                  "        data: vec![",
                  "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                  "        ],",
                  "    };",
                  "",
                  "    let index = 1; // Out of bounds",
                  "    let occupied_entry = RawOccupiedEntryMut {",
                  "        entries: &mut entries,",
                  "        index: hash_table::OccupiedEntry::from_index(index),",
                  "        hash_builder: PhantomData,",
                  "    };",
                  "",
                  "    let key_mut = occupied_entry.into_key(); // This should panic",
                  "    let index = 1;",
                  "    assert!(occupied_entry.index() > entries.as_entries().len() - 1);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestEntries {",
                  "        data: Vec<Bucket<String, i32>>,",
                  "    }",
                  "",
                  "    impl Entries for TestEntries {",
                  "        type Entry = Bucket<String, i32>;",
                  "",
                  "        fn into_entries(self) -> Vec<Self::Entry> {",
                  "            self.data",
                  "        }",
                  "",
                  "        fn as_entries(&self) -> &[Self::Entry] {",
                  "            &self.data",
                  "        }",
                  "",
                  "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                  "            &mut self.data",
                  "        }",
                  "",
                  "        fn with_entries<F>(&mut self, f: F)",
                  "        where",
                  "            F: FnOnce(&mut [Self::Entry]) {",
                  "            f(&mut self.data);",
                  "        }",
                  "    }",
                  "",
                  "    let mut entries = TestEntries {",
                  "        data: vec![",
                  "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                  "        ],",
                  "    };",
                  "",
                  "    let index = 1; // Out of bounds",
                  "    let occupied_entry = RawOccupiedEntryMut {",
                  "        entries: &mut entries,",
                  "        index: hash_table::OccupiedEntry::from_index(index),",
                  "        hash_builder: PhantomData,",
                  "    };",
                  "",
                  "    let key_mut = occupied_entry.into_key(); // This should panic",
                  "    let index = 1;",
                  "    assert_eq!(occupied_entry.entries.as_entries()[0].key, \"key1\".to_string());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestEntries {",
                  "        data: Vec<Bucket<String, i32>>,",
                  "    }",
                  "",
                  "    impl Entries for TestEntries {",
                  "        type Entry = Bucket<String, i32>;",
                  "",
                  "        fn into_entries(self) -> Vec<Self::Entry> {",
                  "            self.data",
                  "        }",
                  "",
                  "        fn as_entries(&self) -> &[Self::Entry] {",
                  "            &self.data",
                  "        }",
                  "",
                  "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
                  "            &mut self.data",
                  "        }",
                  "",
                  "        fn with_entries<F>(&mut self, f: F)",
                  "        where",
                  "            F: FnOnce(&mut [Self::Entry]) {",
                  "            f(&mut self.data);",
                  "        }",
                  "    }",
                  "",
                  "    let mut entries = TestEntries {",
                  "        data: vec![",
                  "            Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },",
                  "        ],",
                  "    };",
                  "",
                  "    let index = 1; // Out of bounds",
                  "    let occupied_entry = RawOccupiedEntryMut {",
                  "        entries: &mut entries,",
                  "        index: hash_table::OccupiedEntry::from_index(index),",
                  "        hash_builder: PhantomData,",
                  "    };",
                  "",
                  "    let key_mut = occupied_entry.into_key(); // This should panic",
                  "    let index = 1;",
                  "    assert_eq!(occupied_entry.entries.as_entries()[0].value, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:675:19\n    |\n675 |         data: Vec<Bucket<String, i32>>,\n    |                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0404]: expected trait, found type alias `Entries`\n   --> src/map/core/raw_entry_v1.rs:678:10\n    |\n678 |     impl Entries for TestEntries {\n    |          ^^^^^^^ type aliases cannot be used as traits\n    |\nhelp: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n   --> src/map/core.rs:25:1\n    |\n25  | trait Entries<K, V> = Vec<Bucket<K, V>>;\n    |\nhelp: consider importing this trait instead\n    |\n668 +    use crate::Entries;\n    |\n\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:679:22\n    |\n679 |         type Entry = Bucket<String, i32>;\n    |                      ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:702:13\n    |\n702 |             Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nwarning: unused import: `ntest::timeout`\n   --> src/map/core/raw_entry_v1.rs:669:8\n    |\n669 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0404, E0412, E0422.\nFor more information about an error, try `rustc --explain E0404`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 4 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:675:19\n    |\n675 |         data: Vec<Bucket<String, i32>>,\n    |                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0404]: expected trait, found type alias `Entries`\n   --> src/map/core/raw_entry_v1.rs:678:10\n    |\n678 |     impl Entries for TestEntries {\n    |          ^^^^^^^ type aliases cannot be used as traits\n    |\nhelp: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n   --> src/map/core.rs:25:1\n    |\n25  | trait Entries<K, V> = Vec<Bucket<K, V>>;\n    |\nhelp: consider importing this trait instead\n    |\n668 +    use crate::Entries;\n    |\n\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:679:22\n    |\n679 |         type Entry = Bucket<String, i32>;\n    |                      ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:702:13\n    |\n702 |             Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nwarning: unused import: `ntest::timeout`\n   --> src/map/core/raw_entry_v1.rs:669:8\n    |\n669 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0404, E0412, E0422.\nFor more information about an error, try `rustc --explain E0404`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 4 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:675:19\n    |\n675 |         data: Vec<Bucket<String, i32>>,\n    |                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0404]: expected trait, found type alias `Entries`\n   --> src/map/core/raw_entry_v1.rs:678:10\n    |\n678 |     impl Entries for TestEntries {\n    |          ^^^^^^^ type aliases cannot be used as traits\n    |\nhelp: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n   --> src/map/core.rs:25:1\n    |\n25  | trait Entries<K, V> = Vec<Bucket<K, V>>;\n    |\nhelp: consider importing this trait instead\n    |\n668 +    use crate::Entries;\n    |\n\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:679:22\n    |\n679 |         type Entry = Bucket<String, i32>;\n    |                      ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:702:13\n    |\n702 |             Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nwarning: unused import: `ntest::timeout`\n   --> src/map/core/raw_entry_v1.rs:669:8\n    |\n669 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0404, E0412, E0422.\nFor more information about an error, try `rustc --explain E0404`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 4 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:675:19\n    |\n675 |         data: Vec<Bucket<String, i32>>,\n    |                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0404]: expected trait, found type alias `Entries`\n   --> src/map/core/raw_entry_v1.rs:678:10\n    |\n678 |     impl Entries for TestEntries {\n    |          ^^^^^^^ type aliases cannot be used as traits\n    |\nhelp: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n   --> src/map/core.rs:25:1\n    |\n25  | trait Entries<K, V> = Vec<Bucket<K, V>>;\n    |\nhelp: consider importing this trait instead\n    |\n668 +    use crate::Entries;\n    |\n\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:679:22\n    |\n679 |         type Entry = Bucket<String, i32>;\n    |                      ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:702:13\n    |\n702 |             Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nwarning: unused import: `ntest::timeout`\n   --> src/map/core/raw_entry_v1.rs:669:8\n    |\n669 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0404, E0412, E0422.\nFor more information about an error, try `rustc --explain E0404`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 4 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:675:19\n    |\n675 |         data: Vec<Bucket<String, i32>>,\n    |                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0404]: expected trait, found type alias `Entries`\n   --> src/map/core/raw_entry_v1.rs:678:10\n    |\n678 |     impl Entries for TestEntries {\n    |          ^^^^^^^ type aliases cannot be used as traits\n    |\nhelp: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n   --> src/map/core.rs:25:1\n    |\n25  | trait Entries<K, V> = Vec<Bucket<K, V>>;\n    |\nhelp: consider importing this trait instead\n    |\n668 +    use crate::Entries;\n    |\n\nerror[E0412]: cannot find type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:679:22\n    |\n679 |         type Entry = Bucket<String, i32>;\n    |                      ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Bucket` in this scope\n   --> src/map/core/raw_entry_v1.rs:702:13\n    |\n702 |             Bucket { hash: HashValue::default(), key: \"key1\".to_string(), value: 1 },\n    |             ^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n668 +    use crate::Bucket;\n    |\n\nwarning: unused import: `ntest::timeout`\n   --> src/map/core/raw_entry_v1.rs:669:8\n    |\n669 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0404, E0412, E0422.\nFor more information about an error, try `rustc --explain E0404`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 4 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}