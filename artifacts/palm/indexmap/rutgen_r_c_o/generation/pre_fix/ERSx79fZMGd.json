{
  "name": "indexmap::map::core::insert_bulk_no_grow",
  "name_with_impl": "indexmap::map::core::insert_bulk_no_grow",
  "mod_info": {
    "name": "map::core",
    "loc": "src/map.rs:4:1:4:10"
  },
  "visible": false,
  "loc": "src/map/core.rs:83:1:88:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: indices.capacity() - indices.len() >= entries.len() is true, with bound indices.capacity() - indices.len() == entries.len()\n",
        "// constraint: entry in entries is true\n",
        "// constraint: entry in entries is false\n"
      ],
      "input_infer": "1 <= indices.len() <= 1000, 1 <= indices.capacity() <= 1000, entries.len() == indices.capacity() - indices.len() == 1 to 999\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[should_panic]",
            "fn test_insert_bulk_no_grow_exceed_capacity() {",
            "    let mut indices = hash_table::HashTable::with_capacity(5); // capacity 5",
            "    for i in 0..3 {",
            "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill three entries",
            "    }",
            "    let entries = vec![Bucket {",
            "        hash: HashValue(3),",
            "        key: 3,",
            "        value: \"value3\",",
            "    }, Bucket {",
            "        hash: HashValue(4),",
            "        key: 4,",
            "        value: \"value4\",",
            "    }];",
            "    insert_bulk_no_grow(&mut indices, &entries); // should panic",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::with_capacity(2); // capacity 2",
                "    indices.insert_unique(0, 0, |_| unreachable!()); // pre-fill one entry",
                "    let entries = vec![Bucket {",
                "        hash: HashValue(1),",
                "        key: 1,",
                "        value: \"value1\",",
                "    }];",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let panic_result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    assert!(panic_result.is_err());"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let panic_result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![Bucket { hash: HashValue(1), key: 1, value: \"value1\" }];",
                  "    let initial_len = indices.len();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.len(), initial_len + 1);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let panic_result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![Bucket { hash: HashValue(1), key: 1, value: \"value1\" }];",
                  "    let initial_len = indices.len();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.get(&1), Some(&0));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(2); // capacity 2",
                  "    indices.insert_unique(0, 0, |_| unreachable!()); // pre-fill one entry",
                  "    let entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 1,",
                  "        value: \"value1\",",
                  "    }];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let panic_result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    assert!(panic_result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(2); // capacity 2",
                  "    indices.insert_unique(0, 0, |_| unreachable!()); // pre-fill one entry",
                  "    let entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 1,",
                  "        value: \"value1\",",
                  "    }];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let panic_result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![Bucket { hash: HashValue(1), key: 1, value: \"value1\" }];",
                  "    let initial_len = indices.len();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.len(), initial_len + 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(2); // capacity 2",
                  "    indices.insert_unique(0, 0, |_| unreachable!()); // pre-fill one entry",
                  "    let entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 1,",
                  "        value: \"value1\",",
                  "    }];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let panic_result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![Bucket { hash: HashValue(1), key: 1, value: \"value1\" }];",
                  "    let initial_len = indices.len();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.get(&1), Some(&0));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n   --> src/map/core.rs:775:49\n    |\n775 |     let panic_result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                        ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                        |                        |\n    |                        |                        `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n    |                        |                        within this `{closure@src/map/core.rs:775:49: 775:51}`\n    |                        required by a bound introduced by this call\n    |\n    = help: within `{closure@src/map/core.rs:775:49: 775:51}`, the trait `UnwindSafe` is not implemented for `&mut HashTable<usize>`, which is required by `{closure@src/map/core.rs:775:49: 775:51}: UnwindSafe`\n    = note: `UnwindSafe` is implemented for `&HashTable<usize>`, but not for `&mut HashTable<usize>`\nnote: required because it's used within this closure\n   --> src/map/core.rs:775:49\n    |\n775 |     let panic_result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                                                 ^^\nnote: required by a bound in `std::panic::catch_unwind`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n    |\n349 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n   --> src/map/core.rs:775:49\n    |\n775 |     let panic_result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                        ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                        |                        |\n    |                        |                        `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n    |                        |                        within this `{closure@src/map/core.rs:775:49: 775:51}`\n    |                        required by a bound introduced by this call\n    |\n    = help: within `{closure@src/map/core.rs:775:49: 775:51}`, the trait `UnwindSafe` is not implemented for `&mut HashTable<usize>`, which is required by `{closure@src/map/core.rs:775:49: 775:51}: UnwindSafe`\n    = note: `UnwindSafe` is implemented for `&HashTable<usize>`, but not for `&mut HashTable<usize>`\nnote: required because it's used within this closure\n   --> src/map/core.rs:775:49\n    |\n775 |     let panic_result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                                                 ^^\nnote: required by a bound in `std::panic::catch_unwind`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n    |\n349 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:781:24\n    |\n781 |     assert_eq!(indices.get(&1), Some(&0));\n    |                        ^^^ method not found in `HashTable<usize>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::with_capacity(10); // capacity 10",
                "    for i in 0..5 {",
                "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill five entries",
                "    }",
                "    let entries: Vec<Bucket<usize, &str>> = (5..10)",
                "        .map(|i| Bucket {",
                "            hash: HashValue(i as usize),",
                "            key: i,",
                "            value: \"value\",",
                "        })",
                "        .collect();",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    assert!(indices.capacity() - indices.len() >= 2);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(10);",
                  "    assert_eq!(indices.len(), 5);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(10);",
                  "    let entries: Vec<Bucket<usize, &str>> = (5..10).map(|i| Bucket { hash: HashValue(i as usize), key: i, value: \"value\" }).collect();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.len(), 10);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(10); // capacity 10",
                  "    for i in 0..5 {",
                  "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill five entries",
                  "    }",
                  "    let entries: Vec<Bucket<usize, &str>> = (5..10)",
                  "        .map(|i| Bucket {",
                  "            hash: HashValue(i as usize),",
                  "            key: i,",
                  "            value: \"value\",",
                  "        })",
                  "        .collect();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    assert!(indices.capacity() - indices.len() >= 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(10); // capacity 10",
                  "    for i in 0..5 {",
                  "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill five entries",
                  "    }",
                  "    let entries: Vec<Bucket<usize, &str>> = (5..10)",
                  "        .map(|i| Bucket {",
                  "            hash: HashValue(i as usize),",
                  "            key: i,",
                  "            value: \"value\",",
                  "        })",
                  "        .collect();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(10); // capacity 10",
                  "    for i in 0..5 {",
                  "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill five entries",
                  "    }",
                  "    let entries: Vec<Bucket<usize, &str>> = (5..10)",
                  "        .map(|i| Bucket {",
                  "            hash: HashValue(i as usize),",
                  "            key: i,",
                  "            value: \"value\",",
                  "        })",
                  "        .collect();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(10);",
                  "    assert_eq!(indices.len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(10); // capacity 10",
                  "    for i in 0..5 {",
                  "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill five entries",
                  "    }",
                  "    let entries: Vec<Bucket<usize, &str>> = (5..10)",
                  "        .map(|i| Bucket {",
                  "            hash: HashValue(i as usize),",
                  "            key: i,",
                  "            value: \"value\",",
                  "        })",
                  "        .collect();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(10);",
                  "    let entries: Vec<Bucket<usize, &str>> = (5..10).map(|i| Bucket { hash: HashValue(i as usize), key: i, value: \"value\" }).collect();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.len(), 10);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0282]: type annotations needed for `HashTable<_>`\n   --> src/map/core.rs:776:9\n    |\n776 |     let mut indices = hash_table::HashTable::with_capacity(5);\n    |         ^^^^^^^^^^^   --------------------------------------- type must be known at this point\n    |\nhelp: consider giving `indices` an explicit type, where the type for type parameter `T` is specified\n    |\n776 |     let mut indices: HashTable<T> = hash_table::HashTable::with_capacity(5);\n    |                    ++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n   --> src/map/core.rs:778:43\n    |\n778 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                  ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |                        |\n    |                  |                        `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n    |                  |                        within this `{closure@src/map/core.rs:778:43: 778:45}`\n    |                  required by a bound introduced by this call\n    |\n    = help: within `{closure@src/map/core.rs:778:43: 778:45}`, the trait `UnwindSafe` is not implemented for `&mut HashTable<usize>`, which is required by `{closure@src/map/core.rs:778:43: 778:45}: UnwindSafe`\n    = note: `UnwindSafe` is implemented for `&HashTable<usize>`, but not for `&mut HashTable<usize>`\nnote: required because it's used within this closure\n   --> src/map/core.rs:778:43\n    |\n778 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                                           ^^\nnote: required by a bound in `std::panic::catch_unwind`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n    |\n349 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n   --> src/map/core.rs:778:43\n    |\n778 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                  ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |                        |\n    |                  |                        `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n    |                  |                        within this `{closure@src/map/core.rs:778:43: 778:45}`\n    |                  required by a bound introduced by this call\n    |\n    = help: within `{closure@src/map/core.rs:778:43: 778:45}`, the trait `UnwindSafe` is not implemented for `&mut HashTable<usize>`, which is required by `{closure@src/map/core.rs:778:43: 778:45}: UnwindSafe`\n    = note: `UnwindSafe` is implemented for `&HashTable<usize>`, but not for `&mut HashTable<usize>`\nnote: required because it's used within this closure\n   --> src/map/core.rs:778:43\n    |\n778 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                                           ^^\nnote: required by a bound in `std::panic::catch_unwind`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n    |\n349 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n   --> src/map/core.rs:778:43\n    |\n778 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                  ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |                        |\n    |                  |                        `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n    |                  |                        within this `{closure@src/map/core.rs:778:43: 778:45}`\n    |                  required by a bound introduced by this call\n    |\n    = help: within `{closure@src/map/core.rs:778:43: 778:45}`, the trait `UnwindSafe` is not implemented for `&mut HashTable<usize>`, which is required by `{closure@src/map/core.rs:778:43: 778:45}: UnwindSafe`\n    = note: `UnwindSafe` is implemented for `&HashTable<usize>`, but not for `&mut HashTable<usize>`\nnote: required because it's used within this closure\n   --> src/map/core.rs:778:43\n    |\n778 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                                           ^^\nnote: required by a bound in `std::panic::catch_unwind`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n    |\n349 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::with_capacity(1000); // capacity 1000",
                "    for i in 0..999 {",
                "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill 999 entries",
                "    }",
                "    let entries = vec![Bucket {",
                "        hash: HashValue(999),",
                "        key: 999,",
                "        value: \"last_value\",",
                "    }];",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(1000);",
                  "    for i in 0..999 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(999), key: 999, value: \"last_value\" }];",
                  "    assert!(indices.len() == 999);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(1000);",
                  "    for i in 0..999 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(999), key: 999, value: \"last_value\" }];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.len() == 1000);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(1000); // capacity 1000",
                  "    for i in 0..999 {",
                  "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill 999 entries",
                  "    }",
                  "    let entries = vec![Bucket {",
                  "        hash: HashValue(999),",
                  "        key: 999,",
                  "        value: \"last_value\",",
                  "    }];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(1000); // capacity 1000",
                  "    for i in 0..999 {",
                  "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill 999 entries",
                  "    }",
                  "    let entries = vec![Bucket {",
                  "        hash: HashValue(999),",
                  "        key: 999,",
                  "        value: \"last_value\",",
                  "    }];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(1000);",
                  "    for i in 0..999 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(999), key: 999, value: \"last_value\" }];",
                  "    assert!(indices.len() == 999);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(1000); // capacity 1000",
                  "    for i in 0..999 {",
                  "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill 999 entries",
                  "    }",
                  "    let entries = vec![Bucket {",
                  "        hash: HashValue(999),",
                  "        key: 999,",
                  "        value: \"last_value\",",
                  "    }];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(3), key: 3, value: \"value3\" }, Bucket { hash: HashValue(4), key: 4, value: \"value4\" }];",
                  "    let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });",
                  "    let mut indices = hash_table::HashTable::with_capacity(1000);",
                  "    for i in 0..999 { indices.insert_unique(i as u64, i, |_| unreachable!()); }",
                  "    let entries = vec![Bucket { hash: HashValue(999), key: 999, value: \"last_value\" }];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.len() == 1000);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n   --> src/map/core.rs:777:43\n    |\n777 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                  ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |                        |\n    |                  |                        `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n    |                  |                        within this `{closure@src/map/core.rs:777:43: 777:45}`\n    |                  required by a bound introduced by this call\n    |\n    = help: within `{closure@src/map/core.rs:777:43: 777:45}`, the trait `UnwindSafe` is not implemented for `&mut HashTable<usize>`, which is required by `{closure@src/map/core.rs:777:43: 777:45}: UnwindSafe`\n    = note: `UnwindSafe` is implemented for `&HashTable<usize>`, but not for `&mut HashTable<usize>`\nnote: required because it's used within this closure\n   --> src/map/core.rs:777:43\n    |\n777 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                                           ^^\nnote: required by a bound in `std::panic::catch_unwind`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n    |\n349 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n   --> src/map/core.rs:777:43\n    |\n777 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                  ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |                        |\n    |                  |                        `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n    |                  |                        within this `{closure@src/map/core.rs:777:43: 777:45}`\n    |                  required by a bound introduced by this call\n    |\n    = help: within `{closure@src/map/core.rs:777:43: 777:45}`, the trait `UnwindSafe` is not implemented for `&mut HashTable<usize>`, which is required by `{closure@src/map/core.rs:777:43: 777:45}: UnwindSafe`\n    = note: `UnwindSafe` is implemented for `&HashTable<usize>`, but not for `&mut HashTable<usize>`\nnote: required because it's used within this closure\n   --> src/map/core.rs:777:43\n    |\n777 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                                           ^^\nnote: required by a bound in `std::panic::catch_unwind`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n    |\n349 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n   --> src/map/core.rs:777:43\n    |\n777 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                  ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |                        |\n    |                  |                        `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n    |                  |                        within this `{closure@src/map/core.rs:777:43: 777:45}`\n    |                  required by a bound introduced by this call\n    |\n    = help: within `{closure@src/map/core.rs:777:43: 777:45}`, the trait `UnwindSafe` is not implemented for `&mut HashTable<usize>`, which is required by `{closure@src/map/core.rs:777:43: 777:45}: UnwindSafe`\n    = note: `UnwindSafe` is implemented for `&HashTable<usize>`, but not for `&mut HashTable<usize>`\nnote: required because it's used within this closure\n   --> src/map/core.rs:777:43\n    |\n777 |     let result = std::panic::catch_unwind(|| { insert_bulk_no_grow(&mut indices, &entries); });\n    |                                           ^^\nnote: required by a bound in `std::panic::catch_unwind`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n    |\n349 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::with_capacity(6); // capacity 6",
                "    for i in 0..4 {",
                "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill four entries",
                "    }",
                "    let entries = vec![",
                "        Bucket {",
                "            hash: HashValue(4),",
                "            key: 4,",
                "            value: \"value4\",",
                "        },",
                "        Bucket {",
                "            hash: HashValue(5),",
                "            key: 5,",
                "            value: \"value5\",",
                "        }",
                "    ];",
                "    insert_bulk_no_grow(&mut indices, &entries); ",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 {",
                  "    indices.insert_unique(i as u64, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![Bucket {",
                  "    hash: HashValue(3),",
                  "    key: 3,",
                  "    value: \"value3\",",
                  "    }, Bucket {",
                  "    hash: HashValue(4),",
                  "    key: 4,",
                  "    value: \"value4\",",
                  "    }];",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    });",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 {",
                  "    indices.insert_unique(i as u64, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![Bucket {",
                  "    hash: HashValue(3),",
                  "    key: 3,",
                  "    value: \"value3\",",
                  "    }, Bucket {",
                  "    hash: HashValue(4),",
                  "    key: 4,",
                  "    value: \"value4\",",
                  "    }];",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    });",
                  "    let mut indices = hash_table::HashTable::with_capacity(6);",
                  "    for i in 0..4 {",
                  "    indices.insert_unique(i as u64, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![",
                  "    Bucket {",
                  "    hash: HashValue(4),",
                  "    key: 4,",
                  "    value: \"value4\",",
                  "    },",
                  "    Bucket {",
                  "    hash: HashValue(5),",
                  "    key: 5,",
                  "    value: \"value5\",",
                  "    }",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.len(), 6);  // Verify total entries after insertion."
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(6); // capacity 6",
                  "    for i in 0..4 {",
                  "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill four entries",
                  "    }",
                  "    let entries = vec![",
                  "        Bucket {",
                  "            hash: HashValue(4),",
                  "            key: 4,",
                  "            value: \"value4\",",
                  "        },",
                  "        Bucket {",
                  "            hash: HashValue(5),",
                  "            key: 5,",
                  "            value: \"value5\",",
                  "        }",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries); ",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 {",
                  "    indices.insert_unique(i as u64, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![Bucket {",
                  "    hash: HashValue(3),",
                  "    key: 3,",
                  "    value: \"value3\",",
                  "    }, Bucket {",
                  "    hash: HashValue(4),",
                  "    key: 4,",
                  "    value: \"value4\",",
                  "    }];",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    });",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(6); // capacity 6",
                  "    for i in 0..4 {",
                  "        indices.insert_unique(i as u64, i, |_| unreachable!()); // pre-fill four entries",
                  "    }",
                  "    let entries = vec![",
                  "        Bucket {",
                  "            hash: HashValue(4),",
                  "            key: 4,",
                  "            value: \"value4\",",
                  "        },",
                  "        Bucket {",
                  "            hash: HashValue(5),",
                  "            key: 5,",
                  "            value: \"value5\",",
                  "        }",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries); ",
                  "    let mut indices = hash_table::HashTable::with_capacity(5);",
                  "    for i in 0..3 {",
                  "    indices.insert_unique(i as u64, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![Bucket {",
                  "    hash: HashValue(3),",
                  "    key: 3,",
                  "    value: \"value3\",",
                  "    }, Bucket {",
                  "    hash: HashValue(4),",
                  "    key: 4,",
                  "    value: \"value4\",",
                  "    }];",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    });",
                  "    let mut indices = hash_table::HashTable::with_capacity(6);",
                  "    for i in 0..4 {",
                  "    indices.insert_unique(i as u64, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![",
                  "    Bucket {",
                  "    hash: HashValue(4),",
                  "    key: 4,",
                  "    value: \"value4\",",
                  "    },",
                  "    Bucket {",
                  "    hash: HashValue(5),",
                  "    key: 5,",
                  "    value: \"value5\",",
                  "    }",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.len(), 6);  // Verify total entries after insertion.",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n   --> src/map/core.rs:794:43\n    |\n794 |       let result = std::panic::catch_unwind(|| {\n    |                    ------------------------ ^-\n    |                    |                        |\n    |  __________________|________________________within this `{closure@src/map/core.rs:794:43: 794:45}`\n    | |                  |\n    | |                  required by a bound introduced by this call\n795 | |     insert_bulk_no_grow(&mut indices, &entries);\n796 | |     });\n    | |_____^ `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n    |\n    = help: within `{closure@src/map/core.rs:794:43: 794:45}`, the trait `UnwindSafe` is not implemented for `&mut HashTable<usize>`, which is required by `{closure@src/map/core.rs:794:43: 794:45}: UnwindSafe`\n    = note: `UnwindSafe` is implemented for `&HashTable<usize>`, but not for `&mut HashTable<usize>`\nnote: required because it's used within this closure\n   --> src/map/core.rs:794:43\n    |\n794 |     let result = std::panic::catch_unwind(|| {\n    |                                           ^^\nnote: required by a bound in `std::panic::catch_unwind`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n    |\n349 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n   --> src/map/core.rs:794:43\n    |\n794 |       let result = std::panic::catch_unwind(|| {\n    |                    ------------------------ ^-\n    |                    |                        |\n    |  __________________|________________________within this `{closure@src/map/core.rs:794:43: 794:45}`\n    | |                  |\n    | |                  required by a bound introduced by this call\n795 | |     insert_bulk_no_grow(&mut indices, &entries);\n796 | |     });\n    | |_____^ `&mut HashTable<usize>` may not be safely transferred across an unwind boundary\n    |\n    = help: within `{closure@src/map/core.rs:794:43: 794:45}`, the trait `UnwindSafe` is not implemented for `&mut HashTable<usize>`, which is required by `{closure@src/map/core.rs:794:43: 794:45}: UnwindSafe`\n    = note: `UnwindSafe` is implemented for `&HashTable<usize>`, but not for `&mut HashTable<usize>`\nnote: required because it's used within this closure\n   --> src/map/core.rs:794:43\n    |\n794 |     let result = std::panic::catch_unwind(|| {\n    |                                           ^^\nnote: required by a bound in `std::panic::catch_unwind`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n    |\n349 | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: indices.capacity() - indices.len() >= entries.len() is true, with bound indices.capacity() - indices.len() == entries.len()\n",
        "// constraint: entry in entries is false\n"
      ],
      "input_infer": "1 <= indices.len() <= indices.capacity() <= 100, entries.len() == indices.capacity() - indices.len(), entries.len() <= 50\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::with_capacity(1);",
                "    indices.insert_unique(0, 0, |_| unreachable!());",
                "    ",
                "    let entries = vec![",
                "        Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                "    ];",
                "    ",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![ Bucket { hash: HashValue(1), key: 1, value: \"One\" }, ];",
                  "    assert!(indices.len() == 1);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![ Bucket { hash: HashValue(1), key: 1, value: \"One\" }, ];",
                  "    assert!(indices.capacity() == 1);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![ Bucket { hash: HashValue(1), key: 1, value: \"One\" }, ];",
                  "    assert!(indices.len() + entries.len() <= indices.capacity());"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![ Bucket { hash: HashValue(1), key: 1, value: \"One\" }, ];",
                  "    assert!(indices.contains_key(&1));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    ",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "    ];",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![ Bucket { hash: HashValue(1), key: 1, value: \"One\" }, ];",
                  "    assert!(indices.len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    ",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "    ];",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![ Bucket { hash: HashValue(1), key: 1, value: \"One\" }, ];",
                  "    assert!(indices.capacity() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    ",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "    ];",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![ Bucket { hash: HashValue(1), key: 1, value: \"One\" }, ];",
                  "    assert!(indices.len() + entries.len() <= indices.capacity());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    ",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "    ];",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(1);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![ Bucket { hash: HashValue(1), key: 1, value: \"One\" }, ];",
                  "    assert!(indices.contains_key(&1));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `contains_key` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:757:21\n    |\n757 |     assert!(indices.contains_key(&1));\n    |                     ^^^^^^^^^^^^ method not found in `HashTable<{integer}>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::with_capacity(2);",
                "    indices.insert_unique(0, 0, |_| unreachable!());",
                "    ",
                "    let entries = vec![",
                "        Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                "        Bucket { hash: HashValue(2), key: 2, value: \"Two\" },",
                "    ];",
                "    ",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "    Bucket { hash: HashValue(2), key: 2, value: \"Two\" },",
                  "    ];",
                  "    let initial_length = indices.len();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.len(), initial_length + entries.len());"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "    Bucket { hash: HashValue(2), key: 2, value: \"Two\" },",
                  "    ];",
                  "    let initial_length = indices.len();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.contains_key(&1));"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "    Bucket { hash: HashValue(2), key: 2, value: \"Two\" },",
                  "    ];",
                  "    let initial_length = indices.len();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.contains_key(&2));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    ",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "        Bucket { hash: HashValue(2), key: 2, value: \"Two\" },",
                  "    ];",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "    Bucket { hash: HashValue(2), key: 2, value: \"Two\" },",
                  "    ];",
                  "    let initial_length = indices.len();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.len(), initial_length + entries.len());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    ",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "        Bucket { hash: HashValue(2), key: 2, value: \"Two\" },",
                  "    ];",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "    Bucket { hash: HashValue(2), key: 2, value: \"Two\" },",
                  "    ];",
                  "    let initial_length = indices.len();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.contains_key(&1));",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    ",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "        Bucket { hash: HashValue(2), key: 2, value: \"Two\" },",
                  "    ];",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(2);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(1), key: 1, value: \"One\" },",
                  "    Bucket { hash: HashValue(2), key: 2, value: \"Two\" },",
                  "    ];",
                  "    let initial_length = indices.len();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.contains_key(&2));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `contains_key` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:763:21\n    |\n763 |     assert!(indices.contains_key(&1));\n    |                     ^^^^^^^^^^^^ method not found in `HashTable<usize>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `contains_key` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:763:21\n    |\n763 |     assert!(indices.contains_key(&2));\n    |                     ^^^^^^^^^^^^ method not found in `HashTable<usize>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::with_capacity(100);",
                "    for i in 0..50 {",
                "        indices.insert_unique(i, i, |_| unreachable!());",
                "    }",
                "",
                "    let entries = (50..100).map(|i| {",
                "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                "    }).collect::<Vec<_>>();",
                "    ",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.len() == 50);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.capacity() == 100);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.capacity() - indices.len() == 50);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.len() == 100);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.get(50).is_some());"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.get(99).is_some());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = (50..100).map(|i| {",
                  "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.len() == 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = (50..100).map(|i| {",
                  "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.capacity() == 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = (50..100).map(|i| {",
                  "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.capacity() - indices.len() == 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = (50..100).map(|i| {",
                  "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.len() == 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = (50..100).map(|i| {",
                  "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.get(50).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = (50..100).map(|i| {",
                  "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    ",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(100);",
                  "    for i in 0..50 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (50..100).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.get(99).is_some());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:755:25\n    |\n755 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:755:25\n    |\n755 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:755:25\n    |\n755 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:755:25\n    |\n755 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:763:25\n    |\n763 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:755:25\n    |\n755 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:763:25\n    |\n763 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0599]: no method named `get` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:764:21\n    |\n764 |     assert!(indices.get(50).is_some());\n    |                     ^^^ method not found in `HashTable<u64>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 3 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:755:25\n    |\n755 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:763:25\n    |\n763 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0599]: no method named `get` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:764:21\n    |\n764 |     assert!(indices.get(99).is_some());\n    |                     ^^^ method not found in `HashTable<u64>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 3 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::with_capacity(20);",
                "    for i in 0..10 {",
                "        indices.insert_unique(i, i, |_| unreachable!());",
                "    }",
                "",
                "    let entries = vec![",
                "        Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                "        Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                "    ];",
                "",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "    Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "    assert_eq!(indices.len(), 10);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "    Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.len(), 12);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "    Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.contains_key(&10));"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "    Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.contains_key(&11));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "        Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "    Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "    assert_eq!(indices.len(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "        Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "    Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert_eq!(indices.len(), 12);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "        Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "    Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.contains_key(&10));",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "        Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(20);",
                  "    for i in 0..10 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(10), key: 10, value: \"Ten\" },",
                  "    Bucket { hash: HashValue(11), key: 11, value: \"Eleven\" },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    assert!(indices.contains_key(&11));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:756:25\n    |\n756 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:756:25\n    |\n756 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:765:25\n    |\n765 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:756:25\n    |\n756 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:765:25\n    |\n765 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0599]: no method named `contains_key` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:766:21\n    |\n766 |     assert!(indices.contains_key(&10));\n    |                     ^^^^^^^^^^^^ method not found in `HashTable<u64>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 3 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:756:25\n    |\n756 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:765:25\n    |\n765 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0599]: no method named `contains_key` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:766:21\n    |\n766 |     assert!(indices.contains_key(&11));\n    |                     ^^^^^^^^^^^^ method not found in `HashTable<u64>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 3 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::with_capacity(3);",
                "    for i in 0..3 {",
                "        indices.insert_unique(i, i, |_| unreachable!());",
                "    }",
                "",
                "    let entries = vec![",
                "        Bucket { hash: HashValue(3), key: 3, value: \"Three\" },",
                "        Bucket { hash: HashValue(4), key: 4, value: \"Four\" },",
                "    ];",
                "",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(3);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    indices.insert_unique(1, 1, |_| unreachable!());",
                  "    indices.insert_unique(2, 2, |_| unreachable!());",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(3), key: 3, value: \"Three\" },",
                  "    Bucket { hash: HashValue(4), key: 4, value: \"Four\" },",
                  "    ];",
                  "    assert!(indices.capacity() - indices.len() == 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(3);",
                  "    for i in 0..3 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = vec![",
                  "        Bucket { hash: HashValue(3), key: 3, value: \"Three\" },",
                  "        Bucket { hash: HashValue(4), key: 4, value: \"Four\" },",
                  "    ];",
                  "",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(3);",
                  "    indices.insert_unique(0, 0, |_| unreachable!());",
                  "    indices.insert_unique(1, 1, |_| unreachable!());",
                  "    indices.insert_unique(2, 2, |_| unreachable!());",
                  "    let entries = vec![",
                  "    Bucket { hash: HashValue(3), key: 3, value: \"Three\" },",
                  "    Bucket { hash: HashValue(4), key: 4, value: \"Four\" },",
                  "    ];",
                  "    assert!(indices.capacity() - indices.len() == 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:757:25\n    |\n757 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::with_capacity(50);",
                "    for i in 0..25 {",
                "        indices.insert_unique(i, i, |_| unreachable!());",
                "    }",
                "",
                "    let entries = (25..50).map(|i| {",
                "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                "    }).collect::<Vec<_>>();",
                "",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (25..50).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.capacity() - indices.len() == 25);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (25..50).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert_eq!(indices.len(), 25);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (25..50).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.get(&25).is_some());"
                ],
                [
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (25..50).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.get(&49).is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = (25..50).map(|i| {",
                  "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (25..50).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.capacity() - indices.len() == 25);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = (25..50).map(|i| {",
                  "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (25..50).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert_eq!(indices.len(), 25);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = (25..50).map(|i| {",
                  "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (25..50).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.get(&25).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "        indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "",
                  "    let entries = (25..50).map(|i| {",
                  "        Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices = hash_table::HashTable::with_capacity(50);",
                  "    for i in 0..25 {",
                  "    indices.insert_unique(i, i, |_| unreachable!());",
                  "    }",
                  "    let entries = (25..50).map(|i| {",
                  "    Bucket { hash: HashValue(i as usize), key: i as usize, value: \"Value\" }",
                  "    }).collect::<Vec<_>>();",
                  "    assert!(indices.get(&49).is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:755:25\n    |\n755 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:755:25\n    |\n755 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:755:25\n    |\n755 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0599]: no method named `get` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:763:21\n    |\n763 |     assert!(indices.get(&25).is_some());\n    |                     ^^^ method not found in `HashTable<u64>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:755:25\n    |\n755 |     insert_bulk_no_grow(&mut indices, &entries);\n    |     ------------------- ^^^^^^^^^^^^ expected `&mut HashTable<usize>`, found `&mut HashTable<u64>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut HashTable<usize>`\n               found mutable reference `&mut HashTable<u64>`\nnote: function defined here\n   --> src/map/core.rs:83:4\n    |\n83  | fn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]) {\n    |    ^^^^^^^^^^^^^^^^^^^       ---------------------\n\nerror[E0599]: no method named `get` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:763:21\n    |\n763 |     assert!(indices.get(&49).is_none());\n    |                     ^^^ method not found in `HashTable<u64>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: indices.capacity() - indices.len() >= entries.len() is false\n"
      ],
      "input_infer": "entries.len() in the range [1, indices.capacity() - indices.len() + 1]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::with_capacity(2);",
                "    let entries: Vec<Bucket<usize, usize>> = vec![",
                "        Bucket { hash: HashValue(1), key: 10, value: 100 },",
                "        Bucket { hash: HashValue(2), key: 20, value: 200 },",
                "        Bucket { hash: HashValue(3), key: 30, value: 300 },",
                "    ];",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(2);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "    Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "    Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    Bucket { hash: HashValue(3), key: 30, value: 300 },",
                  "    ];",
                  "    assert!(indices.capacity() - indices.len() < entries.len());"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(2);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "    Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "    Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    Bucket { hash: HashValue(3), key: 30, value: 300 },",
                  "    ];",
                  "    assert!(std::panic::catch_unwind(|| {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(2);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "        Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "        Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "        Bucket { hash: HashValue(3), key: 30, value: 300 },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(2);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "    Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "    Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    Bucket { hash: HashValue(3), key: 30, value: 300 },",
                  "    ];",
                  "    assert!(indices.capacity() - indices.len() < entries.len());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(2);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "        Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "        Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "        Bucket { hash: HashValue(3), key: 30, value: 300 },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(2);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "    Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "    Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    Bucket { hash: HashValue(3), key: 30, value: 300 },",
                  "    ];",
                  "    assert!(std::panic::catch_unwind(|| {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror: mismatched closing delimiter: `}`\n   --> src/map/core.rs:760:37\n    |\n746 | {\n    | - closing delimiter possibly meant for this\n...\n760 |     assert!(std::panic::catch_unwind(|| {\n    |                                     ^ unclosed delimiter\n761 | }\n762 | }\n    | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n   --> src/map/core.rs:762:3\n    |\n740 | mod llmtests {\n    |              - unclosed delimiter\n...\n762 | }\n    |   ^\n\nerror: could not compile `indexmap` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::with_capacity(3);",
                "    let entries: Vec<Bucket<usize, usize>> = vec![",
                "        Bucket { hash: HashValue(1), key: 10, value: 100 },",
                "        Bucket { hash: HashValue(2), key: 20, value: 200 },",
                "    ];",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(3);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "    Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "    Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    ];",
                  "    panic::catch_unwind(|| {",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    }).unwrap_err();",
                  "    assert!(indices.len() == 0);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(3);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "    Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "    Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    ];",
                  "    panic::catch_unwind(|| {",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    }).unwrap_err();",
                  "    assert!(indices.capacity() == 3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(3);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "        Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "        Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(3);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "    Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "    Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    ];",
                  "    panic::catch_unwind(|| {",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    }).unwrap_err();",
                  "    assert!(indices.len() == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(3);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "        Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "        Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(3);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "    Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "    Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    ];",
                  "    panic::catch_unwind(|| {",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    }).unwrap_err();",
                  "    assert!(indices.capacity() == 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0433]: failed to resolve: use of undeclared crate or module `panic`\n   --> src/map/core.rs:757:5\n    |\n757 |     panic::catch_unwind(|| {\n    |     ^^^^^ use of undeclared crate or module `panic`\n    |\nhelp: consider importing this module\n    |\n741 +    use std::panic;\n    |\n\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0433]: failed to resolve: use of undeclared crate or module `panic`\n   --> src/map/core.rs:757:5\n    |\n757 |     panic::catch_unwind(|| {\n    |     ^^^^^ use of undeclared crate or module `panic`\n    |\nhelp: consider importing this module\n    |\n741 +    use std::panic;\n    |\n\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::with_capacity(1);",
                "    let entries: Vec<Bucket<usize, usize>> = vec![",
                "        Bucket { hash: HashValue(1), key: 10, value: 100 },",
                "        Bucket { hash: HashValue(2), key: 20, value: 200 },",
                "    ];",
                "    insert_bulk_no_grow(&mut indices, &entries);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(1);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "    Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "    Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    ];",
                  "    assert!(std::panic::catch_unwind(|| {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(1);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "        Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "        Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    ];",
                  "    insert_bulk_no_grow(&mut indices, &entries);",
                  "    let mut indices: Indices = hash_table::HashTable::with_capacity(1);",
                  "    let entries: Vec<Bucket<usize, usize>> = vec![",
                  "    Bucket { hash: HashValue(1), key: 10, value: 100 },",
                  "    Bucket { hash: HashValue(2), key: 20, value: 200 },",
                  "    ];",
                  "    assert!(std::panic::catch_unwind(|| {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror: mismatched closing delimiter: `}`\n   --> src/map/core.rs:758:37\n    |\n746 | {\n    | - closing delimiter possibly meant for this\n...\n758 |     assert!(std::panic::catch_unwind(|| {\n    |                                     ^ unclosed delimiter\n759 | }\n760 | }\n    | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n   --> src/map/core.rs:760:3\n    |\n740 | mod llmtests {\n    |              - unclosed delimiter\n...\n760 | }\n    |   ^\n\nerror: could not compile `indexmap` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}