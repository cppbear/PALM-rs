{
  "name": "indexmap::set::<&set::IndexSet<T, S1> as std::ops::Sub<&set::IndexSet<T, S2>>>::sub",
  "name_with_impl": "indexmap::set::{impl#20}::sub",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:123:1:123:13"
  },
  "visible": true,
  "loc": "src/set.rs:1298:5:1300:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "1 <= T <= 100, 1 <= S1 <= 100, 1 <= S2 <= 100, 0 <= self.len() <= 1000, 0 <= other.len() <= 1000\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                "    let _result = set1.sub(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 0);"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                "",
                "    for i in 1..=10 {",
                "        set1.insert(i);",
                "    }",
                "    ",
                "    for i in 5..=15 {",
                "        set2.insert(i);",
                "    }",
                "",
                "    let _result = set1.sub(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 5);"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&1));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&2));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&3));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&4));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&5) == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "    ",
                  "    for i in 5..=15 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "    ",
                  "    for i in 5..=15 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&1));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "    ",
                  "    for i in 5..=15 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&2));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "    ",
                  "    for i in 5..=15 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&3));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "    ",
                  "    for i in 5..=15 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&4));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "    ",
                  "    for i in 5..=15 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 5..=15 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&5) == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                "",
                "    for i in 1..=10 {",
                "        set1.insert(i);",
                "        set2.insert(i);",
                "    }",
                "",
                "    let _result = set1.sub(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 {",
                  "    set1.insert(i);",
                  "    set2.insert(i);",
                  "    }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.is_empty());"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 {",
                  "    set1.insert(i);",
                  "    set2.insert(i);",
                  "    }",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 0);"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 {",
                  "    set1.insert(i);",
                  "    set2.insert(i);",
                  "    }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.iter().next().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 {",
                  "    set1.insert(i);",
                  "    set2.insert(i);",
                  "    }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 {",
                  "    set1.insert(i);",
                  "    set2.insert(i);",
                  "    }",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 {",
                  "    set1.insert(i);",
                  "    set2.insert(i);",
                  "    }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.iter().next().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                "",
                "    for i in 1..=10 {",
                "        set1.insert(i);",
                "    }",
                "",
                "    for i in 11..=20 {",
                "        set2.insert(i);",
                "    }",
                "",
                "    let _result = set1.sub(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 10);"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&1));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&2));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&3));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&4));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&5));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&6));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&7));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&8));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&9));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&10));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&1));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&2));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&3));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&4));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&5));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&6));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&7));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&8));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&9));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=10 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 11..=20 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=10 { set1.insert(i); }",
                  "    for i in 11..=20 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&10));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                "",
                "    for i in 1..=100 {",
                "        set1.insert(i);",
                "    }",
                "",
                "    for i in 50..=150 {",
                "        set2.insert(i);",
                "    }",
                "",
                "    let _result = set1.sub(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 49);"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&1));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&2));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&3));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&4));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&5));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&6));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&7));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&8));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&9));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&10));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&11));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&12));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&13));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&14));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&15));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&16));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&17));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&18));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&19));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&20));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&21));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&22));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&23));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&24));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&25));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&26));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&27));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&28));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&29));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&30));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&31));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&32));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&33));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&34));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&35));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&36));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&37));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&38));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&39));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&40));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&41));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&42));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&43));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&44));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&45));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&46));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&47));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&48));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&49));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&50));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&51));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&52));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&53));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&54));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&55));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&56));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&57));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&58));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&59));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&60));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&61));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&62));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&63));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&64));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&65));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&66));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&67));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&68));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&69));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&70));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&71));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&72));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&73));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&74));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&75));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&76));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&77));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&78));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&79));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&80));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&81));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&82));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&83));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&84));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&85));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&86));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&87));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&88));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&89));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&90));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&91));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&92));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&93));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&94));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&95));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&96));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&97));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&98));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&99));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&100));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&101));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&102));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&103));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&104));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&105));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&106));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&107));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&108));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&109));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&110));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&111));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&112));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&113));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&114));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&115));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&116));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&117));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&118));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&119));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&120));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&121));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&122));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&123));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&124));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&125));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&126));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&127));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&128));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&129));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&130));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&131));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&132));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&133));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&134));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&135));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&136));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&137));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&138));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&139));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&140));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&141));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&142));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&143));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&144));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&145));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&146));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&147));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&148));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&149));"
                ],
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&150));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 49);",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(result.contains(&1));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&2));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&3));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&4));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&5));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&6));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&7));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "  ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "  ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "  ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&8));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(result.contains(&9));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&10));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "   assert!(result.contains(&11));  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&12));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&13));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&14));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&15));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&16));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&17));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(result.contains(&18));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&19));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&20));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&21));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(result.contains(&22));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&23));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "   assert!(result.contains(&24));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&25));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&26));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&27));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(result.contains(&28));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(result.contains(&29));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "   assert!(result.contains(&30));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(result.contains(&31));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(result.contains(&32));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&33));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(result.contains(&34));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(result.contains(&35));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "",
                  "",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "   assert!(result.contains(&37));  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(result.contains(&38));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&39));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&40));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default(); // Made mutable",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default(); // Made mutable",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(result.contains(&41));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&42));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&43));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&44));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&45));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&46));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&47));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&48));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&49));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&50));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&51));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&52));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&53));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&54));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&55));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&56));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&57));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&58));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default(); // changed to mutable",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default(); // changed to mutable",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&59));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&60));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&61));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&62));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&63));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&64));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&65));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&66));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default(); // Changed to mutable",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default(); // Changed to mutable",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&67));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(!result.contains(&68));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "   assert!(!result.contains(&69));  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&70));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&71));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(!result.contains(&72));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(!result.contains(&73));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(!result.contains(&74));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&75));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&76));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&77));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&78));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&79));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&80));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&81));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&82));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "   assert!(!result.contains(&83));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&84));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(!result.contains(&85));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&86));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default(); // Declare mutable",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default(); // Declare mutable",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&87));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  " ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  " ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  " ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&88));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&89));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&90));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "   assert!(!result.contains(&91));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&92));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(!result.contains(&93));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&94));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&95));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&96));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&97));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&98));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&99));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&100));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "   assert!(!result.contains(&101));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&102));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&103));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&104));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&105));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&106));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&107));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&108));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(!result.contains(&109));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&110));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&111));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "    assert!(!result.contains(&112));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&113));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&114));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&115));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  " ",
                  "   for i in 1..=100 {  ",
                  "       set1.insert(i);  ",
                  "   }  ",
                  " ",
                  "   for i in 50..=150 {  ",
                  "       set2.insert(i);  ",
                  "   }  ",
                  " ",
                  "   let _result = set1.sub(&set2);  ",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();  ",
                  "   for i in 1..=100 { set1.insert(i); }  ",
                  "   for i in 50..=150 { set2.insert(i); }  ",
                  "   let result = set1.sub(&set2);  ",
                  "   assert!(!result.contains(&116));  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "   let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&117));",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   for i in 1..=100 {",
                  "       set1.insert(i);",
                  "   }",
                  "   ",
                  "   for i in 50..=150 {",
                  "       set2.insert(i);",
                  "   }",
                  "   ",
                  "   let _result = set1.sub(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   for i in 1..=100 { set1.insert(i); }",
                  "   for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&118));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&119));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&120));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&121));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&122));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&123));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&124));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&125));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&126));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&127));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&128));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&129));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&130));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&131));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&132));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&133));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&134));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&135));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&136));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&137));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&138));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&139));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&140));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&141));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&142));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&143));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&144));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&145));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&146));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&147));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&148));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&149));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "",
                  "    for i in 1..=100 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 50..=150 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=100 { set1.insert(i); }",
                  "    for i in 50..=150 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&150));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling syn v2.0.101\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1326:24\n     |\n1326 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1324 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1327:25\n     |\n1327 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/set.rs:1305:8\n     |\n1305 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0596]: cannot borrow `set1` as mutable, as it is not declared as mutable\n    --> src/set.rs:1323:24\n     |\n1323 |     for i in 1..=100 { set1.insert(i); }\n     |                        ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1321 |     let mut set1: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nerror[E0596]: cannot borrow `set2` as mutable, as it is not declared as mutable\n    --> src/set.rs:1324:25\n     |\n1324 |     for i in 50..=150 { set2.insert(i); }\n     |                         ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1322 |     let mut set2: IndexSet<i32, RandomState> = IndexSet::default();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                "    ",
                "    for i in 1..=20 {",
                "        set1.insert(i);",
                "    }",
                "",
                "    for i in 10..=30 {",
                "        set2.insert(i);",
                "    }",
                "",
                "    let _result = set1.sub(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 9);"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&1));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&2));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&3));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&4));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&5));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&6));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&7));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&8));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&9));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&10));"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&11));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert_eq!(result.len(), 9);",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&1));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&2));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&3));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&4));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&5));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&6));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&7));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&8));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(result.contains(&9));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&10));",
                  "}"
                ],
                [
                  "{",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    ",
                  "    for i in 1..=20 {",
                  "        set1.insert(i);",
                  "    }",
                  "",
                  "    for i in 10..=30 {",
                  "        set2.insert(i);",
                  "    }",
                  "",
                  "    let _result = set1.sub(&set2);",
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "    for i in 1..=20 { set1.insert(i); }",
                  "    for i in 10..=30 { set2.insert(i); }",
                  "    let result = set1.sub(&set2);",
                  "    assert!(!result.contains(&11));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}