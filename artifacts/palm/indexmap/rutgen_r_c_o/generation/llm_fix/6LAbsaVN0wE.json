{
  "name": "indexmap::set::set::IndexSet<T, S>::symmetric_difference",
  "name_with_impl": "indexmap::set::{impl#5}::symmetric_difference",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:123:1:123:13"
  },
  "visible": true,
  "loc": "src/set.rs:531:5:539:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "0 <= index <= 1000, 0 <= value_count <= 1000, 1 <= set_count <= 10, 0 <= additional_values <= 1000\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    let set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    let _ = set1.symmetric_difference(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    assert!(result.iter.len() == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let _ = set1.symmetric_difference(&set2);",
                  "   let set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    assert!(result.iter.len() == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0616]: field `iter` of struct `set::iter::SymmetricDifference` is private\n    --> src/set.rs:1318:20\n     |\n1318 |     assert!(result.iter.len() == 0);\n     |                    ^^^^ private field\n\nFor more information about this error, try `rustc --explain E0616`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    set1.insert(1);",
                "    set2.insert(2);",
                "    let _ = set1.symmetric_difference(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set1.insert(1);",
                  "    set2.insert(2);",
                  "    let symmetric_diff = set1.symmetric_difference(&set2);",
                  "    let result: Vec<_> = symmetric_diff.iter().collect();",
                  "    assert_eq!(result, vec![1, 2]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::new();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::new();",
                  "   set1.insert(1);",
                  "   set2.insert(2);",
                  "   let _ = set1.symmetric_difference(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::new();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::new();",
                  "   set1.insert(1);",
                  "   set2.insert(2);",
                  "   let symmetric_diff = set1.symmetric_difference(&set2);",
                  "   let result: Vec<_> = symmetric_diff.iter().collect();",
                  "   assert_eq!(result, vec![1, 2]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for struct `set::iter::SymmetricDifference` in the current scope\n    --> src/set.rs:1322:40\n     |\n1322 |    let result: Vec<_> = symmetric_diff.iter().collect();\n     |                                        ^^^^ private field, not a method\n     |\n    ::: src/set/iter.rs:350:1\n     |\n350  | pub struct SymmetricDifference<'a, T, S1, S2> {\n     | --------------------------------------------- method `iter` not found for this struct\n     |\nhelp: there is a method `filter` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:884:5\n     |\n884  | /     fn filter<P>(self, predicate: P) -> Filter<Self, P>\n885  | |     where\n886  | |         Self: Sized,\n887  | |         P: FnMut(&Self::Item) -> bool,\n     | |______________________________________^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    set1.insert(1);",
                "    set1.insert(2);",
                "    set2.insert(2);",
                "    set2.insert(3);",
                "    let _ = set1.symmetric_difference(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set1.insert(1);",
                  "    set1.insert(2);",
                  "    set2.insert(2);",
                  "    set2.insert(3);",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    assert_eq!(result.collect::<Vec<_>>(), vec![1, 3]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "  let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::with_hasher(RandomState::new()) };",
                  "  let mut set2: IndexSet<i32, RandomState> = IndexSet::with_hasher(RandomState::new());",
                  "   set1.insert(1);",
                  "   set1.insert(2);",
                  "   set2.insert(2);",
                  "   set2.insert(3);",
                  "   let _ = set1.symmetric_difference(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::with_hasher(RandomState::new()) };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::with_hasher(RandomState::new()) };",
                  "    set1.insert(1);",
                  "    set1.insert(2);",
                  "    set2.insert(2);",
                  "    set2.insert(3);",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    assert_eq!(result.collect::<Vec<_>>(), vec![1, 3]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: can't compare `&i32` with `{integer}`\n    --> src/set.rs:1326:5\n     |\n1326 |     assert_eq!(result.collect::<Vec<_>>(), vec![1, 3]);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `&i32 == {integer}`\n     |\n     = help: the trait `PartialEq<{integer}>` is not implemented for `&i32`, which is required by `std::vec::Vec<&i32>: PartialEq<std::vec::Vec<{integer}>>`\n     = help: the trait `PartialEq` is implemented for `i32`\n     = help: for that trait implementation, expected `i32`, found `&i32`\n     = note: required for `std::vec::Vec<&i32>` to implement `PartialEq<std::vec::Vec<{integer}>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    ",
                "    for i in 0..500 {",
                "        set1.insert(i);",
                "    }",
                "    for i in 250..750 {",
                "        set2.insert(i);",
                "    }",
                "    let _ = set1.symmetric_difference(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    for i in 0..500 {",
                  "    set1.insert(i);",
                  "    }",
                  "    for i in 250..750 {",
                  "    set2.insert(i);",
                  "    }",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    assert_eq!(result.collect::<Vec<_>>(), vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499]);"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    for i in 0..500 {",
                  "    set1.insert(i);",
                  "    }",
                  "    for i in 250..750 {",
                  "    set2.insert(i);",
                  "    }",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    assert_eq!(result.len(), 500);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };  ",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::new();  ",
                  "   ",
                  "   for i in 0..500 {",
                  "       set1.insert(i);",
                  "   }",
                  "   for i in 250..750 {",
                  "       set2.insert(i);",
                  "   }",
                  "   let _ = set1.symmetric_difference(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   for i in 0..500 {",
                  "   set1.insert(i);",
                  "   }",
                  "   for i in 250..750 {",
                  "   set2.insert(i);",
                  "   }",
                  "   let result = set1.symmetric_difference(&set2);",
                  "   assert_eq!(result.collect::<Vec<_>>(), vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499]);",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   ",
                  "   for i in 0..500 {",
                  "       set1.insert(i);",
                  "   }",
                  "   for i in 250..750 {",
                  "       set2.insert(i);",
                  "   }",
                  "   let _ = set1.symmetric_difference(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "    for i in 0..500 {",
                  "    set1.insert(i);",
                  "    }",
                  "    for i in 250..750 {",
                  "    set2.insert(i);",
                  "    }",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    assert_eq!(result.len(), 500);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: can't compare `&i32` with `{integer}`\n    --> src/set.rs:1331:4\n     |\n1331 |    assert_eq!(result.collect::<Vec<_>>(), vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499...\n     |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `&i32 == {integer}`\n     |\n     = help: the trait `PartialEq<{integer}>` is not implemented for `&i32`, which is required by `std::vec::Vec<&i32>: PartialEq<std::vec::Vec<{integer}>>`\n     = help: the trait `PartialEq` is implemented for `i32`\n     = help: for that trait implementation, expected `i32`, found `&i32`\n     = note: required for `std::vec::Vec<&i32>` to implement `PartialEq<std::vec::Vec<{integer}>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for struct `set::iter::SymmetricDifference` in the current scope\n    --> src/set.rs:1331:23\n     |\n1331 |     assert_eq!(result.len(), 500);\n     |                       ^^^\n     |\n    ::: src/set/iter.rs:350:1\n     |\n350  | pub struct SymmetricDifference<'a, T, S1, S2> {\n     | --------------------------------------------- method `len` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `len`, perhaps you need to implement it:\n             candidate #1: `ExactSizeIterator`\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3889:5\n     |\n3889 | /     fn le<I>(self, other: I) -> bool\n3890 | |     where\n3891 | |         I: IntoIterator,\n3892 | |         Self::Item: PartialOrd<I::Item>,\n3893 | |         Self: Sized,\n     | |____________________^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    ",
                "    set2.insert(42);",
                "    let _ = set1.symmetric_difference(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set2.insert(42);",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    assert!(result.iter.count() == 0);"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set2.insert(42);",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    let mut set3: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set3.insert(1);",
                  "    set3.insert(2);",
                  "    set3.insert(3);",
                  "    set1.insert(1);",
                  "    set1.insert(2);",
                  "    set1.insert(3);",
                  "    let result2 = set1.symmetric_difference(&set3);",
                  "    assert!(result2.iter.count() == 0);"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set2.insert(42);",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    let mut set3: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set3.insert(1);",
                  "    set3.insert(2);",
                  "    set3.insert(3);",
                  "    set1.insert(1);",
                  "    set1.insert(2);",
                  "    set1.insert(3);",
                  "    let result2 = set1.symmetric_difference(&set3);",
                  "    set1.insert(4);",
                  "    let result3 = set1.symmetric_difference(&set3);",
                  "    assert!(result3.iter.count() == 1);"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set2.insert(42);",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    let mut set3: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set3.insert(1);",
                  "    set3.insert(2);",
                  "    set3.insert(3);",
                  "    set1.insert(1);",
                  "    set1.insert(2);",
                  "    set1.insert(3);",
                  "    let result2 = set1.symmetric_difference(&set3);",
                  "    set1.insert(4);",
                  "    let result3 = set1.symmetric_difference(&set3);",
                  "    assert!(result3.iter.next().unwrap() == &4);"
                ],
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set2.insert(42);",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    let mut set3: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set3.insert(1);",
                  "    set3.insert(2);",
                  "    set3.insert(3);",
                  "    set1.insert(1);",
                  "    set1.insert(2);",
                  "    set1.insert(3);",
                  "    let result2 = set1.symmetric_difference(&set3);",
                  "    set1.insert(4);",
                  "    let result3 = set1.symmetric_difference(&set3);",
                  "    set2.insert(10);",
                  "    let result4 = set1.symmetric_difference(&set2);",
                  "    assert!(result4.iter.count() == 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   ",
                  "   set2.insert(42);",
                  "   let _ = set1.symmetric_difference(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   set2.insert(42);",
                  "   let result = set1.symmetric_difference(&set2);",
                  "   assert!(result.count() == 0);",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::new();",
                  "    ",
                  "    set2.insert(42);",
                  "    let _ = set1.symmetric_difference(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::new();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::new();",
                  "   set2.insert(42);",
                  "   let result = set1.symmetric_difference(&set2);",
                  "   let mut set3: IndexSet<i32, RandomState> = IndexSet::new();",
                  "    set3.insert(1);",
                  "    set3.insert(2);",
                  "    set3.insert(3);",
                  "    set1.insert(1);",
                  "    set1.insert(2);",
                  "    set1.insert(3);",
                  "    let result2 = set1.symmetric_difference(&set3);",
                  "    assert!(result2.iter.count() == 0);",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "    ",
                  "    set2.insert(42);",
                  "    let _ = set1.symmetric_difference(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::new();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::new();",
                  "    set2.insert(42);",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    let mut set3: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set3.insert(1);",
                  "    set3.insert(2);",
                  "    set3.insert(3);",
                  "    set1.insert(1);",
                  "    set1.insert(2);",
                  "    set1.insert(3);",
                  "    let result2 = set1.symmetric_difference(&set3);",
                  "    set1.insert(4);",
                  "    let result3 = set1.symmetric_difference(&set3);",
                  "   assert!(result3.count() == 1);",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   ",
                  "   set2.insert(42);",
                  "   let _ = set1.symmetric_difference(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "    set2.insert(42);",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    let mut set3: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    set3.insert(1);",
                  "    set3.insert(2);",
                  "    set3.insert(3);",
                  "    set1.insert(1);",
                  "    set1.insert(2);",
                  "    set1.insert(3);",
                  "    let result2 = set1.symmetric_difference(&set3);",
                  "    set1.insert(4);",
                  "   let result3: Vec<_> = set1.symmetric_difference(&set3).cloned().collect();  ",
                  "   assert!(result3.iter().next().unwrap() == &4);  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::default();",
                  "   ",
                  "   set2.insert(42);",
                  "   let _ = set1.symmetric_difference(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   set2.insert(42);",
                  "   let result = set1.symmetric_difference(&set2);",
                  "   let mut set3: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   set3.insert(1);",
                  "   set3.insert(2);",
                  "   set3.insert(3);",
                  "   set1.insert(1);",
                  "   set1.insert(2);",
                  "   set1.insert(3);",
                  "   let result2 = set1.symmetric_difference(&set3);",
                  "   set1.insert(4);",
                  "   let result3 = set1.symmetric_difference(&set3);",
                  "   set2.insert(10);",
                  "   let result4 = set1.symmetric_difference(&set2);",
                  "   assert!(result4.iter.count() == 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0616]: field `iter` of struct `set::iter::SymmetricDifference` is private\n    --> src/set.rs:1329:21\n     |\n1329 |     assert!(result2.iter.count() == 0);\n     |                     ^^^^ private field\n\nFor more information about this error, try `rustc --explain E0616`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0433]: failed to resolve: use of undeclared type `IndexMapCore`\n    --> src/set.rs:1321:81\n     |\n1321 |     let mut set3: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };\n     |                                                                                 ^^^^^^^^^^^^\n     |                                                                                 |\n     |                                                                                 use of undeclared type `IndexMapCore`\n     |                                                                                 help: a struct with a similar name exists: `IndexMap`\n     |\nnote: struct `crate::map::tests::IndexMapCore` exists but is inaccessible\n    --> src/map/core.rs:31:1\n     |\n31   | pub(crate) struct IndexMapCore<K, V> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0433]: failed to resolve: use of undeclared type `IndexMapCore`\n    --> src/set.rs:1321:81\n     |\n1321 |     let mut set3: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };\n     |                                                                                 ^^^^^^^^^^^^\n     |                                                                                 |\n     |                                                                                 use of undeclared type `IndexMapCore`\n     |                                                                                 help: a struct with a similar name exists: `IndexMap`\n     |\nnote: struct `crate::map::tests::IndexMapCore` exists but is inaccessible\n    --> src/map/core.rs:31:1\n     |\n31   | pub(crate) struct IndexMapCore<K, V> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0616]: field `iter` of struct `set::iter::SymmetricDifference` is private\n    --> src/set.rs:1333:20\n     |\n1333 |    assert!(result4.iter.count() == 2);\n     |                    ^^^^ private field\n\nFor more information about this error, try `rustc --explain E0616`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                "    ",
                "    for i in 0..1000 {",
                "        set1.insert(i);",
                "    }",
                "    for i in 500..1500 {",
                "        set2.insert(i);",
                "    }",
                "    let _ = set1.symmetric_difference(&set2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    let mut set2: IndexSet<i32, RandomState> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
                  "    for i in 0..1000 { set1.insert(i); }",
                  "    for i in 500..1500 { set2.insert(i); }",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    let expected_difference: Vec<i32> = (0..500).chain(1000..1500).collect();",
                  "    assert_eq!(result.collect::<Vec<_>>(), expected_difference);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet { map: IndexMap::new() };",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::new();",
                  "    ",
                  "    for i in 0..1000 {",
                  "        set1.insert(i);",
                  "    }",
                  "    for i in 500..1500 {",
                  "        set2.insert(i);",
                  "    }",
                  "    let _ = set1.symmetric_difference(&set2);",
                  "   let mut set1: IndexSet<i32, RandomState> = IndexSet::new();",
                  "   let mut set2: IndexSet<i32, RandomState> = IndexSet::new();",
                  "    for i in 0..1000 { set1.insert(i); }",
                  "    for i in 500..1500 { set2.insert(i); }",
                  "    let result = set1.symmetric_difference(&set2);",
                  "    let expected_difference: Vec<i32> = (0..500).chain(1000..1500).collect();",
                  "    assert_eq!(result.collect::<Vec<_>>(), expected_difference);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: can't compare `&i32` with `i32`\n    --> src/set.rs:1328:5\n     |\n1328 |     assert_eq!(result.collect::<Vec<_>>(), expected_difference);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `&i32 == i32`\n     |\n     = help: the trait `PartialEq<i32>` is not implemented for `&i32`, which is required by `std::vec::Vec<&i32>: PartialEq<std::vec::Vec<i32>>`\n     = help: the trait `PartialEq` is implemented for `i32`\n     = help: for that trait implementation, expected `i32`, found `&i32`\n     = note: required for `std::vec::Vec<&i32>` to implement `PartialEq<std::vec::Vec<i32>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}