{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::retain_in_order","tests":4,"tests_lines":[43,43,42,54],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":10,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[497,498,499,500,501,502,503,504,505,506],"codes_lines_covered":[[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> TestMap<K, V> {","        pub(crate) fn new() -> Self {","            TestMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        pub(crate) fn retain_in_order<F>(&mut self, mut keep: F)","        where","            F: FnMut(&mut K, &mut V) -> bool,","        {","            self.entries.retain_mut(|entry| keep(&mut entry.key, &mut entry.value));","            if self.entries.len() < self.indices.len() {","                self.rebuild_hash_table();","            }","        }","","        fn rebuild_hash_table(&self) {","            // Simulate hash table rebuilding","        }","    }","","    let mut test_map: TestMap<i32, String> = TestMap::new();","    test_map.entries.push(Entry { key: 1, value: \"one\".to_string() });","    test_map.entries.push(Entry { key: 2, value: \"two\".to_string() });","    test_map.indices = vec![0, 1, 2]; // Ensure constraint is met","","    test_map.retain_in_order(|key, value| *key > 3); // No entries should be retained","","    assert_eq!(test_map.entries.len(), 0); // Expect no entries","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> TestMap<K, V> {","        pub(crate) fn new() -> Self {","            TestMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        pub(crate) fn retain_in_order<F>(&mut self, mut keep: F)","        where","            F: FnMut(&mut K, &mut V) -> bool,","        {","            self.entries.retain_mut(|entry| keep(&mut entry.key, &mut entry.value));","            if self.entries.len() < self.indices.len() {","                self.rebuild_hash_table();","            }","        }","","        fn rebuild_hash_table(&self) {","            // Simulate hash table rebuilding","        }","    }","","    let mut test_map: TestMap<i32, String> = TestMap::new();","    test_map.entries.push(Entry { key: 1, value: \"one\".to_string() });","    test_map.entries.push(Entry { key: 2, value: \"two\".to_string() });","    test_map.indices = vec![0, 1, 2]; // Ensure constraint is met","","    test_map.retain_in_order(|key, value| *key <= 2); // Retain all entries","","    assert_eq!(test_map.entries.len(), 2); // Expect both entries to be retained","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> TestMap<K, V> {","        pub(crate) fn new() -> Self {","            TestMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        pub(crate) fn retain_in_order<F>(&mut self, mut keep: F)","        where","            F: FnMut(&mut K, &mut V) -> bool,","        {","            self.entries.retain_mut(|entry| keep(&mut entry.key, &mut entry.value));","            if self.entries.len() < self.indices.len() {","                self.rebuild_hash_table();","            }","        }","","        fn rebuild_hash_table(&self) {","            // Simulate hash table rebuilding","        }","    }","","    let mut test_map: TestMap<i32, String> = TestMap::new();","    test_map.entries.push(Entry { key: 1, value: \"one\".to_string() });","    test_map.indices = vec![0]; // Ensure constraint is met","","    test_map.retain_in_order(|key, value| *key == 1); // Retain the single entry","","    assert_eq!(test_map.entries.len(), 1); // Expect the single entry to be retained","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct IndexMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> IndexMap<K, V> {","        fn new() -> Self {","            IndexMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        fn retain_in_order<F>(&mut self, mut keep: F)","        where","            F: FnMut(&mut K, &mut V) -> bool,","        {","            self.entries","                .retain_mut(|entry| keep(&mut entry.key, &mut entry.value));","            if self.entries.len() < self.indices.len() {","                self.rebuild_hash_table();","            }","        }","","        fn rebuild_hash_table(&self) {","            // Dummy implementation for rebuilding hash table","        }","    }","","    let mut map = IndexMap::new();","    map.entries.push(Entry { key: 1, value: \"a\" });","    map.entries.push(Entry { key: 2, value: \"b\" });","","    map.indices = vec![0, 1]; // Ensure entries.len() == indices.len()","","    // Retain only the entry with key 1","    map.retain_in_order(|key, value| {","        *key == 1 // Keep entry with key 1","    });","","    assert_eq!(map.entries.len(), 1);","    assert_eq!(map.entries[0].key, 1);","    assert_eq!(map.entries[0].value, \"a\");","","    // Test retaining no entries","    map.retain_in_order(|_key, _value| false);","    assert_eq!(map.entries.len(), 0);","}"],[]]],"codes_branches":[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> TestMap<K, V> {","        pub(crate) fn new() -> Self {","            TestMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        pub(crate) fn retain_in_order<F>(&mut self, mut keep: F)","        where","            F: FnMut(&mut K, &mut V) -> bool,","        {","            self.entries.retain_mut(|entry| keep(&mut entry.key, &mut entry.value));","            if self.entries.len() < self.indices.len() {","                self.rebuild_hash_table();","            }","        }","","        fn rebuild_hash_table(&self) {","            // Simulate hash table rebuilding","        }","    }","","    let mut test_map: TestMap<i32, String> = TestMap::new();","    test_map.entries.push(Entry { key: 1, value: \"one\".to_string() });","    test_map.entries.push(Entry { key: 2, value: \"two\".to_string() });","    test_map.indices = vec![0, 1, 2]; // Ensure constraint is met","","    test_map.retain_in_order(|key, value| *key > 3); // No entries should be retained","","    assert_eq!(test_map.entries.len(), 0); // Expect no entries","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":false}]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> TestMap<K, V> {","        pub(crate) fn new() -> Self {","            TestMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        pub(crate) fn retain_in_order<F>(&mut self, mut keep: F)","        where","            F: FnMut(&mut K, &mut V) -> bool,","        {","            self.entries.retain_mut(|entry| keep(&mut entry.key, &mut entry.value));","            if self.entries.len() < self.indices.len() {","                self.rebuild_hash_table();","            }","        }","","        fn rebuild_hash_table(&self) {","            // Simulate hash table rebuilding","        }","    }","","    let mut test_map: TestMap<i32, String> = TestMap::new();","    test_map.entries.push(Entry { key: 1, value: \"one\".to_string() });","    test_map.entries.push(Entry { key: 2, value: \"two\".to_string() });","    test_map.indices = vec![0, 1, 2]; // Ensure constraint is met","","    test_map.retain_in_order(|key, value| *key <= 2); // Retain all entries","","    assert_eq!(test_map.entries.len(), 2); // Expect both entries to be retained","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":false}]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> TestMap<K, V> {","        pub(crate) fn new() -> Self {","            TestMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        pub(crate) fn retain_in_order<F>(&mut self, mut keep: F)","        where","            F: FnMut(&mut K, &mut V) -> bool,","        {","            self.entries.retain_mut(|entry| keep(&mut entry.key, &mut entry.value));","            if self.entries.len() < self.indices.len() {","                self.rebuild_hash_table();","            }","        }","","        fn rebuild_hash_table(&self) {","            // Simulate hash table rebuilding","        }","    }","","    let mut test_map: TestMap<i32, String> = TestMap::new();","    test_map.entries.push(Entry { key: 1, value: \"one\".to_string() });","    test_map.indices = vec![0]; // Ensure constraint is met","","    test_map.retain_in_order(|key, value| *key == 1); // Retain the single entry","","    assert_eq!(test_map.entries.len(), 1); // Expect the single entry to be retained","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":false}]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct IndexMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> IndexMap<K, V> {","        fn new() -> Self {","            IndexMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        fn retain_in_order<F>(&mut self, mut keep: F)","        where","            F: FnMut(&mut K, &mut V) -> bool,","        {","            self.entries","                .retain_mut(|entry| keep(&mut entry.key, &mut entry.value));","            if self.entries.len() < self.indices.len() {","                self.rebuild_hash_table();","            }","        }","","        fn rebuild_hash_table(&self) {","            // Dummy implementation for rebuilding hash table","        }","    }","","    let mut map = IndexMap::new();","    map.entries.push(Entry { key: 1, value: \"a\" });","    map.entries.push(Entry { key: 2, value: \"b\" });","","    map.indices = vec![0, 1]; // Ensure entries.len() == indices.len()","","    // Retain only the entry with key 1","    map.retain_in_order(|key, value| {","        *key == 1 // Keep entry with key 1","    });","","    assert_eq!(map.entries.len(), 1);","    assert_eq!(map.entries[0].key, 1);","    assert_eq!(map.entries[0].value, \"a\");","","    // Test retaining no entries","    map.retain_in_order(|_key, _value| false);","    assert_eq!(map.entries.len(), 0);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":51,"positive":false,"negative":false}]]]}