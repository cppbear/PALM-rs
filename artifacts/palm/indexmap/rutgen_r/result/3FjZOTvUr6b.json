{"function_name":"indexmap::set::set::IndexSet<T, S>::as_slice","tests":2,"tests_lines":[31,24],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[978,979,980],"codes_lines_covered":[[["{","    struct MySet<T> {","        entries: Vec<T>,","    }","","    impl<T> MySet<T> {","        fn new() -> Self {","            MySet { entries: Vec::new() }","        }","","        fn as_entries(&self) -> &[T] {","            &self.entries","        }","","        fn as_slice(&self) -> &[T] {","            &self.as_entries()","        }","","        fn insert(&mut self, value: T) {","            self.entries.push(value);","        }","    }","","    let mut set = MySet::new();","    set.insert(1);","    set.insert(2);","    set.insert(3);","","    let slice = set.as_slice();","    assert_eq!(slice, &[1, 2, 3]);","}"],[]],[["{","    struct MySet<T> {","        entries: Vec<T>,","    }","","    impl<T> MySet<T> {","        fn new() -> Self {","            MySet { entries: Vec::new() }","        }","","        fn as_entries(&self) -> &[T] {","            &self.entries","        }","","        fn as_slice(&self) -> &[T] {","            &self.as_entries()","        }","    }","","    let set: MySet<i32> = MySet::new();","","    let slice = set.as_slice();","    assert!(slice.is_empty());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MySet<T> {","        entries: Vec<T>,","    }","","    impl<T> MySet<T> {","        fn new() -> Self {","            MySet { entries: Vec::new() }","        }","","        fn as_entries(&self) -> &[T] {","            &self.entries","        }","","        fn as_slice(&self) -> &[T] {","            &self.as_entries()","        }","","        fn insert(&mut self, value: T) {","            self.entries.push(value);","        }","    }","","    let mut set = MySet::new();","    set.insert(1);","    set.insert(2);","    set.insert(3);","","    let slice = set.as_slice();","    assert_eq!(slice, &[1, 2, 3]);","}"],[]],[["{","    struct MySet<T> {","        entries: Vec<T>,","    }","","    impl<T> MySet<T> {","        fn new() -> Self {","            MySet { entries: Vec::new() }","        }","","        fn as_entries(&self) -> &[T] {","            &self.entries","        }","","        fn as_slice(&self) -> &[T] {","            &self.as_entries()","        }","    }","","    let set: MySet<i32> = MySet::new();","","    let slice = set.as_slice();","    assert!(slice.is_empty());","}"],[]]]}