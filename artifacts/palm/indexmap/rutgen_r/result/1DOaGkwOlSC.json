{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::get_index_of","tests":3,"tests_lines":[68,62,51],"oracles":3,"oracles_compiled":1,"oracles_compiled_rate":33.33333333333333,"tests_compiled":1,"tests_compiled_rate":33.33333333333333,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[319,320,321,322,323,324,325],"codes_lines_covered":[[["{","    struct HashValue {","        value: usize","    }","","    impl HashValue {","        fn get(&self) -> usize {","            self.value","        }","    }","","    struct Entry {","        key: usize,","    }","","    struct Indices {","        indices: Vec<usize>,","    }","","    impl Indices {","        fn find(&self, hash: usize, _: bool) -> Option<&usize> {","            // Trigger panic if hash is out of bounds","            if hash >= self.indices.len() {","                panic!(\"Hash index out of bounds\");","            }","            self.indices.get(hash)","        }","    }","","    struct Map {","        entries: Vec<Entry>,","        indices: Indices,","    }","","    impl Map {","        fn get_index_of<Q>(&self, hash: HashValue, _: &Q) -> Option<usize>","        where","            Q: ?Sized + Equivalent<usize>,","        {","            self.indices.find(hash.get(), true).copied()","        }","    }","","    let map = Map {","        entries: vec![Entry { key: 1 }],","        indices: Indices { indices: vec![0, 1] },","    };","","    let hash_value = HashValue { value: 3 }; // Out of bounds hash","    map.get_index_of(hash_value, &1);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct HashValue {","        value: usize","    }","","    impl HashValue {","        fn get(&self) -> usize {","            self.value","        }","    }","","    struct Entry {","        key: usize,","    }","","    struct Indices {","        indices: Vec<usize>,","    }","","    impl Indices {","        fn find(&self, hash: usize, _: bool) -> Option<&usize> {","            // Trigger panic if hash is out of bounds","            if hash >= self.indices.len() {","                panic!(\"Hash index out of bounds\");","            }","            self.indices.get(hash)","        }","    }","","    struct Map {","        entries: Vec<Entry>,","        indices: Indices,","    }","","    impl Map {","        fn get_index_of<Q>(&self, hash: HashValue, _: &Q) -> Option<usize>","        where","            Q: ?Sized + Equivalent<usize>,","        {","            self.indices.find(hash.get(), true).copied()","        }","    }","","    let map = Map {","        entries: vec![Entry { key: 1 }],","        indices: Indices { indices: vec![0, 1] },","    };","","    let hash_value = HashValue { value: 3 }; // Out of bounds hash","    map.get_index_of(hash_value, &1);","}"],[]]]}