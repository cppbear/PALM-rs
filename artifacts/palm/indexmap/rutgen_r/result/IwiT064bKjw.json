{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::pop","tests":2,"tests_lines":[35,58],"oracles":2,"oracles_compiled":1,"oracles_compiled_rate":50.0,"tests_compiled":1,"tests_compiled_rate":50.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[308,309,310,311,312,314,316],"codes_lines_covered":[[["{","    struct TestMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    struct Entry<K, V> {","        key: K,","        value: V,","        hash: usize,","    }","","    impl<K, V> TestMap<K, V> {","        pub(crate) fn pop(&mut self) -> Option<(K, V)> {","            if let Some(entry) = self.entries.pop() {","                let last = self.entries.len();","                self.erase_index(entry.hash, last);","                Some((entry.key, entry.value))","            } else {","                None","            }","        }","","        fn erase_index(&mut self, _hash: usize, _last: usize) {","            // For testing, no-op","        }","    }","","    let mut test_map: TestMap<i32, String> = TestMap {","        entries: Vec::new(),","        indices: Vec::new(),","    };","","    assert_eq!(test_map.pop(), None);","}"],[]]],"codes_branches":[{"start_line":309,"start_column":16,"end_line":309,"end_column":27,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    struct Entry<K, V> {","        key: K,","        value: V,","        hash: usize,","    }","","    impl<K, V> TestMap<K, V> {","        pub(crate) fn pop(&mut self) -> Option<(K, V)> {","            if let Some(entry) = self.entries.pop() {","                let last = self.entries.len();","                self.erase_index(entry.hash, last);","                Some((entry.key, entry.value))","            } else {","                None","            }","        }","","        fn erase_index(&mut self, _hash: usize, _last: usize) {","            // For testing, no-op","        }","    }","","    let mut test_map: TestMap<i32, String> = TestMap {","        entries: Vec::new(),","        indices: Vec::new(),","    };","","    assert_eq!(test_map.pop(), None);","}"],[{"start_line":309,"start_column":16,"end_line":309,"end_column":27,"positive":false,"negative":false}]]]}