{"function_name":"indexmap::set::<set::IndexSet<T, S> as Entries>::as_entries_mut","tests":3,"tests_lines":[32,32,34],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[122,123,124],"codes_lines_covered":[[["{","    struct TestEntry;","    struct TestMap {","        entries: Vec<TestEntry>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            self.entries.as_mut_slice()","        }","    }","","    struct TestStruct {","        map: TestMap,","    }","","    impl TestStruct {","        fn new() -> Self {","            Self {","                map: TestMap { entries: Vec::new() },","            }","        }","","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            self.map.as_entries_mut()","        }","    }","","    let mut test_struct = TestStruct::new();","    let entries = test_struct.as_entries_mut();","    assert_eq!(entries.len(), 0);","}"],[]],[["{","    struct TestEntry;","    struct TestMap {","        entries: Vec<TestEntry>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            self.entries.as_mut_slice()","        }","    }","","    struct TestStruct {","        map: TestMap,","    }","","    impl TestStruct {","        fn new(entries: Vec<TestEntry>) -> Self {","            Self {","                map: TestMap { entries },","            }","        }","","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            self.map.as_entries_mut()","        }","    }","","    let mut test_struct = TestStruct::new(vec![TestEntry, TestEntry]);","    let entries = test_struct.as_entries_mut();","    assert_eq!(entries.len(), 2);","}"],[]],[["{","    struct TestEntry;","    struct TestMap {","        entries: Vec<TestEntry>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            if self.entries.is_empty() {","                panic!(\"Panic: map is empty\");","            }","            self.entries.as_mut_slice()","        }","    }","","    struct TestStruct {","        map: TestMap,","    }","","    impl TestStruct {","        fn new(entries: Vec<TestEntry>) -> Self {","            Self {","                map: TestMap { entries },","            }","        }","","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            self.map.as_entries_mut()","        }","    }","","    let mut test_struct = TestStruct::new(vec![]);","    test_struct.as_entries_mut(); // This should trigger a panic","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestEntry;","    struct TestMap {","        entries: Vec<TestEntry>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            self.entries.as_mut_slice()","        }","    }","","    struct TestStruct {","        map: TestMap,","    }","","    impl TestStruct {","        fn new() -> Self {","            Self {","                map: TestMap { entries: Vec::new() },","            }","        }","","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            self.map.as_entries_mut()","        }","    }","","    let mut test_struct = TestStruct::new();","    let entries = test_struct.as_entries_mut();","    assert_eq!(entries.len(), 0);","}"],[]],[["{","    struct TestEntry;","    struct TestMap {","        entries: Vec<TestEntry>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            self.entries.as_mut_slice()","        }","    }","","    struct TestStruct {","        map: TestMap,","    }","","    impl TestStruct {","        fn new(entries: Vec<TestEntry>) -> Self {","            Self {","                map: TestMap { entries },","            }","        }","","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            self.map.as_entries_mut()","        }","    }","","    let mut test_struct = TestStruct::new(vec![TestEntry, TestEntry]);","    let entries = test_struct.as_entries_mut();","    assert_eq!(entries.len(), 2);","}"],[]],[["{","    struct TestEntry;","    struct TestMap {","        entries: Vec<TestEntry>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            if self.entries.is_empty() {","                panic!(\"Panic: map is empty\");","            }","            self.entries.as_mut_slice()","        }","    }","","    struct TestStruct {","        map: TestMap,","    }","","    impl TestStruct {","        fn new(entries: Vec<TestEntry>) -> Self {","            Self {","                map: TestMap { entries },","            }","        }","","        fn as_entries_mut(&mut self) -> &mut [TestEntry] {","            self.map.as_entries_mut()","        }","    }","","    let mut test_struct = TestStruct::new(vec![]);","    test_struct.as_entries_mut(); // This should trigger a panic","}"],[]]]}