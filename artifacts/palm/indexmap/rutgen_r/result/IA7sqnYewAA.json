{"function_name":"indexmap::map::slice::map::slice::Slice<K, V>::partition_point","tests":4,"tests_lines":[34,27,33,33],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[267,268,269,270,271,272,273],"codes_lines_covered":[[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap<K, V> {","        entries: Vec<Entry<K, V>>,","    }","","    impl<K, V> SortedMap<K, V> {","        pub fn partition_point<P>(&self, mut pred: P) -> usize","        where","            P: FnMut(&K, &V) -> bool,","        {","            self.entries","                .iter()","                .position(|entry| !pred(&entry.key, &entry.value))","                .unwrap_or(self.entries.len())","        }","    }","","    let map = SortedMap {","        entries: vec![","            Entry { key: 1, value: \"a\" },","            Entry { key: 2, value: \"b\" },","            Entry { key: 3, value: \"c\" },","            Entry { key: 4, value: \"d\" },","        ],","    };","","    let result = map.partition_point(|&key, &_value| key < 3);","    assert_eq!(result, 2);","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap<K, V> {","        entries: Vec<Entry<K, V>>,","    }","","    impl<K, V> SortedMap<K, V> {","        pub fn partition_point<P>(&self, mut pred: P) -> usize","        where","            P: FnMut(&K, &V) -> bool,","        {","            self.entries","                .iter()","                .position(|entry| !pred(&entry.key, &entry.value))","                .unwrap_or(self.entries.len())","        }","    }","","    let map: SortedMap<i32, &str> = SortedMap { entries: Vec::new() };","","    let result = map.partition_point(|&key, &_value| key < 3);","    assert_eq!(result, 0);","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap<K, V> {","        entries: Vec<Entry<K, V>>,","    }","","    impl<K, V> SortedMap<K, V> {","        pub fn partition_point<P>(&self, mut pred: P) -> usize","        where","            P: FnMut(&K, &V) -> bool,","        {","            self.entries","                .iter()","                .position(|entry| !pred(&entry.key, &entry.value))","                .unwrap_or(self.entries.len())","        }","    }","","    let map = SortedMap {","        entries: vec![","            Entry { key: 1, value: \"a\" },","            Entry { key: 2, value: \"b\" },","            Entry { key: 3, value: \"c\" },","        ],","    };","","    let result = map.partition_point(|&key, &_value| key < 4);","    assert_eq!(result, 3);","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap<K, V> {","        entries: Vec<Entry<K, V>>,","    }","","    impl<K, V> SortedMap<K, V> {","        pub fn partition_point<P>(&self, mut pred: P) -> usize","        where","            P: FnMut(&K, &V) -> bool,","        {","            self.entries","                .iter()","                .position(|entry| !pred(&entry.key, &entry.value))","                .unwrap_or(self.entries.len())","        }","    }","","    let map = SortedMap {","        entries: vec![","            Entry { key: 1, value: \"a\" },","            Entry { key: 2, value: \"b\" },","            Entry { key: 3, value: \"c\" },","        ],","    };","","    let result = map.partition_point(|&key, &_value| key > 3);","    assert_eq!(result, 0);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap<K, V> {","        entries: Vec<Entry<K, V>>,","    }","","    impl<K, V> SortedMap<K, V> {","        pub fn partition_point<P>(&self, mut pred: P) -> usize","        where","            P: FnMut(&K, &V) -> bool,","        {","            self.entries","                .iter()","                .position(|entry| !pred(&entry.key, &entry.value))","                .unwrap_or(self.entries.len())","        }","    }","","    let map = SortedMap {","        entries: vec![","            Entry { key: 1, value: \"a\" },","            Entry { key: 2, value: \"b\" },","            Entry { key: 3, value: \"c\" },","            Entry { key: 4, value: \"d\" },","        ],","    };","","    let result = map.partition_point(|&key, &_value| key < 3);","    assert_eq!(result, 2);","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap<K, V> {","        entries: Vec<Entry<K, V>>,","    }","","    impl<K, V> SortedMap<K, V> {","        pub fn partition_point<P>(&self, mut pred: P) -> usize","        where","            P: FnMut(&K, &V) -> bool,","        {","            self.entries","                .iter()","                .position(|entry| !pred(&entry.key, &entry.value))","                .unwrap_or(self.entries.len())","        }","    }","","    let map: SortedMap<i32, &str> = SortedMap { entries: Vec::new() };","","    let result = map.partition_point(|&key, &_value| key < 3);","    assert_eq!(result, 0);","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap<K, V> {","        entries: Vec<Entry<K, V>>,","    }","","    impl<K, V> SortedMap<K, V> {","        pub fn partition_point<P>(&self, mut pred: P) -> usize","        where","            P: FnMut(&K, &V) -> bool,","        {","            self.entries","                .iter()","                .position(|entry| !pred(&entry.key, &entry.value))","                .unwrap_or(self.entries.len())","        }","    }","","    let map = SortedMap {","        entries: vec![","            Entry { key: 1, value: \"a\" },","            Entry { key: 2, value: \"b\" },","            Entry { key: 3, value: \"c\" },","        ],","    };","","    let result = map.partition_point(|&key, &_value| key < 4);","    assert_eq!(result, 3);","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap<K, V> {","        entries: Vec<Entry<K, V>>,","    }","","    impl<K, V> SortedMap<K, V> {","        pub fn partition_point<P>(&self, mut pred: P) -> usize","        where","            P: FnMut(&K, &V) -> bool,","        {","            self.entries","                .iter()","                .position(|entry| !pred(&entry.key, &entry.value))","                .unwrap_or(self.entries.len())","        }","    }","","    let map = SortedMap {","        entries: vec![","            Entry { key: 1, value: \"a\" },","            Entry { key: 2, value: \"b\" },","            Entry { key: 3, value: \"c\" },","        ],","    };","","    let result = map.partition_point(|&key, &_value| key > 3);","    assert_eq!(result, 0);","}"],[]]]}