{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::truncate","tests":5,"tests_lines":[10,10,11,10,10],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[179,180,181,182,183,184],"codes_lines_covered":[[["{","    let mut map = IndexMap {","        entries: Entries {","            entries: vec![1, 2, 3, 4, 5], // initial length is 5","        },","    };","    map.truncate(3); // truncate to 3, should work without panic","    assert_eq!(map.len(), 3);","    assert_eq!(map.entries.entries, vec![1, 2, 3]);","}"],[]],[["{","    let mut map = IndexMap {","        entries: Entries {","            entries: vec![10, 20, 30], // initial length is 3","        },","    };","    map.truncate(2); // truncate to 2, should work without panic","    assert_eq!(map.len(), 2);","    assert_eq!(map.entries.entries, vec![10, 20]);","}"],[]],[["{","    let mut test_struct = TestStruct {","        entries: vec![1, 2, 3, 4, 5],","    };","    let initial_length = test_struct.len();","    ","    test_struct.truncate(initial_length);","    ","    assert_eq!(test_struct.len(), initial_length);","    assert_eq!(test_struct.entries, vec![1, 2, 3, 4, 5]);","}"],[]],[["{","    let mut test_struct = TestStruct {","        entries: Vec::new(),","    };","    ","    test_struct.truncate(0);","    ","    assert_eq!(test_struct.len(), 0);","    assert_eq!(test_struct.entries, Vec::new());","}"],[]],[["{","    let mut test_struct = TestStruct {","        entries: vec![42],","    };","    ","    test_struct.truncate(1);","    ","    assert_eq!(test_struct.len(), 1);","    assert_eq!(test_struct.entries, vec![42]);","}"],[]]],"codes_branches":[{"start_line":180,"start_column":12,"end_line":180,"end_column":28,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut map = IndexMap {","        entries: Entries {","            entries: vec![1, 2, 3, 4, 5], // initial length is 5","        },","    };","    map.truncate(3); // truncate to 3, should work without panic","    assert_eq!(map.len(), 3);","    assert_eq!(map.entries.entries, vec![1, 2, 3]);","}"],[{"start_line":180,"start_column":12,"end_line":180,"end_column":28,"positive":false,"negative":false}]],[["{","    let mut map = IndexMap {","        entries: Entries {","            entries: vec![10, 20, 30], // initial length is 3","        },","    };","    map.truncate(2); // truncate to 2, should work without panic","    assert_eq!(map.len(), 2);","    assert_eq!(map.entries.entries, vec![10, 20]);","}"],[{"start_line":180,"start_column":12,"end_line":180,"end_column":28,"positive":false,"negative":false}]],[["{","    let mut test_struct = TestStruct {","        entries: vec![1, 2, 3, 4, 5],","    };","    let initial_length = test_struct.len();","    ","    test_struct.truncate(initial_length);","    ","    assert_eq!(test_struct.len(), initial_length);","    assert_eq!(test_struct.entries, vec![1, 2, 3, 4, 5]);","}"],[{"start_line":180,"start_column":12,"end_line":180,"end_column":28,"positive":false,"negative":false}]],[["{","    let mut test_struct = TestStruct {","        entries: Vec::new(),","    };","    ","    test_struct.truncate(0);","    ","    assert_eq!(test_struct.len(), 0);","    assert_eq!(test_struct.entries, Vec::new());","}"],[{"start_line":180,"start_column":12,"end_line":180,"end_column":28,"positive":false,"negative":false}]],[["{","    let mut test_struct = TestStruct {","        entries: vec![42],","    };","    ","    test_struct.truncate(1);","    ","    assert_eq!(test_struct.len(), 1);","    assert_eq!(test_struct.entries, vec![42]);","}"],[{"start_line":180,"start_column":12,"end_line":180,"end_column":28,"positive":false,"negative":false}]]]}