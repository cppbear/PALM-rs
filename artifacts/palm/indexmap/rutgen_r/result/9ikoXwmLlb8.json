{"function_name":"indexmap::Bucket<K, V>::refs","tests":3,"tests_lines":[7,7,15],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[195,196,197],"codes_lines_covered":[[["{","    let item = Item::new(\"test_key\", 42);","    let (key_ref, value_ref) = item.refs();","    ","    assert_eq!(*key_ref, \"test_key\");","    assert_eq!(*value_ref, 42);","}"],[]],[["{","    let item = Item::new(1.5, \"value\");","    let (key_ref, value_ref) = item.refs();","    ","    assert_eq!(*key_ref, 1.5);","    assert_eq!(*value_ref, \"value\");","}"],[]],[["{","    let mut item = Item::new(\"key\", \"value\");","    {","        let (key_ref, value_ref) = item.refs();","        // Trying to mutate would panic if we had mutable references that are kept alive","        // This is not directly coded but illustrates the concept of maintaining references safely.","        // In this case, we are not modifying anything, but this serves as a guard against ","        // unintentional changes while the reference holds.","        assert_eq!(*key_ref, \"key\");","        assert_eq!(*value_ref, \"value\");","    }","    // Simulating a panic scenario by going out of scope (not the case here directly)","    // Inserting an element here would typically be out of context and should lead to unsafe behavior,","    // but also shows the potential for misunderstanding if references are retained incorrectly.","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let item = Item::new(\"test_key\", 42);","    let (key_ref, value_ref) = item.refs();","    ","    assert_eq!(*key_ref, \"test_key\");","    assert_eq!(*value_ref, 42);","}"],[]],[["{","    let item = Item::new(1.5, \"value\");","    let (key_ref, value_ref) = item.refs();","    ","    assert_eq!(*key_ref, 1.5);","    assert_eq!(*value_ref, \"value\");","}"],[]],[["{","    let mut item = Item::new(\"key\", \"value\");","    {","        let (key_ref, value_ref) = item.refs();","        // Trying to mutate would panic if we had mutable references that are kept alive","        // This is not directly coded but illustrates the concept of maintaining references safely.","        // In this case, we are not modifying anything, but this serves as a guard against ","        // unintentional changes while the reference holds.","        assert_eq!(*key_ref, \"key\");","        assert_eq!(*value_ref, \"value\");","    }","    // Simulating a panic scenario by going out of scope (not the case here directly)","    // Inserting an element here would typically be out of context and should lead to unsafe behavior,","    // but also shows the potential for misunderstanding if references are retained incorrectly.","}"],[]]]}