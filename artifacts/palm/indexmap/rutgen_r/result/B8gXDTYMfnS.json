{"function_name":"indexmap::map::core::raw_entry_v1::map::core::raw_entry_v1::RawOccupiedEntryMut<'a, K, V, S>::key_mut","tests":2,"tests_lines":[27,25],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[422,423,424,425],"codes_lines_covered":[[["{","    struct Entry<K> {","        key: K,","    }","","    struct Map<K> {","        entries: Vec<Entry<K>>,","        index: usize,","    }","","    impl<K> Map<K> {","        pub fn new(entries: Vec<Entry<K>>, index: usize) -> Self {","            Map { entries, index }","        }","","        pub fn key_mut(&mut self) -> &mut K {","            let index = self.index;","            &mut self.entries[index].key","        }","    }","","    // Test case with valid index","    let mut map = Map::new(vec![Entry { key: 1 }, Entry { key: 2 }], 1);","    let key_ref = map.key_mut();","    *key_ref += 5; // Modify the value","    assert_eq!(*key_ref, 7);","}"],[]],[["{","    struct Entry<K> {","        key: K,","    }","","    struct Map<K> {","        entries: Vec<Entry<K>>,","        index: usize,","    }","","    impl<K> Map<K> {","        pub fn new(entries: Vec<Entry<K>>, index: usize) -> Self {","            Map { entries, index }","        }","","        pub fn key_mut(&mut self) -> &mut K {","            let index = self.index;","            &mut self.entries[index].key","        }","    }","","    // Test case with out-of-bounds index","    let mut map = Map::new(vec![Entry { key: 1 }, Entry { key: 2 }], 2);","    let _key_ref = map.key_mut(); // This should panic","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Entry<K> {","        key: K,","    }","","    struct Map<K> {","        entries: Vec<Entry<K>>,","        index: usize,","    }","","    impl<K> Map<K> {","        pub fn new(entries: Vec<Entry<K>>, index: usize) -> Self {","            Map { entries, index }","        }","","        pub fn key_mut(&mut self) -> &mut K {","            let index = self.index;","            &mut self.entries[index].key","        }","    }","","    // Test case with valid index","    let mut map = Map::new(vec![Entry { key: 1 }, Entry { key: 2 }], 1);","    let key_ref = map.key_mut();","    *key_ref += 5; // Modify the value","    assert_eq!(*key_ref, 7);","}"],[]],[["{","    struct Entry<K> {","        key: K,","    }","","    struct Map<K> {","        entries: Vec<Entry<K>>,","        index: usize,","    }","","    impl<K> Map<K> {","        pub fn new(entries: Vec<Entry<K>>, index: usize) -> Self {","            Map { entries, index }","        }","","        pub fn key_mut(&mut self) -> &mut K {","            let index = self.index;","            &mut self.entries[index].key","        }","    }","","    // Test case with out-of-bounds index","    let mut map = Map::new(vec![Entry { key: 1 }, Entry { key: 2 }], 2);","    let _key_ref = map.key_mut(); // This should panic","}"],[]]]}