{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::push_entry","tests":3,"tests_lines":[55,42,44],"oracles":3,"oracles_compiled":2,"oracles_compiled_rate":66.66666666666666,"tests_compiled":2,"tests_compiled_rate":66.66666666666666,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[329,330,331,332,333,334,335,336],"codes_lines_covered":[[["{","    struct HashValue(u64);","    ","    struct Bucket<K, V> {","        hash: HashValue,","        key: K,","        value: V,","    }","    ","    struct TestMap<K, V> {","        entries: Vec<Bucket<K, V>>,","    }","    ","    impl<K, V> TestMap<K, V> {","        fn new(capacity: usize) -> Self {","            TestMap {","                entries: Vec::with_capacity(capacity),","            }","        }","        ","        fn push_entry(&mut self, hash: HashValue, key: K, value: V) {","            if self.entries.len() == self.entries.capacity() {","                self.reserve_entries(1);","            }","            self.entries.push(Bucket { hash, key, value });","        }","        ","        fn reserve_entries(&mut self, additional: usize) {","            self.entries.reserve(additional);","        }","    }","","    let mut test_map: TestMap<String, String> = TestMap::new(2);","    test_map.push_entry(HashValue(1), \"key1\".to_string(), \"value1\".to_string());","    test_map.push_entry(HashValue(2), \"key2\".to_string(), \"value2\".to_string());","","    assert_eq!(test_map.entries.len(), 2);","    assert_eq!(test_map.entries[0].key, \"key1\");","    assert_eq!(test_map.entries[0].value, \"value1\");","    assert_eq!(test_map.entries[1].key, \"key2\");","    assert_eq!(test_map.entries[1].value, \"value2\");","}"],[]],[["{","    struct HashValue(u64);","    ","    struct Bucket<K, V> {","        hash: HashValue,","        key: K,","        value: V,","    }","    ","    struct TestMap<K, V> {","        entries: Vec<Bucket<K, V>>,","    }","    ","    impl<K, V> TestMap<K, V> {","        fn new(capacity: usize) -> Self {","            TestMap {","                entries: Vec::with_capacity(capacity),","            }","        }","        ","        fn push_entry(&mut self, hash: HashValue, key: K, value: V) {","            if self.entries.len() == self.entries.capacity() {","                self.reserve_entries(1);","            }","            self.entries.push(Bucket { hash, key, value });","        }","        ","        fn reserve_entries(&mut self, additional: usize) {","            self.entries.reserve(additional);","        }","    }","","    let mut test_map: TestMap<String, String> = TestMap::new(1);","    test_map.push_entry(HashValue(1), \"key1\".to_string(), \"value1\".to_string());","    ","    assert_eq!(test_map.entries.len(), 1);","","    // This will trigger the growth of the underlying vector","    test_map.push_entry(HashValue(2), \"key2\".to_string(), \"value2\".to_string());","    ","    assert_eq!(test_map.entries.len(), 2);","    assert_eq!(test_map.entries[0].key, \"key1\");","    assert_eq!(test_map.entries[1].key, \"key2\");","}"],[]]],"codes_branches":[{"start_line":330,"start_column":12,"end_line":330,"end_column":57,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct HashValue(u64);","    ","    struct Bucket<K, V> {","        hash: HashValue,","        key: K,","        value: V,","    }","    ","    struct TestMap<K, V> {","        entries: Vec<Bucket<K, V>>,","    }","    ","    impl<K, V> TestMap<K, V> {","        fn new(capacity: usize) -> Self {","            TestMap {","                entries: Vec::with_capacity(capacity),","            }","        }","        ","        fn push_entry(&mut self, hash: HashValue, key: K, value: V) {","            if self.entries.len() == self.entries.capacity() {","                self.reserve_entries(1);","            }","            self.entries.push(Bucket { hash, key, value });","        }","        ","        fn reserve_entries(&mut self, additional: usize) {","            self.entries.reserve(additional);","        }","    }","","    let mut test_map: TestMap<String, String> = TestMap::new(2);","    test_map.push_entry(HashValue(1), \"key1\".to_string(), \"value1\".to_string());","    test_map.push_entry(HashValue(2), \"key2\".to_string(), \"value2\".to_string());","","    assert_eq!(test_map.entries.len(), 2);","    assert_eq!(test_map.entries[0].key, \"key1\");","    assert_eq!(test_map.entries[0].value, \"value1\");","    assert_eq!(test_map.entries[1].key, \"key2\");","    assert_eq!(test_map.entries[1].value, \"value2\");","}"],[{"start_line":330,"start_column":12,"end_line":330,"end_column":57,"positive":false,"negative":false}]],[["{","    struct HashValue(u64);","    ","    struct Bucket<K, V> {","        hash: HashValue,","        key: K,","        value: V,","    }","    ","    struct TestMap<K, V> {","        entries: Vec<Bucket<K, V>>,","    }","    ","    impl<K, V> TestMap<K, V> {","        fn new(capacity: usize) -> Self {","            TestMap {","                entries: Vec::with_capacity(capacity),","            }","        }","        ","        fn push_entry(&mut self, hash: HashValue, key: K, value: V) {","            if self.entries.len() == self.entries.capacity() {","                self.reserve_entries(1);","            }","            self.entries.push(Bucket { hash, key, value });","        }","        ","        fn reserve_entries(&mut self, additional: usize) {","            self.entries.reserve(additional);","        }","    }","","    let mut test_map: TestMap<String, String> = TestMap::new(1);","    test_map.push_entry(HashValue(1), \"key1\".to_string(), \"value1\".to_string());","    ","    assert_eq!(test_map.entries.len(), 1);","","    // This will trigger the growth of the underlying vector","    test_map.push_entry(HashValue(2), \"key2\".to_string(), \"value2\".to_string());","    ","    assert_eq!(test_map.entries.len(), 2);","    assert_eq!(test_map.entries[0].key, \"key1\");","    assert_eq!(test_map.entries[1].key, \"key2\");","}"],[{"start_line":330,"start_column":12,"end_line":330,"end_column":57,"positive":false,"negative":false}]]]}