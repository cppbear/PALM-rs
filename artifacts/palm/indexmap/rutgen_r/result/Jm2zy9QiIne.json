{"function_name":"indexmap::map::core::entry::map::core::entry::OccupiedEntry<'a, K, V>::get_mut","tests":2,"tests_lines":[31,29],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[193,194,195,196],"codes_lines_covered":[[["{","    struct Entry {","        value: i32,","    }","","    struct EntryMap {","        entries: Vec<Entry>,","        index: usize,","    }","","    impl EntryMap {","        fn new(entries: Vec<Entry>, index: usize) -> Self {","            EntryMap { entries, index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn get_mut(&mut self) -> &mut i32 {","            let index = self.index();","            &mut self.entries[index].value","        }","    }","","    // Initialize with a valid index","    let mut map = EntryMap::new(vec![Entry { value: 1 }, Entry { value: 2 }], 1);","    let value = map.get_mut();","    *value += 5;","    assert_eq!(*value, 7);","}"],[]],[["{","    struct Entry {","        value: i32,","    }","","    struct EntryMap {","        entries: Vec<Entry>,","        index: usize,","    }","","    impl EntryMap {","        fn new(entries: Vec<Entry>, index: usize) -> Self {","            EntryMap { entries, index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn get_mut(&mut self) -> &mut i32 {","            let index = self.index();","            &mut self.entries[index].value","        }","    }","","    // Initialize with an out-of-bounds index","    let mut map = EntryMap::new(vec![Entry { value: 1 }, Entry { value: 2 }], 2);","    map.get_mut(); // This should panic due to out-of-bounds access","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Entry {","        value: i32,","    }","","    struct EntryMap {","        entries: Vec<Entry>,","        index: usize,","    }","","    impl EntryMap {","        fn new(entries: Vec<Entry>, index: usize) -> Self {","            EntryMap { entries, index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn get_mut(&mut self) -> &mut i32 {","            let index = self.index();","            &mut self.entries[index].value","        }","    }","","    // Initialize with a valid index","    let mut map = EntryMap::new(vec![Entry { value: 1 }, Entry { value: 2 }], 1);","    let value = map.get_mut();","    *value += 5;","    assert_eq!(*value, 7);","}"],[]],[["{","    struct Entry {","        value: i32,","    }","","    struct EntryMap {","        entries: Vec<Entry>,","        index: usize,","    }","","    impl EntryMap {","        fn new(entries: Vec<Entry>, index: usize) -> Self {","            EntryMap { entries, index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn get_mut(&mut self) -> &mut i32 {","            let index = self.index();","            &mut self.entries[index].value","        }","    }","","    // Initialize with an out-of-bounds index","    let mut map = EntryMap::new(vec![Entry { value: 1 }, Entry { value: 2 }], 2);","    map.get_mut(); // This should panic due to out-of-bounds access","}"],[]]]}