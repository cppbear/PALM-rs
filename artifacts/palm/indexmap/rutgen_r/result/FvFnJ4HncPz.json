{"function_name":"indexmap::map::map::IndexMap<K, V, S>::get_range_mut","tests":7,"tests_lines":[43,42,43,43,54,46,50],"oracles":7,"oracles_compiled":4,"oracles_compiled_rate":57.14285714285714,"tests_compiled":4,"tests_compiled_rate":57.14285714285714,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1258,1259,1260,1261,1262],"codes_lines_covered":[[["{","    struct TestMap {","        entries: Vec<(usize, usize)>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut Vec<(usize, usize)> {","            &mut self.entries","        }","        ","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn get_range_mut<R: std::ops::RangeBounds<usize>>(&mut self, range: R) -> Option<&mut [(usize, usize)]> {","            use std::ops::Bound::*;","            let entries = self.as_entries_mut();","            let start = match range.start_bound() {","                Unbounded => 0,","                Included(&n) => n,","                Excluded(&n) => n + 1,","            };","            let end = match range.end_bound() {","                Unbounded => entries.len(),","                Included(&n) => n + 1,","                Excluded(&n) => n,","            };","            if start < end && end <= entries.len() {","                Some(&mut entries[start..end])","            } else {","                None","            }","        }","    }","","    let mut map = TestMap {","        entries: vec![(0, 1), (2, 3), (4, 5)],","    };","","    let result = map.get_range_mut(1..3);","    assert!(result.is_some());","    assert_eq!(result.unwrap(), &mut vec![(2, 3), (4, 5)]);","}"],[]],[["{","    struct TestMap {","        entries: Vec<(usize, usize)>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut Vec<(usize, usize)> {","            &mut self.entries","        }","        ","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn get_range_mut<R: std::ops::RangeBounds<usize>>(&mut self, range: R) -> Option<&mut [(usize, usize)]> {","            use std::ops::Bound::*;","            let entries = self.as_entries_mut();","            let start = match range.start_bound() {","                Unbounded => 0,","                Included(&n) => n,","                Excluded(&n) => n + 1,","            };","            let end = match range.end_bound() {","                Unbounded => entries.len(),","                Included(&n) => n + 1,","                Excluded(&n) => n,","            };","            if start < end && end <= entries.len() {","                Some(&mut entries[start..end])","            } else {","                None","            }","        }","    }","","    let mut map = TestMap {","        entries: vec![(0, 1), (2, 3)],","    };","","    let result = map.get_range_mut(2..4);","    assert!(result.is_none());","}"],[]],[["{","    struct TestMap {","        entries: Vec<(usize, usize)>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut Vec<(usize, usize)> {","            &mut self.entries","        }","        ","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn get_range_mut<R: std::ops::RangeBounds<usize>>(&mut self, range: R) -> Option<&mut [(usize, usize)]> {","            use std::ops::Bound::*;","            let entries = self.as_entries_mut();","            let start = match range.start_bound() {","                Unbounded => 0,","                Included(&n) => n,","                Excluded(&n) => n + 1,","            };","            let end = match range.end_bound() {","                Unbounded => entries.len(),","                Included(&n) => n + 1,","                Excluded(&n) => n,","            };","            if start < end && end <= entries.len() {","                Some(&mut entries[start..end])","            } else {","                None","            }","        }","    }","","    let mut map = TestMap {","        entries: vec![(0, 1)],","    };","","    let result = map.get_range_mut(1..1);","    assert!(result.is_some());","    assert_eq!(result.unwrap().len(), 0);","}"],[]],[["{","    struct TestMap {","        entries: Vec<(usize, usize)>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut Vec<(usize, usize)> {","            &mut self.entries","        }","        ","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn get_range_mut<R: std::ops::RangeBounds<usize>>(&mut self, range: R) -> Option<&mut [(usize, usize)]> {","            use std::ops::Bound::*;","            let entries = self.as_entries_mut();","            let start = match range.start_bound() {","                Unbounded => 0,","                Included(&n) => n,","                Excluded(&n) => n + 1,","            };","            let end = match range.end_bound() {","                Unbounded => entries.len(),","                Included(&n) => n + 1,","                Excluded(&n) => n,","            };","            if start < end && end <= entries.len() {","                Some(&mut entries[start..end])","            } else {","                None","            }","        }","    }","","    let mut map = TestMap {","        entries: vec![(0, 1), (2, 3), (4, 5)],","    };","","    let result = map.get_range_mut(..2);","    assert!(result.is_some());","    assert_eq!(result.unwrap(), &mut [(0, 1), (2, 3)]);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestMap {","        entries: Vec<(usize, usize)>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut Vec<(usize, usize)> {","            &mut self.entries","        }","        ","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn get_range_mut<R: std::ops::RangeBounds<usize>>(&mut self, range: R) -> Option<&mut [(usize, usize)]> {","            use std::ops::Bound::*;","            let entries = self.as_entries_mut();","            let start = match range.start_bound() {","                Unbounded => 0,","                Included(&n) => n,","                Excluded(&n) => n + 1,","            };","            let end = match range.end_bound() {","                Unbounded => entries.len(),","                Included(&n) => n + 1,","                Excluded(&n) => n,","            };","            if start < end && end <= entries.len() {","                Some(&mut entries[start..end])","            } else {","                None","            }","        }","    }","","    let mut map = TestMap {","        entries: vec![(0, 1), (2, 3), (4, 5)],","    };","","    let result = map.get_range_mut(1..3);","    assert!(result.is_some());","    assert_eq!(result.unwrap(), &mut vec![(2, 3), (4, 5)]);","}"],[]],[["{","    struct TestMap {","        entries: Vec<(usize, usize)>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut Vec<(usize, usize)> {","            &mut self.entries","        }","        ","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn get_range_mut<R: std::ops::RangeBounds<usize>>(&mut self, range: R) -> Option<&mut [(usize, usize)]> {","            use std::ops::Bound::*;","            let entries = self.as_entries_mut();","            let start = match range.start_bound() {","                Unbounded => 0,","                Included(&n) => n,","                Excluded(&n) => n + 1,","            };","            let end = match range.end_bound() {","                Unbounded => entries.len(),","                Included(&n) => n + 1,","                Excluded(&n) => n,","            };","            if start < end && end <= entries.len() {","                Some(&mut entries[start..end])","            } else {","                None","            }","        }","    }","","    let mut map = TestMap {","        entries: vec![(0, 1), (2, 3)],","    };","","    let result = map.get_range_mut(2..4);","    assert!(result.is_none());","}"],[]],[["{","    struct TestMap {","        entries: Vec<(usize, usize)>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut Vec<(usize, usize)> {","            &mut self.entries","        }","        ","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn get_range_mut<R: std::ops::RangeBounds<usize>>(&mut self, range: R) -> Option<&mut [(usize, usize)]> {","            use std::ops::Bound::*;","            let entries = self.as_entries_mut();","            let start = match range.start_bound() {","                Unbounded => 0,","                Included(&n) => n,","                Excluded(&n) => n + 1,","            };","            let end = match range.end_bound() {","                Unbounded => entries.len(),","                Included(&n) => n + 1,","                Excluded(&n) => n,","            };","            if start < end && end <= entries.len() {","                Some(&mut entries[start..end])","            } else {","                None","            }","        }","    }","","    let mut map = TestMap {","        entries: vec![(0, 1)],","    };","","    let result = map.get_range_mut(1..1);","    assert!(result.is_some());","    assert_eq!(result.unwrap().len(), 0);","}"],[]],[["{","    struct TestMap {","        entries: Vec<(usize, usize)>,","    }","","    impl TestMap {","        fn as_entries_mut(&mut self) -> &mut Vec<(usize, usize)> {","            &mut self.entries","        }","        ","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn get_range_mut<R: std::ops::RangeBounds<usize>>(&mut self, range: R) -> Option<&mut [(usize, usize)]> {","            use std::ops::Bound::*;","            let entries = self.as_entries_mut();","            let start = match range.start_bound() {","                Unbounded => 0,","                Included(&n) => n,","                Excluded(&n) => n + 1,","            };","            let end = match range.end_bound() {","                Unbounded => entries.len(),","                Included(&n) => n + 1,","                Excluded(&n) => n,","            };","            if start < end && end <= entries.len() {","                Some(&mut entries[start..end])","            } else {","                None","            }","        }","    }","","    let mut map = TestMap {","        entries: vec![(0, 1), (2, 3), (4, 5)],","    };","","    let result = map.get_range_mut(..2);","    assert!(result.is_some());","    assert_eq!(result.unwrap(), &mut [(0, 1), (2, 3)]);","}"],[]]]}