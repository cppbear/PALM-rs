{"function_name":"indexmap::set::set::IndexSet<T, S>::insert","tests":4,"tests_lines":[20,21,22,23],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[344,345,346],"codes_lines_covered":[[["{","    struct TestSet<T> {","        map: std::collections::HashMap<T, ()>,","    }","","    impl<T: std::hash::Hash + Eq> TestSet<T> {","        pub fn new() -> Self {","            Self {","                map: std::collections::HashMap::new(),","            }","        }","","        pub fn insert(&mut self, value: T) -> bool {","            self.map.insert(value, ()).is_none()","        }","    }","","    let mut set = TestSet::new();","    assert_eq!(set.insert(1), true); // Insert a new value","}"],[]],[["{","    struct TestSet<T> {","        map: std::collections::HashMap<T, ()>,","    }","","    impl<T: std::hash::Hash + Eq> TestSet<T> {","        pub fn new() -> Self {","            Self {","                map: std::collections::HashMap::new(),","            }","        }","","        pub fn insert(&mut self, value: T) -> bool {","            self.map.insert(value, ()).is_none()","        }","    }","","    let mut set = TestSet::new();","    assert_eq!(set.insert(1), true); // Insert a new value","    assert_eq!(set.insert(1), false); // Try to insert the same value again","}"],[]],[["{","    struct TestSet<T> {","        map: std::collections::HashMap<T, ()>,","    }","","    impl<T: std::hash::Hash + Eq> TestSet<T> {","        pub fn new() -> Self {","            Self {","                map: std::collections::HashMap::new(),","            }","        }","","        pub fn insert(&mut self, value: T) -> bool {","            self.map.insert(value, ()).is_none()","        }","    }","","    let mut set = TestSet::new();","    assert_eq!(set.insert(\"value1\"), true); // Insert a string","    assert_eq!(set.insert(\"value2\"), true); // Insert a different string","    assert_eq!(set.insert(\"value1\"), false); // Try to insert the same string","}"],[]],[["{","    struct TestSet<T> {","        map: std::collections::HashMap<T, ()>,","    }","","    impl<T: std::hash::Hash + Eq> TestSet<T> {","        pub fn new() -> Self {","            Self {","                map: std::collections::HashMap::new(),","            }","        }","","        pub fn insert(&mut self, value: T) -> bool {","            self.map.insert(value, ()).is_none()","        }","    }","","    let mut set = TestSet::new();","    assert_eq!(set.insert(0), true); // Insert boundary value 0","    assert_eq!(set.insert(std::u32::MAX), true); // Insert maximum u32 value","    assert_eq!(set.insert(std::u32::MIN), true); // Insert minimum u32 value","    assert_eq!(set.insert(0), false); // Insert same boundary value 0 again","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestSet<T> {","        map: std::collections::HashMap<T, ()>,","    }","","    impl<T: std::hash::Hash + Eq> TestSet<T> {","        pub fn new() -> Self {","            Self {","                map: std::collections::HashMap::new(),","            }","        }","","        pub fn insert(&mut self, value: T) -> bool {","            self.map.insert(value, ()).is_none()","        }","    }","","    let mut set = TestSet::new();","    assert_eq!(set.insert(1), true); // Insert a new value","}"],[]],[["{","    struct TestSet<T> {","        map: std::collections::HashMap<T, ()>,","    }","","    impl<T: std::hash::Hash + Eq> TestSet<T> {","        pub fn new() -> Self {","            Self {","                map: std::collections::HashMap::new(),","            }","        }","","        pub fn insert(&mut self, value: T) -> bool {","            self.map.insert(value, ()).is_none()","        }","    }","","    let mut set = TestSet::new();","    assert_eq!(set.insert(1), true); // Insert a new value","    assert_eq!(set.insert(1), false); // Try to insert the same value again","}"],[]],[["{","    struct TestSet<T> {","        map: std::collections::HashMap<T, ()>,","    }","","    impl<T: std::hash::Hash + Eq> TestSet<T> {","        pub fn new() -> Self {","            Self {","                map: std::collections::HashMap::new(),","            }","        }","","        pub fn insert(&mut self, value: T) -> bool {","            self.map.insert(value, ()).is_none()","        }","    }","","    let mut set = TestSet::new();","    assert_eq!(set.insert(\"value1\"), true); // Insert a string","    assert_eq!(set.insert(\"value2\"), true); // Insert a different string","    assert_eq!(set.insert(\"value1\"), false); // Try to insert the same string","}"],[]],[["{","    struct TestSet<T> {","        map: std::collections::HashMap<T, ()>,","    }","","    impl<T: std::hash::Hash + Eq> TestSet<T> {","        pub fn new() -> Self {","            Self {","                map: std::collections::HashMap::new(),","            }","        }","","        pub fn insert(&mut self, value: T) -> bool {","            self.map.insert(value, ()).is_none()","        }","    }","","    let mut set = TestSet::new();","    assert_eq!(set.insert(0), true); // Insert boundary value 0","    assert_eq!(set.insert(std::u32::MAX), true); // Insert maximum u32 value","    assert_eq!(set.insert(std::u32::MIN), true); // Insert minimum u32 value","    assert_eq!(set.insert(0), false); // Insert same boundary value 0 again","}"],[]]]}