{"function_name":"indexmap::map::core::raw_entry_v1::map::core::raw_entry_v1::RawOccupiedEntryMut<'a, K, V, S>::insert_key","tests":2,"tests_lines":[28,28],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[483,484,485],"codes_lines_covered":[[["{","    struct TestEntry {","        key: Option<i32>,","    }","","    impl TestEntry {","        fn new() -> Self {","            TestEntry { key: None }","        }","","        fn key_mut(&mut self) -> &mut Option<i32> {","            &mut self.key","        }","","        fn insert_key(&mut self, key: i32) -> Option<i32> {","            std::mem::replace(self.key_mut(), Some(key))","        }","    }","","    let mut entry = TestEntry::new();","    let old_key = entry.insert_key(42);","    assert_eq!(old_key, None);","    assert_eq!(entry.key, Some(42));","    ","    let old_key = entry.insert_key(100);","    assert_eq!(old_key, Some(42));","    assert_eq!(entry.key, Some(100));","}"],[]],[["{","    struct TestEntry {","        key: Option<i32>,","    }","","    impl TestEntry {","        fn new() -> Self {","            TestEntry { key: None }","        }","","        fn key_mut(&mut self) -> &mut Option<i32> {","            &mut self.key","        }","","        fn insert_key(&mut self, key: i32) -> Option<i32> {","            std::mem::replace(self.key_mut(), Some(key))","        }","    }","","    let mut entry = TestEntry::new();","    let old_key = entry.insert_key(0);","    assert_eq!(old_key, None);","    assert_eq!(entry.key, Some(0));","    ","    let old_key = entry.insert_key(-1);","    assert_eq!(old_key, Some(0));","    assert_eq!(entry.key, Some(-1));","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestEntry {","        key: Option<i32>,","    }","","    impl TestEntry {","        fn new() -> Self {","            TestEntry { key: None }","        }","","        fn key_mut(&mut self) -> &mut Option<i32> {","            &mut self.key","        }","","        fn insert_key(&mut self, key: i32) -> Option<i32> {","            std::mem::replace(self.key_mut(), Some(key))","        }","    }","","    let mut entry = TestEntry::new();","    let old_key = entry.insert_key(42);","    assert_eq!(old_key, None);","    assert_eq!(entry.key, Some(42));","    ","    let old_key = entry.insert_key(100);","    assert_eq!(old_key, Some(42));","    assert_eq!(entry.key, Some(100));","}"],[]],[["{","    struct TestEntry {","        key: Option<i32>,","    }","","    impl TestEntry {","        fn new() -> Self {","            TestEntry { key: None }","        }","","        fn key_mut(&mut self) -> &mut Option<i32> {","            &mut self.key","        }","","        fn insert_key(&mut self, key: i32) -> Option<i32> {","            std::mem::replace(self.key_mut(), Some(key))","        }","    }","","    let mut entry = TestEntry::new();","    let old_key = entry.insert_key(0);","    assert_eq!(old_key, None);","    assert_eq!(entry.key, Some(0));","    ","    let old_key = entry.insert_key(-1);","    assert_eq!(old_key, Some(0));","    assert_eq!(entry.key, Some(-1));","}"],[]]]}