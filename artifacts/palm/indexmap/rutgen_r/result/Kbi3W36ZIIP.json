{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::rebuild_hash_table","tests":4,"tests_lines":[30,30,30,30],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[508,509,510,511],"codes_lines_covered":[[["{","    struct IndexMap {","        indices: Vec<usize>,","        entries: Vec<i32>,","    }","","    impl IndexMap {","        fn new() -> Self {","            IndexMap {","                indices: Vec::new(),","                entries: Vec::new(),","            }","        }","","        fn rebuild_hash_table(&mut self) {","            self.indices.clear();","            insert_bulk_no_grow(&mut self.indices, &self.entries);","        }","    }","","    fn insert_bulk_no_grow(indices: &mut Vec<usize>, entries: &Vec<i32>) {","        for (i, _entry) in entries.iter().enumerate() {","            indices.push(i);","        }","    }","","    let mut index_map = IndexMap::new();","    index_map.rebuild_hash_table();","    assert!(index_map.indices.is_empty());","}"],[]],[["{","    struct IndexMap {","        indices: Vec<usize>,","        entries: Vec<i32>,","    }","","    impl IndexMap {","        fn new(entries: Vec<i32>) -> Self {","            IndexMap {","                indices: Vec::new(),","                entries,","            }","        }","","        fn rebuild_hash_table(&mut self) {","            self.indices.clear();","            insert_bulk_no_grow(&mut self.indices, &self.entries);","        }","    }","","    fn insert_bulk_no_grow(indices: &mut Vec<usize>, entries: &Vec<i32>) {","        for (i, _entry) in entries.iter().enumerate() {","            indices.push(i);","        }","    }","","    let mut index_map = IndexMap::new(vec![42]);","    index_map.rebuild_hash_table();","    assert_eq!(index_map.indices, vec![0]);","}"],[]],[["{","    struct IndexMap {","        indices: Vec<usize>,","        entries: Vec<i32>,","    }","","    impl IndexMap {","        fn new(entries: Vec<i32>) -> Self {","            IndexMap {","                indices: Vec::new(),","                entries,","            }","        }","","        fn rebuild_hash_table(&mut self) {","            self.indices.clear();","            insert_bulk_no_grow(&mut self.indices, &self.entries);","        }","    }","","    fn insert_bulk_no_grow(indices: &mut Vec<usize>, entries: &Vec<i32>) {","        for (i, _entry) in entries.iter().enumerate() {","            indices.push(i);","        }","    }","","    let mut index_map = IndexMap::new(vec![1, 2, 3]);","    index_map.rebuild_hash_table();","    assert_eq!(index_map.indices, vec![0, 1, 2]);","}"],[]],[["{","    struct IndexMap {","        indices: Vec<usize>,","        entries: Vec<i32>,","    }","","    impl IndexMap {","        fn new(entries: Vec<i32>) -> Self {","            IndexMap {","                indices: Vec::with_capacity(entries.len()),","                entries,","            }","        }","","        fn rebuild_hash_table(&mut self) {","            self.indices.clear();","            insert_bulk_no_grow(&mut self.indices, &self.entries);","        }","    }","","    fn insert_bulk_no_grow(indices: &mut Vec<usize>, entries: &Vec<i32>) {","        for (i, _entry) in entries.iter().enumerate() {","            indices.push(i);","        }","    }","","    let mut index_map = IndexMap::new(vec![10, 20, 30, 40]);","    index_map.rebuild_hash_table();","    assert_eq!(index_map.indices, vec![0, 1, 2, 3]);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct IndexMap {","        indices: Vec<usize>,","        entries: Vec<i32>,","    }","","    impl IndexMap {","        fn new() -> Self {","            IndexMap {","                indices: Vec::new(),","                entries: Vec::new(),","            }","        }","","        fn rebuild_hash_table(&mut self) {","            self.indices.clear();","            insert_bulk_no_grow(&mut self.indices, &self.entries);","        }","    }","","    fn insert_bulk_no_grow(indices: &mut Vec<usize>, entries: &Vec<i32>) {","        for (i, _entry) in entries.iter().enumerate() {","            indices.push(i);","        }","    }","","    let mut index_map = IndexMap::new();","    index_map.rebuild_hash_table();","    assert!(index_map.indices.is_empty());","}"],[]],[["{","    struct IndexMap {","        indices: Vec<usize>,","        entries: Vec<i32>,","    }","","    impl IndexMap {","        fn new(entries: Vec<i32>) -> Self {","            IndexMap {","                indices: Vec::new(),","                entries,","            }","        }","","        fn rebuild_hash_table(&mut self) {","            self.indices.clear();","            insert_bulk_no_grow(&mut self.indices, &self.entries);","        }","    }","","    fn insert_bulk_no_grow(indices: &mut Vec<usize>, entries: &Vec<i32>) {","        for (i, _entry) in entries.iter().enumerate() {","            indices.push(i);","        }","    }","","    let mut index_map = IndexMap::new(vec![42]);","    index_map.rebuild_hash_table();","    assert_eq!(index_map.indices, vec![0]);","}"],[]],[["{","    struct IndexMap {","        indices: Vec<usize>,","        entries: Vec<i32>,","    }","","    impl IndexMap {","        fn new(entries: Vec<i32>) -> Self {","            IndexMap {","                indices: Vec::new(),","                entries,","            }","        }","","        fn rebuild_hash_table(&mut self) {","            self.indices.clear();","            insert_bulk_no_grow(&mut self.indices, &self.entries);","        }","    }","","    fn insert_bulk_no_grow(indices: &mut Vec<usize>, entries: &Vec<i32>) {","        for (i, _entry) in entries.iter().enumerate() {","            indices.push(i);","        }","    }","","    let mut index_map = IndexMap::new(vec![1, 2, 3]);","    index_map.rebuild_hash_table();","    assert_eq!(index_map.indices, vec![0, 1, 2]);","}"],[]],[["{","    struct IndexMap {","        indices: Vec<usize>,","        entries: Vec<i32>,","    }","","    impl IndexMap {","        fn new(entries: Vec<i32>) -> Self {","            IndexMap {","                indices: Vec::with_capacity(entries.len()),","                entries,","            }","        }","","        fn rebuild_hash_table(&mut self) {","            self.indices.clear();","            insert_bulk_no_grow(&mut self.indices, &self.entries);","        }","    }","","    fn insert_bulk_no_grow(indices: &mut Vec<usize>, entries: &Vec<i32>) {","        for (i, _entry) in entries.iter().enumerate() {","            indices.push(i);","        }","    }","","    let mut index_map = IndexMap::new(vec![10, 20, 30, 40]);","    index_map.rebuild_hash_table();","    assert_eq!(index_map.indices, vec![0, 1, 2, 3]);","}"],[]]]}