{"function_name":"indexmap::map::core::raw_entry_v1::map::core::raw_entry_v1::RawOccupiedEntryMut<'a, K, V, S>::into_mut","tests":2,"tests_lines":[33,30],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[454,455,456,457],"codes_lines_covered":[[["{","    struct Entry<V> {","        value: V,","    }","","    struct Map<V> {","        entries: Vec<Entry<V>>,","    }","","    impl<V> Map<V> {","        fn new() -> Self {","            Map { entries: Vec::new() }","        }","        ","        fn add_entry(&mut self, value: V) {","            self.entries.push(Entry { value });","        }","","        fn into_mut(&mut self, index: usize) -> &mut V {","            let entry = &mut self.entries[index];","            &mut entry.value","        }","    }","","    let mut map = Map::new();","    map.add_entry(10);","    map.add_entry(20);","    ","    let value_ref = map.into_mut(1);","    *value_ref += 5;","","    assert_eq!(map.entries[1].value, 25);","}"],[]],[["{","    struct Entry<V> {","        value: V,","    }","","    struct Map<V> {","        entries: Vec<Entry<V>>,","    }","","    impl<V> Map<V> {","        fn new() -> Self {","            Map { entries: Vec::new() }","        }","        ","        fn add_entry(&mut self, value: V) {","            self.entries.push(Entry { value });","        }","","        fn into_mut(&mut self, index: usize) -> &mut V {","            let entry = &mut self.entries[index];","            &mut entry.value","        }","    }","","    let mut map = Map::new();","    map.add_entry(30);","","    // This will panic since there is no entry at index 1","    let _value_ref = map.into_mut(1);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Entry<V> {","        value: V,","    }","","    struct Map<V> {","        entries: Vec<Entry<V>>,","    }","","    impl<V> Map<V> {","        fn new() -> Self {","            Map { entries: Vec::new() }","        }","        ","        fn add_entry(&mut self, value: V) {","            self.entries.push(Entry { value });","        }","","        fn into_mut(&mut self, index: usize) -> &mut V {","            let entry = &mut self.entries[index];","            &mut entry.value","        }","    }","","    let mut map = Map::new();","    map.add_entry(10);","    map.add_entry(20);","    ","    let value_ref = map.into_mut(1);","    *value_ref += 5;","","    assert_eq!(map.entries[1].value, 25);","}"],[]],[["{","    struct Entry<V> {","        value: V,","    }","","    struct Map<V> {","        entries: Vec<Entry<V>>,","    }","","    impl<V> Map<V> {","        fn new() -> Self {","            Map { entries: Vec::new() }","        }","        ","        fn add_entry(&mut self, value: V) {","            self.entries.push(Entry { value });","        }","","        fn into_mut(&mut self, index: usize) -> &mut V {","            let entry = &mut self.entries[index];","            &mut entry.value","        }","    }","","    let mut map = Map::new();","    map.add_entry(30);","","    // This will panic since there is no entry at index 1","    let _value_ref = map.into_mut(1);","}"],[]]]}