{"function_name":"indexmap::map::mutable::<map::core::entry::OccupiedEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut","tests":1,"tests_lines":[39],"oracles":1,"oracles_compiled":1,"oracles_compiled_rate":100.0,"tests_compiled":1,"tests_compiled_rate":100.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[133,134,135],"codes_lines_covered":[[["{","    struct TestMap {","        key: i32,","    }","","    impl TestMap {","        fn new(key: i32) -> Self {","            TestMap { key }","        }","","        fn key_mut(&mut self) -> &mut i32 {","            &mut self.key","        }","    }","","    // Test case: Normal scenario","    let mut map = TestMap::new(10);","    {","        let key_reference = map.key_mut();","        *key_reference += 5;","    }","    assert_eq!(map.key, 15);","","    // Test case: Boundary condition with negative key","    let mut map_negative = TestMap::new(-5);","    {","        let key_reference = map_negative.key_mut();","        *key_reference = -10;","    }","    assert_eq!(map_negative.key, -10);","","    // Test case: Boundary condition with zero key","    let mut map_zero = TestMap::new(0);","    {","        let key_reference = map_zero.key_mut();","        *key_reference += 1;","    }","    assert_eq!(map_zero.key, 1);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestMap {","        key: i32,","    }","","    impl TestMap {","        fn new(key: i32) -> Self {","            TestMap { key }","        }","","        fn key_mut(&mut self) -> &mut i32 {","            &mut self.key","        }","    }","","    // Test case: Normal scenario","    let mut map = TestMap::new(10);","    {","        let key_reference = map.key_mut();","        *key_reference += 5;","    }","    assert_eq!(map.key, 15);","","    // Test case: Boundary condition with negative key","    let mut map_negative = TestMap::new(-5);","    {","        let key_reference = map_negative.key_mut();","        *key_reference = -10;","    }","    assert_eq!(map_negative.key, -10);","","    // Test case: Boundary condition with zero key","    let mut map_zero = TestMap::new(0);","    {","        let key_reference = map_zero.key_mut();","        *key_reference += 1;","    }","    assert_eq!(map_zero.key, 1);","}"],[]]]}