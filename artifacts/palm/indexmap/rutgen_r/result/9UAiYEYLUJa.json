{"function_name":"indexmap::map::core::entry::map::core::entry::OccupiedEntry<'a, K, V>::swap_indices","tests":3,"tests_lines":[32,31,33],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[311,312,313,314],"codes_lines_covered":[[["{","    struct Entry {","        index: usize,","    }","","    impl Entry {","        pub fn new(index: usize) -> Self {","            Entry { index }","        }","","        pub fn index(&self) -> usize {","            self.index","        }","","        pub fn into_ref_mut(&mut self) -> &mut Self {","            self","        }","","        pub fn swap_indices(&mut self, index1: usize, index2: usize) {","            let temp = self.index;","            self.index = index2;","            // Simulate other entry's index swapping","            // This is a placeholder to represent the swap operation","        }","    }","","    let mut entry1 = Entry::new(0);","    let entry2 = Entry::new(1);","    ","    entry1.swap_indices(entry1.index(), entry2.index());","    assert_eq!(entry1.index(), 1);","}"],[]],[["{","    struct Entry {","        index: usize,","    }","","    impl Entry {","        pub fn new(index: usize) -> Self {","            Entry { index }","        }","","        pub fn index(&self) -> usize {","            self.index","        }","","        pub fn into_ref_mut(&mut self) -> &mut Self {","            self","        }","","        pub fn swap_indices(&mut self, index1: usize, index2: usize) {","            if index2 >= 2 { // Simulating out-of-bounds condition for 2 entries","                panic!(\"Index out of bounds\");","            }","            let temp = self.index;","            self.index = index2;","            // Simulate other entry's index swapping","        }","    }","","    let mut entry1 = Entry::new(0);","    entry1.swap_indices(entry1.index(), 2); // This should panic","}"],[]],[["{","    struct Entry {","        index: usize,","    }","","    impl Entry {","        pub fn new(index: usize) -> Self {","            Entry { index }","        }","","        pub fn index(&self) -> usize {","            self.index","        }","","        pub fn into_ref_mut(&mut self) -> &mut Self {","            self","        }","","        pub fn swap_indices(&mut self, index1: usize, index2: usize) {","            if index2 >= 1 { // Simulating out-of-bounds condition for 1 entry","                panic!(\"Index out of bounds\");","            }","            let temp = self.index;","            self.index = index2;","            // Simulate other entry's index swapping","        }","    }","","    let mut entry1 = Entry::new(0);","    assert_eq!(entry1.index(), 0);","    entry1.swap_indices(entry1.index(), 0); // Valid condition; index remains the same","    assert_eq!(entry1.index(), 0);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Entry {","        index: usize,","    }","","    impl Entry {","        pub fn new(index: usize) -> Self {","            Entry { index }","        }","","        pub fn index(&self) -> usize {","            self.index","        }","","        pub fn into_ref_mut(&mut self) -> &mut Self {","            self","        }","","        pub fn swap_indices(&mut self, index1: usize, index2: usize) {","            let temp = self.index;","            self.index = index2;","            // Simulate other entry's index swapping","            // This is a placeholder to represent the swap operation","        }","    }","","    let mut entry1 = Entry::new(0);","    let entry2 = Entry::new(1);","    ","    entry1.swap_indices(entry1.index(), entry2.index());","    assert_eq!(entry1.index(), 1);","}"],[]],[["{","    struct Entry {","        index: usize,","    }","","    impl Entry {","        pub fn new(index: usize) -> Self {","            Entry { index }","        }","","        pub fn index(&self) -> usize {","            self.index","        }","","        pub fn into_ref_mut(&mut self) -> &mut Self {","            self","        }","","        pub fn swap_indices(&mut self, index1: usize, index2: usize) {","            if index2 >= 2 { // Simulating out-of-bounds condition for 2 entries","                panic!(\"Index out of bounds\");","            }","            let temp = self.index;","            self.index = index2;","            // Simulate other entry's index swapping","        }","    }","","    let mut entry1 = Entry::new(0);","    entry1.swap_indices(entry1.index(), 2); // This should panic","}"],[]],[["{","    struct Entry {","        index: usize,","    }","","    impl Entry {","        pub fn new(index: usize) -> Self {","            Entry { index }","        }","","        pub fn index(&self) -> usize {","            self.index","        }","","        pub fn into_ref_mut(&mut self) -> &mut Self {","            self","        }","","        pub fn swap_indices(&mut self, index1: usize, index2: usize) {","            if index2 >= 1 { // Simulating out-of-bounds condition for 1 entry","                panic!(\"Index out of bounds\");","            }","            let temp = self.index;","            self.index = index2;","            // Simulate other entry's index swapping","        }","    }","","    let mut entry1 = Entry::new(0);","    assert_eq!(entry1.index(), 0);","    entry1.swap_indices(entry1.index(), 0); // Valid condition; index remains the same","    assert_eq!(entry1.index(), 0);","}"],[]]]}