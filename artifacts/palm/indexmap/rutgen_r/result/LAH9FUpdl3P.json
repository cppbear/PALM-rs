{"function_name":"indexmap::map::core::entry::map::core::entry::OccupiedEntry<'a, K, V>::move_index","tests":4,"tests_lines":[38,37,39,40],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[298,299,300,301],"codes_lines_covered":[[["{","    struct TestEntry {","        index: usize,","    }","","    impl TestEntry {","        fn new(index: usize) -> Self {","            Self { index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            // Simulate moving index (this would normally mutate the structure)","            self.index = to;","        }","","        fn into_ref_mut(self) -> TestEntryRefMut {","            TestEntryRefMut { entry: self }","        }","    }","","    struct TestEntryRefMut {","        entry: TestEntry,","    }","","    impl TestEntryRefMut {","        fn move_index(&mut self, from: usize, to: usize) {","            self.entry.move_index(from, to);","        }","    }","","    let mut entry = TestEntry::new(0);","    entry.move_index(0, 2);","    assert_eq!(entry.index(), 2);","}"],[]],[["{","    struct TestEntry {","        index: usize,","    }","","    impl TestEntry {","        fn new(index: usize) -> Self {","            Self { index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            self.index = to;","        }","","        fn into_ref_mut(self) -> TestEntryRefMut {","            TestEntryRefMut { entry: self }","        }","    }","","    struct TestEntryRefMut {","        entry: TestEntry,","    }","","    impl TestEntryRefMut {","        fn move_index(&mut self, from: usize, to: usize) {","            self.entry.move_index(from, to);","        }","    }","","    let mut entry = TestEntry::new(3);","    entry.move_index(3, 1);","    assert_eq!(entry.index(), 1);","}"],[]],[["{","    struct TestEntry {","        index: usize,","    }","","    impl TestEntry {","        fn new(index: usize) -> Self {","            Self { index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            if to > 5 {","                panic!(\"to index out of bounds\");","            }","            self.index = to;","        }","","        fn into_ref_mut(self) -> TestEntryRefMut {","            TestEntryRefMut { entry: self }","        }","    }","","    struct TestEntryRefMut {","        entry: TestEntry,","    }","","    impl TestEntryRefMut {","        fn move_index(&mut self, from: usize, to: usize) {","            self.entry.move_index(from, to);","        }","    }","","    let mut entry = TestEntry::new(0);","    entry.move_index(0, 6); // This should trigger a panic","}"],[]],[["{","    struct TestEntry {","        index: usize,","    }","","    impl TestEntry {","        fn new(index: usize) -> Self {","            Self { index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            // No change should occur if moved to the same index","            if from != to {","                self.index = to;","            }","        }","","        fn into_ref_mut(self) -> TestEntryRefMut {","            TestEntryRefMut { entry: self }","        }","    }","","    struct TestEntryRefMut {","        entry: TestEntry,","    }","","    impl TestEntryRefMut {","        fn move_index(&mut self, from: usize, to: usize) {","            self.entry.move_index(from, to);","        }","    }","","    let mut entry = TestEntry::new(1);","    entry.move_index(1, 1); // Moving to the same index","    assert_eq!(entry.index(), 1);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestEntry {","        index: usize,","    }","","    impl TestEntry {","        fn new(index: usize) -> Self {","            Self { index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            // Simulate moving index (this would normally mutate the structure)","            self.index = to;","        }","","        fn into_ref_mut(self) -> TestEntryRefMut {","            TestEntryRefMut { entry: self }","        }","    }","","    struct TestEntryRefMut {","        entry: TestEntry,","    }","","    impl TestEntryRefMut {","        fn move_index(&mut self, from: usize, to: usize) {","            self.entry.move_index(from, to);","        }","    }","","    let mut entry = TestEntry::new(0);","    entry.move_index(0, 2);","    assert_eq!(entry.index(), 2);","}"],[]],[["{","    struct TestEntry {","        index: usize,","    }","","    impl TestEntry {","        fn new(index: usize) -> Self {","            Self { index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            self.index = to;","        }","","        fn into_ref_mut(self) -> TestEntryRefMut {","            TestEntryRefMut { entry: self }","        }","    }","","    struct TestEntryRefMut {","        entry: TestEntry,","    }","","    impl TestEntryRefMut {","        fn move_index(&mut self, from: usize, to: usize) {","            self.entry.move_index(from, to);","        }","    }","","    let mut entry = TestEntry::new(3);","    entry.move_index(3, 1);","    assert_eq!(entry.index(), 1);","}"],[]],[["{","    struct TestEntry {","        index: usize,","    }","","    impl TestEntry {","        fn new(index: usize) -> Self {","            Self { index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            if to > 5 {","                panic!(\"to index out of bounds\");","            }","            self.index = to;","        }","","        fn into_ref_mut(self) -> TestEntryRefMut {","            TestEntryRefMut { entry: self }","        }","    }","","    struct TestEntryRefMut {","        entry: TestEntry,","    }","","    impl TestEntryRefMut {","        fn move_index(&mut self, from: usize, to: usize) {","            self.entry.move_index(from, to);","        }","    }","","    let mut entry = TestEntry::new(0);","    entry.move_index(0, 6); // This should trigger a panic","}"],[]],[["{","    struct TestEntry {","        index: usize,","    }","","    impl TestEntry {","        fn new(index: usize) -> Self {","            Self { index }","        }","","        fn index(&self) -> usize {","            self.index","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            // No change should occur if moved to the same index","            if from != to {","                self.index = to;","            }","        }","","        fn into_ref_mut(self) -> TestEntryRefMut {","            TestEntryRefMut { entry: self }","        }","    }","","    struct TestEntryRefMut {","        entry: TestEntry,","    }","","    impl TestEntryRefMut {","        fn move_index(&mut self, from: usize, to: usize) {","            self.entry.move_index(from, to);","        }","    }","","    let mut entry = TestEntry::new(1);","    entry.move_index(1, 1); // Moving to the same index","    assert_eq!(entry.index(), 1);","}"],[]]]}