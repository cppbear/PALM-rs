{"function_name":"indexmap::map::core::map::core::RefMut<'a, K, V>::shift_remove_index","tests":5,"tests_lines":[30,30,30,30,33],"oracles":5,"oracles_compiled":4,"oracles_compiled_rate":80.0,"tests_compiled":4,"tests_compiled_rate":80.0,"oracles_run":4,"oracles_passed":1,"oracles_passed_rate":25.0,"tests_run":4,"tests_passed":1,"tests_passed_rate":25.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[590,591,592,593,594,596,598],"codes_lines_covered":[[["{","    struct TestEntries {","        entries: Vec<(i32, i32)>, // Use i32 for both K and V types","    }","","    impl TestEntries {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            Self { entries }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (i32, i32) {","            self.entries.remove(index)","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(_) => {","                    self.shift_remove_finish(index);","                    Some(self.entries[index].clone())","                }","                None => None,","            }","        }","    }","","    let mut test_entries = TestEntries::new(vec![(1, 2), (3, 4), (5, 6)]);","","    let result = test_entries.shift_remove_index(1);","    assert_eq!(result, Some((3, 4))); // Expecting the entry at index 1 to be removed and returned","}"],[]],[["{","    struct TestEntries {","        entries: Vec<(i32, i32)>,","    }","","    impl TestEntries {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            Self { entries }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (i32, i32) {","            self.entries.remove(index)","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(_) => {","                    self.shift_remove_finish(index);","                    Some(self.entries[index].clone())","                }","                None => None,","            }","        }","    }","","    let mut test_entries = TestEntries::new(vec![(1, 2), (3, 4), (5, 6)]);","","    let result = test_entries.shift_remove_index(0);","    assert_eq!(result, Some((1, 2))); // Expecting the entry at index 0 to be removed and returned","}"],[]],[["{","    struct TestEntries {","        entries: Vec<(i32, i32)>,","    }","","    impl TestEntries {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            Self { entries }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (i32, i32) {","            self.entries.remove(index)","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(_) => {","                    self.shift_remove_finish(index);","                    Some(self.entries[index].clone())","                }","                None => None,","            }","        }","    }","","    let mut test_entries = TestEntries::new(vec![(1, 2), (3, 4), (5, 6)]);","","    let result = test_entries.shift_remove_index(2);","    assert_eq!(result, Some((5, 6))); // Expecting the entry at index 2 to be removed and returned","}"],[]],[["{","    struct TestEntries {","        entries: Vec<(i32, i32)>,","    }","","    impl TestEntries {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            Self { entries }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (i32, i32) {","            self.entries.remove(index)","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(_) => {","                    self.shift_remove_finish(index);","                    Some(self.entries[index].clone())","                }","                None => None,","            }","        }","    }","","    let mut test_entries = TestEntries::new(vec![(1, 2), (3, 4), (5, 6)]);","","    let result = test_entries.shift_remove_index(3);","    assert_eq!(result, None); // Expecting None as index 3 is out of bounds","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestEntries {","        entries: Vec<(i32, i32)>, // Use i32 for both K and V types","    }","","    impl TestEntries {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            Self { entries }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (i32, i32) {","            self.entries.remove(index)","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(_) => {","                    self.shift_remove_finish(index);","                    Some(self.entries[index].clone())","                }","                None => None,","            }","        }","    }","","    let mut test_entries = TestEntries::new(vec![(1, 2), (3, 4), (5, 6)]);","","    let result = test_entries.shift_remove_index(1);","    assert_eq!(result, Some((3, 4))); // Expecting the entry at index 1 to be removed and returned","}"],[]],[["{","    struct TestEntries {","        entries: Vec<(i32, i32)>,","    }","","    impl TestEntries {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            Self { entries }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (i32, i32) {","            self.entries.remove(index)","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(_) => {","                    self.shift_remove_finish(index);","                    Some(self.entries[index].clone())","                }","                None => None,","            }","        }","    }","","    let mut test_entries = TestEntries::new(vec![(1, 2), (3, 4), (5, 6)]);","","    let result = test_entries.shift_remove_index(0);","    assert_eq!(result, Some((1, 2))); // Expecting the entry at index 0 to be removed and returned","}"],[]],[["{","    struct TestEntries {","        entries: Vec<(i32, i32)>,","    }","","    impl TestEntries {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            Self { entries }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (i32, i32) {","            self.entries.remove(index)","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(_) => {","                    self.shift_remove_finish(index);","                    Some(self.entries[index].clone())","                }","                None => None,","            }","        }","    }","","    let mut test_entries = TestEntries::new(vec![(1, 2), (3, 4), (5, 6)]);","","    let result = test_entries.shift_remove_index(2);","    assert_eq!(result, Some((5, 6))); // Expecting the entry at index 2 to be removed and returned","}"],[]],[["{","    struct TestEntries {","        entries: Vec<(i32, i32)>,","    }","","    impl TestEntries {","        fn new(entries: Vec<(i32, i32)>) -> Self {","            Self { entries }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (i32, i32) {","            self.entries.remove(index)","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(_) => {","                    self.shift_remove_finish(index);","                    Some(self.entries[index].clone())","                }","                None => None,","            }","        }","    }","","    let mut test_entries = TestEntries::new(vec![(1, 2), (3, 4), (5, 6)]);","","    let result = test_entries.shift_remove_index(3);","    assert_eq!(result, None); // Expecting None as index 3 is out of bounds","}"],[]]]}