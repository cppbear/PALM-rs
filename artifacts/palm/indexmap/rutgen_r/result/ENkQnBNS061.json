{"function_name":"indexmap::map::iter::<map::iter::IntoIter<K, V> as std::fmt::Debug>::fmt","tests":4,"tests_lines":[19,23,25,25],"oracles":4,"oracles_compiled":1,"oracles_compiled_rate":25.0,"tests_compiled":1,"tests_compiled_rate":25.0,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[266,267,268,269],"codes_lines_covered":[[["{","    struct Bucket {","        refs: usize,","    }","","    struct TestStruct {","        iter: Vec<Bucket>,","    }","","    impl TestStruct {","        fn new() -> Self {","            TestStruct { iter: vec![Bucket { refs: 1 }] }","        }","","        fn iter(&self) -> &[Bucket] {","            &self.iter","        }","    }","","    let test_struct = TestStruct::new();","    // Intentionally cause a panic if the refs count is 0","    if test_struct.iter.first().unwrap().refs == 0 {","        panic!(\"Reference count is zero\");","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Bucket {","        refs: usize,","    }","","    struct TestStruct {","        iter: Vec<Bucket>,","    }","","    impl TestStruct {","        fn new() -> Self {","            TestStruct { iter: vec![Bucket { refs: 1 }] }","        }","","        fn iter(&self) -> &[Bucket] {","            &self.iter","        }","    }","","    let test_struct = TestStruct::new();","    // Intentionally cause a panic if the refs count is 0","    if test_struct.iter.first().unwrap().refs == 0 {","        panic!(\"Reference count is zero\");","    }","}"],[]]]}