{"function_name":"indexmap::set::<set::IndexSet<T, S> as Entries>::as_entries","tests":4,"tests_lines":[5,7,13,10],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[117,118,119],"codes_lines_covered":[[["{","    let struct_instance = DummyStruct::new(vec![]);","    let entries = struct_instance.as_entries();","    assert_eq!(entries.len(), 0);","}"],[]],[["{","    let struct_instance = DummyStruct::new(vec![DummyEntry { key: 1, value: \"one\".to_string() }]);","    let entries = struct_instance.as_entries();","    assert_eq!(entries.len(), 1);","    assert_eq!(entries[0].key, 1);","    assert_eq!(entries[0].value, \"one\");","}"],[]],[["{","    let entries = vec![","        DummyEntry { key: 1, value: \"one\".to_string() },","        DummyEntry { key: 2, value: \"two\".to_string() },","        DummyEntry { key: 3, value: \"three\".to_string() },","    ];","    let struct_instance = DummyStruct::new(entries);","    let result_entries = struct_instance.as_entries();","    assert_eq!(result_entries.len(), 3);","    assert_eq!(result_entries[0].key, 1);","    assert_eq!(result_entries[1].key, 2);","    assert_eq!(result_entries[2].key, 3);","}"],[]],[["{","    let entries: Vec<DummyEntry> = (0..1000)","        .map(|i| DummyEntry { key: i, value: i.to_string() })","        .collect();","    let struct_instance = DummyStruct::new(entries);","    let result_entries = struct_instance.as_entries();","    assert_eq!(result_entries.len(), 1000);","    assert_eq!(result_entries[999].key, 999);","    assert_eq!(result_entries[999].value, \"999\");","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let struct_instance = DummyStruct::new(vec![]);","    let entries = struct_instance.as_entries();","    assert_eq!(entries.len(), 0);","}"],[]],[["{","    let struct_instance = DummyStruct::new(vec![DummyEntry { key: 1, value: \"one\".to_string() }]);","    let entries = struct_instance.as_entries();","    assert_eq!(entries.len(), 1);","    assert_eq!(entries[0].key, 1);","    assert_eq!(entries[0].value, \"one\");","}"],[]],[["{","    let entries = vec![","        DummyEntry { key: 1, value: \"one\".to_string() },","        DummyEntry { key: 2, value: \"two\".to_string() },","        DummyEntry { key: 3, value: \"three\".to_string() },","    ];","    let struct_instance = DummyStruct::new(entries);","    let result_entries = struct_instance.as_entries();","    assert_eq!(result_entries.len(), 3);","    assert_eq!(result_entries[0].key, 1);","    assert_eq!(result_entries[1].key, 2);","    assert_eq!(result_entries[2].key, 3);","}"],[]],[["{","    let entries: Vec<DummyEntry> = (0..1000)","        .map(|i| DummyEntry { key: i, value: i.to_string() })","        .collect();","    let struct_instance = DummyStruct::new(entries);","    let result_entries = struct_instance.as_entries();","    assert_eq!(result_entries.len(), 1000);","    assert_eq!(result_entries[999].key, 999);","    assert_eq!(result_entries[999].value, \"999\");","}"],[]]]}