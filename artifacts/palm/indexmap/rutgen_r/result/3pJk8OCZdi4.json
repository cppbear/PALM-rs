{"function_name":"indexmap::map::map::IndexMap<K, V, S>::shift_remove_index","tests":3,"tests_lines":[39,34,26],"oracles":3,"oracles_compiled":2,"oracles_compiled_rate":66.66666666666666,"tests_compiled":2,"tests_compiled_rate":66.66666666666666,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1330,1331,1332],"codes_lines_covered":[[["{","    struct TestMap<K, V> {","        core: Vec<(K, V)>,","    }","","    impl<K, V> TestMap<K, V> {","        fn new() -> Self {","            TestMap { core: Vec::new() }","        }","","        fn insert(&mut self, key: K, value: V) {","            self.core.push((key, value));","        }","","        fn len(&self) -> usize {","            self.core.len()","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)> {","            if index < self.len() {","                Some(self.core.remove(index))","            } else {","                None","            }","        }","    }","","    let mut map = TestMap::new();","    map.insert(1, \"one\");","    map.insert(2, \"two\");","    map.insert(3, \"three\");","","    assert_eq!(map.shift_remove_index(1), Some((2, \"two\")));","    assert_eq!(map.len(), 2);","    assert_eq!(map.shift_remove_index(0), Some((1, \"one\")));","    assert_eq!(map.len(), 1);","    assert_eq!(map.shift_remove_index(0), Some((3, \"three\")));","    assert_eq!(map.len(), 0);","}"],[]],[["{","    struct TestMap<K, V> {","        core: Vec<(K, V)>,","    }","","    impl<K, V> TestMap<K, V> {","        fn new() -> Self {","            TestMap { core: Vec::new() }","        }","","        fn insert(&mut self, key: K, value: V) {","            self.core.push((key, value));","        }","","        fn len(&self) -> usize {","            self.core.len()","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)> {","            if index < self.len() {","                Some(self.core.remove(index))","            } else {","                panic!(\"Index out of bounds\");","            }","        }","    }","","    let mut map = TestMap::new();","    map.insert(1, \"one\");","    map.insert(2, \"two\");","    map.insert(3, \"three\");","    ","    let _ = map.shift_remove_index(3); // This should panic","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestMap<K, V> {","        core: Vec<(K, V)>,","    }","","    impl<K, V> TestMap<K, V> {","        fn new() -> Self {","            TestMap { core: Vec::new() }","        }","","        fn insert(&mut self, key: K, value: V) {","            self.core.push((key, value));","        }","","        fn len(&self) -> usize {","            self.core.len()","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)> {","            if index < self.len() {","                Some(self.core.remove(index))","            } else {","                None","            }","        }","    }","","    let mut map = TestMap::new();","    map.insert(1, \"one\");","    map.insert(2, \"two\");","    map.insert(3, \"three\");","","    assert_eq!(map.shift_remove_index(1), Some((2, \"two\")));","    assert_eq!(map.len(), 2);","    assert_eq!(map.shift_remove_index(0), Some((1, \"one\")));","    assert_eq!(map.len(), 1);","    assert_eq!(map.shift_remove_index(0), Some((3, \"three\")));","    assert_eq!(map.len(), 0);","}"],[]],[["{","    struct TestMap<K, V> {","        core: Vec<(K, V)>,","    }","","    impl<K, V> TestMap<K, V> {","        fn new() -> Self {","            TestMap { core: Vec::new() }","        }","","        fn insert(&mut self, key: K, value: V) {","            self.core.push((key, value));","        }","","        fn len(&self) -> usize {","            self.core.len()","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)> {","            if index < self.len() {","                Some(self.core.remove(index))","            } else {","                panic!(\"Index out of bounds\");","            }","        }","    }","","    let mut map = TestMap::new();","    map.insert(1, \"one\");","    map.insert(2, \"two\");","    map.insert(3, \"three\");","    ","    let _ = map.shift_remove_index(3); // This should panic","}"],[]]]}