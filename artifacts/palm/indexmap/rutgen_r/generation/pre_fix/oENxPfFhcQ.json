{
  "name": "indexmap::map::iter::map::iter::Splice<'a, I, K, V, S>::new",
  "name_with_impl": "indexmap::map::iter::{impl#76}::new",
  "mod_info": {
    "name": "map::iter",
    "loc": "src/map.rs:5:1:5:10"
  },
  "visible": false,
  "loc": "src/map/iter.rs:671:5:682:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: Self {\n            map,\n            tail,\n            drain,\n            replace_with,\n        }\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use std::ops::RangeBounds;",
            "use indexmap::IndexMap;"
          ],
          "has_test_mod": false,
          "common": [
            "fn test_new_with_valid_range() {",
            "",
            "    struct TestReplacer;",
            "    let mut map = IndexMap::new();",
            "    map.insert(0, \"a\");",
            "    map.insert(1, \"b\");",
            "    map.insert(2, \"c\");",
            "    ",
            "    // Valid range and replace_with",
            "    {",
            "        let range: std::ops::Range<usize> = 0..2;",
            "        let replace_with = TestReplacer;",
            "",
            "        let result = new(&mut map, range, replace_with);",
            "",
            "        // Check the expected structure",
            "        assert_eq!(map.len(), 1); // Expecting that the first two elements are drained",
            "        assert_eq!(result.tail.len(), 1); // Remaining elements in tail",
            "        assert_eq!(result.drain.len(), 2); // Drained elements",
            "    }",
            "}",
            "",
            "fn test_new_with_empty_map() {",
            "",
            "    struct TestReplacer;",
            "    let mut map = IndexMap::new();",
            "    ",
            "    // Valid range but should handle empty map",
            "    {",
            "        let range: std::ops::Range<usize> = 0..1;",
            "        let replace_with = TestReplacer;",
            "",
            "        let result = new(&mut map, range, replace_with);",
            "",
            "        // Check the expected structure",
            "        assert_eq!(map.len(), 0); // The map should still be empty",
            "        assert!(result.tail.is_empty()); // Tail should be empty",
            "        assert!(result.drain.is_empty()); // There should be nothing drained",
            "    }",
            "}",
            "",
            "fn test_new_with_exceeding_range() {",
            "",
            "    struct TestReplacer;",
            "    let mut map = IndexMap::new();",
            "    map.insert(0, \"a\");",
            "    ",
            "    // Range exceeds current map size",
            "    {",
            "        let range: std::ops::Range<usize> = 0..5;",
            "        let replace_with = TestReplacer;",
            "",
            "        let result = new(&mut map, range, replace_with);",
            "",
            "        // Check the expected structure",
            "        assert_eq!(map.len(), 0); // The map should be empty after being drained",
            "        assert_eq!(result.tail.len(), 0); // Tail should be empty",
            "        assert_eq!(result.drain.len(), 1); // Drained the one element we had",
            "    }",
            "}"
          ],
          "chain_tests": []
        }
      ]
    }
  ]
}