{"function_name":"indexmap::set::<set::IndexSet<T, S> as std::ops::Index<usize>>::index","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/set.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":2,"tests_lines":[34,32],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1108,1109,1110,1111,1112,1113,1114,1115],"codes_lines_covered":[[["{","    struct TestSet {","        items: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { items: vec![1, 2, 3] }","        }","","        fn len(&self) -> usize {","            self.items.len()","        }","","        fn get_index(&self, index: usize) -> Option<&i32> {","            self.items.get(index)","        }","","        fn index(&self, index: usize) -> &i32 {","            self.get_index(index).unwrap_or_else(|| {","                panic!(","                    \"index out of bounds: the len is {len} but the index is {index}\",","                    len = self.len(),","                    index = index","                );","            })","        }","    }","","    let set = TestSet::new();","    assert_eq!(*set.index(0), 1);","    assert_eq!(*set.index(1), 2);","    assert_eq!(*set.index(2), 3);","}"],[]],[["{","    struct TestSet {","        items: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { items: vec![1, 2, 3] }","        }","","        fn len(&self) -> usize {","            self.items.len()","        }","","        fn get_index(&self, index: usize) -> Option<&i32> {","            self.items.get(index)","        }","","        fn index(&self, index: usize) -> &i32 {","            self.get_index(index).unwrap_or_else(|| {","                panic!(","                    \"index out of bounds: the len is {len} but the index is {index}\",","                    len = self.len(),","                    index = index","                );","            })","        }","    }","","    let set = TestSet::new();","    let _ = set.index(3); // This should panic","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestSet {","        items: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { items: vec![1, 2, 3] }","        }","","        fn len(&self) -> usize {","            self.items.len()","        }","","        fn get_index(&self, index: usize) -> Option<&i32> {","            self.items.get(index)","        }","","        fn index(&self, index: usize) -> &i32 {","            self.get_index(index).unwrap_or_else(|| {","                panic!(","                    \"index out of bounds: the len is {len} but the index is {index}\",","                    len = self.len(),","                    index = index","                );","            })","        }","    }","","    let set = TestSet::new();","    assert_eq!(*set.index(0), 1);","    assert_eq!(*set.index(1), 2);","    assert_eq!(*set.index(2), 3);","}"],[]],[["{","    struct TestSet {","        items: Vec<i32>,","    }","","    impl TestSet {","        fn new() -> Self {","            TestSet { items: vec![1, 2, 3] }","        }","","        fn len(&self) -> usize {","            self.items.len()","        }","","        fn get_index(&self, index: usize) -> Option<&i32> {","            self.items.get(index)","        }","","        fn index(&self, index: usize) -> &i32 {","            self.get_index(index).unwrap_or_else(|| {","                panic!(","                    \"index out of bounds: the len is {len} but the index is {index}\",","                    len = self.len(),","                    index = index","                );","            })","        }","    }","","    let set = TestSet::new();","    let _ = set.index(3); // This should panic","}"],[]]]}