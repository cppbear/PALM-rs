{"function_name":"indexmap::map::slice::map::slice::Slice<K, V>::binary_search_by","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/slice.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":3,"tests_lines":[33,33,28],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[238,239,240,241,242,243],"codes_lines_covered":[[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap {","        entries: Vec<Entry<i32, &'static str>>,","    }","","    impl SortedMap {","        fn new(entries: Vec<Entry<i32, &'static str>>) -> Self {","            SortedMap { entries }","        }","","        pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>","        where","            F: FnMut(&'a i32, &'a &'static str) -> std::cmp::Ordering,","        {","            self.entries.binary_search_by(move |a| f(&a.key, &a.value))","        }","    }","","    let entries = vec![","        Entry { key: 1, value: \"one\" },","        Entry { key: 2, value: \"two\" },","        Entry { key: 3, value: \"three\" },","    ];","    let map = SortedMap::new(entries);","","    let result = map.binary_search_by(|&key, _| key.cmp(&2));","    assert_eq!(result, Ok(1));","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap {","        entries: Vec<Entry<i32, &'static str>>,","    }","","    impl SortedMap {","        fn new(entries: Vec<Entry<i32, &'static str>>) -> Self {","            SortedMap { entries }","        }","","        pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>","        where","            F: FnMut(&'a i32, &'a &'static str) -> std::cmp::Ordering,","        {","            self.entries.binary_search_by(move |a| f(&a.key, &a.value))","        }","    }","","    let entries = vec![","        Entry { key: 1, value: \"one\" },","        Entry { key: 2, value: \"two\" },","        Entry { key: 3, value: \"three\" },","    ];","    let map = SortedMap::new(entries);","","    let result = map.binary_search_by(|&key, _| key.cmp(&4));","    assert_eq!(result, Err(3));","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap {","        entries: Vec<Entry<i32, &'static str>>,","    }","","    impl SortedMap {","        fn new(entries: Vec<Entry<i32, &'static str>>) -> Self {","            SortedMap { entries }","        }","","        pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>","        where","            F: FnMut(&'a i32, &'a &'static str) -> std::cmp::Ordering,","        {","            self.entries.binary_search_by(move |a| f(&a.key, &a.value))","        }","    }","","    let map = SortedMap::new(vec![]);","","    let result = map.binary_search_by(|&key, _| key.cmp(&1));","    assert_eq!(result, Err(0));","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap {","        entries: Vec<Entry<i32, &'static str>>,","    }","","    impl SortedMap {","        fn new(entries: Vec<Entry<i32, &'static str>>) -> Self {","            SortedMap { entries }","        }","","        pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>","        where","            F: FnMut(&'a i32, &'a &'static str) -> std::cmp::Ordering,","        {","            self.entries.binary_search_by(move |a| f(&a.key, &a.value))","        }","    }","","    let entries = vec![","        Entry { key: 1, value: \"one\" },","        Entry { key: 2, value: \"two\" },","        Entry { key: 3, value: \"three\" },","    ];","    let map = SortedMap::new(entries);","","    let result = map.binary_search_by(|&key, _| key.cmp(&2));","    assert_eq!(result, Ok(1));","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap {","        entries: Vec<Entry<i32, &'static str>>,","    }","","    impl SortedMap {","        fn new(entries: Vec<Entry<i32, &'static str>>) -> Self {","            SortedMap { entries }","        }","","        pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>","        where","            F: FnMut(&'a i32, &'a &'static str) -> std::cmp::Ordering,","        {","            self.entries.binary_search_by(move |a| f(&a.key, &a.value))","        }","    }","","    let entries = vec![","        Entry { key: 1, value: \"one\" },","        Entry { key: 2, value: \"two\" },","        Entry { key: 3, value: \"three\" },","    ];","    let map = SortedMap::new(entries);","","    let result = map.binary_search_by(|&key, _| key.cmp(&4));","    assert_eq!(result, Err(3));","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct SortedMap {","        entries: Vec<Entry<i32, &'static str>>,","    }","","    impl SortedMap {","        fn new(entries: Vec<Entry<i32, &'static str>>) -> Self {","            SortedMap { entries }","        }","","        pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>","        where","            F: FnMut(&'a i32, &'a &'static str) -> std::cmp::Ordering,","        {","            self.entries.binary_search_by(move |a| f(&a.key, &a.value))","        }","    }","","    let map = SortedMap::new(vec![]);","","    let result = map.binary_search_by(|&key, _| key.cmp(&1));","    assert_eq!(result, Err(0));","}"],[]]]}