{"function_name":"indexmap::map::core::map::core::RefMut<'a, K, V>::shift_remove_index","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":2,"tests_lines":[44,34],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[590,591,592,593,594,596,598],"codes_lines_covered":[[["{","    struct TestMap {","        entries: Vec<(i32, i32)>,","        indices: Vec<usize>,","    }","","    impl TestMap {","        fn new() -> Self {","            TestMap {","                entries: vec![(1, 10), (2, 20), (3, 30)],","                indices: vec![0, 1, 2],","            }","        }","","        fn entries(&self) -> &Vec<(i32, i32)> {","            &self.entries","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (i32, i32) {","            self.entries.remove(index)","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(entry) => {","                    let hash = 0; // Assume there's a hash function returning 0 for simplicity","                    erase_index(&mut self.indices, hash, index);","                    Some(self.shift_remove_finish(index))","                }","                None => None,","            }","        }","    }","","    fn erase_index(indices: &mut Vec<usize>, hash: usize, index: usize) {","        indices.remove(index);","    }","","    let mut map = TestMap::new();","    let removed = map.shift_remove_index(1);","    assert_eq!(removed, Some((2, 20)));","    assert_eq!(map.entries.len(), 2);","    assert!(map.entries.iter().all(|&(k, _)| k != 2));","}"],[]],[["{","    struct TestMap {","        entries: Vec<(i32, i32)>,","        indices: Vec<usize>,","    }","","    impl TestMap {","        fn new() -> Self {","            TestMap {","                entries: vec![(1, 10), (2, 20)],","                indices: vec![0, 1],","            }","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(entry) => {","                    let hash = 0; // Assume there’s a hash function returning 0 for simplicity","                    erase_index(&mut self.indices, hash, index);","                    Some(self.entries.remove(index))","                }","                None => None,","            }","        }","    }","","    fn erase_index(indices: &mut Vec<usize>, hash: usize, index: usize) {","        indices.remove(index);","    }","","    let mut map = TestMap::new();","    let removed = map.shift_remove_index(5);","    assert_eq!(removed, None);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestMap {","        entries: Vec<(i32, i32)>,","        indices: Vec<usize>,","    }","","    impl TestMap {","        fn new() -> Self {","            TestMap {","                entries: vec![(1, 10), (2, 20), (3, 30)],","                indices: vec![0, 1, 2],","            }","        }","","        fn entries(&self) -> &Vec<(i32, i32)> {","            &self.entries","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (i32, i32) {","            self.entries.remove(index)","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(entry) => {","                    let hash = 0; // Assume there's a hash function returning 0 for simplicity","                    erase_index(&mut self.indices, hash, index);","                    Some(self.shift_remove_finish(index))","                }","                None => None,","            }","        }","    }","","    fn erase_index(indices: &mut Vec<usize>, hash: usize, index: usize) {","        indices.remove(index);","    }","","    let mut map = TestMap::new();","    let removed = map.shift_remove_index(1);","    assert_eq!(removed, Some((2, 20)));","    assert_eq!(map.entries.len(), 2);","    assert!(map.entries.iter().all(|&(k, _)| k != 2));","}"],[]],[["{","    struct TestMap {","        entries: Vec<(i32, i32)>,","        indices: Vec<usize>,","    }","","    impl TestMap {","        fn new() -> Self {","            TestMap {","                entries: vec![(1, 10), (2, 20)],","                indices: vec![0, 1],","            }","        }","","        fn shift_remove_index(&mut self, index: usize) -> Option<(i32, i32)> {","            match self.entries.get(index) {","                Some(entry) => {","                    let hash = 0; // Assume there’s a hash function returning 0 for simplicity","                    erase_index(&mut self.indices, hash, index);","                    Some(self.entries.remove(index))","                }","                None => None,","            }","        }","    }","","    fn erase_index(indices: &mut Vec<usize>, hash: usize, index: usize) {","        indices.remove(index);","    }","","    let mut map = TestMap::new();","    let removed = map.shift_remove_index(5);","    assert_eq!(removed, None);","}"],[]]]}