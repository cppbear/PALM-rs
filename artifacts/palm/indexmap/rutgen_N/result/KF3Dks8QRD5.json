{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::drain","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":4,"tests_lines":[53,43,50,50],"oracles":4,"oracles_compiled":3,"oracles_compiled_rate":75.0,"tests_compiled":3,"tests_compiled_rate":75.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[187,188,189,190,191,192,193,194],"codes_lines_covered":[[["{","    use std::ops::{Range, RangeBounds};","    use std::vec;","","    struct Bucket<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Bucket<K, V>>,","    }","","    impl<K, V> TestMap<K, V> {","        fn new() -> Self {","            Self {","                entries: Vec::new(),","            }","        }","","        fn insert(&mut self, key: K, value: V) {","            self.entries.push(Bucket { key, value });","        }","","        pub(crate) fn drain<R>(&mut self, range: R) -> vec::Drain<'_, Bucket<K, V>>","        where","            R: RangeBounds<usize>,","        {","            let start = match range.start_bound() {","                std::ops::Bound::Included(&idx) => idx,","                std::ops::Bound::Excluded(&idx) => idx + 1,","                std::ops::Bound::Unbounded => 0,","            };","            let end = match range.end_bound() {","                std::ops::Bound::Included(&idx) => idx + 1,","                std::ops::Bound::Excluded(&idx) => idx,","                std::ops::Bound::Unbounded => self.entries.len(),","            };","            self.entries.drain(start..end)","        }","    }","","    let mut map = TestMap::new();","    map.insert(1, 'a');","    map.insert(2, 'b');","    map.insert(3, 'c');","","    let drained: Vec<_> = map.drain(1..3).collect();","    assert_eq!(drained.len(), 2);","    assert_eq!(drained[0].key, 2);","    assert_eq!(drained[1].key, 3);","    assert_eq!(map.entries.len(), 1); // Should be left with one entry","}"],[]],[["{","    use std::ops::{RangeBounds};","    use std::vec;","","    struct Bucket<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Bucket<K, V>>,","    }","","    impl<K, V> TestMap<K, V> {","        fn new() -> Self {","            Self {","                entries: Vec::new(),","            }","        }","","        fn insert(&mut self, key: K, value: V) {","            self.entries.push(Bucket { key, value });","        }","","        pub(crate) fn drain<R>(&mut self, range: R) -> vec::Drain<'_, Bucket<K, V>>","        where","            R: RangeBounds<usize>,","        {","            let start = match range.start_bound() {","                std::ops::Bound::Included(&idx) => idx,","                std::ops::Bound::Excluded(&idx) => idx + 1,","                std::ops::Bound::Unbounded => 0,","            };","            let end = match range.end_bound() {","                std::ops::Bound::Included(&idx) => idx + 1,","                std::ops::Bound::Excluded(&idx) => idx,","                std::ops::Bound::Unbounded => self.entries.len(),","            };","            self.entries.drain(start..end)","        }","    }","","    let mut map = TestMap::new();","    map.insert(1, 'a');","    map.insert(2, 'b');","","    let drained: Vec<_> = map.drain(0..5).collect(); // Drain out of bounds","    assert_eq!(drained.len(), 2); // Should drain all entries","    assert_eq!(map.entries.len(), 0); // Should be empty after draining","}"],[]],[["{","    use std::ops::{RangeBounds};","    use std::vec;","","    struct Bucket<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Bucket<K, V>>,","    }","","    impl<K, V> TestMap<K, V> {","        fn new() -> Self {","            Self {","                entries: Vec::new(),","            }","        }","","        fn insert(&mut self, key: K, value: V) {","            self.entries.push(Bucket { key, value });","        }","","        pub(crate) fn drain<R>(&mut self, range: R) -> vec::Drain<'_, Bucket<K, V>>","        where","            R: RangeBounds<usize>,","        {","            let start = match range.start_bound() {","                std::ops::Bound::Included(&idx) => idx,","                std::ops::Bound::Excluded(&idx) => idx + 1,","                std::ops::Bound::Unbounded => 0,","            };","            let end = match range.end_bound() {","                std::ops::Bound::Included(&idx) => idx + 1,","                std::ops::Bound::Excluded(&idx) => idx,","                std::ops::Bound::Unbounded => self.entries.len(),","            };","            self.entries.drain(start..end)","        }","    }","","    let mut map = TestMap::new();","    map.insert(1, 'a');","","    let drained: Vec<_> = map.drain(0..1).collect(); // Drain single element","    assert_eq!(drained.len(), 1); ","    assert_eq!(drained[0].key, 1);","    assert_eq!(map.entries.len(), 0); // Should be empty after draining","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::ops::{Range, RangeBounds};","    use std::vec;","","    struct Bucket<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Bucket<K, V>>,","    }","","    impl<K, V> TestMap<K, V> {","        fn new() -> Self {","            Self {","                entries: Vec::new(),","            }","        }","","        fn insert(&mut self, key: K, value: V) {","            self.entries.push(Bucket { key, value });","        }","","        pub(crate) fn drain<R>(&mut self, range: R) -> vec::Drain<'_, Bucket<K, V>>","        where","            R: RangeBounds<usize>,","        {","            let start = match range.start_bound() {","                std::ops::Bound::Included(&idx) => idx,","                std::ops::Bound::Excluded(&idx) => idx + 1,","                std::ops::Bound::Unbounded => 0,","            };","            let end = match range.end_bound() {","                std::ops::Bound::Included(&idx) => idx + 1,","                std::ops::Bound::Excluded(&idx) => idx,","                std::ops::Bound::Unbounded => self.entries.len(),","            };","            self.entries.drain(start..end)","        }","    }","","    let mut map = TestMap::new();","    map.insert(1, 'a');","    map.insert(2, 'b');","    map.insert(3, 'c');","","    let drained: Vec<_> = map.drain(1..3).collect();","    assert_eq!(drained.len(), 2);","    assert_eq!(drained[0].key, 2);","    assert_eq!(drained[1].key, 3);","    assert_eq!(map.entries.len(), 1); // Should be left with one entry","}"],[]],[["{","    use std::ops::{RangeBounds};","    use std::vec;","","    struct Bucket<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Bucket<K, V>>,","    }","","    impl<K, V> TestMap<K, V> {","        fn new() -> Self {","            Self {","                entries: Vec::new(),","            }","        }","","        fn insert(&mut self, key: K, value: V) {","            self.entries.push(Bucket { key, value });","        }","","        pub(crate) fn drain<R>(&mut self, range: R) -> vec::Drain<'_, Bucket<K, V>>","        where","            R: RangeBounds<usize>,","        {","            let start = match range.start_bound() {","                std::ops::Bound::Included(&idx) => idx,","                std::ops::Bound::Excluded(&idx) => idx + 1,","                std::ops::Bound::Unbounded => 0,","            };","            let end = match range.end_bound() {","                std::ops::Bound::Included(&idx) => idx + 1,","                std::ops::Bound::Excluded(&idx) => idx,","                std::ops::Bound::Unbounded => self.entries.len(),","            };","            self.entries.drain(start..end)","        }","    }","","    let mut map = TestMap::new();","    map.insert(1, 'a');","    map.insert(2, 'b');","","    let drained: Vec<_> = map.drain(0..5).collect(); // Drain out of bounds","    assert_eq!(drained.len(), 2); // Should drain all entries","    assert_eq!(map.entries.len(), 0); // Should be empty after draining","}"],[]],[["{","    use std::ops::{RangeBounds};","    use std::vec;","","    struct Bucket<K, V> {","        key: K,","        value: V,","    }","","    struct TestMap<K, V> {","        entries: Vec<Bucket<K, V>>,","    }","","    impl<K, V> TestMap<K, V> {","        fn new() -> Self {","            Self {","                entries: Vec::new(),","            }","        }","","        fn insert(&mut self, key: K, value: V) {","            self.entries.push(Bucket { key, value });","        }","","        pub(crate) fn drain<R>(&mut self, range: R) -> vec::Drain<'_, Bucket<K, V>>","        where","            R: RangeBounds<usize>,","        {","            let start = match range.start_bound() {","                std::ops::Bound::Included(&idx) => idx,","                std::ops::Bound::Excluded(&idx) => idx + 1,","                std::ops::Bound::Unbounded => 0,","            };","            let end = match range.end_bound() {","                std::ops::Bound::Included(&idx) => idx + 1,","                std::ops::Bound::Excluded(&idx) => idx,","                std::ops::Bound::Unbounded => self.entries.len(),","            };","            self.entries.drain(start..end)","        }","    }","","    let mut map = TestMap::new();","    map.insert(1, 'a');","","    let drained: Vec<_> = map.drain(0..1).collect(); // Drain single element","    assert_eq!(drained.len(), 1); ","    assert_eq!(drained[0].key, 1);","    assert_eq!(map.entries.len(), 0); // Should be empty after draining","}"],[]]]}