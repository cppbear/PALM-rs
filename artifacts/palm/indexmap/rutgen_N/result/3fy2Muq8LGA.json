{"function_name":"indexmap::map::core::entry::map::core::entry::OccupiedEntry<'a, K, V>::into_mut","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core/entry.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":2,"tests_lines":[29,29],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[200,201,202,203],"codes_lines_covered":[[["{","    struct Entry<'a, V> {","        index: usize,","        entries: &'a mut Vec<EntryValue<V>>,","    }","    ","    struct EntryValue<V> {","        value: V,","    }","","    impl<'a, V> Entry<'a, V> {","        pub fn index(&self) -> usize {","            self.index","        }","","        pub fn into_mut(self) -> &'a mut V {","            let index = self.index();","            &mut self.entries[index].value","        }","    }","","    let mut values = vec![EntryValue { value: 1 }, EntryValue { value: 2 }];","    let entry = Entry { index: 0, entries: &mut values };","","    let value_mut: &mut i32 = entry.into_mut();","    *value_mut += 10;","","    assert_eq!(values[0].value, 11);","}"],[]],[["{","    struct Entry<'a, V> {","        index: usize,","        entries: &'a mut Vec<EntryValue<V>>,","    }","    ","    struct EntryValue<V> {","        value: V,","    }","","    impl<'a, V> Entry<'a, V> {","        pub fn index(&self) -> usize {","            self.index","        }","","        pub fn into_mut(self) -> &'a mut V {","            let index = self.index();","            &mut self.entries[index].value","        }","    }","","    let mut values = vec![EntryValue { value: 0 }];","    let entry = Entry { index: 0, entries: &mut values };","","    let value_mut: &mut i32 = entry.into_mut();","    *value_mut = -5;","","    assert_eq!(values[0].value, -5);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Entry<'a, V> {","        index: usize,","        entries: &'a mut Vec<EntryValue<V>>,","    }","    ","    struct EntryValue<V> {","        value: V,","    }","","    impl<'a, V> Entry<'a, V> {","        pub fn index(&self) -> usize {","            self.index","        }","","        pub fn into_mut(self) -> &'a mut V {","            let index = self.index();","            &mut self.entries[index].value","        }","    }","","    let mut values = vec![EntryValue { value: 1 }, EntryValue { value: 2 }];","    let entry = Entry { index: 0, entries: &mut values };","","    let value_mut: &mut i32 = entry.into_mut();","    *value_mut += 10;","","    assert_eq!(values[0].value, 11);","}"],[]],[["{","    struct Entry<'a, V> {","        index: usize,","        entries: &'a mut Vec<EntryValue<V>>,","    }","    ","    struct EntryValue<V> {","        value: V,","    }","","    impl<'a, V> Entry<'a, V> {","        pub fn index(&self) -> usize {","            self.index","        }","","        pub fn into_mut(self) -> &'a mut V {","            let index = self.index();","            &mut self.entries[index].value","        }","    }","","    let mut values = vec![EntryValue { value: 0 }];","    let entry = Entry { index: 0, entries: &mut values };","","    let value_mut: &mut i32 = entry.into_mut();","    *value_mut = -5;","","    assert_eq!(values[0].value, -5);","}"],[]]]}