{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::truncate","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":3,"tests_lines":[30,30,30],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[179,180,181,182,183,184],"codes_lines_covered":[[["{","    struct TestMap {","        entries: Vec<i32>,","    }","","    impl TestMap {","        fn new() -> Self {","            Self { entries: vec![1, 2, 3, 4, 5] }","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn erase_indices(&mut self, start: usize, end: usize) {","            self.entries.splice(start..end, std::iter::empty());","        }","","        fn truncate(&mut self, len: usize) {","            if len < self.len() {","                self.erase_indices(len, self.entries.len());","                self.entries.truncate(len);","            }","        }","    }","","    let mut map = TestMap::new();","    map.truncate(3);","    assert_eq!(map.len(), 3);","}"],[]],[["{","    struct TestMap {","        entries: Vec<i32>,","    }","","    impl TestMap {","        fn new() -> Self {","            Self { entries: vec![1, 2, 3, 4, 5] }","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn erase_indices(&mut self, start: usize, end: usize) {","            self.entries.splice(start..end, std::iter::empty());","        }","","        fn truncate(&mut self, len: usize) {","            if len < self.len() {","                self.erase_indices(len, self.entries.len());","                self.entries.truncate(len);","            }","        }","    }","","    let mut map = TestMap::new();","    map.truncate(5);","    assert_eq!(map.len(), 5);","}"],[]],[["{","    struct TestMap {","        entries: Vec<i32>,","    }","","    impl TestMap {","        fn new() -> Self {","            Self { entries: vec![1, 2, 3, 4, 5] }","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn erase_indices(&mut self, start: usize, end: usize) {","            self.entries.splice(start..end, std::iter::empty());","        }","","        fn truncate(&mut self, len: usize) {","            if len < self.len() {","                self.erase_indices(len, self.entries.len());","                self.entries.truncate(len);","            }","        }","    }","","    let mut map = TestMap::new();","    map.truncate(6);","    assert_eq!(map.len(), 5);","}"],[]]],"codes_branches":[{"start_line":180,"start_column":12,"end_line":180,"end_column":28,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestMap {","        entries: Vec<i32>,","    }","","    impl TestMap {","        fn new() -> Self {","            Self { entries: vec![1, 2, 3, 4, 5] }","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn erase_indices(&mut self, start: usize, end: usize) {","            self.entries.splice(start..end, std::iter::empty());","        }","","        fn truncate(&mut self, len: usize) {","            if len < self.len() {","                self.erase_indices(len, self.entries.len());","                self.entries.truncate(len);","            }","        }","    }","","    let mut map = TestMap::new();","    map.truncate(3);","    assert_eq!(map.len(), 3);","}"],[{"start_line":180,"start_column":12,"end_line":180,"end_column":28,"positive":false,"negative":false}]],[["{","    struct TestMap {","        entries: Vec<i32>,","    }","","    impl TestMap {","        fn new() -> Self {","            Self { entries: vec![1, 2, 3, 4, 5] }","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn erase_indices(&mut self, start: usize, end: usize) {","            self.entries.splice(start..end, std::iter::empty());","        }","","        fn truncate(&mut self, len: usize) {","            if len < self.len() {","                self.erase_indices(len, self.entries.len());","                self.entries.truncate(len);","            }","        }","    }","","    let mut map = TestMap::new();","    map.truncate(5);","    assert_eq!(map.len(), 5);","}"],[{"start_line":180,"start_column":12,"end_line":180,"end_column":28,"positive":false,"negative":false}]],[["{","    struct TestMap {","        entries: Vec<i32>,","    }","","    impl TestMap {","        fn new() -> Self {","            Self { entries: vec![1, 2, 3, 4, 5] }","        }","","        fn len(&self) -> usize {","            self.entries.len()","        }","","        fn erase_indices(&mut self, start: usize, end: usize) {","            self.entries.splice(start..end, std::iter::empty());","        }","","        fn truncate(&mut self, len: usize) {","            if len < self.len() {","                self.erase_indices(len, self.entries.len());","                self.entries.truncate(len);","            }","        }","    }","","    let mut map = TestMap::new();","    map.truncate(6);","    assert_eq!(map.len(), 5);","}"],[{"start_line":180,"start_column":12,"end_line":180,"end_column":28,"positive":false,"negative":false}]]]}