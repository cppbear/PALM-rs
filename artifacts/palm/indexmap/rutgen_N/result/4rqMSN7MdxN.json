{"function_name":"indexmap::map::map::IndexMap<K, V, S>::sort_unstable_by","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":4,"tests_lines":[17,17,16,7],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1069,1070,1071,1072,1073,1074,1075,1076],"codes_lines_covered":[[["{","    let mut map = Map {","        entries: vec![","            Entry { key: 3, value: \"three\" },","            Entry { key: 1, value: \"one\" },","            Entry { key: 2, value: \"two\" },","        ],","    };","","    map.sort_unstable_by(|k1, v1, k2, v2| k1.cmp(k2));","    ","    assert_eq!(map.entries, vec![","        Entry { key: 1, value: \"one\" },","        Entry { key: 2, value: \"two\" },","        Entry { key: 3, value: \"three\" },","    ]);","}"],[]],[["{","    let mut map = Map {","        entries: vec![","            Entry { key: 1, value: \"banana\" },","            Entry { key: 2, value: \"apple\" },","            Entry { key: 3, value: \"cherry\" },","        ],","    };","","    map.sort_unstable_by(|k1, v1, k2, v2| v1.cmp(v2));","    ","    assert_eq!(map.entries, vec![","        Entry { key: 2, value: \"apple\" },","        Entry { key: 1, value: \"banana\" },","        Entry { key: 3, value: \"cherry\" },","    ]);","}"],[]],[["{","    let mut map = Map {","        entries: vec![","            Entry { key: 1, value: \"a\" },","            Entry { key: 1, value: \"b\" },","            Entry { key: 2, value: \"c\" },","        ],","    };","","    map.sort_unstable_by(|k1, v1, k2, v2| k1.cmp(k2));","    ","    // Check that the order of equal keys is not preserved","    assert_eq!(map.entries.len(), 3);","    assert!(map.entries[0].key <= map.entries[1].key);","    assert!(map.entries[1].key <= map.entries[2].key);","}"],[]],[["{","    let mut map: Map<i32, &str> = Map { entries: vec![] };","","    map.sort_unstable_by(|_, _, _, _| std::cmp::Ordering::Equal);","    ","    assert!(map.entries.is_empty());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut map = Map {","        entries: vec![","            Entry { key: 3, value: \"three\" },","            Entry { key: 1, value: \"one\" },","            Entry { key: 2, value: \"two\" },","        ],","    };","","    map.sort_unstable_by(|k1, v1, k2, v2| k1.cmp(k2));","    ","    assert_eq!(map.entries, vec![","        Entry { key: 1, value: \"one\" },","        Entry { key: 2, value: \"two\" },","        Entry { key: 3, value: \"three\" },","    ]);","}"],[]],[["{","    let mut map = Map {","        entries: vec![","            Entry { key: 1, value: \"banana\" },","            Entry { key: 2, value: \"apple\" },","            Entry { key: 3, value: \"cherry\" },","        ],","    };","","    map.sort_unstable_by(|k1, v1, k2, v2| v1.cmp(v2));","    ","    assert_eq!(map.entries, vec![","        Entry { key: 2, value: \"apple\" },","        Entry { key: 1, value: \"banana\" },","        Entry { key: 3, value: \"cherry\" },","    ]);","}"],[]],[["{","    let mut map = Map {","        entries: vec![","            Entry { key: 1, value: \"a\" },","            Entry { key: 1, value: \"b\" },","            Entry { key: 2, value: \"c\" },","        ],","    };","","    map.sort_unstable_by(|k1, v1, k2, v2| k1.cmp(k2));","    ","    // Check that the order of equal keys is not preserved","    assert_eq!(map.entries.len(), 3);","    assert!(map.entries[0].key <= map.entries[1].key);","    assert!(map.entries[1].key <= map.entries[2].key);","}"],[]],[["{","    let mut map: Map<i32, &str> = Map { entries: vec![] };","","    map.sort_unstable_by(|_, _, _, _| std::cmp::Ordering::Equal);","    ","    assert!(map.entries.is_empty());","}"],[]]]}