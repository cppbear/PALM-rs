{"function_name":"indexmap::map::core::map::core::IndexMapCore<K, V>::shrink_to","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":3,"tests_lines":[31,31,31],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[301,302,303,304,305],"codes_lines_covered":[[["{","    struct Map {","        indices: Vec<usize>,","        entries: Vec<Option<usize>>,","    }","","    impl Map {","        fn new() -> Self {","            Map {","                indices: vec![],","                entries: vec![],","            }","        }","        ","        fn shrink_to(&mut self, min_capacity: usize) {","            self.indices = self.indices.iter().cloned().take(min_capacity).collect();","            self.entries = self.entries.iter().cloned().take(min_capacity).collect();","        }","    }","","    let mut map = Map::new();","    map.indices.extend(vec![0, 1, 2, 3, 4]);","    map.entries.extend(vec![Some(10), Some(20), Some(30), Some(40), Some(50)]);","","    map.shrink_to(3);","","    assert_eq!(map.indices.len(), 3);","    assert_eq!(map.entries.len(), 3);","    assert_eq!(map.indices, vec![0, 1, 2]);","    assert_eq!(map.entries, vec![Some(10), Some(20), Some(30)]);","}"],[]],[["{","    struct Map {","        indices: Vec<usize>,","        entries: Vec<Option<usize>>,","    }","","    impl Map {","        fn new() -> Self {","            Map {","                indices: vec![],","                entries: vec![],","            }","        }","        ","        fn shrink_to(&mut self, min_capacity: usize) {","            self.indices = self.indices.iter().cloned().take(min_capacity).collect();","            self.entries = self.entries.iter().cloned().take(min_capacity).collect();","        }","    }","","    let mut map = Map::new();","    map.indices.extend(vec![0, 1, 2]);","    map.entries.extend(vec![Some(10), Some(20), Some(30)]);","","    map.shrink_to(5);","","    assert_eq!(map.indices.len(), 3);","    assert_eq!(map.entries.len(), 3);","    assert_eq!(map.indices, vec![0, 1, 2]);","    assert_eq!(map.entries, vec![Some(10), Some(20), Some(30)]);","}"],[]],[["{","    struct Map {","        indices: Vec<usize>,","        entries: Vec<Option<usize>>,","    }","","    impl Map {","        fn new() -> Self {","            Map {","                indices: vec![],","                entries: vec![],","            }","        }","        ","        fn shrink_to(&mut self, min_capacity: usize) {","            self.indices = self.indices.iter().cloned().take(min_capacity).collect();","            self.entries = self.entries.iter().cloned().take(min_capacity).collect();","        }","    }","","    let mut map = Map::new();","    map.indices.extend(vec![0, 1, 2]);","    map.entries.extend(vec![Some(10), Some(20), Some(30)]);","","    map.shrink_to(0);","","    assert_eq!(map.indices.len(), 0);","    assert_eq!(map.entries.len(), 0);","    assert_eq!(map.indices, vec![]);","    assert_eq!(map.entries, vec![]);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Map {","        indices: Vec<usize>,","        entries: Vec<Option<usize>>,","    }","","    impl Map {","        fn new() -> Self {","            Map {","                indices: vec![],","                entries: vec![],","            }","        }","        ","        fn shrink_to(&mut self, min_capacity: usize) {","            self.indices = self.indices.iter().cloned().take(min_capacity).collect();","            self.entries = self.entries.iter().cloned().take(min_capacity).collect();","        }","    }","","    let mut map = Map::new();","    map.indices.extend(vec![0, 1, 2, 3, 4]);","    map.entries.extend(vec![Some(10), Some(20), Some(30), Some(40), Some(50)]);","","    map.shrink_to(3);","","    assert_eq!(map.indices.len(), 3);","    assert_eq!(map.entries.len(), 3);","    assert_eq!(map.indices, vec![0, 1, 2]);","    assert_eq!(map.entries, vec![Some(10), Some(20), Some(30)]);","}"],[]],[["{","    struct Map {","        indices: Vec<usize>,","        entries: Vec<Option<usize>>,","    }","","    impl Map {","        fn new() -> Self {","            Map {","                indices: vec![],","                entries: vec![],","            }","        }","        ","        fn shrink_to(&mut self, min_capacity: usize) {","            self.indices = self.indices.iter().cloned().take(min_capacity).collect();","            self.entries = self.entries.iter().cloned().take(min_capacity).collect();","        }","    }","","    let mut map = Map::new();","    map.indices.extend(vec![0, 1, 2]);","    map.entries.extend(vec![Some(10), Some(20), Some(30)]);","","    map.shrink_to(5);","","    assert_eq!(map.indices.len(), 3);","    assert_eq!(map.entries.len(), 3);","    assert_eq!(map.indices, vec![0, 1, 2]);","    assert_eq!(map.entries, vec![Some(10), Some(20), Some(30)]);","}"],[]],[["{","    struct Map {","        indices: Vec<usize>,","        entries: Vec<Option<usize>>,","    }","","    impl Map {","        fn new() -> Self {","            Map {","                indices: vec![],","                entries: vec![],","            }","        }","        ","        fn shrink_to(&mut self, min_capacity: usize) {","            self.indices = self.indices.iter().cloned().take(min_capacity).collect();","            self.entries = self.entries.iter().cloned().take(min_capacity).collect();","        }","    }","","    let mut map = Map::new();","    map.indices.extend(vec![0, 1, 2]);","    map.entries.extend(vec![Some(10), Some(20), Some(30)]);","","    map.shrink_to(0);","","    assert_eq!(map.indices.len(), 0);","    assert_eq!(map.entries.len(), 0);","    assert_eq!(map.indices, vec![]);","    assert_eq!(map.entries, vec![]);","}"],[]]]}