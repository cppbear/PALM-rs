{"function_name":"indexmap::map::map::IndexMap<K, V, S>::move_index","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":3,"tests_lines":[37,29,29],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1344,1345,1346],"codes_lines_covered":[[["{","    struct IndexMap {","        core: Vec<(usize, usize)>,","    }","","    impl IndexMap {","        fn new() -> Self {","            Self { core: Vec::new() }","        }","","        fn insert(&mut self, key: usize, value: usize) {","            self.core.push((key, value));","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            if from >= self.core.len() || to >= self.core.len() {","                panic!(\"index out of bounds\");","            }","            let item = self.core.remove(from);","            self.core.insert(to, item);","        }","","        fn get(&self) -> &Vec<(usize, usize)> {","            &self.core","        }","    }","","    let mut map = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    map.insert(3, 30);","    ","    map.move_index(0, 2);","    ","    let result = map.get();","    assert_eq!(result, &[(2, 20), (3, 30), (1, 10)]);","}"],[]],[["{","    struct IndexMap {","        core: Vec<(usize, usize)>,","    }","","    impl IndexMap {","        fn new() -> Self {","            Self { core: Vec::new() }","        }","","        fn insert(&mut self, key: usize, value: usize) {","            self.core.push((key, value));","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            if from >= self.core.len() || to >= self.core.len() {","                panic!(\"index out of bounds\");","            }","            let item = self.core.remove(from);","            self.core.insert(to, item);","        }","    }","","    let mut map = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    ","    map.move_index(2, 1); // from index 2 (out of bounds)","}"],[]],[["{","    struct IndexMap {","        core: Vec<(usize, usize)>,","    }","","    impl IndexMap {","        fn new() -> Self {","            Self { core: Vec::new() }","        }","","        fn insert(&mut self, key: usize, value: usize) {","            self.core.push((key, value));","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            if from >= self.core.len() || to >= self.core.len() {","                panic!(\"index out of bounds\");","            }","            let item = self.core.remove(from);","            self.core.insert(to, item);","        }","    }","","    let mut map = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    ","    map.move_index(0, 2); // to index 2 (out of bounds)","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct IndexMap {","        core: Vec<(usize, usize)>,","    }","","    impl IndexMap {","        fn new() -> Self {","            Self { core: Vec::new() }","        }","","        fn insert(&mut self, key: usize, value: usize) {","            self.core.push((key, value));","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            if from >= self.core.len() || to >= self.core.len() {","                panic!(\"index out of bounds\");","            }","            let item = self.core.remove(from);","            self.core.insert(to, item);","        }","","        fn get(&self) -> &Vec<(usize, usize)> {","            &self.core","        }","    }","","    let mut map = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    map.insert(3, 30);","    ","    map.move_index(0, 2);","    ","    let result = map.get();","    assert_eq!(result, &[(2, 20), (3, 30), (1, 10)]);","}"],[]],[["{","    struct IndexMap {","        core: Vec<(usize, usize)>,","    }","","    impl IndexMap {","        fn new() -> Self {","            Self { core: Vec::new() }","        }","","        fn insert(&mut self, key: usize, value: usize) {","            self.core.push((key, value));","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            if from >= self.core.len() || to >= self.core.len() {","                panic!(\"index out of bounds\");","            }","            let item = self.core.remove(from);","            self.core.insert(to, item);","        }","    }","","    let mut map = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    ","    map.move_index(2, 1); // from index 2 (out of bounds)","}"],[]],[["{","    struct IndexMap {","        core: Vec<(usize, usize)>,","    }","","    impl IndexMap {","        fn new() -> Self {","            Self { core: Vec::new() }","        }","","        fn insert(&mut self, key: usize, value: usize) {","            self.core.push((key, value));","        }","","        fn move_index(&mut self, from: usize, to: usize) {","            if from >= self.core.len() || to >= self.core.len() {","                panic!(\"index out of bounds\");","            }","            let item = self.core.remove(from);","            self.core.insert(to, item);","        }","    }","","    let mut map = IndexMap::new();","    map.insert(1, 10);","    map.insert(2, 20);","    ","    map.move_index(0, 2); // to index 2 (out of bounds)","}"],[]]]}