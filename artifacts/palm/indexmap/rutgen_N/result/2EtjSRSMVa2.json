{"function_name":"indexmap::map::core::map::core::RefMut<'a, K, V>::shift_remove_finish","file_path":"/home/abezbm/rust-utgen-test-crates-new/indexmap/src/map/core.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/indexmap","tests":2,"tests_lines":[51,45],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[603,604,605,606,607,608,609,610],"codes_lines_covered":[[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct MyMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> MyMap<K, V> {","        fn new() -> Self {","            MyMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        fn decrement_indices(&mut self, start: usize, end: usize) {","            for i in start..end {","                if let Some(index) = self.indices.get_mut(i) {","                    *index -= 1;","                }","            }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (K, V) {","            self.decrement_indices(index + 1, self.entries.len());","            let entry = self.entries.remove(index);","            (entry.key, entry.value)","        }","","        fn insert(&mut self, key: K, value: V) {","            self.entries.push(Entry { key, value });","            self.indices.push(self.entries.len() - 1);","        }","    }","","    let mut my_map = MyMap::new();","    my_map.insert(1, \"one\");","    my_map.insert(2, \"two\");","    my_map.insert(3, \"three\");","","    let (key, value) = my_map.shift_remove_finish(1);","    assert_eq!(key, 2);","    assert_eq!(value, \"two\");","    assert_eq!(my_map.entries.len(), 2);","    assert_eq!(my_map.entries[0].key, 1);","    assert_eq!(my_map.entries[1].key, 3);","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct MyMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> MyMap<K, V> {","        fn new() -> Self {","            MyMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        fn decrement_indices(&mut self, start: usize, end: usize) {","            for i in start..end {","                if let Some(index) = self.indices.get_mut(i) {","                    *index -= 1;","                }","            }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (K, V) {","            self.decrement_indices(index + 1, self.entries.len());","            let entry = self.entries.remove(index);","            (entry.key, entry.value)","        }","","        fn insert(&mut self, key: K, value: V) {","            self.entries.push(Entry { key, value });","            self.indices.push(self.entries.len() - 1);","        }","    }","","    let mut my_map = MyMap::new();","    my_map.insert(1, \"one\");","    my_map.insert(2, \"two\");","","    my_map.shift_remove_finish(2); // This index is out of bounds and should panic.","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct MyMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> MyMap<K, V> {","        fn new() -> Self {","            MyMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        fn decrement_indices(&mut self, start: usize, end: usize) {","            for i in start..end {","                if let Some(index) = self.indices.get_mut(i) {","                    *index -= 1;","                }","            }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (K, V) {","            self.decrement_indices(index + 1, self.entries.len());","            let entry = self.entries.remove(index);","            (entry.key, entry.value)","        }","","        fn insert(&mut self, key: K, value: V) {","            self.entries.push(Entry { key, value });","            self.indices.push(self.entries.len() - 1);","        }","    }","","    let mut my_map = MyMap::new();","    my_map.insert(1, \"one\");","    my_map.insert(2, \"two\");","    my_map.insert(3, \"three\");","","    let (key, value) = my_map.shift_remove_finish(1);","    assert_eq!(key, 2);","    assert_eq!(value, \"two\");","    assert_eq!(my_map.entries.len(), 2);","    assert_eq!(my_map.entries[0].key, 1);","    assert_eq!(my_map.entries[1].key, 3);","}"],[]],[["{","    struct Entry<K, V> {","        key: K,","        value: V,","    }","","    struct MyMap<K, V> {","        entries: Vec<Entry<K, V>>,","        indices: Vec<usize>,","    }","","    impl<K, V> MyMap<K, V> {","        fn new() -> Self {","            MyMap {","                entries: Vec::new(),","                indices: Vec::new(),","            }","        }","","        fn decrement_indices(&mut self, start: usize, end: usize) {","            for i in start..end {","                if let Some(index) = self.indices.get_mut(i) {","                    *index -= 1;","                }","            }","        }","","        fn shift_remove_finish(&mut self, index: usize) -> (K, V) {","            self.decrement_indices(index + 1, self.entries.len());","            let entry = self.entries.remove(index);","            (entry.key, entry.value)","        }","","        fn insert(&mut self, key: K, value: V) {","            self.entries.push(Entry { key, value });","            self.indices.push(self.entries.len() - 1);","        }","    }","","    let mut my_map = MyMap::new();","    my_map.insert(1, \"one\");","    my_map.insert(2, \"two\");","","    my_map.shift_remove_finish(2); // This index is out of bounds and should panic.","}"],[]]]}