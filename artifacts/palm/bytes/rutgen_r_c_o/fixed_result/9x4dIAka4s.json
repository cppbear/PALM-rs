{"function_name":"bytes::buf::reader::buf::reader::Reader<B>::get_ref","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/buf/reader.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":9,"tests_lines":[72,72,72,44,46,46,46,46,46],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":6,"tests_compiled_rate":66.66666666666666,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[33,34,35],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data","        }","        ","        fn advance(&mut self, _: usize) {}","        ","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            dst.copy_from_slice(&self.data);","        }","","        fn get_u8(&mut self) -> u8 {","            self.data[0]","        }","","        fn get_i8(&mut self) -> i8 {","            self.data[0] as i8","        }","","        fn get_u16(&mut self) -> u16 {","            0","        }","","        fn get_u32(&mut self) -> u32 {","            0","        }","","        fn get_u64(&mut self) -> u64 {","            0","        }","","        fn get_u128(&mut self) -> u128 {","            0","        }","","        fn get_int(&mut self, _: usize) -> i64 {","            0","        }","","       fn try_copy_to_slice(&mut self, _: &mut [u8]) -> Result<(), crate::TryGetError> {  ","           Ok(())  ","       }  "," ","       fn try_get_u8(&mut self) -> Result<u8, crate::TryGetError> {  ","           Ok(0)  ","       }  ","","        // other trait methods omitted for brevity...","    }","","    let test_buf = TestBuf { data: b\"hello world\".to_vec() };","    let reader = Reader { buf: test_buf };","","    let result = reader.get_ref();","    let test_buf = TestBuf { data: b\"hello world\".to_vec() };","    let reader = Reader { buf: test_buf };","    let result = reader.get_ref();","    assert_eq!(result.chunk(), b\"hello world\");","}"],[33,34,35]],[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data","        }","        ","        fn advance(&mut self, _: usize) {}","        ","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            dst.copy_from_slice(&self.data);","        }","","        fn get_u8(&mut self) -> u8 {","            self.data[0]","        }","","        fn get_i8(&mut self) -> i8 {","            self.data[0] as i8","        }","","        fn get_u16(&mut self) -> u16 {","            0","        }","","        fn get_u32(&mut self) -> u32 {","            0","        }","","        fn get_u64(&mut self) -> u64 {","            0","        }","","        fn get_u128(&mut self) -> u128 {","            0","        }","","        fn get_int(&mut self, _: usize) -> i64 {","            0","        }","","       fn try_copy_to_slice(&mut self, _: &mut [u8]) -> Result<(), crate::TryGetError> {  ","            Ok(())","        }","","       fn try_get_u8(&mut self) -> Result<u8, crate::TryGetError> {  ","           Ok(0)  ","       }  ","","        // other trait methods omitted for brevity...","    }","","    let test_buf = TestBuf { data: b\"hello world\".to_vec() };","    let reader = Reader { buf: test_buf };","","    let result = reader.get_ref();","    let test_buf = TestBuf { data: b\"hello world\".to_vec() };","    let reader = Reader { buf: test_buf };","    let result = reader.get_ref();","    assert_eq!(result.remaining(), 11);","}"],[33,34,35]],[["{","   #[derive(PartialEq)]","   struct EmptyBuf {","       data: Vec<u8>,","   }","   ","   impl Buf for EmptyBuf {","       fn remaining(&self) -> usize {","           self.data.len()","       }","   ","       fn chunk(&self) -> &[u8] {","           &self.data","       }","   ","       fn advance(&mut self, _: usize) {}","   ","       fn has_remaining(&self) -> bool {","           !self.data.is_empty()","       }","   ","       fn copy_to_slice(&mut self, dst: &mut [u8]) {","           dst.copy_from_slice(&self.data);","       }","   ","       fn get_u8(&mut self) -> u8 {","           0","       }","   ","       fn get_i8(&mut self) -> i8 {","           0","       }","   ","       // other trait methods omitted for brevity...","   }","   ","   let empty_buf = EmptyBuf { data: vec![] };","   let reader = Reader { buf: empty_buf };","   ","   let result = reader.get_ref();","   let empty_buf = EmptyBuf { data: vec![] };","   let reader = Reader { buf: empty_buf };","   let result = reader.get_ref();","}"],[33,34,35]],[["{","    struct LargeBuf {","        data: Vec<u8>,","    }","","    impl Buf for LargeBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            dst.copy_from_slice(&self.data);","        }","","        fn get_u8(&mut self) -> u8 {","            0","        }","","        fn get_i8(&mut self) -> i8 {","            0","        }","","        // other trait methods omitted for brevity...","    }","","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","","    let result = reader.get_ref();","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","    let result = reader.get_ref();","    assert_eq!(result.remaining(), 1_000_000);","}"],[33,34,35]],[["{","    struct LargeBuf {","        data: Vec<u8>,","    }","","    impl Buf for LargeBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            dst.copy_from_slice(&self.data);","        }","","        fn get_u8(&mut self) -> u8 {","            0","        }","","        fn get_i8(&mut self) -> i8 {","            0","        }","","        // other trait methods omitted for brevity...","    }","","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","","    let result = reader.get_ref();","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","    let result = reader.get_ref();","    assert_eq!(result.chunk(), result.chunk());","}"],[33,34,35]],[["{","    struct LargeBuf {","        data: Vec<u8>,","    }","","    impl Buf for LargeBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            dst.copy_from_slice(&self.data);","        }","","        fn get_u8(&mut self) -> u8 {","            0","        }","","        fn get_i8(&mut self) -> i8 {","            0","        }","","        // other trait methods omitted for brevity...","    }","","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","","    let result = reader.get_ref();","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","    let result = reader.get_ref();","    assert!(result.has_remaining());","}"],[33,34,35]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data","        }","        ","        fn advance(&mut self, _: usize) {}","        ","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            dst.copy_from_slice(&self.data);","        }","","        fn get_u8(&mut self) -> u8 {","            self.data[0]","        }","","        fn get_i8(&mut self) -> i8 {","            self.data[0] as i8","        }","","        fn get_u16(&mut self) -> u16 {","            0","        }","","        fn get_u32(&mut self) -> u32 {","            0","        }","","        fn get_u64(&mut self) -> u64 {","            0","        }","","        fn get_u128(&mut self) -> u128 {","            0","        }","","        fn get_int(&mut self, _: usize) -> i64 {","            0","        }","","       fn try_copy_to_slice(&mut self, _: &mut [u8]) -> Result<(), crate::TryGetError> {  ","           Ok(())  ","       }  "," ","       fn try_get_u8(&mut self) -> Result<u8, crate::TryGetError> {  ","           Ok(0)  ","       }  ","","        // other trait methods omitted for brevity...","    }","","    let test_buf = TestBuf { data: b\"hello world\".to_vec() };","    let reader = Reader { buf: test_buf };","","    let result = reader.get_ref();","    let test_buf = TestBuf { data: b\"hello world\".to_vec() };","    let reader = Reader { buf: test_buf };","    let result = reader.get_ref();","    assert_eq!(result.chunk(), b\"hello world\");","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data","        }","        ","        fn advance(&mut self, _: usize) {}","        ","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            dst.copy_from_slice(&self.data);","        }","","        fn get_u8(&mut self) -> u8 {","            self.data[0]","        }","","        fn get_i8(&mut self) -> i8 {","            self.data[0] as i8","        }","","        fn get_u16(&mut self) -> u16 {","            0","        }","","        fn get_u32(&mut self) -> u32 {","            0","        }","","        fn get_u64(&mut self) -> u64 {","            0","        }","","        fn get_u128(&mut self) -> u128 {","            0","        }","","        fn get_int(&mut self, _: usize) -> i64 {","            0","        }","","       fn try_copy_to_slice(&mut self, _: &mut [u8]) -> Result<(), crate::TryGetError> {  ","            Ok(())","        }","","       fn try_get_u8(&mut self) -> Result<u8, crate::TryGetError> {  ","           Ok(0)  ","       }  ","","        // other trait methods omitted for brevity...","    }","","    let test_buf = TestBuf { data: b\"hello world\".to_vec() };","    let reader = Reader { buf: test_buf };","","    let result = reader.get_ref();","    let test_buf = TestBuf { data: b\"hello world\".to_vec() };","    let reader = Reader { buf: test_buf };","    let result = reader.get_ref();","    assert_eq!(result.remaining(), 11);","}"],[]],[["{","   #[derive(PartialEq)]","   struct EmptyBuf {","       data: Vec<u8>,","   }","   ","   impl Buf for EmptyBuf {","       fn remaining(&self) -> usize {","           self.data.len()","       }","   ","       fn chunk(&self) -> &[u8] {","           &self.data","       }","   ","       fn advance(&mut self, _: usize) {}","   ","       fn has_remaining(&self) -> bool {","           !self.data.is_empty()","       }","   ","       fn copy_to_slice(&mut self, dst: &mut [u8]) {","           dst.copy_from_slice(&self.data);","       }","   ","       fn get_u8(&mut self) -> u8 {","           0","       }","   ","       fn get_i8(&mut self) -> i8 {","           0","       }","   ","       // other trait methods omitted for brevity...","   }","   ","   let empty_buf = EmptyBuf { data: vec![] };","   let reader = Reader { buf: empty_buf };","   ","   let result = reader.get_ref();","   let empty_buf = EmptyBuf { data: vec![] };","   let reader = Reader { buf: empty_buf };","   let result = reader.get_ref();","}"],[]],[["{","    struct LargeBuf {","        data: Vec<u8>,","    }","","    impl Buf for LargeBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            dst.copy_from_slice(&self.data);","        }","","        fn get_u8(&mut self) -> u8 {","            0","        }","","        fn get_i8(&mut self) -> i8 {","            0","        }","","        // other trait methods omitted for brevity...","    }","","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","","    let result = reader.get_ref();","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","    let result = reader.get_ref();","    assert_eq!(result.remaining(), 1_000_000);","}"],[]],[["{","    struct LargeBuf {","        data: Vec<u8>,","    }","","    impl Buf for LargeBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            dst.copy_from_slice(&self.data);","        }","","        fn get_u8(&mut self) -> u8 {","            0","        }","","        fn get_i8(&mut self) -> i8 {","            0","        }","","        // other trait methods omitted for brevity...","    }","","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","","    let result = reader.get_ref();","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","    let result = reader.get_ref();","    assert_eq!(result.chunk(), result.chunk());","}"],[]],[["{","    struct LargeBuf {","        data: Vec<u8>,","    }","","    impl Buf for LargeBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            dst.copy_from_slice(&self.data);","        }","","        fn get_u8(&mut self) -> u8 {","            0","        }","","        fn get_i8(&mut self) -> i8 {","            0","        }","","        // other trait methods omitted for brevity...","    }","","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","","    let result = reader.get_ref();","    let large_data = (0..1_000_000).map(|x| x as u8).collect();","    let large_buf = LargeBuf { data: large_data };","    let reader = Reader { buf: large_buf };","    let result = reader.get_ref();","    assert!(result.has_remaining());","}"],[]]]}