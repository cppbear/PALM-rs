{"function_name":"bytes::bytes::release_shared","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":17,"tests_lines":[25,25,25,36,36,38,38,38,38,25,25,26,25,27,27,27,11],"oracles":5,"oracles_compiled":4,"oracles_compiled_rate":80.0,"tests_compiled":6,"tests_compiled_rate":35.294117647058826,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":31,"lines_covered":31,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594],"codes_lines_covered":[[["{","  struct TestShared {  ","      buf: *mut u8,  ","      cap: usize,  ","      ref_cnt: AtomicUsize,  ","  }  "," ","  let buf = Box::into_raw(Box::new([0u8; 10])); // Create a buffer  ","  let shared = Box::new(TestShared {  ","      buf: buf as *mut u8,  ","      cap: 10,  ","      ref_cnt: AtomicUsize::new(2), // Set reference count greater than 1  ","  });  "," ","   let ptr = Box::into_raw(shared); // Get raw pointer  "," ","   unsafe {  ","       release_shared(ptr as *mut Shared); // Cast ptr to *mut Shared  ","   }  ","  let buf = Box::into_raw(Box::new([0u8; 10]));  ","  let shared = Box::new(TestShared { buf: buf as *mut u8, cap: 10, ref_cnt: AtomicUsize::new(2) });  ","  let ptr = Box::into_raw(shared);  ","  unsafe { release_shared(ptr as *mut Shared); } // Cast ptr to *mut Shared  ","  assert_eq!(ptr.is_null(), false);  ","}"],[1564,1565,1566,1567,1594]],[["{","  struct TestShared {","      buf: *mut [u8; 10],","      cap: usize,","      ref_cnt: AtomicUsize,","  }","  ","  let buf1 = Box::into_raw(Box::new([1u8; 10])); // Create a buffer","  let buf2 = Box::into_raw(Box::new([2u8; 10])); // Create another buffer","  let shared1 = Box::new(TestShared {","      buf: buf1,","      cap: 10,","      ref_cnt: AtomicUsize::new(3), // Set reference count greater than 1","  });","  ","  let shared2 = Box::new(TestShared {","      buf: buf2,","      cap: 10,","      ref_cnt: AtomicUsize::new(3), // Set another reference count","  });","  ","  let ptr1 = Box::into_raw(shared1) as *mut Shared; // Get raw pointer and cast to *mut Shared","  let ptr2 = Box::into_raw(shared2) as *mut Shared; // Get another raw pointer and cast to *mut Shared","  ","  unsafe {","      release_shared(ptr1); // Call the function for the first shared object","      release_shared(ptr2); // Call the function for the second shared object","  }","   let buf1 = Box::into_raw(Box::new([1u8; 10]));","   let buf2 = Box::into_raw(Box::new([2u8; 10]));","   let shared1 = Box::new(TestShared { buf: buf1, cap: 10, ref_cnt: AtomicUsize::new(3) });","    let shared2 = Box::new(TestShared { buf: buf2, cap: 10, ref_cnt: AtomicUsize::new(3) });","    let ptr1 = Box::into_raw(shared1);","    let ptr2 = Box::into_raw(shared2);","   unsafe { assert_eq!((*ptr2).ref_cnt.load(Ordering::SeqCst), 3); }  ","}"],[1564,1565,1566,1567,1594]],[["{","  struct TestShared {","      buf: *mut [u8; 10], // Changed from *mut u8 to *mut [u8; 10]","      cap: usize,","      ref_cnt: AtomicUsize,","  }","","  let buf = Box::into_raw(Box::new([0u8; 10])); // Create a buffer","  let shared = Box::new(TestShared {","      buf,","      cap: 10,","      ref_cnt: AtomicUsize::new(2), // Set reference count to 2","  });","","  let ptr = Box::into_raw(shared) as *mut Shared; // Cast raw pointer to *mut Shared","  ","  unsafe {","      release_shared(ptr); // Call the function under test","  }","  let buf = Box::into_raw(Box::new([0u8; 10]));","  let shared = Box::new(TestShared { buf, cap: 10, ref_cnt: AtomicUsize::new(2), }); // No change needed here","   let ptr = Box::into_raw(shared) as *mut Shared; // Cast raw pointer to *mut Shared","   unsafe { release_shared(ptr); }","   assert!(!ptr.is_null());","}"],[1564,1565,1566,1567,1594]],[["{","   struct TestShared {  ","       buf: *mut [u8; 10], // Change pointer type to match the allocated buffer type  ","       cap: usize,  ","       ref_cnt: AtomicUsize,  ","   }  "," ","   let buf = Box::into_raw(Box::new([0u8; 10])); // Create a buffer  ","   let shared = Box::new(TestShared {  ","       buf,  ","       cap: 10,  ","       ref_cnt: AtomicUsize::new(2), // Set reference count to 2  ","    });","","    let ptr = Box::into_raw(shared); // Get raw pointer","","   unsafe {","       release_shared(ptr as *mut Shared); // Call the function under test with correct type","   }","   let buf = Box::into_raw(Box::new([0u8; 10]));","   let shared = Box::new(TestShared { buf, cap: 10, ref_cnt: AtomicUsize::new(2), });","  let ptr = Box::into_raw(shared);  ","  unsafe { release_shared(ptr as *mut Shared); }  ","  let shared_ref = unsafe { &*ptr };  ","  assert_eq!(shared_ref.cap, 10);  ","}"],[1564,1565,1566,1567,1594]],[["{","   use core::ptr::null_mut;  ","   use alloc::boxed::Box;  ","   use core::sync::atomic::AtomicUsize;  "," ","   struct Shared {  ","       buf: *mut u8,  ","       cap: usize,  ","       ref_cnt: AtomicUsize,  ","   }  "," ","   let shared_memory = Box::new(Shared {  ","       buf: null_mut(),  ","       cap: 0,  ","       ref_cnt: AtomicUsize::new(1),  ","   });  "," ","   let ptr: *mut Shared = Box::into_raw(shared_memory);  ","   ","   unsafe {  ","       release_shared(ptr.cast());  ","   }  ","   let shared_memory = Box::new(Shared { buf: null_mut(), cap: 0, ref_cnt: AtomicUsize::new(1), });  ","   let ptr: *mut Shared = Box::into_raw(shared_memory);  ","   unsafe { release_shared(ptr.cast()); }  ","      assert_eq!(unsafe { (*ptr).ref_cnt.load(Ordering::Relaxed) }, 0);","}"],[1564,1565,1566,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594]],[["{","   use core::ptr::null_mut;","   use alloc::boxed::Box;","   use core::sync::atomic::AtomicUsize;","","   struct Shared {","       buf: *mut u8,","       cap: usize,","       ref_cnt: AtomicUsize,","   }","","   let shared_memory = Box::new(Shared {","       buf: null_mut(),","       cap: 0,","       ref_cnt: AtomicUsize::new(1),","   });","","   let ptr: *mut Shared = Box::into_raw(shared_memory);","   ","   unsafe {","       release_shared(ptr.cast());","   }","   let shared_memory = Box::new(Shared { buf: null_mut(), cap: 0, ref_cnt: AtomicUsize::new(1), });","   let ptr: *mut Shared = Box::into_raw(shared_memory);","   unsafe { release_shared(ptr.cast()); }","   assert!(ptr.is_null() == false);","}"],[1564,1565,1566,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594]]],"codes_branches":[{"start_line":1566,"start_column":8,"end_line":1566,"end_column":59,"positive":true,"negative":true}],"codes_branches_covered":[[["{","  struct TestShared {  ","      buf: *mut u8,  ","      cap: usize,  ","      ref_cnt: AtomicUsize,  ","  }  "," ","  let buf = Box::into_raw(Box::new([0u8; 10])); // Create a buffer  ","  let shared = Box::new(TestShared {  ","      buf: buf as *mut u8,  ","      cap: 10,  ","      ref_cnt: AtomicUsize::new(2), // Set reference count greater than 1  ","  });  "," ","   let ptr = Box::into_raw(shared); // Get raw pointer  "," ","   unsafe {  ","       release_shared(ptr as *mut Shared); // Cast ptr to *mut Shared  ","   }  ","  let buf = Box::into_raw(Box::new([0u8; 10]));  ","  let shared = Box::new(TestShared { buf: buf as *mut u8, cap: 10, ref_cnt: AtomicUsize::new(2) });  ","  let ptr = Box::into_raw(shared);  ","  unsafe { release_shared(ptr as *mut Shared); } // Cast ptr to *mut Shared  ","  assert_eq!(ptr.is_null(), false);  ","}"],[{"start_line":1566,"start_column":8,"end_line":1566,"end_column":59,"positive":true,"negative":false}]],[["{","  struct TestShared {","      buf: *mut [u8; 10],","      cap: usize,","      ref_cnt: AtomicUsize,","  }","  ","  let buf1 = Box::into_raw(Box::new([1u8; 10])); // Create a buffer","  let buf2 = Box::into_raw(Box::new([2u8; 10])); // Create another buffer","  let shared1 = Box::new(TestShared {","      buf: buf1,","      cap: 10,","      ref_cnt: AtomicUsize::new(3), // Set reference count greater than 1","  });","  ","  let shared2 = Box::new(TestShared {","      buf: buf2,","      cap: 10,","      ref_cnt: AtomicUsize::new(3), // Set another reference count","  });","  ","  let ptr1 = Box::into_raw(shared1) as *mut Shared; // Get raw pointer and cast to *mut Shared","  let ptr2 = Box::into_raw(shared2) as *mut Shared; // Get another raw pointer and cast to *mut Shared","  ","  unsafe {","      release_shared(ptr1); // Call the function for the first shared object","      release_shared(ptr2); // Call the function for the second shared object","  }","   let buf1 = Box::into_raw(Box::new([1u8; 10]));","   let buf2 = Box::into_raw(Box::new([2u8; 10]));","   let shared1 = Box::new(TestShared { buf: buf1, cap: 10, ref_cnt: AtomicUsize::new(3) });","    let shared2 = Box::new(TestShared { buf: buf2, cap: 10, ref_cnt: AtomicUsize::new(3) });","    let ptr1 = Box::into_raw(shared1);","    let ptr2 = Box::into_raw(shared2);","   unsafe { assert_eq!((*ptr2).ref_cnt.load(Ordering::SeqCst), 3); }  ","}"],[{"start_line":1566,"start_column":8,"end_line":1566,"end_column":59,"positive":true,"negative":false}]],[["{","  struct TestShared {","      buf: *mut [u8; 10], // Changed from *mut u8 to *mut [u8; 10]","      cap: usize,","      ref_cnt: AtomicUsize,","  }","","  let buf = Box::into_raw(Box::new([0u8; 10])); // Create a buffer","  let shared = Box::new(TestShared {","      buf,","      cap: 10,","      ref_cnt: AtomicUsize::new(2), // Set reference count to 2","  });","","  let ptr = Box::into_raw(shared) as *mut Shared; // Cast raw pointer to *mut Shared","  ","  unsafe {","      release_shared(ptr); // Call the function under test","  }","  let buf = Box::into_raw(Box::new([0u8; 10]));","  let shared = Box::new(TestShared { buf, cap: 10, ref_cnt: AtomicUsize::new(2), }); // No change needed here","   let ptr = Box::into_raw(shared) as *mut Shared; // Cast raw pointer to *mut Shared","   unsafe { release_shared(ptr); }","   assert!(!ptr.is_null());","}"],[{"start_line":1566,"start_column":8,"end_line":1566,"end_column":59,"positive":true,"negative":false}]],[["{","   struct TestShared {  ","       buf: *mut [u8; 10], // Change pointer type to match the allocated buffer type  ","       cap: usize,  ","       ref_cnt: AtomicUsize,  ","   }  "," ","   let buf = Box::into_raw(Box::new([0u8; 10])); // Create a buffer  ","   let shared = Box::new(TestShared {  ","       buf,  ","       cap: 10,  ","       ref_cnt: AtomicUsize::new(2), // Set reference count to 2  ","    });","","    let ptr = Box::into_raw(shared); // Get raw pointer","","   unsafe {","       release_shared(ptr as *mut Shared); // Call the function under test with correct type","   }","   let buf = Box::into_raw(Box::new([0u8; 10]));","   let shared = Box::new(TestShared { buf, cap: 10, ref_cnt: AtomicUsize::new(2), });","  let ptr = Box::into_raw(shared);  ","  unsafe { release_shared(ptr as *mut Shared); }  ","  let shared_ref = unsafe { &*ptr };  ","  assert_eq!(shared_ref.cap, 10);  ","}"],[{"start_line":1566,"start_column":8,"end_line":1566,"end_column":59,"positive":true,"negative":false}]],[["{","   use core::ptr::null_mut;  ","   use alloc::boxed::Box;  ","   use core::sync::atomic::AtomicUsize;  "," ","   struct Shared {  ","       buf: *mut u8,  ","       cap: usize,  ","       ref_cnt: AtomicUsize,  ","   }  "," ","   let shared_memory = Box::new(Shared {  ","       buf: null_mut(),  ","       cap: 0,  ","       ref_cnt: AtomicUsize::new(1),  ","   });  "," ","   let ptr: *mut Shared = Box::into_raw(shared_memory);  ","   ","   unsafe {  ","       release_shared(ptr.cast());  ","   }  ","   let shared_memory = Box::new(Shared { buf: null_mut(), cap: 0, ref_cnt: AtomicUsize::new(1), });  ","   let ptr: *mut Shared = Box::into_raw(shared_memory);  ","   unsafe { release_shared(ptr.cast()); }  ","      assert_eq!(unsafe { (*ptr).ref_cnt.load(Ordering::Relaxed) }, 0);","}"],[{"start_line":1566,"start_column":8,"end_line":1566,"end_column":59,"positive":false,"negative":true}]],[["{","   use core::ptr::null_mut;","   use alloc::boxed::Box;","   use core::sync::atomic::AtomicUsize;","","   struct Shared {","       buf: *mut u8,","       cap: usize,","       ref_cnt: AtomicUsize,","   }","","   let shared_memory = Box::new(Shared {","       buf: null_mut(),","       cap: 0,","       ref_cnt: AtomicUsize::new(1),","   });","","   let ptr: *mut Shared = Box::into_raw(shared_memory);","   ","   unsafe {","       release_shared(ptr.cast());","   }","   let shared_memory = Box::new(Shared { buf: null_mut(), cap: 0, ref_cnt: AtomicUsize::new(1), });","   let ptr: *mut Shared = Box::into_raw(shared_memory);","   unsafe { release_shared(ptr.cast()); }","   assert!(ptr.is_null() == false);","}"],[{"start_line":1566,"start_column":8,"end_line":1566,"end_column":59,"positive":false,"negative":true}]]]}