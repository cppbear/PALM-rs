{"function_name":"bytes::buf::take::<buf::take::Take<T> as buf::buf_impl::Buf>::chunk","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/buf/take.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":14,"tests_lines":[34,34,34,33,33,33,33,32,33,34,36,34,34,34],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":11,"tests_compiled_rate":78.57142857142857,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":11,"tests_passed":10,"tests_passed_rate":90.9090909090909,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[140,141,142,143],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![1, 2, 3, 4], ","        position: 0 ","    };","    let take = buf.take(0);","    let result = take.chunk();","    let buf = TestBuf { data: vec![1, 2, 3, 4], position: 0 };","    let take = buf.take(0);","    let result = take.chunk();","    assert_eq!(result, &[]);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![1, 2, 3, 4], ","        position: 0 ","    };","    let take = buf.take(0);","    let result = take.chunk();","    let buf = TestBuf { data: vec![1, 2, 3, 4], position: 0 };","    let take = buf.take(0);","    let result = take.chunk();","    assert_eq!(result.len(), 0);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![1, 2, 3, 4], ","        position: 0 ","    };","    let take = buf.take(0);","    let result = take.chunk();","    let buf = TestBuf { data: vec![1, 2, 3, 4], position: 0 };","    let take = buf.take(0);","    let result = take.chunk();","    assert!(result.is_empty());","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","   let buf = TestBuf { ","       data: vec![1, 2, 3, 4], ","       position: 0 ","   };","   let take = buf.take(4);","   let result = take.chunk();","   let bytes = take.chunk();","   let expected_length = cmp::min(take.remaining(), 4);","   assert_eq!(result.len(), expected_length);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","   let buf = TestBuf { ","       data: vec![1, 2, 3, 4], ","       position: 0 ","   };","   let take = buf.take(10);","   let result = take.chunk();","   let bytes = take.chunk();","   let expected_length = cmp::min(take.remaining(), 10);","    assert_eq!(result.len(), expected_length);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","   let mut buf = TestBuf { ","       data: vec![1, 2, 3, 4], ","       position: 0 ","   };","   let take = buf.take(10);","   let result = take.chunk();","   let bytes = take.chunk();","   let expected_length = cmp::min(take.remaining(), 10);","   assert_eq!(result, &[1, 2, 3, 4]);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","  let mut buf = TestBuf {  ","      data: vec![1, 2, 3, 4],  ","      position: 0  ","  };  ","  let take = (&mut buf).take(1);  ","  let result = take.chunk();  ","  buf.advance(1);  ","  let bytes1 = (&mut buf).take(2).chunk();  ","  buf.advance(2);  ","  let bytes2 = (&mut buf).take(5).chunk();  ","}"],[140,141,142,143]],[["{","   #[derive(Clone)]","   struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","   let buf = TestBuf { ","       data: vec![1, 2, 3, 4], ","       position: 0 ","   };","   let take = buf.clone().take(1);","   let result = take.chunk();","   let bytes = buf.clone().take(1).chunk();","   let bytes = buf.clone().take(2).chunk();","   let bytes = buf.clone().take(5).chunk();","   let bytes = buf.clone().take(0).chunk();","   assert_eq!(result, &[]);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![], ","        position: 0 ","    };","    let take = buf.take(5);","    let result = take.chunk();","    let bytes: &[u8] = &[];","    let limit: usize = 5;","    let expected: &[u8] = &[];","    assert_eq!(result, expected);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![], ","        position: 0 ","    };","    let take = buf.take(5);","    let result = take.chunk();","    let bytes: &[u8] = &[];","    let limit: usize = 5;","    let expected: &[u8] = &[];","    assert_eq!(result.len(), 0);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![], ","        position: 0 ","    };","    let take = buf.take(5);","    let result = take.chunk();","    let bytes: &[u8] = &[];","    let limit: usize = 5;","    let expected: &[u8] = &[];","    assert_eq!(take.remaining(), 0);","}"],[140,141,142,143]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![1, 2, 3, 4], ","        position: 0 ","    };","    let take = buf.take(0);","    let result = take.chunk();","    let buf = TestBuf { data: vec![1, 2, 3, 4], position: 0 };","    let take = buf.take(0);","    let result = take.chunk();","    assert_eq!(result, &[]);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![1, 2, 3, 4], ","        position: 0 ","    };","    let take = buf.take(0);","    let result = take.chunk();","    let buf = TestBuf { data: vec![1, 2, 3, 4], position: 0 };","    let take = buf.take(0);","    let result = take.chunk();","    assert_eq!(result.len(), 0);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![1, 2, 3, 4], ","        position: 0 ","    };","    let take = buf.take(0);","    let result = take.chunk();","    let buf = TestBuf { data: vec![1, 2, 3, 4], position: 0 };","    let take = buf.take(0);","    let result = take.chunk();","    assert!(result.is_empty());","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","   let buf = TestBuf { ","       data: vec![1, 2, 3, 4], ","       position: 0 ","   };","   let take = buf.take(4);","   let result = take.chunk();","   let bytes = take.chunk();","   let expected_length = cmp::min(take.remaining(), 4);","   assert_eq!(result.len(), expected_length);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","   let buf = TestBuf { ","       data: vec![1, 2, 3, 4], ","       position: 0 ","   };","   let take = buf.take(10);","   let result = take.chunk();","   let bytes = take.chunk();","   let expected_length = cmp::min(take.remaining(), 10);","    assert_eq!(result.len(), expected_length);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","   let mut buf = TestBuf { ","       data: vec![1, 2, 3, 4], ","       position: 0 ","   };","   let take = buf.take(10);","   let result = take.chunk();","   let bytes = take.chunk();","   let expected_length = cmp::min(take.remaining(), 10);","   assert_eq!(result, &[1, 2, 3, 4]);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","  let mut buf = TestBuf {  ","      data: vec![1, 2, 3, 4],  ","      position: 0  ","  };  ","  let take = (&mut buf).take(1);  ","  let result = take.chunk();  ","  buf.advance(1);  ","  let bytes1 = (&mut buf).take(2).chunk();  ","  buf.advance(2);  ","  let bytes2 = (&mut buf).take(5).chunk();  ","}"],[]],[["{","   #[derive(Clone)]","   struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","   let buf = TestBuf { ","       data: vec![1, 2, 3, 4], ","       position: 0 ","   };","   let take = buf.clone().take(1);","   let result = take.chunk();","   let bytes = buf.clone().take(1).chunk();","   let bytes = buf.clone().take(2).chunk();","   let bytes = buf.clone().take(5).chunk();","   let bytes = buf.clone().take(0).chunk();","   assert_eq!(result, &[]);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![], ","        position: 0 ","    };","    let take = buf.take(5);","    let result = take.chunk();","    let bytes: &[u8] = &[];","    let limit: usize = 5;","    let expected: &[u8] = &[];","    assert_eq!(result, expected);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![], ","        position: 0 ","    };","    let take = buf.take(5);","    let result = take.chunk();","    let bytes: &[u8] = &[];","    let limit: usize = 5;","    let expected: &[u8] = &[];","    assert_eq!(result.len(), 0);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { ","        data: vec![], ","        position: 0 ","    };","    let take = buf.take(5);","    let result = take.chunk();","    let bytes: &[u8] = &[];","    let limit: usize = 5;","    let expected: &[u8] = &[];","    assert_eq!(take.remaining(), 0);","}"],[]]]}