{"function_name":"bytes::bytes::bytes::Bytes::as_slice","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":19,"tests_lines":[9,9,9,9,9,9,9,8,8,9,9,9,9,9,9,6,6,6,10],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":19,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":19,"tests_passed":17,"tests_passed_rate":89.47368421052632,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[667,668,669],"codes_lines_covered":[[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice.len(), 5);","}"],[667,668,669]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice[0], 1);","}"],[667,668,669]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice[1], 2);","}"],[667,668,669]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice[2], 3);","}"],[667,668,669]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice[3], 4);","}"],[667,668,669]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice[4], 5);","}"],[667,668,669]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert!(slice.as_ptr() == bytes.ptr);","}"],[667,668,669]],[["{","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    assert_eq!(bytes.len(), 0);","}"],[667,668,669]],[["{","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    assert!(bytes.is_empty());","}"],[667,668,669]],[["{","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice, data);","}"],[667,668,669]],[["{","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice.len(), bytes.len());","}"],[667,668,669]],[["{","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    assert_eq!(slice.len(), usize::MAX);","}"],[667,668,669]],[["{","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    assert_eq!(slice.as_ptr(), bytes.ptr);","}"],[667,668,669]],[["{","   let data: Vec<u8> = (0..usize::MAX as u8).collect();","   let bytes = Bytes::from_owner(data);","   let slice = bytes.as_slice();","   let data: Vec<u8> = (0..usize::MAX as u8).collect();","   let bytes = Bytes::from_owner(data);","   let slice = bytes.as_slice();","   assert!(!slice.is_empty());","}"],[667,668,669]],[["{","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    assert!(slice.iter().enumerate().all(|(i, &v)| v == i as u8));","}"],[667,668,669]],[["{","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    let slice = bytes.as_slice();","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    assert_eq!(slice, unsafe { slice::from_raw_parts(bytes.ptr, bytes.len) });","}"],[]],[["{","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    let slice = bytes.as_slice();","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    assert!(slice.is_empty());","}"],[]],[["{","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    let slice = bytes.as_slice();","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    assert_eq!(bytes.len(), 0);","}"],[]],[["{","    let data: &[u8] = &[1, 2, 3];","    let mut bytes = Bytes::from_static(data);","    unsafe { bytes.len = usize::MAX; }","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3];","    let mut bytes = Bytes::from_static(data);","    unsafe { bytes.len = usize::MAX; }","   assert!(bytes.ptr.is_null());  ","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice.len(), 5);","}"],[]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice[0], 1);","}"],[]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice[1], 2);","}"],[]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice[2], 3);","}"],[]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice[3], 4);","}"],[]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice[4], 5);","}"],[]],[["{","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3, 4, 5];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert!(slice.as_ptr() == bytes.ptr);","}"],[]],[["{","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    assert_eq!(bytes.len(), 0);","}"],[]],[["{","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    assert!(bytes.is_empty());","}"],[]],[["{","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice, data);","}"],[]],[["{","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    let data: &[u8] = &[];","    let bytes = Bytes::from_static(data);","    let slice = bytes.as_slice();","    assert_eq!(slice.len(), bytes.len());","}"],[]],[["{","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    assert_eq!(slice.len(), usize::MAX);","}"],[]],[["{","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    assert_eq!(slice.as_ptr(), bytes.ptr);","}"],[]],[["{","   let data: Vec<u8> = (0..usize::MAX as u8).collect();","   let bytes = Bytes::from_owner(data);","   let slice = bytes.as_slice();","   let data: Vec<u8> = (0..usize::MAX as u8).collect();","   let bytes = Bytes::from_owner(data);","   let slice = bytes.as_slice();","   assert!(!slice.is_empty());","}"],[]],[["{","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    let data: Vec<u8> = (0..usize::MAX as u8).collect();","    let bytes = Bytes::from_owner(data);","    let slice = bytes.as_slice();","    assert!(slice.iter().enumerate().all(|(i, &v)| v == i as u8));","}"],[]],[["{","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    let slice = bytes.as_slice();","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    assert_eq!(slice, unsafe { slice::from_raw_parts(bytes.ptr, bytes.len) });","}"],[]],[["{","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    let slice = bytes.as_slice();","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    assert!(slice.is_empty());","}"],[]],[["{","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    let slice = bytes.as_slice();","    let mut bytes = Bytes::new_empty_with_ptr(ptr::null());","    assert_eq!(bytes.len(), 0);","}"],[]],[["{","    let data: &[u8] = &[1, 2, 3];","    let mut bytes = Bytes::from_static(data);","    unsafe { bytes.len = usize::MAX; }","    let slice = bytes.as_slice();","    let data: &[u8] = &[1, 2, 3];","    let mut bytes = Bytes::from_static(data);","    unsafe { bytes.len = usize::MAX; }","   assert!(bytes.ptr.is_null());  ","}"],[]]]}