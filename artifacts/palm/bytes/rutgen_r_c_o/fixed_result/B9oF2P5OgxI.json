{"function_name":"bytes::buf::chain::<buf::chain::Chain<T, U> as buf::buf_impl::Buf>::remaining","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/buf/chain.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":18,"tests_lines":[23,26,29,32,35,38,24,28,32,36,23,26,29,32,35,24,24,24],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":18,"tests_compiled_rate":100.0,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":18,"tests_passed":18,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[135,136,137],"codes_lines_covered":[[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 0);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 8);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 12 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 12);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 12 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 20 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 20);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 12 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 20 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: usize::MAX };","    let buf_b = TestBuf { remaining: 1 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), usize::MAX);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 12 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 20 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: usize::MAX };","    let buf_b = TestBuf { remaining: 1 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 1 };","    let buf_b = TestBuf { remaining: usize::MAX };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), usize::MAX);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, 5);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 5 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, 5);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 5 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 3 };","    let buf_b = TestBuf { remaining: 4 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, 7);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 5 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 3 };","    let buf_b = TestBuf { remaining: 4 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, 0);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 10);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 15 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 20);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 15 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 0);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 15 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 7 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 10);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 15 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 7 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 42 };","    let buf_b = TestBuf { remaining: 8 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 50);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 15 };","    let buf_b = TestBuf { remaining: 25 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 15 };","    let buf_b = TestBuf { remaining: 25 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, 40);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: usize::MAX };","    let buf_b = TestBuf { remaining: usize::MAX };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: usize::MAX };","    let buf_b = TestBuf { remaining: usize::MAX };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, usize::MAX.saturating_add(usize::MAX));","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: usize::MAX - 1 };","    let buf_b = TestBuf { remaining: 2 }; // This will cause an overflow in the addition","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: usize::MAX - 1 };","    let buf_b = TestBuf { remaining: 2 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, usize::MAX);","}"],[135,136,137]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 0);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 8);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 12 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 12);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 12 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 20 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 20);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 12 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 20 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: usize::MAX };","    let buf_b = TestBuf { remaining: 1 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), usize::MAX);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 12 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 20 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: usize::MAX };","    let buf_b = TestBuf { remaining: 1 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 1 };","    let buf_b = TestBuf { remaining: usize::MAX };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), usize::MAX);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, 5);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 5 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, 5);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 5 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 3 };","    let buf_b = TestBuf { remaining: 4 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, 7);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 5 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 3 };","    let buf_b = TestBuf { remaining: 4 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, 0);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 10);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 15 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 20);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 15 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 0);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 15 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 7 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 10);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 10 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 5 };","    let buf_b = TestBuf { remaining: 15 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 0 };","    let buf_b = TestBuf { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 7 };","    let buf_b = TestBuf { remaining: 3 };","    let chain = Chain { a: buf_a, b: buf_b };","    let buf_a = TestBuf { remaining: 42 };","    let buf_b = TestBuf { remaining: 8 };","    let chain = Chain { a: buf_a, b: buf_b };","    assert_eq!(chain.remaining(), 50);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: 15 };","    let buf_b = TestBuf { remaining: 25 };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: 15 };","    let buf_b = TestBuf { remaining: 25 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, 40);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: usize::MAX };","    let buf_b = TestBuf { remaining: usize::MAX };","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: usize::MAX };","    let buf_b = TestBuf { remaining: usize::MAX };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, usize::MAX.saturating_add(usize::MAX));","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","    ","    let buf_a = TestBuf { remaining: usize::MAX - 1 };","    let buf_b = TestBuf { remaining: 2 }; // This will cause an overflow in the addition","    let chain = Chain { a: buf_a, b: buf_b };","    let _ = chain.remaining();","    let buf_a = TestBuf { remaining: usize::MAX - 1 };","    let buf_b = TestBuf { remaining: 2 };","    let chain = Chain { a: buf_a, b: buf_b };","    let result = chain.remaining();","    assert_eq!(result, usize::MAX);","}"],[]]]}