{"function_name":"bytes::buf::buf_impl::_assert_trait_object","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/buf/buf_impl.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":10,"tests_lines":[25,25,25,25,25,25,24,24,27,25],"oracles":5,"oracles_compiled":2,"oracles_compiled_rate":40.0,"tests_compiled":2,"tests_compiled_rate":20.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":1,"lines_covered":1,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[2962],"codes_lines_covered":[[["{","  struct TestBuf {  ","      remaining: usize,  ","  }  ","  ","  impl crate::buf::buf_impl::Buf for TestBuf {  ","      fn remaining(&self) -> usize {  ","          self.remaining  ","      }  ","      ","      fn chunk(&self) -> &[u8] {  ","          &[]  ","      }  ","  ","      fn advance(&mut self, cnt: usize) {  ","          self.remaining = self.remaining.saturating_sub(cnt);  ","      }  ","  }  "," ","  let test_buf = TestBuf { remaining: 0 };  ","  _assert_trait_object(&test_buf);  ","  let test_buf = TestBuf { remaining: 0 };  ","  _assert_trait_object(&test_buf);  ","  assert_eq!(test_buf.remaining(), 0);  ","}"],[2962]],[["{","  struct TestBuf {","      remaining: usize,","  }","  ","  impl crate::buf::buf_impl::Buf for TestBuf {","      fn remaining(&self) -> usize {","          self.remaining","      }","      ","      fn chunk(&self) -> &[u8] {","          &[] // Will cause a panic with remaining instances","      }","      ","      fn advance(&mut self, cnt: usize) {","          self.remaining = self.remaining.saturating_sub(cnt);","      }","  }","  ","  let test_buf = TestBuf { remaining: 0 };","  _assert_trait_object(&test_buf);","  let test_buf = TestBuf { remaining: 0 };","  let result = std::panic::catch_unwind(|| _assert_trait_object(&test_buf));","  assert!(result.unwrap_err().is::<&str>());","}"],[2962]]],"codes_branches":[],"codes_branches_covered":[[["{","  struct TestBuf {  ","      remaining: usize,  ","  }  ","  ","  impl crate::buf::buf_impl::Buf for TestBuf {  ","      fn remaining(&self) -> usize {  ","          self.remaining  ","      }  ","      ","      fn chunk(&self) -> &[u8] {  ","          &[]  ","      }  ","  ","      fn advance(&mut self, cnt: usize) {  ","          self.remaining = self.remaining.saturating_sub(cnt);  ","      }  ","  }  "," ","  let test_buf = TestBuf { remaining: 0 };  ","  _assert_trait_object(&test_buf);  ","  let test_buf = TestBuf { remaining: 0 };  ","  _assert_trait_object(&test_buf);  ","  assert_eq!(test_buf.remaining(), 0);  ","}"],[]],[["{","  struct TestBuf {","      remaining: usize,","  }","  ","  impl crate::buf::buf_impl::Buf for TestBuf {","      fn remaining(&self) -> usize {","          self.remaining","      }","      ","      fn chunk(&self) -> &[u8] {","          &[] // Will cause a panic with remaining instances","      }","      ","      fn advance(&mut self, cnt: usize) {","          self.remaining = self.remaining.saturating_sub(cnt);","      }","  }","  ","  let test_buf = TestBuf { remaining: 0 };","  _assert_trait_object(&test_buf);","  let test_buf = TestBuf { remaining: 0 };","  let result = std::panic::catch_unwind(|| _assert_trait_object(&test_buf));","  assert!(result.unwrap_err().is::<&str>());","}"],[]]]}