{"function_name":"bytes::bytes::promotable_is_unique","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":5,"tests_lines":[24,24,28,30,34],"oracles":5,"oracles_compiled":4,"oracles_compiled_rate":80.0,"tests_compiled":4,"tests_compiled_rate":80.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":9,"lines_covered":8,"lines_coveraged_rate":88.88888888888889,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[1338,1339,1340,1341,1342,1343,1344,1346,1348],"codes_lines_covered":[[["{","    use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};","    ","    struct Shared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let shared_instance = Shared {","        buf: std::ptr::null_mut(),","        cap: 0,","        ref_cnt: AtomicUsize::new(1),","    };","","   let shared_ptr = AtomicPtr::new(&shared_instance as *const Shared as *mut ());","   unsafe {","      let result = promotable_is_unique(&shared_ptr);","   }","   let shared_instance = Shared { buf: std::ptr::null_mut(), cap: 0, ref_cnt: AtomicUsize::new(1) };","  let shared_ptr = AtomicPtr::new(&shared_instance as *const Shared as *mut ());","  let result = unsafe { promotable_is_unique(&shared_ptr) };","   assert_eq!(result, true);","}"],[1338,1339,1340,1341,1342,1343,1344,1348]],[["{","    use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};","    ","    struct Shared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let shared_instance = Shared {","        buf: Box::into_raw(Box::new(0u8)),","        cap: 512,","        ref_cnt: AtomicUsize::new(1),","    };","","  let shared_ptr = AtomicPtr::new(&shared_instance as *const Shared as *mut ());","  let result;","  unsafe {","      result = promotable_is_unique(&shared_ptr);","  }","  ","  unsafe {","      drop(Box::from_raw(shared_instance.buf)); // Clean up the allocated memory","  }","  let shared_instance = Shared { buf: Box::into_raw(Box::new(0u8)), cap: 512, ref_cnt: AtomicUsize::new(1) };","  let shared_ptr = AtomicPtr::new(&shared_instance as *const Shared as *mut ());","   assert_eq!(result, true);","}"],[1338,1339,1340,1341,1342,1343,1344,1348]],[["{","    struct DummyShared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let buffer: Vec<u8> = Vec::with_capacity(10);","    let shared = Box::into_raw(Box::new(DummyShared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.capacity(),","        ref_cnt: AtomicUsize::new(1),","    }));","","    let atomic_ptr = AtomicPtr::new(shared as *mut ());","","    unsafe {","        promotable_is_unique(&atomic_ptr);","    }","","    // Clean up","    unsafe {","        let _ = Box::from_raw(shared);","    }","    let buffer: Vec<u8> = Vec::with_capacity(10);","    let shared = Box::into_raw(Box::new(DummyShared { buf: buffer.as_ptr() as *mut u8, cap: buffer.capacity(), ref_cnt: AtomicUsize::new(1), }));","    let atomic_ptr = AtomicPtr::new(shared as *mut ());","    let result = unsafe { promotable_is_unique(&atomic_ptr) };","    assert_eq!(result, true);","}"],[1338,1339,1340,1341,1342,1343,1344,1348]],[["{","    struct DummyShared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let buffer: Vec<u8> = Vec::with_capacity(20);","    let shared = Box::into_raw(Box::new(DummyShared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.capacity(),","        ref_cnt: AtomicUsize::new(1),","    }));","","    let atomic_ptr = AtomicPtr::new(shared as *mut ());","","    unsafe {","        promotable_is_unique(&atomic_ptr);","    }","","    // Clean up","    unsafe {","        let _ = Box::from_raw(shared);","    }","    let buffer: Vec<u8> = Vec::with_capacity(20);","    let shared = Box::into_raw(Box::new(DummyShared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.capacity(),","    ref_cnt: AtomicUsize::new(1),","    }));","    let atomic_ptr = AtomicPtr::new(shared as *mut ());","    let result = unsafe { promotable_is_unique(&atomic_ptr) };","    assert!(result == true);","}"],[1338,1339,1340,1341,1342,1343,1344,1348]]],"codes_branches":[{"start_line":1342,"start_column":8,"end_line":1342,"end_column":24,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};","    ","    struct Shared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let shared_instance = Shared {","        buf: std::ptr::null_mut(),","        cap: 0,","        ref_cnt: AtomicUsize::new(1),","    };","","   let shared_ptr = AtomicPtr::new(&shared_instance as *const Shared as *mut ());","   unsafe {","      let result = promotable_is_unique(&shared_ptr);","   }","   let shared_instance = Shared { buf: std::ptr::null_mut(), cap: 0, ref_cnt: AtomicUsize::new(1) };","  let shared_ptr = AtomicPtr::new(&shared_instance as *const Shared as *mut ());","  let result = unsafe { promotable_is_unique(&shared_ptr) };","   assert_eq!(result, true);","}"],[{"start_line":1342,"start_column":8,"end_line":1342,"end_column":24,"positive":true,"negative":false}]],[["{","    use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};","    ","    struct Shared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let shared_instance = Shared {","        buf: Box::into_raw(Box::new(0u8)),","        cap: 512,","        ref_cnt: AtomicUsize::new(1),","    };","","  let shared_ptr = AtomicPtr::new(&shared_instance as *const Shared as *mut ());","  let result;","  unsafe {","      result = promotable_is_unique(&shared_ptr);","  }","  ","  unsafe {","      drop(Box::from_raw(shared_instance.buf)); // Clean up the allocated memory","  }","  let shared_instance = Shared { buf: Box::into_raw(Box::new(0u8)), cap: 512, ref_cnt: AtomicUsize::new(1) };","  let shared_ptr = AtomicPtr::new(&shared_instance as *const Shared as *mut ());","   assert_eq!(result, true);","}"],[{"start_line":1342,"start_column":8,"end_line":1342,"end_column":24,"positive":true,"negative":false}]],[["{","    struct DummyShared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let buffer: Vec<u8> = Vec::with_capacity(10);","    let shared = Box::into_raw(Box::new(DummyShared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.capacity(),","        ref_cnt: AtomicUsize::new(1),","    }));","","    let atomic_ptr = AtomicPtr::new(shared as *mut ());","","    unsafe {","        promotable_is_unique(&atomic_ptr);","    }","","    // Clean up","    unsafe {","        let _ = Box::from_raw(shared);","    }","    let buffer: Vec<u8> = Vec::with_capacity(10);","    let shared = Box::into_raw(Box::new(DummyShared { buf: buffer.as_ptr() as *mut u8, cap: buffer.capacity(), ref_cnt: AtomicUsize::new(1), }));","    let atomic_ptr = AtomicPtr::new(shared as *mut ());","    let result = unsafe { promotable_is_unique(&atomic_ptr) };","    assert_eq!(result, true);","}"],[{"start_line":1342,"start_column":8,"end_line":1342,"end_column":24,"positive":true,"negative":false}]],[["{","    struct DummyShared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let buffer: Vec<u8> = Vec::with_capacity(20);","    let shared = Box::into_raw(Box::new(DummyShared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.capacity(),","        ref_cnt: AtomicUsize::new(1),","    }));","","    let atomic_ptr = AtomicPtr::new(shared as *mut ());","","    unsafe {","        promotable_is_unique(&atomic_ptr);","    }","","    // Clean up","    unsafe {","        let _ = Box::from_raw(shared);","    }","    let buffer: Vec<u8> = Vec::with_capacity(20);","    let shared = Box::into_raw(Box::new(DummyShared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.capacity(),","    ref_cnt: AtomicUsize::new(1),","    }));","    let atomic_ptr = AtomicPtr::new(shared as *mut ());","    let result = unsafe { promotable_is_unique(&atomic_ptr) };","    assert!(result == true);","}"],[{"start_line":1342,"start_column":8,"end_line":1342,"end_column":24,"positive":true,"negative":false}]]]}