{"function_name":"bytes::bytes::promotable_to_vec","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":49,"tests_lines":[17,18,18,18,18,18,18,18,18,18,18,18,18,17,46,46,46,46,46,42,42,42,43,43,43,43,27,27,64,64,64,64,26,26,26,26,29,29,29,29,29,29,29,16,25,25,25,25,25],"oracles":13,"oracles_compiled":5,"oracles_compiled_rate":38.46153846153847,"tests_compiled":15,"tests_compiled_rate":30.612244897959183,"oracles_run":5,"oracles_passed":1,"oracles_passed_rate":20.0,"tests_run":15,"tests_passed":3,"tests_passed_rate":20.0,"lines":21,"lines_covered":12,"lines_coveraged_rate":57.14285714285714,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1234,1236,1237,1238,1239,1240,1241,1242,1243,1245],"codes_lines_covered":[[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    // Ensure that the result has the same contents as the original buf","    assert_eq!(result, buf);","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","    buffer: buf.as_mut_ptr(),","    cap: buf.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(len, 10);","}"],[]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    // Ensure that the result has the same contents as the original buf","    assert_eq!(result, buf);","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","    buffer: buf.as_mut_ptr(),","    cap: buf.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(buf.len(), len);","}"],[]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    // Ensure that the result has the same contents as the original buf","    assert_eq!(result, buf);","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","    buffer: buf.as_mut_ptr(),","    cap: buf.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","   let ptr: *mut u8 = buf.as_mut_ptr();","   assert_eq!(buf.as_mut_ptr(), ptr);","}"],[]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    // Ensure that the result has the same contents as the original buf","    assert_eq!(result, buf);","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","    buffer: buf.as_mut_ptr(),","    cap: buf.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(result, buf);","}"],[]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(data.load(Ordering::Acquire) as usize & KIND_MASK, KIND_ARC);","}"],[1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1245]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(len, 0);","}"],[1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1245]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(unsafe { promotable_to_vec(&data, ptr, len, |shared| { let shared_struct = unsafe { &*(shared as *mut TestStruct) }; shared_struct.buffer }) }, buf);","}"],[1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1245]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 1024; // Large length","    let mut buf: Vec<u8> = vec![1; len];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 1024;","    let mut buf: Vec<u8> = vec![1; len];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    let result = unsafe { promotable_to_vec(&data, ptr, len, |shared| { let shared_struct = unsafe { &*(shared as *mut TestStruct) }; shared_struct.buffer }) };","    assert_eq!(result.len(), len);","}"],[]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 1024; // Large length","    let mut buf: Vec<u8> = vec![1; len];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 1024;","    let mut buf: Vec<u8> = vec![1; len];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    let result = unsafe { promotable_to_vec(&data, ptr, len, |shared| { let shared_struct = unsafe { &*(shared as *mut TestStruct) }; shared_struct.buffer }) };","    assert_eq!(result.as_ptr(), buf.as_ptr());","}"],[]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 1024; // Large length","    let mut buf: Vec<u8> = vec![1; len];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 1024;","    let mut buf: Vec<u8> = vec![1; len];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    let result = unsafe { promotable_to_vec(&data, ptr, len, |shared| { let shared_struct = unsafe { &*(shared as *mut TestStruct) }; shared_struct.buffer }) };","    assert!(result.iter().all(|&x| x == 1));","}"],[]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 1024; // Large length","    let mut buf: Vec<u8> = vec![1; len];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 1024;","    let mut buf: Vec<u8> = vec![1; len];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    let result = unsafe { promotable_to_vec(&data, ptr, len, |shared| { let shared_struct = unsafe { &*(shared as *mut TestStruct) }; shared_struct.buffer }) };","    assert!(data.load(Ordering::Acquire).is_null());","}"],[]],[["{","  let len: usize = 1;  ","  let ptr: *const u8 = std::ptr::null_mut();  ","  ","  let data = AtomicPtr::new(std::ptr::null_mut());  ","  ","  let _result = unsafe {  ","      promotable_to_vec(  ","          &data,  ","          ptr,  ","          len,  ","         |shared| std::ptr::null_mut(), // Invalid function pointer  ","      )  ","  };  ","  let len: usize = 1;  ","  // Removed redundant declaration of `ptr` since it's already declared.  ","  let data = AtomicPtr::new(std::ptr::null_mut());  ","   let result = unsafe {  ","   promotable_to_vec(  ","   &data,  ","   ptr,  ","   len,  ","  |shared| std::ptr::null_mut(),  ","   )  ","   };  ","   assert_eq!(len, result.len());  ","}"],[]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","   let len: usize = 5;","   let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];","   let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];","","    let mut shared1 = Box::new(TestStruct {","        buffer: buf1.as_mut_ptr(),","        cap: buf1.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let mut shared2 = Box::new(TestStruct {","        buffer: buf2.as_mut_ptr(),","        cap: buf2.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","","    let result1 = unsafe {","        promotable_to_vec(","            &data1,","            buf1.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    let result2 = unsafe {","        promotable_to_vec(","            &data2,","            buf2.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result1, buf1);","    assert_eq!(result2, buf2);","    let len: usize = 5;","   let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];","   let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];","   let shared1 = Box::new(TestStruct { buffer: buf1.as_mut_ptr(), cap: buf1.len(), ref_cnt: AtomicUsize::new(1), });","    let shared2 = Box::new(TestStruct { buffer: buf2.as_mut_ptr(), cap: buf2.len(), ref_cnt: AtomicUsize::new(1), });","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","    assert_eq!(result1.as_slice(), buf1.as_slice());","}"],[]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 5;","    let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];","   let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];  "," ","   let mut shared1 = Box::new(TestStruct {  ","       buffer: buf1.as_mut_ptr(),  ","       cap: buf1.len(),  ","       ref_cnt: AtomicUsize::new(1),  ","   });  "," ","   let shared2 = Box::new(TestStruct {  ","       buffer: buf2.as_mut_ptr(),  ","       cap: buf2.len(),  ","       ref_cnt: AtomicUsize::new(1),  ","   });  ","","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","","    let result1 = unsafe {","        promotable_to_vec(","            &data1,","            buf1.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    let result2 = unsafe {","        promotable_to_vec(","            &data2,","            buf2.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result1, buf1);","    assert_eq!(result2, buf2);","    let len: usize = 5;","   let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];  ","   let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];  ","   let shared1 = Box::new(TestStruct { buffer: buf1.as_mut_ptr(), cap: buf1.len(), ref_cnt: AtomicUsize::new(1), });  ","   let shared2 = Box::new(TestStruct { buffer: buf2.as_mut_ptr(), cap: buf2.len(), ref_cnt: AtomicUsize::new(1), });  ","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","    assert_eq!(result2.as_slice(), buf2.as_slice());","}"],[]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 5;","    let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];","    let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];","","    let mut shared1 = Box::new(TestStruct {","        buffer: buf1.as_mut_ptr(),","        cap: buf1.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let mut shared2 = Box::new(TestStruct {","        buffer: buf2.as_mut_ptr(),","        cap: buf2.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","","    let result1 = unsafe {","        promotable_to_vec(","            &data1,","            buf1.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    let result2 = unsafe {","        promotable_to_vec(","            &data2,","            buf2.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result1, buf1);","    assert_eq!(result2, buf2);","    let len: usize = 5;","   let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];  ","   let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];  ","   let shared1 = Box::new(TestStruct { buffer: buf1.as_mut_ptr(), cap: buf1.len(), ref_cnt: AtomicUsize::new(1), });  ","   let shared2 = Box::new(TestStruct { buffer: buf2.as_mut_ptr(), cap: buf2.len(), ref_cnt: AtomicUsize::new(1), });  ","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","    assert_eq!(data2.load(Ordering::Acquire) as usize & KIND_MASK, KIND_VEC);","}"],[]]],"codes_branches":[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    // Ensure that the result has the same contents as the original buf","    assert_eq!(result, buf);","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","    buffer: buf.as_mut_ptr(),","    cap: buf.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(len, 10);","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    // Ensure that the result has the same contents as the original buf","    assert_eq!(result, buf);","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","    buffer: buf.as_mut_ptr(),","    cap: buf.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(buf.len(), len);","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    // Ensure that the result has the same contents as the original buf","    assert_eq!(result, buf);","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","    buffer: buf.as_mut_ptr(),","    cap: buf.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","   let ptr: *mut u8 = buf.as_mut_ptr();","   assert_eq!(buf.as_mut_ptr(), ptr);","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    // Ensure that the result has the same contents as the original buf","    assert_eq!(result, buf);","    let len: usize = 10;","    let mut buf: Vec<u8> = vec![0; len];","    let mut shared = Box::new(TestStruct {","    buffer: buf.as_mut_ptr(),","    cap: buf.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(result, buf);","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(data.load(Ordering::Acquire) as usize & KIND_MASK, KIND_ARC);","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":true,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(len, 0);","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":true,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 0;","    let mut buf: Vec<u8> = vec![];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    assert_eq!(unsafe { promotable_to_vec(&data, ptr, len, |shared| { let shared_struct = unsafe { &*(shared as *mut TestStruct) }; shared_struct.buffer }) }, buf);","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":true,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 1024; // Large length","    let mut buf: Vec<u8> = vec![1; len];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 1024;","    let mut buf: Vec<u8> = vec![1; len];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    let result = unsafe { promotable_to_vec(&data, ptr, len, |shared| { let shared_struct = unsafe { &*(shared as *mut TestStruct) }; shared_struct.buffer }) };","    assert_eq!(result.len(), len);","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 1024; // Large length","    let mut buf: Vec<u8> = vec![1; len];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 1024;","    let mut buf: Vec<u8> = vec![1; len];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    let result = unsafe { promotable_to_vec(&data, ptr, len, |shared| { let shared_struct = unsafe { &*(shared as *mut TestStruct) }; shared_struct.buffer }) };","    assert_eq!(result.as_ptr(), buf.as_ptr());","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 1024; // Large length","    let mut buf: Vec<u8> = vec![1; len];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 1024;","    let mut buf: Vec<u8> = vec![1; len];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    let result = unsafe { promotable_to_vec(&data, ptr, len, |shared| { let shared_struct = unsafe { &*(shared as *mut TestStruct) }; shared_struct.buffer }) };","    assert!(result.iter().all(|&x| x == 1));","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 1024; // Large length","    let mut buf: Vec<u8> = vec![1; len];","","    let mut shared = Box::new(TestStruct {","        buffer: buf.as_mut_ptr(),","        cap: buf.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","","    let result = unsafe {","        promotable_to_vec(","            &data,","            ptr,","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result, buf);","    let len: usize = 1024;","    let mut buf: Vec<u8> = vec![1; len];","    let mut shared = Box::new(TestStruct { buffer: buf.as_mut_ptr(), cap: buf.len(), ref_cnt: AtomicUsize::new(1), });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = buf.as_ptr();","    let result = unsafe { promotable_to_vec(&data, ptr, len, |shared| { let shared_struct = unsafe { &*(shared as *mut TestStruct) }; shared_struct.buffer }) };","    assert!(data.load(Ordering::Acquire).is_null());","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","  let len: usize = 1;  ","  let ptr: *const u8 = std::ptr::null_mut();  ","  ","  let data = AtomicPtr::new(std::ptr::null_mut());  ","  ","  let _result = unsafe {  ","      promotable_to_vec(  ","          &data,  ","          ptr,  ","          len,  ","         |shared| std::ptr::null_mut(), // Invalid function pointer  ","      )  ","  };  ","  let len: usize = 1;  ","  // Removed redundant declaration of `ptr` since it's already declared.  ","  let data = AtomicPtr::new(std::ptr::null_mut());  ","   let result = unsafe {  ","   promotable_to_vec(  ","   &data,  ","   ptr,  ","   len,  ","  |shared| std::ptr::null_mut(),  ","   )  ","   };  ","   assert_eq!(len, result.len());  ","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","   let len: usize = 5;","   let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];","   let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];","","    let mut shared1 = Box::new(TestStruct {","        buffer: buf1.as_mut_ptr(),","        cap: buf1.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let mut shared2 = Box::new(TestStruct {","        buffer: buf2.as_mut_ptr(),","        cap: buf2.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","","    let result1 = unsafe {","        promotable_to_vec(","            &data1,","            buf1.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    let result2 = unsafe {","        promotable_to_vec(","            &data2,","            buf2.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result1, buf1);","    assert_eq!(result2, buf2);","    let len: usize = 5;","   let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];","   let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];","   let shared1 = Box::new(TestStruct { buffer: buf1.as_mut_ptr(), cap: buf1.len(), ref_cnt: AtomicUsize::new(1), });","    let shared2 = Box::new(TestStruct { buffer: buf2.as_mut_ptr(), cap: buf2.len(), ref_cnt: AtomicUsize::new(1), });","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","    assert_eq!(result1.as_slice(), buf1.as_slice());","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 5;","    let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];","   let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];  "," ","   let mut shared1 = Box::new(TestStruct {  ","       buffer: buf1.as_mut_ptr(),  ","       cap: buf1.len(),  ","       ref_cnt: AtomicUsize::new(1),  ","   });  "," ","   let shared2 = Box::new(TestStruct {  ","       buffer: buf2.as_mut_ptr(),  ","       cap: buf2.len(),  ","       ref_cnt: AtomicUsize::new(1),  ","   });  ","","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","","    let result1 = unsafe {","        promotable_to_vec(","            &data1,","            buf1.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    let result2 = unsafe {","        promotable_to_vec(","            &data2,","            buf2.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result1, buf1);","    assert_eq!(result2, buf2);","    let len: usize = 5;","   let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];  ","   let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];  ","   let shared1 = Box::new(TestStruct { buffer: buf1.as_mut_ptr(), cap: buf1.len(), ref_cnt: AtomicUsize::new(1), });  ","   let shared2 = Box::new(TestStruct { buffer: buf2.as_mut_ptr(), cap: buf2.len(), ref_cnt: AtomicUsize::new(1), });  ","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","    assert_eq!(result2.as_slice(), buf2.as_slice());","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]],[["{","    use std::mem::MaybeUninit;","    use std::ptr::null_mut;","","    struct TestStruct {","        buffer: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let len: usize = 5;","    let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];","    let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];","","    let mut shared1 = Box::new(TestStruct {","        buffer: buf1.as_mut_ptr(),","        cap: buf1.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let mut shared2 = Box::new(TestStruct {","        buffer: buf2.as_mut_ptr(),","        cap: buf2.len(),","        ref_cnt: AtomicUsize::new(1),","    });","","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","","    let result1 = unsafe {","        promotable_to_vec(","            &data1,","            buf1.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    let result2 = unsafe {","        promotable_to_vec(","            &data2,","            buf2.as_ptr(),","            len,","            |shared| {","                let shared_struct = unsafe { &*(shared as *mut TestStruct) };","                shared_struct.buffer","            },","        )","    };","","    assert_eq!(result1, buf1);","    assert_eq!(result2, buf2);","    let len: usize = 5;","   let mut buf1: Vec<u8> = vec![1, 2, 3, 4, 5];  ","   let mut buf2: Vec<u8> = vec![6, 7, 8, 9, 10];  ","   let shared1 = Box::new(TestStruct { buffer: buf1.as_mut_ptr(), cap: buf1.len(), ref_cnt: AtomicUsize::new(1), });  ","   let shared2 = Box::new(TestStruct { buffer: buf2.as_mut_ptr(), cap: buf2.len(), ref_cnt: AtomicUsize::new(1), });  ","    let data1 = AtomicPtr::new(Box::into_raw(shared1) as *mut ());","    let data2 = AtomicPtr::new(Box::into_raw(shared2) as *mut ());","    assert_eq!(data2.load(Ordering::Acquire) as usize & KIND_MASK, KIND_VEC);","}"],[{"start_line":1230,"start_column":8,"end_line":1230,"end_column":24,"positive":false,"negative":false}]]]}