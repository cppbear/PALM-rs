{"function_name":"bytes::bytes::bytes::Bytes::with_vtable","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":20,"tests_lines":[11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,10,10],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":12,"tests_compiled_rate":60.0,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":12,"tests_passed":10,"tests_passed_rate":83.33333333333334,"lines":13,"lines_covered":13,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[650,651,652,653,654,655,656,657,658,659,660,661,662],"codes_lines_covered":[[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x1 as *const u8; // Non-null pointer","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x1 as *const u8; // Non-null pointer","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.ptr, ptr);","}"],[650,651,652,653,654,655,656,657,658,659,660,661,662]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x1 as *const u8; // Non-null pointer","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x1 as *const u8; // Non-null pointer","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.len, len);","}"],[650,651,652,653,654,655,656,657,658,659,660,661,662]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x2 as *const u8; // Non-null pointer","    let len = 0; // Length is zero","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x2 as *const u8;","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.ptr, ptr);","}"],[650,651,652,653,654,655,656,657,658,659,660,661,662]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x2 as *const u8; // Non-null pointer","    let len = 0; // Length is zero","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x2 as *const u8;","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.len, len);","}"],[650,651,652,653,654,655,656,657,658,659,660,661,662]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x3 as *const u8; // Non-null pointer","    let len = 1; // Length is small","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let ptr = 0x3 as *const u8;","    let len = 1;","    let data = AtomicPtr::new(ptr::null_mut());","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.ptr, ptr);","}"],[650,651,652,653,654,655,656,657,658,659,660,661,662]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x3 as *const u8; // Non-null pointer","    let len = 1; // Length is small","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let ptr = 0x3 as *const u8;","    let len = 1;","    let data = AtomicPtr::new(ptr::null_mut());","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.len, len);","}"],[650,651,652,653,654,655,656,657,658,659,660,661,662]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x3 as *const u8; // Non-null pointer","    let len = 1; // Length is small","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let ptr = 0x3 as *const u8;","    let len = 1;","    let data = AtomicPtr::new(ptr::null_mut());","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert!(result.data.load(Ordering::SeqCst).is_null());","}"],[650,651,652,653,654,655,656,657,658,659,660,661,662]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8; // Non-null pointer","    let len = usize::MAX; // Maximum length","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8;","    let len = usize::MAX;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.ptr, ptr);","}"],[650,651,652,653,654,655,656,657,658,659,660,661,662]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8; // Non-null pointer","    let len = usize::MAX; // Maximum length","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8;","    let len = usize::MAX;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.len, len);","}"],[650,651,652,653,654,655,656,657,658,659,660,661,662]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8; // Non-null pointer","    let len = usize::MAX; // Maximum length","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8;","    let len = usize::MAX;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.data.load(Ordering::SeqCst), ptr::null_mut());","}"],[650,651,652,653,654,655,656,657,658,659,660,661,662]],[["{","   let data: AtomicPtr<()/* Specify the appropriate type here */> = AtomicPtr::new(ptr::null_mut());","   let ptr = 0x5 as *const u8; // Non-null pointer","   let len = 10; // Arbitrary valid length","   let result = unsafe { Bytes::with_vtable(ptr, len, data, &OWNED_VTABLE) };","   let data: AtomicPtr<()/* Specify the appropriate type here */> = AtomicPtr::new(ptr::null_mut());","   let ptr = 0x5 as *const u8;","   let len = 10;","   assert_eq!(result.ptr, ptr);","}"],[]],[["{","   let data: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());","   let ptr = 0x5 as *const u8; // Non-null pointer","   let len = 10; // Arbitrary valid length","   let result = unsafe { Bytes::with_vtable(ptr, len, data, &OWNED_VTABLE) };","   let data: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());","   let ptr = 0x5 as *const u8;","   let len = 10;","   assert_eq!(result.len, len);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x1 as *const u8; // Non-null pointer","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x1 as *const u8; // Non-null pointer","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.ptr, ptr);","}"],[]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x1 as *const u8; // Non-null pointer","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x1 as *const u8; // Non-null pointer","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.len, len);","}"],[]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x2 as *const u8; // Non-null pointer","    let len = 0; // Length is zero","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x2 as *const u8;","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.ptr, ptr);","}"],[]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x2 as *const u8; // Non-null pointer","    let len = 0; // Length is zero","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x2 as *const u8;","    let len = 0;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.len, len);","}"],[]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x3 as *const u8; // Non-null pointer","    let len = 1; // Length is small","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let ptr = 0x3 as *const u8;","    let len = 1;","    let data = AtomicPtr::new(ptr::null_mut());","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.ptr, ptr);","}"],[]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x3 as *const u8; // Non-null pointer","    let len = 1; // Length is small","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let ptr = 0x3 as *const u8;","    let len = 1;","    let data = AtomicPtr::new(ptr::null_mut());","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.len, len);","}"],[]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x3 as *const u8; // Non-null pointer","    let len = 1; // Length is small","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let ptr = 0x3 as *const u8;","    let len = 1;","    let data = AtomicPtr::new(ptr::null_mut());","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert!(result.data.load(Ordering::SeqCst).is_null());","}"],[]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8; // Non-null pointer","    let len = usize::MAX; // Maximum length","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8;","    let len = usize::MAX;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.ptr, ptr);","}"],[]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8; // Non-null pointer","    let len = usize::MAX; // Maximum length","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8;","    let len = usize::MAX;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.len, len);","}"],[]],[["{","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8; // Non-null pointer","    let len = usize::MAX; // Maximum length","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    let data = AtomicPtr::new(ptr::null_mut());","    let ptr = 0x4 as *const u8;","    let len = usize::MAX;","    let result = unsafe { Bytes::with_vtable(ptr, len, data, &STATIC_VTABLE) };","    assert_eq!(result.data.load(Ordering::SeqCst), ptr::null_mut());","}"],[]],[["{","   let data: AtomicPtr<()/* Specify the appropriate type here */> = AtomicPtr::new(ptr::null_mut());","   let ptr = 0x5 as *const u8; // Non-null pointer","   let len = 10; // Arbitrary valid length","   let result = unsafe { Bytes::with_vtable(ptr, len, data, &OWNED_VTABLE) };","   let data: AtomicPtr<()/* Specify the appropriate type here */> = AtomicPtr::new(ptr::null_mut());","   let ptr = 0x5 as *const u8;","   let len = 10;","   assert_eq!(result.ptr, ptr);","}"],[]],[["{","   let data: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());","   let ptr = 0x5 as *const u8; // Non-null pointer","   let len = 10; // Arbitrary valid length","   let result = unsafe { Bytes::with_vtable(ptr, len, data, &OWNED_VTABLE) };","   let data: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());","   let ptr = 0x5 as *const u8;","   let len = 10;","   assert_eq!(result.len, len);","}"],[]]]}