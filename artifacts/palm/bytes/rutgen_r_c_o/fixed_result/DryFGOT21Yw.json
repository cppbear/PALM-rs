{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::get_vec_pos","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes_mut.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":13,"tests_lines":[15,17,16,14,11,11,11,11,11,11,11,11,17],"oracles":8,"oracles_compiled":6,"oracles_compiled_rate":75.0,"tests_compiled":11,"tests_compiled_rate":84.61538461538461,"oracles_run":6,"oracles_passed":1,"oracles_passed_rate":16.666666666666664,"tests_run":11,"tests_passed":3,"tests_passed_rate":27.27272727272727,"lines":4,"lines_covered":2,"lines_coveraged_rate":50.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1069,1070,1072,1073],"codes_lines_covered":[[["{","   let mut bytes_mut = BytesMut::with_capacity(1);","   unsafe { bytes_mut.set_len(1) };","   let data_addr = (&mut bytes_mut as *mut _ as usize) | KIND_VEC; // make it KIND_VEC","   bytes_mut.data = data_addr as *mut Shared;","   let result;","   unsafe {","       result = bytes_mut.get_vec_pos();","   }","   let mut bytes_mut = BytesMut::with_capacity(1);","   unsafe { bytes_mut.set_len(1) };","   let data_addr = (&mut bytes_mut as *mut _ as usize) | KIND_VEC; // make it KIND_VEC","   bytes_mut.data = data_addr as *mut Shared;","   let expected = data_addr >> VEC_POS_OFFSET;","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(1);","    unsafe { bytes_mut.set_len(1) };","    let data_addr = ((usize::MAX >> VEC_POS_OFFSET) << VEC_POS_OFFSET) | KIND_VEC; // ensure it's within bounds","    bytes_mut.data = data_addr as *mut Shared;","    unsafe {","   let result = bytes_mut.get_vec_pos();","   }","   let mut bytes_mut = BytesMut::with_capacity(1);","   unsafe { bytes_mut.set_len(1) };","   let data_addr = ((usize::MAX >> VEC_POS_OFFSET) << VEC_POS_OFFSET) | KIND_VEC;","   bytes_mut.data = data_addr as *mut Shared;","   unsafe {","       let result = bytes_mut.get_vec_pos();","       assert_eq!(result, usize::MAX >> VEC_POS_OFFSET);","   }","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe {","        bytes_mut.set_vec_pos(32);","        let result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.set_vec_pos(32); }","    let result = unsafe { bytes_mut.get_vec_pos() };","    assert_eq!(result, 32 >> VEC_POS_OFFSET);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe {","        bytes_mut.set_vec_pos(32);","        let result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.set_vec_pos(32); }","    let result = unsafe { bytes_mut.get_vec_pos() };","    assert!(bytes_mut.kind() == KIND_VEC);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe {","        bytes_mut.set_vec_pos(32);","        let result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.set_vec_pos(32); }","    let result = unsafe { bytes_mut.get_vec_pos() };","    assert!(result != 0);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe {","        bytes_mut.set_vec_pos(32);","        let result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.set_vec_pos(32); }","    let result = unsafe { bytes_mut.get_vec_pos() };","    assert!(result & NOT_VEC_POS_MASK == 0);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe {","        bytes_mut.set_vec_pos(usize::MAX >> VEC_POS_OFFSET);","        let result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.set_vec_pos(usize::MAX >> VEC_POS_OFFSET); }","    let result = unsafe { bytes_mut.get_vec_pos() };","    assert!(result != usize::MAX >> VEC_POS_OFFSET);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    // Directly manipulating the kind for testing","    unsafe {","        bytes_mut.promote_to_shared(1); // This will set it to a non-KIND_VEC","        let _result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.promote_to_shared(1); }","    assert_eq!(bytes_mut.kind(), KIND_ARC);","}"],[1069,1070]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    // Directly manipulating the kind for testing","    unsafe {","        bytes_mut.promote_to_shared(1); // This will set it to a non-KIND_VEC","        let _result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.promote_to_shared(1); }","    assert_ne!(bytes_mut.kind(), KIND_VEC);","}"],[1069,1070]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    // Directly manipulating the kind for testing","    unsafe {","        bytes_mut.promote_to_shared(1); // This will set it to a non-KIND_VEC","        let _result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.promote_to_shared(1); }","    assert!(std::panic::catch_unwind(|| { unsafe { bytes_mut.get_vec_pos(); } }).is_err());","}"],[1069,1070]],[["{","   let mut bytes_mut1 = BytesMut::with_capacity(16);  ","   let mut bytes_mut2 = BytesMut::with_capacity(16);  "," ","   let result1;  ","   let result2;  ","   unsafe {  ","       bytes_mut1.set_vec_pos(10);  ","       result1 = bytes_mut1.get_vec_pos();  "," ","       bytes_mut2.set_vec_pos(20);  ","       result2 = bytes_mut2.get_vec_pos();  ","   }  ","   unsafe { bytes_mut1.set_vec_pos(10); }  ","   unsafe { bytes_mut2.set_vec_pos(20); }  ","   assert!(result1 != result2);  ","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","   let mut bytes_mut = BytesMut::with_capacity(1);","   unsafe { bytes_mut.set_len(1) };","   let data_addr = (&mut bytes_mut as *mut _ as usize) | KIND_VEC; // make it KIND_VEC","   bytes_mut.data = data_addr as *mut Shared;","   let result;","   unsafe {","       result = bytes_mut.get_vec_pos();","   }","   let mut bytes_mut = BytesMut::with_capacity(1);","   unsafe { bytes_mut.set_len(1) };","   let data_addr = (&mut bytes_mut as *mut _ as usize) | KIND_VEC; // make it KIND_VEC","   bytes_mut.data = data_addr as *mut Shared;","   let expected = data_addr >> VEC_POS_OFFSET;","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(1);","    unsafe { bytes_mut.set_len(1) };","    let data_addr = ((usize::MAX >> VEC_POS_OFFSET) << VEC_POS_OFFSET) | KIND_VEC; // ensure it's within bounds","    bytes_mut.data = data_addr as *mut Shared;","    unsafe {","   let result = bytes_mut.get_vec_pos();","   }","   let mut bytes_mut = BytesMut::with_capacity(1);","   unsafe { bytes_mut.set_len(1) };","   let data_addr = ((usize::MAX >> VEC_POS_OFFSET) << VEC_POS_OFFSET) | KIND_VEC;","   bytes_mut.data = data_addr as *mut Shared;","   unsafe {","       let result = bytes_mut.get_vec_pos();","       assert_eq!(result, usize::MAX >> VEC_POS_OFFSET);","   }","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe {","        bytes_mut.set_vec_pos(32);","        let result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.set_vec_pos(32); }","    let result = unsafe { bytes_mut.get_vec_pos() };","    assert_eq!(result, 32 >> VEC_POS_OFFSET);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe {","        bytes_mut.set_vec_pos(32);","        let result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.set_vec_pos(32); }","    let result = unsafe { bytes_mut.get_vec_pos() };","    assert!(bytes_mut.kind() == KIND_VEC);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe {","        bytes_mut.set_vec_pos(32);","        let result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.set_vec_pos(32); }","    let result = unsafe { bytes_mut.get_vec_pos() };","    assert!(result != 0);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe {","        bytes_mut.set_vec_pos(32);","        let result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.set_vec_pos(32); }","    let result = unsafe { bytes_mut.get_vec_pos() };","    assert!(result & NOT_VEC_POS_MASK == 0);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe {","        bytes_mut.set_vec_pos(usize::MAX >> VEC_POS_OFFSET);","        let result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.set_vec_pos(usize::MAX >> VEC_POS_OFFSET); }","    let result = unsafe { bytes_mut.get_vec_pos() };","    assert!(result != usize::MAX >> VEC_POS_OFFSET);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    // Directly manipulating the kind for testing","    unsafe {","        bytes_mut.promote_to_shared(1); // This will set it to a non-KIND_VEC","        let _result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.promote_to_shared(1); }","    assert_eq!(bytes_mut.kind(), KIND_ARC);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    // Directly manipulating the kind for testing","    unsafe {","        bytes_mut.promote_to_shared(1); // This will set it to a non-KIND_VEC","        let _result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.promote_to_shared(1); }","    assert_ne!(bytes_mut.kind(), KIND_VEC);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(16);","    // Directly manipulating the kind for testing","    unsafe {","        bytes_mut.promote_to_shared(1); // This will set it to a non-KIND_VEC","        let _result = bytes_mut.get_vec_pos();","    }","    let mut bytes_mut = BytesMut::with_capacity(16);","    unsafe { bytes_mut.promote_to_shared(1); }","    assert!(std::panic::catch_unwind(|| { unsafe { bytes_mut.get_vec_pos(); } }).is_err());","}"],[]],[["{","   let mut bytes_mut1 = BytesMut::with_capacity(16);  ","   let mut bytes_mut2 = BytesMut::with_capacity(16);  "," ","   let result1;  ","   let result2;  ","   unsafe {  ","       bytes_mut1.set_vec_pos(10);  ","       result1 = bytes_mut1.get_vec_pos();  "," ","       bytes_mut2.set_vec_pos(20);  ","       result2 = bytes_mut2.get_vec_pos();  ","   }  ","   unsafe { bytes_mut1.set_vec_pos(10); }  ","   unsafe { bytes_mut2.set_vec_pos(20); }  ","   assert!(result1 != result2);  ","}"],[]]]}