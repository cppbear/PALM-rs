{"function_name":"bytes::buf::take::buf::take::Take<T>::get_ref","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/buf/take.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":8,"tests_lines":[19,19,19,19,19,18,18,18],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":8,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":8,"tests_passed":6,"tests_passed_rate":75.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[59,60,61],"codes_lines_covered":[[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![1, 2, 3, 4, 5] };","    let take = Take { inner, limit: 5 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![1, 2, 3, 4, 5] };","    let take = Take { inner, limit: 5 };","    let ref_val = take.get_ref();","    assert_eq!(ref_val.remaining(), 5);","}"],[59,60,61]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![] };","    let take = Take { inner, limit: 0 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![1, 2, 3] };","    let take = Take { inner, limit: 3 };","    let result = take.get_ref();","    assert_eq!(result.remaining(), 3);","}"],[59,60,61]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![] };","    let take = Take { inner, limit: 0 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![1, 2, 3] };","    let take = Take { inner, limit: 3 };","    let result = take.get_ref();","    assert_eq!(result.data.len(), 3);","}"],[59,60,61]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![] };","    let take = Take { inner, limit: 0 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![1, 2, 3] };","    let take = Take { inner, limit: 3 };","    let result = take.get_ref();","    assert_eq!(take.get_ref() as *const _ != &take.inner as *const _, true);","}"],[59,60,61]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![0;usize::MAX] };","    let take = Take { inner, limit: usize::MAX };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![0; usize::MAX] };","    let take = Take { inner, limit: usize::MAX };","    let result_ref = take.get_ref();","    assert_eq!(result_ref.remaining(), usize::MAX);","}"],[]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    assert_eq!(take.get_ref().remaining(), 1);","}"],[59,60,61]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    assert_eq!(take.limit(), 1);","}"],[59,60,61]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    assert!(take.get_ref().data.len() > 0);","}"],[59,60,61]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![1, 2, 3, 4, 5] };","    let take = Take { inner, limit: 5 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![1, 2, 3, 4, 5] };","    let take = Take { inner, limit: 5 };","    let ref_val = take.get_ref();","    assert_eq!(ref_val.remaining(), 5);","}"],[]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![] };","    let take = Take { inner, limit: 0 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![1, 2, 3] };","    let take = Take { inner, limit: 3 };","    let result = take.get_ref();","    assert_eq!(result.remaining(), 3);","}"],[]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![] };","    let take = Take { inner, limit: 0 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![1, 2, 3] };","    let take = Take { inner, limit: 3 };","    let result = take.get_ref();","    assert_eq!(result.data.len(), 3);","}"],[]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![] };","    let take = Take { inner, limit: 0 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![1, 2, 3] };","    let take = Take { inner, limit: 3 };","    let result = take.get_ref();","    assert_eq!(take.get_ref() as *const _ != &take.inner as *const _, true);","}"],[]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![0;usize::MAX] };","    let take = Take { inner, limit: usize::MAX };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![0; usize::MAX] };","    let take = Take { inner, limit: usize::MAX };","    let result_ref = take.get_ref();","    assert_eq!(result_ref.remaining(), usize::MAX);","}"],[]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    assert_eq!(take.get_ref().remaining(), 1);","}"],[]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    assert_eq!(take.limit(), 1);","}"],[]],[["{","    struct InnerBuf {","        data: Vec<u8>,","    }","","    impl InnerBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","    }","","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    let _ = take.get_ref();","    let inner = InnerBuf { data: vec![42] };","    let take = Take { inner, limit: 1 };","    assert!(take.get_ref().data.len() > 0);","}"],[]]]}