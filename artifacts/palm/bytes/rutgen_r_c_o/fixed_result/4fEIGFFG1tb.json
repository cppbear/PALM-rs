{"function_name":"bytes::bytes::bytes::Bytes::from_owner","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":34,"tests_lines":[14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":31,"tests_compiled_rate":91.17647058823529,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":31,"tests_passed":20,"tests_passed_rate":64.51612903225806,"lines":40,"lines_covered":40,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290],"codes_lines_covered":[[["{","    struct OwnerEmpty;","","    impl AsRef<[u8]> for OwnerEmpty {","        fn as_ref(&self) -> &[u8] {","            &[]","        }","    }","","    let owner = OwnerEmpty;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerEmpty;","    assert!(bytes.ptr != ptr::null());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerEmpty;","","    impl AsRef<[u8]> for OwnerEmpty {","        fn as_ref(&self) -> &[u8] {","            &[]","        }","    }","","    let owner = OwnerEmpty;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerEmpty;","    assert_eq!(bytes.len, 0);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerEmpty;","","    impl AsRef<[u8]> for OwnerEmpty {","        fn as_ref(&self) -> &[u8] {","            &[]","        }","    }","","    let owner = OwnerEmpty;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerEmpty;","    assert!(bytes.is_unique());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerEmpty;","","    impl AsRef<[u8]> for OwnerEmpty {","        fn as_ref(&self) -> &[u8] {","            &[]","        }","    }","","    let owner = OwnerEmpty;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerEmpty;","    assert!(bytes.is_empty());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerSmall;","","    impl AsRef<[u8]> for OwnerSmall {","        fn as_ref(&self) -> &[u8] {","            b\"small\"","        }","    }","","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.len(), 5);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerSmall;","","    impl AsRef<[u8]> for OwnerSmall {","        fn as_ref(&self) -> &[u8] {","            b\"small\"","        }","    }","","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.as_slice(), b\"small\");","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerSmall;","","    impl AsRef<[u8]> for OwnerSmall {","        fn as_ref(&self) -> &[u8] {","            b\"small\"","        }","    }","","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    assert!(!bytes.is_empty());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerSmall;","","    impl AsRef<[u8]> for OwnerSmall {","        fn as_ref(&self) -> &[u8] {","            b\"small\"","        }","    }","","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    assert!(bytes.is_unique());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerLarge;","","    impl AsRef<[u8]> for OwnerLarge {","        fn as_ref(&self) -> &[u8] {","            b\"this is a considerably larger buffer to test the from_owner functionality\"","        }","    }","","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.len(), 75);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerLarge;","","    impl AsRef<[u8]> for OwnerLarge {","        fn as_ref(&self) -> &[u8] {","            b\"this is a considerably larger buffer to test the from_owner functionality\"","        }","    }","","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(unsafe { core::slice::from_raw_parts(bytes.ptr, bytes.len) }, b\"this is a considerably larger buffer to test the from_owner functionality\");","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerLarge;","","    impl AsRef<[u8]> for OwnerLarge {","        fn as_ref(&self) -> &[u8] {","            b\"this is a considerably larger buffer to test the from_owner functionality\"","        }","    }","","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    assert!(!bytes.data.load(Ordering::Relaxed).is_null());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerLarge;","","    impl AsRef<[u8]> for OwnerLarge {","        fn as_ref(&self) -> &[u8] {","            b\"this is a considerably larger buffer to test the from_owner functionality\"","        }","    }","","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    assert!(bytes.is_unique());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerMultiple;","","    impl AsRef<[u8]> for OwnerMultiple {","        fn as_ref(&self) -> &[u8] {","            b\"multiple bytes are definitely better than one\"","        }","    }","","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.len(), 40);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerMultiple;","","    impl AsRef<[u8]> for OwnerMultiple {","        fn as_ref(&self) -> &[u8] {","            b\"multiple bytes are definitely better than one\"","        }","    }","","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.is_empty(), false);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerMultiple;","","    impl AsRef<[u8]> for OwnerMultiple {","        fn as_ref(&self) -> &[u8] {","            b\"multiple bytes are definitely better than one\"","        }","    }","","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.ptr as usize, bytes.data.load(Ordering::SeqCst) as usize);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerMultiple;","","    impl AsRef<[u8]> for OwnerMultiple {","        fn as_ref(&self) -> &[u8] {","            b\"multiple bytes are definitely better than one\"","        }","    }","","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    assert!(bytes.is_unique());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerMultiple;","","    impl AsRef<[u8]> for OwnerMultiple {","        fn as_ref(&self) -> &[u8] {","            b\"multiple bytes are definitely better than one\"","        }","    }","","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(unsafe { slice::from_raw_parts(bytes.ptr, bytes.len) }, b\"multiple bytes are definitely better than one\");","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(owner_bytes.len(), 4);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(owner_bytes[0], 0xF0);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(owner_bytes[1], 0x9F);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(owner_bytes[2], 0x98);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(owner_bytes[3], 0x81);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert!(!bytes.is_empty());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert!(bytes.is_unique());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(bytes.len(), 4);","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(bytes.ptr, owner_bytes.as_ptr());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","   struct OwnerMaxSize;  "," ","   impl AsRef<[u8]> for OwnerMaxSize {  ","       fn as_ref(&self) -> &[u8] {  ","           static DATA: [u8; 8] = [0; 8];  ","           &DATA  ","       }  ","   }  "," ","   let owner = OwnerMaxSize;  ","   let bytes = Bytes::from_owner(owner);  ","   let owner = OwnerMaxSize;  ","   let bytes = Bytes::from_owner(owner);  ","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","   struct OwnerMaxSize;  "," ","   impl AsRef<[u8]> for OwnerMaxSize {  ","       fn as_ref(&self) -> &[u8] {  ","           Box::leak(vec![0; usize::MAX].into_boxed_slice())  ","       }  ","    }","","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    assert!(!bytes.ptr.is_null());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerMaxSize;","","   impl AsRef<[u8]> for OwnerMaxSize {  ","       fn as_ref(&self) -> &[u8] {  ","           Box::leak(vec![0; usize::MAX].into_boxed_slice())  ","       }  ","    }","","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    assert!(bytes.data.load(Ordering::SeqCst).is_null());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","   struct OwnerMaxSize;","","   impl AsRef<[u8]> for OwnerMaxSize {","       fn as_ref(&self) -> &[u8] {","           &[0; 8] // Using a fixed size array instead of a vector","       }","   }","","   let owner = OwnerMaxSize;","   let bytes = Bytes::from_owner(owner);","   let owner = OwnerMaxSize;","   let bytes = Bytes::from_owner(owner);","   assert!(bytes.is_unique());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","   struct OwnerMaxSize;","","   impl AsRef<[u8]> for OwnerMaxSize {","       fn as_ref(&self) -> &[u8] {","           &[0][..] // simplistic fixed return, adjust as needed","       }","    }","","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    assert!(!bytes.is_empty());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct OwnerEmpty;","","    impl AsRef<[u8]> for OwnerEmpty {","        fn as_ref(&self) -> &[u8] {","            &[]","        }","    }","","    let owner = OwnerEmpty;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerEmpty;","    assert!(bytes.ptr != ptr::null());","}"],[]],[["{","    struct OwnerEmpty;","","    impl AsRef<[u8]> for OwnerEmpty {","        fn as_ref(&self) -> &[u8] {","            &[]","        }","    }","","    let owner = OwnerEmpty;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerEmpty;","    assert_eq!(bytes.len, 0);","}"],[]],[["{","    struct OwnerEmpty;","","    impl AsRef<[u8]> for OwnerEmpty {","        fn as_ref(&self) -> &[u8] {","            &[]","        }","    }","","    let owner = OwnerEmpty;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerEmpty;","    assert!(bytes.is_unique());","}"],[]],[["{","    struct OwnerEmpty;","","    impl AsRef<[u8]> for OwnerEmpty {","        fn as_ref(&self) -> &[u8] {","            &[]","        }","    }","","    let owner = OwnerEmpty;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerEmpty;","    assert!(bytes.is_empty());","}"],[]],[["{","    struct OwnerSmall;","","    impl AsRef<[u8]> for OwnerSmall {","        fn as_ref(&self) -> &[u8] {","            b\"small\"","        }","    }","","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.len(), 5);","}"],[]],[["{","    struct OwnerSmall;","","    impl AsRef<[u8]> for OwnerSmall {","        fn as_ref(&self) -> &[u8] {","            b\"small\"","        }","    }","","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.as_slice(), b\"small\");","}"],[]],[["{","    struct OwnerSmall;","","    impl AsRef<[u8]> for OwnerSmall {","        fn as_ref(&self) -> &[u8] {","            b\"small\"","        }","    }","","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    assert!(!bytes.is_empty());","}"],[]],[["{","    struct OwnerSmall;","","    impl AsRef<[u8]> for OwnerSmall {","        fn as_ref(&self) -> &[u8] {","            b\"small\"","        }","    }","","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerSmall;","    let bytes = Bytes::from_owner(owner);","    assert!(bytes.is_unique());","}"],[]],[["{","    struct OwnerLarge;","","    impl AsRef<[u8]> for OwnerLarge {","        fn as_ref(&self) -> &[u8] {","            b\"this is a considerably larger buffer to test the from_owner functionality\"","        }","    }","","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.len(), 75);","}"],[]],[["{","    struct OwnerLarge;","","    impl AsRef<[u8]> for OwnerLarge {","        fn as_ref(&self) -> &[u8] {","            b\"this is a considerably larger buffer to test the from_owner functionality\"","        }","    }","","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(unsafe { core::slice::from_raw_parts(bytes.ptr, bytes.len) }, b\"this is a considerably larger buffer to test the from_owner functionality\");","}"],[]],[["{","    struct OwnerLarge;","","    impl AsRef<[u8]> for OwnerLarge {","        fn as_ref(&self) -> &[u8] {","            b\"this is a considerably larger buffer to test the from_owner functionality\"","        }","    }","","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    assert!(!bytes.data.load(Ordering::Relaxed).is_null());","}"],[]],[["{","    struct OwnerLarge;","","    impl AsRef<[u8]> for OwnerLarge {","        fn as_ref(&self) -> &[u8] {","            b\"this is a considerably larger buffer to test the from_owner functionality\"","        }","    }","","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerLarge;","    let bytes = Bytes::from_owner(owner);","    assert!(bytes.is_unique());","}"],[]],[["{","    struct OwnerMultiple;","","    impl AsRef<[u8]> for OwnerMultiple {","        fn as_ref(&self) -> &[u8] {","            b\"multiple bytes are definitely better than one\"","        }","    }","","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.len(), 40);","}"],[]],[["{","    struct OwnerMultiple;","","    impl AsRef<[u8]> for OwnerMultiple {","        fn as_ref(&self) -> &[u8] {","            b\"multiple bytes are definitely better than one\"","        }","    }","","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.is_empty(), false);","}"],[]],[["{","    struct OwnerMultiple;","","    impl AsRef<[u8]> for OwnerMultiple {","        fn as_ref(&self) -> &[u8] {","            b\"multiple bytes are definitely better than one\"","        }","    }","","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(bytes.ptr as usize, bytes.data.load(Ordering::SeqCst) as usize);","}"],[]],[["{","    struct OwnerMultiple;","","    impl AsRef<[u8]> for OwnerMultiple {","        fn as_ref(&self) -> &[u8] {","            b\"multiple bytes are definitely better than one\"","        }","    }","","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    assert!(bytes.is_unique());","}"],[]],[["{","    struct OwnerMultiple;","","    impl AsRef<[u8]> for OwnerMultiple {","        fn as_ref(&self) -> &[u8] {","            b\"multiple bytes are definitely better than one\"","        }","    }","","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMultiple;","    let bytes = Bytes::from_owner(owner);","    assert_eq!(unsafe { slice::from_raw_parts(bytes.ptr, bytes.len) }, b\"multiple bytes are definitely better than one\");","}"],[]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(owner_bytes.len(), 4);","}"],[]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(owner_bytes[0], 0xF0);","}"],[]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(owner_bytes[1], 0x9F);","}"],[]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(owner_bytes[2], 0x98);","}"],[]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(owner_bytes[3], 0x81);","}"],[]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert!(!bytes.is_empty());","}"],[]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert!(bytes.is_unique());","}"],[]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(bytes.len(), 4);","}"],[]],[["{","    struct OwnerNonAscii;","","    impl AsRef<[u8]> for OwnerNonAscii {","        fn as_ref(&self) -> &[u8] {","            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes","        }","    }","","    let owner = OwnerNonAscii;","    let bytes = Bytes::from_owner(owner);","    let owner_bytes = bytes.as_ref();","    assert_eq!(bytes.ptr, owner_bytes.as_ptr());","}"],[]],[["{","   struct OwnerMaxSize;  "," ","   impl AsRef<[u8]> for OwnerMaxSize {  ","       fn as_ref(&self) -> &[u8] {  ","           static DATA: [u8; 8] = [0; 8];  ","           &DATA  ","       }  ","   }  "," ","   let owner = OwnerMaxSize;  ","   let bytes = Bytes::from_owner(owner);  ","   let owner = OwnerMaxSize;  ","   let bytes = Bytes::from_owner(owner);  ","}"],[]],[["{","   struct OwnerMaxSize;  "," ","   impl AsRef<[u8]> for OwnerMaxSize {  ","       fn as_ref(&self) -> &[u8] {  ","           Box::leak(vec![0; usize::MAX].into_boxed_slice())  ","       }  ","    }","","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    assert!(!bytes.ptr.is_null());","}"],[]],[["{","    struct OwnerMaxSize;","","   impl AsRef<[u8]> for OwnerMaxSize {  ","       fn as_ref(&self) -> &[u8] {  ","           Box::leak(vec![0; usize::MAX].into_boxed_slice())  ","       }  ","    }","","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    assert!(bytes.data.load(Ordering::SeqCst).is_null());","}"],[]],[["{","   struct OwnerMaxSize;","","   impl AsRef<[u8]> for OwnerMaxSize {","       fn as_ref(&self) -> &[u8] {","           &[0; 8] // Using a fixed size array instead of a vector","       }","   }","","   let owner = OwnerMaxSize;","   let bytes = Bytes::from_owner(owner);","   let owner = OwnerMaxSize;","   let bytes = Bytes::from_owner(owner);","   assert!(bytes.is_unique());","}"],[]],[["{","   struct OwnerMaxSize;","","   impl AsRef<[u8]> for OwnerMaxSize {","       fn as_ref(&self) -> &[u8] {","           &[0][..] // simplistic fixed return, adjust as needed","       }","    }","","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    let owner = OwnerMaxSize;","    let bytes = Bytes::from_owner(owner);","    assert!(!bytes.is_empty());","}"],[]]]}