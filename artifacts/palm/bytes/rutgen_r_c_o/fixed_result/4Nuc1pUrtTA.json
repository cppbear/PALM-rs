{"function_name":"bytes::bytes::bytes::Bytes::try_into_mut","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":17,"tests_lines":[8,8,8,8,8,8,8,8,9,9,9,7,7,7,7,7,7],"oracles":8,"oracles_compiled":8,"oracles_compiled_rate":100.0,"tests_compiled":17,"tests_compiled_rate":100.0,"oracles_run":8,"oracles_passed":7,"oracles_passed_rate":87.5,"tests_run":17,"tests_passed":16,"tests_passed_rate":94.11764705882352,"lines":5,"lines_covered":4,"lines_coveraged_rate":80.0,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[641,642,643,645,647],"codes_lines_covered":[[["{","    let data = vec![1];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![1];","    let bytes = Bytes::from_owner(data);","    assert!(bytes.is_unique() == false);","}"],[641,642,645,647]],[["{","    let data = vec![1];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![1];","    let bytes = Bytes::from_owner(data);","    assert_eq!(result, Err(bytes));","}"],[641,642,645,647]],[["{","    let data = vec![0; usize::MAX];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![0; usize::MAX];","    let bytes = Bytes::from_owner(data);","    assert_eq!(result, Err(bytes));","}"],[]],[["{","    let data = vec![5, 10, 15];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![5, 10, 15];","    let bytes = Bytes::from_owner(data);","    assert!(bytes.is_unique() == false);","}"],[641,642,645,647]],[["{","    let data = vec![5, 10, 15];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![5, 10, 15];","    let bytes = Bytes::from_owner(data);","    assert!(matches!(bytes.try_into_mut(), Err(_)));","}"],[641,642,645,647]],[["{","    let data = vec![34];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![34];","    let bytes = Bytes::from_owner(data);","    assert!(bytes.try_into_mut().is_err(), \"Expected try_into_mut to fail when called on bytes created from from_owner.\");","}"],[641,642,645,647]],[["{","    let data = vec![255, 0, 127, 64];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![255, 0, 127, 64];","    let bytes = Bytes::from_owner(data);","    assert!(bytes.is_unique() == false);","}"],[641,642,645,647]],[["{","    let data = vec![255, 0, 127, 64];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![255, 0, 127, 64];","    let bytes = Bytes::from_owner(data);","    assert!(result.is_err());","}"],[641,642,645,647]],[["{","    let data = vec![1, 2, 3, 4, 5];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![1, 2, 3, 4, 5];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    assert!(result.is_err(), \"Expected an error when trying to convert non-unique Bytes to BytesMut\");","}"],[641,642,645,647]],[["{","   let data = vec![1, 2, 3, 4, 5];","   let bytes = Bytes::from_owner(data);","   let result = bytes.clone().try_into_mut();","   let data = vec![1, 2, 3, 4, 5];","   let bytes = Bytes::from_owner(data);","   let result = bytes.clone().try_into_mut();","   assert_eq!(result.unwrap_err().len(), bytes.len(), \"The length of the returned Bytes should be equal to the original Bytes length\");","}"],[641,642,645,647]],[["{","   let data = vec![1, 2, 3, 4, 5];","   let bytes = Bytes::from_owner(data);","   let result = bytes.try_into_mut();","   assert!(result.is_err(), \"The original Bytes should not be unique when constructed from owner\");","   let data = vec![1, 2, 3, 4, 5];","   let bytes = Bytes::from_owner(data);","   let result = bytes.try_into_mut();","}"],[641,642,645,647]],[["{","   static STATIC_BYTES: &[u8] = &[10, 20, 30, 40, 50];","   let bytes = Bytes::from_static(STATIC_BYTES);","   let result = bytes.clone().try_into_mut();","   let bytes_is_unique = bytes.is_unique();","   assert_eq!(bytes.clone().try_into_mut(), Err(bytes));","}"],[641,642,645,647]],[["{","   static STATIC_BYTES: &[u8] = &[10, 20, 30, 40, 50];","   let bytes = Bytes::from_static(STATIC_BYTES);","   let result = bytes.try_into_mut();","   let bytes_is_unique = result.is_err(); // check if result indicates uniqueness","   assert!(bytes_is_unique);","}"],[641,642,645,647]],[["{","    let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","    assert!(result.is_err());","}"],[641,642,645,647]],[["{","    let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","    assert_eq!(result.err().unwrap().len(), 1000);","}"],[641,642,645,647]],[["{","   let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();  ","   let bytes = Bytes::from_owner(data);  ","   let result = bytes.clone().try_into_mut();  ","   let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();  ","   assert_eq!(result.err().unwrap().as_slice(), bytes.as_slice());  ","}"],[641,642,645,647]],[["{","   let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","   let bytes = Bytes::from_owner(data);","   let result = bytes.try_into_mut();","   let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","   assert_eq!(result.is_ok(), false);","}"],[641,642,645,647]]],"codes_branches":[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    let data = vec![1];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![1];","    let bytes = Bytes::from_owner(data);","    assert!(bytes.is_unique() == false);","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","    let data = vec![1];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![1];","    let bytes = Bytes::from_owner(data);","    assert_eq!(result, Err(bytes));","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","    let data = vec![0; usize::MAX];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![0; usize::MAX];","    let bytes = Bytes::from_owner(data);","    assert_eq!(result, Err(bytes));","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":false}]],[["{","    let data = vec![5, 10, 15];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![5, 10, 15];","    let bytes = Bytes::from_owner(data);","    assert!(bytes.is_unique() == false);","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","    let data = vec![5, 10, 15];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![5, 10, 15];","    let bytes = Bytes::from_owner(data);","    assert!(matches!(bytes.try_into_mut(), Err(_)));","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","    let data = vec![34];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![34];","    let bytes = Bytes::from_owner(data);","    assert!(bytes.try_into_mut().is_err(), \"Expected try_into_mut to fail when called on bytes created from from_owner.\");","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","    let data = vec![255, 0, 127, 64];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![255, 0, 127, 64];","    let bytes = Bytes::from_owner(data);","    assert!(bytes.is_unique() == false);","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","    let data = vec![255, 0, 127, 64];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![255, 0, 127, 64];","    let bytes = Bytes::from_owner(data);","    assert!(result.is_err());","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","    let data = vec![1, 2, 3, 4, 5];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = vec![1, 2, 3, 4, 5];","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    assert!(result.is_err(), \"Expected an error when trying to convert non-unique Bytes to BytesMut\");","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","   let data = vec![1, 2, 3, 4, 5];","   let bytes = Bytes::from_owner(data);","   let result = bytes.clone().try_into_mut();","   let data = vec![1, 2, 3, 4, 5];","   let bytes = Bytes::from_owner(data);","   let result = bytes.clone().try_into_mut();","   assert_eq!(result.unwrap_err().len(), bytes.len(), \"The length of the returned Bytes should be equal to the original Bytes length\");","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","   let data = vec![1, 2, 3, 4, 5];","   let bytes = Bytes::from_owner(data);","   let result = bytes.try_into_mut();","   assert!(result.is_err(), \"The original Bytes should not be unique when constructed from owner\");","   let data = vec![1, 2, 3, 4, 5];","   let bytes = Bytes::from_owner(data);","   let result = bytes.try_into_mut();","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","   static STATIC_BYTES: &[u8] = &[10, 20, 30, 40, 50];","   let bytes = Bytes::from_static(STATIC_BYTES);","   let result = bytes.clone().try_into_mut();","   let bytes_is_unique = bytes.is_unique();","   assert_eq!(bytes.clone().try_into_mut(), Err(bytes));","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","   static STATIC_BYTES: &[u8] = &[10, 20, 30, 40, 50];","   let bytes = Bytes::from_static(STATIC_BYTES);","   let result = bytes.try_into_mut();","   let bytes_is_unique = result.is_err(); // check if result indicates uniqueness","   assert!(bytes_is_unique);","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","    let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","    assert!(result.is_err());","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","    let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","    let bytes = Bytes::from_owner(data);","    let result = bytes.try_into_mut();","    let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","    assert_eq!(result.err().unwrap().len(), 1000);","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","   let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();  ","   let bytes = Bytes::from_owner(data);  ","   let result = bytes.clone().try_into_mut();  ","   let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();  ","   assert_eq!(result.err().unwrap().as_slice(), bytes.as_slice());  ","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]],[["{","   let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","   let bytes = Bytes::from_owner(data);","   let result = bytes.try_into_mut();","   let data = (0..1000).map(|x| x as u8).collect::<Vec<u8>>();","   assert_eq!(result.is_ok(), false);","}"],[{"start_line":642,"start_column":12,"end_line":642,"end_column":28,"positive":false,"negative":true}]]]}