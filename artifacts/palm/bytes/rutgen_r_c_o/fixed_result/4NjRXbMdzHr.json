{"function_name":"bytes::bytes::bytes::Bytes::slice_ref","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":58,"tests_lines":[9,9,9,9,9,9,9,9,9,9,9,9,8,9,9,9,9,9,8,9,9,9,9,10,10,10,10,13,16,19,22,10,10,10,10,11,11,9,9,9,9,9,9,8,9,9,9,8,8,8,8,8,8,8,8,8,8,8],"oracles":18,"oracles_compiled":17,"oracles_compiled_rate":94.44444444444444,"tests_compiled":57,"tests_compiled_rate":98.27586206896551,"oracles_run":17,"oracles_passed":14,"oracles_passed_rate":82.35294117647058,"tests_run":57,"tests_passed":42,"tests_passed_rate":73.68421052631578,"lines":28,"lines_covered":28,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,459,460,461,462,463,464,468,469,470,471],"codes_lines_covered":[[["{","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.len(), 0);","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.is_empty());","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.as_ptr(), Bytes::new().as_ptr());","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(b\"abcdef\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdef\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.len(), 0);","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(b\"abcdef\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdef\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.is_empty());","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.len(), 0);","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.is_empty());","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.ptr, NonNull::dangling().as_ptr());","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..]; // subset equals the entire bytes","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..];","    let subslice = bytes.slice_ref(&subset);","    assert_eq!(subslice.len(), 8);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..]; // subset equals the entire bytes","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..];","    let subslice = bytes.slice_ref(&subset);","    assert_eq!(&subslice[..], b\"abcdefgh\");","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..]; // subset equals the entire bytes","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.as_ptr() == bytes.as_ptr());","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..]; // subset equals the entire bytes","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.is_empty() == false);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset: &[u8] = &[]; // empty subset","    let _ = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset: &[u8] = &[];","    assert!(std::panic::catch_unwind(|| { bytes.slice_ref(&subset); }).is_err());","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4]; // subset \"abcd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4];","    let subslice = bytes.slice_ref(&subset);","    assert_eq!(&subslice[..], b\"abcd\");","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4]; // subset \"abcd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4];","    let subslice = bytes.slice_ref(&subset);","    assert_eq!(subslice.len(), 4);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4]; // subset \"abcd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.is_empty() == false);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4]; // subset \"abcd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.as_ptr() >= bytes.as_ptr());","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","   let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","   let subset = &bytes[0..4]; // subset \"abcd\"","   let subslice = bytes.slice_ref(&subset);","   let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","   let subset = &bytes[0..4];","   let subslice = bytes.slice_ref(&subset);","   assert!(subslice.as_ptr().wrapping_add(subslice.len()) <= bytes.as_ptr().wrapping_add(bytes.len()));","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[4..8]; // subset \"efgh\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[4..8]; // subset \"efgh\"","    assert_eq!(&subslice[..], b\"efgh\");","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6]; // subset \"cd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6];","    let subslice = bytes.slice_ref(&subset);","    assert_eq!(&subslice[..], b\"cd\");","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6]; // subset \"cd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.len() == 4);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6]; // subset \"cd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.as_ptr() == bytes.as_ptr().wrapping_add(2));","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6]; // subset \"cd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.is_empty() == false);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5]; // sub_p == bytes_p, sub_len is 6, which is out of bounds.","    let _ = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5];","    let bytes_len = bytes.len();","    let sub_len = subset.len();","    assert!(sub_len > bytes_len, \"subset length must not be greater than bytes length\");","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4]; // sub_p < bytes_p (here bytes_p is 0)","    let _ = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let bytes_p = bytes.as_ptr() as usize;","    let sub_p = subset.as_ptr() as usize;","    assert!(sub_p >= bytes_p);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,461,462,463,464]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4]; // sub_p < bytes_p (here bytes_p is 0)","    let _ = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let bytes_p = bytes.as_ptr() as usize;","    let sub_p = subset.as_ptr() as usize;","    assert!(sub_p + subset.len() <= bytes_p + bytes.len());","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,461,462,463,464]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[]; // empty slice is allowed","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2];","    let result = bytes.slice_ref(subset);","    assert_eq!(&result[..], &[1, 2]);","}"],[440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,459,460,461,462,463,464,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[]; // empty slice is allowed","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[3, 4];","    let result = bytes.slice_ref(subset);","    assert_eq!(&result[..], &[3, 4]);","}"],[440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,459,460,461,462,463,464,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[]; // empty slice is allowed","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[3, 4];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[4, 5];","    let result = bytes.slice_ref(subset);","    assert_eq!(&result[..], &[4, 5]);","}"],[440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,459,460,461,462,463,464,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[]; // empty slice is allowed","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[3, 4];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[4, 5];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let result = bytes.slice_ref(subset);","    assert_eq!(&result[..], &[2, 3, 4]);","}"],[440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,459,460,461,462,463,464,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[]; // empty slice is allowed","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[3, 4];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[4, 5];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[];","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","}"],[440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,459,460,461,462,463,464,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5]; // Exact match, should be valid","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 5);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5];","    let result = bytes.slice_ref(subset);","    assert!(result.len() == 5);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5]; // Exact match, should be valid","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 5);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5];","    let result = bytes.slice_ref(subset);","    assert_eq!(result.as_slice(), &[1, 2, 3, 4, 5]);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5]; // Exact match, should be valid","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 5);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5];","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty() == false);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5]; // Exact match, should be valid","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 5);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5];","    let result = bytes.slice_ref(subset);","    assert!(result.is_unique() == true);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4]; // Valid subset within bounds","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 3);","    assert_eq!(&*result, &[2, 3, 4]);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 3);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,461,462,463,464]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4]; // Valid subset within bounds","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 3);","    assert_eq!(&*result, &[2, 3, 4]);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let result = bytes.slice_ref(subset);","    assert_eq!(&*result, &[2, 3, 4]);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,461,462,463,464]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    assert_eq!(&subslice[..], subset);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,455,456,457]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.len(), subset.len());","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,455,456,457]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.is_empty() == false);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,455,456,457]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.len() == 5);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,455,456,457]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.as_ptr() >= bytes.as_ptr());","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,455,456,457]],[["{","   let bytes = Bytes::from_static(b\"hello world\");","   let subset = b\"hello\";","   let subslice = bytes.slice_ref(subset);","   let bytes = Bytes::from_static(b\"hello world\");","   let subset = b\"hello\";","   let subslice = bytes.slice_ref(subset);","   assert!(subslice.as_ptr().wrapping_add(subslice.len()) <= bytes.as_ptr().wrapping_add(bytes.len()));","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,455,456,457]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.len() == 0);","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.is_empty());","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.as_ptr(), Bytes::new().as_ptr());","}"],[440,441,442,443,444,471]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"world!\";","    let _subslice = bytes.slice_ref(subset); // This will panic because subset is out of bounds","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"world!\";","    assert!(std::panic::catch_unwind(|| bytes.slice_ref(subset)).is_err());","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,455,456,457]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subset.len() == 3);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert_eq!(&subslice[..], b\"cde\");","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(bytes.len() == 10);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subslice.len() == 3);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(bytes.is_empty() == false);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subslice.is_empty() == false);","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subslice.as_ptr() >= bytes.as_ptr());","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subslice.as_ptr() < unsafe { bytes.as_ptr().add(bytes.len()) });","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subslice.as_ptr() >= unsafe { bytes.as_ptr().add(2) });","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]],[["{","   let bytes = Bytes::from_static(b\"abcdefghij\");","   let subset = &bytes[2..5]; // subset = b\"cde\"","   let subslice = bytes.slice_ref(subset);","   let bytes = Bytes::from_static(b\"abcdefghij\");","   let subset = &bytes[2..5];","   unsafe { assert!(subslice.as_ptr().add(subslice.len()) <= bytes.as_ptr().add(5)); }","}"],[440,441,442,443,445,446,447,448,449,450,451,452,453,454,459,460,468,469,470,471]]],"codes_branches":[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.len(), 0);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.is_empty());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"123456789\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.as_ptr(), Bytes::new().as_ptr());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(b\"abcdef\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdef\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.len(), 0);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(b\"abcdef\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdef\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.is_empty());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.len(), 0);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.is_empty());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"\");","    let subset: &[u8] = &[];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.ptr, NonNull::dangling().as_ptr());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..]; // subset equals the entire bytes","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..];","    let subslice = bytes.slice_ref(&subset);","    assert_eq!(subslice.len(), 8);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..]; // subset equals the entire bytes","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..];","    let subslice = bytes.slice_ref(&subset);","    assert_eq!(&subslice[..], b\"abcdefgh\");","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..]; // subset equals the entire bytes","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.as_ptr() == bytes.as_ptr());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..]; // subset equals the entire bytes","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &b\"abcdefgh\"[..];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.is_empty() == false);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset: &[u8] = &[]; // empty subset","    let _ = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset: &[u8] = &[];","    assert!(std::panic::catch_unwind(|| { bytes.slice_ref(&subset); }).is_err());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4]; // subset \"abcd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4];","    let subslice = bytes.slice_ref(&subset);","    assert_eq!(&subslice[..], b\"abcd\");","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4]; // subset \"abcd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4];","    let subslice = bytes.slice_ref(&subset);","    assert_eq!(subslice.len(), 4);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4]; // subset \"abcd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.is_empty() == false);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4]; // subset \"abcd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[0..4];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.as_ptr() >= bytes.as_ptr());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","   let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","   let subset = &bytes[0..4]; // subset \"abcd\"","   let subslice = bytes.slice_ref(&subset);","   let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","   let subset = &bytes[0..4];","   let subslice = bytes.slice_ref(&subset);","   assert!(subslice.as_ptr().wrapping_add(subslice.len()) <= bytes.as_ptr().wrapping_add(bytes.len()));","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[4..8]; // subset \"efgh\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[4..8]; // subset \"efgh\"","    assert_eq!(&subslice[..], b\"efgh\");","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6]; // subset \"cd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6];","    let subslice = bytes.slice_ref(&subset);","    assert_eq!(&subslice[..], b\"cd\");","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6]; // subset \"cd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.len() == 4);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6]; // subset \"cd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.as_ptr() == bytes.as_ptr().wrapping_add(2));","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6]; // subset \"cd\"","    let subslice = bytes.slice_ref(&subset);","    let bytes = Bytes::from_static(&b\"abcdefgh\"[..]);","    let subset = &bytes[2..6];","    let subslice = bytes.slice_ref(&subset);","    assert!(subslice.is_empty() == false);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5]; // sub_p == bytes_p, sub_len is 6, which is out of bounds.","    let _ = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5];","    let bytes_len = bytes.len();","    let sub_len = subset.len();","    assert!(sub_len > bytes_len, \"subset length must not be greater than bytes length\");","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4]; // sub_p < bytes_p (here bytes_p is 0)","    let _ = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let bytes_p = bytes.as_ptr() as usize;","    let sub_p = subset.as_ptr() as usize;","    assert!(sub_p >= bytes_p);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4]; // sub_p < bytes_p (here bytes_p is 0)","    let _ = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let bytes_p = bytes.as_ptr() as usize;","    let sub_p = subset.as_ptr() as usize;","    assert!(sub_p + subset.len() <= bytes_p + bytes.len());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[]; // empty slice is allowed","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2];","    let result = bytes.slice_ref(subset);","    assert_eq!(&result[..], &[1, 2]);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[]; // empty slice is allowed","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[3, 4];","    let result = bytes.slice_ref(subset);","    assert_eq!(&result[..], &[3, 4]);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[]; // empty slice is allowed","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[3, 4];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[4, 5];","    let result = bytes.slice_ref(subset);","    assert_eq!(&result[..], &[4, 5]);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[]; // empty slice is allowed","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[3, 4];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[4, 5];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let result = bytes.slice_ref(subset);","    assert_eq!(&result[..], &[2, 3, 4]);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[]; // empty slice is allowed","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[3, 4];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[4, 5];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let result = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[];","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5]; // Exact match, should be valid","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 5);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5];","    let result = bytes.slice_ref(subset);","    assert!(result.len() == 5);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5]; // Exact match, should be valid","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 5);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5];","    let result = bytes.slice_ref(subset);","    assert_eq!(result.as_slice(), &[1, 2, 3, 4, 5]);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5]; // Exact match, should be valid","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 5);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5];","    let result = bytes.slice_ref(subset);","    assert!(result.is_empty() == false);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5]; // Exact match, should be valid","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 5);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[1, 2, 3, 4, 5];","    let result = bytes.slice_ref(subset);","    assert!(result.is_unique() == true);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4]; // Valid subset within bounds","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 3);","    assert_eq!(&*result, &[2, 3, 4]);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 3);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4]; // Valid subset within bounds","    let result = bytes.slice_ref(subset);","    assert_eq!(result.len(), 3);","    assert_eq!(&*result, &[2, 3, 4]);","    let bytes = Bytes::from_static(&[1, 2, 3, 4, 5]);","    let subset = &[2, 3, 4];","    let result = bytes.slice_ref(subset);","    assert_eq!(&*result, &[2, 3, 4]);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    assert_eq!(&subslice[..], subset);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.len(), subset.len());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.is_empty() == false);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.len() == 5);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"hello\";","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.as_ptr() >= bytes.as_ptr());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","   let bytes = Bytes::from_static(b\"hello world\");","   let subset = b\"hello\";","   let subslice = bytes.slice_ref(subset);","   let bytes = Bytes::from_static(b\"hello world\");","   let subset = b\"hello\";","   let subslice = bytes.slice_ref(subset);","   assert!(subslice.as_ptr().wrapping_add(subslice.len()) <= bytes.as_ptr().wrapping_add(bytes.len()));","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.len() == 0);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    assert!(subslice.is_empty());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = &b\"\"[..];","    let subslice = bytes.slice_ref(subset);","    assert_eq!(subslice.as_ptr(), Bytes::new().as_ptr());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":true,"negative":false}]],[["{","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"world!\";","    let _subslice = bytes.slice_ref(subset); // This will panic because subset is out of bounds","    let bytes = Bytes::from_static(b\"hello world\");","    let subset = b\"world!\";","    assert!(std::panic::catch_unwind(|| bytes.slice_ref(subset)).is_err());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subset.len() == 3);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert_eq!(&subslice[..], b\"cde\");","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(bytes.len() == 10);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subslice.len() == 3);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(bytes.is_empty() == false);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subslice.is_empty() == false);","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subslice.as_ptr() >= bytes.as_ptr());","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subslice.as_ptr() < unsafe { bytes.as_ptr().add(bytes.len()) });","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5]; // subset = b\"cde\"","    let subslice = bytes.slice_ref(subset);","    let bytes = Bytes::from_static(b\"abcdefghij\");","    let subset = &bytes[2..5];","    assert!(subslice.as_ptr() >= unsafe { bytes.as_ptr().add(2) });","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]],[["{","   let bytes = Bytes::from_static(b\"abcdefghij\");","   let subset = &bytes[2..5]; // subset = b\"cde\"","   let subslice = bytes.slice_ref(subset);","   let bytes = Bytes::from_static(b\"abcdefghij\");","   let subset = &bytes[2..5];","   unsafe { assert!(subslice.as_ptr().add(subslice.len()) <= bytes.as_ptr().add(5)); }","}"],[{"start_line":443,"start_column":12,"end_line":443,"end_column":29,"positive":false,"negative":true}]]]}