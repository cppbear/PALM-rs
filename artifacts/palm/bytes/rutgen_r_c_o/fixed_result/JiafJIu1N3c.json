{"function_name":"bytes::bytes::promotable_to_mut","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":51,"tests_lines":[22,22,22,23,26,27,27,27,27,27,24,24,18,18,18,19,20,21,22,23,23,23,20,20,20,20,20,20,20,20,20,20,20,20,23,23,23,23,23,20,20,20,16,16,16,19,19,19,19,19,19],"oracles":11,"oracles_compiled":7,"oracles_compiled_rate":63.63636363636363,"tests_compiled":16,"tests_compiled_rate":31.372549019607842,"oracles_run":7,"oracles_passed":2,"oracles_passed_rate":28.57142857142857,"tests_run":16,"tests_passed":3,"tests_passed_rate":18.75,"lines":21,"lines_covered":21,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1263,1265,1266,1267,1268,1269,1270,1271,1272,1274],"codes_lines_covered":[[["{","   use core::ptr::null_mut;  ","   use std::sync::atomic::{AtomicPtr, Ordering};  "," ","   struct Dummy;  "," ","   // Prepare a scenario where the kind is KIND_VEC  ","   let vec = vec![0u8; 20];  ","   let buffer: *mut u8 = vec.as_ptr() as *mut u8;  ","   let shared_data = AtomicPtr::new(buffer as *mut ());  "," ","   let ptr: *const u8 = buffer;  ","   let len: usize = 10;  "," ","   fn dummy_function(shared: *mut ()) -> *mut u8 {  ","       shared as *mut u8  ","   }  "," ","   let _result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };  ","   let vec = vec![0u8; 20];  ","   let buffer: *mut u8 = vec.as_ptr() as *mut u8;  ","   let _shared_data = AtomicPtr::new(buffer as *mut ());  ","   let ptr: *const u8 = buffer;  ","   let len: usize = 10;  ","   let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };  ","   assert!(result.len() == len);  ","}"],[1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1274]],[["{","   use core::ptr::null_mut;","   use std::sync::atomic::{AtomicPtr, Ordering};","","   struct Dummy;","","   // Prepare a scenario where the kind is KIND_VEC","   let vec = vec![0u8; 20];","   let buffer: *mut u8 = vec.as_ptr() as *mut u8;","   let shared_data = AtomicPtr::<()>::new(buffer as *mut ());","","   let ptr: *const u8 = buffer;","   let len: usize = 10;","","   fn dummy_function(shared: *mut ()) -> *mut u8 {","       shared as *mut u8","   }","","   let _result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };","   let vec = vec![0u8; 20];","   let buffer: *mut u8 = vec.as_ptr() as *mut u8;","   let shared_data = AtomicPtr::<()>::new(buffer as *mut ());","   let ptr: *const u8 = buffer;","   let len: usize = 10;","  let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };  ","   assert!(result.len() == len);  ","}"],[1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1274]],[["{","   use std::sync::atomic::{AtomicPtr, Ordering};  "," ","   struct Dummy;  "," ","   let shared_data: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)) as *mut ());  ","   let ptr: *const u8 = core::ptr::null();  ","   let len: usize = 10;  "," ","   fn dummy_function(_: *mut ()) -> *mut u8 {  ","      let mut buffer = vec![0u8; 20]; // Simulated buffer  ","      buffer.as_mut_ptr()  ","  }  "," ","   let _result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };  ","   let shared = shared_data.load(Ordering::Acquire);  ","   assert_eq!(len, 10);  ","}"],[1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1263,1265,1266,1267,1268,1269,1270,1271,1272,1274]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","   let len = 1;","   ","  fn fake_function(_: *mut ()) -> *mut u8 {","      // Simulates the behavior of function `f`","      ptr::null_mut()","  }","  ","  let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = 1;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   assert!(result.capacity() == 0);","}"],[]],[["{","   use core::ptr::null_mut;  ","   use alloc::sync::Arc;  "," ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = 1;  ","   ","  fn fake_function(shared: *mut ()) -> *mut u8 {  ","      // Simulates the behavior of function `f`  ","      ptr::null_mut()  ","  }  ","  ","  let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = 1;  ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   assert!(result.is_empty());  ","}"],[]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = 1;","    ","   fn fake_function(shared: *mut ()) -> *mut u8 {","       // Simulates the behavior of function `f`","       ptr::null_mut()","   }","","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = 1;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   assert!(result.as_ptr() == ptr::null_mut());","}"],[]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = 0;","    ","   fn fake_function(shared: *mut ()) -> *mut u8 {","       // Simulates the behavior of function `f`","       ptr::null_mut()","   }","   ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = 0;  ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","    assert_eq!(result.len(), 0);","}"],[]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = 0;","    ","   fn fake_function(_: *mut ()) -> *mut u8 {","       // Simulates the behavior of function `f`","       ptr::null_mut()","   }","   ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = 0;  ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","    assert!(result.is_empty());","}"],[]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = usize::MAX;","    ","   fn fake_function(_: *mut ()) -> *mut u8 {","       // Simulates the behavior of function `f`","       ptr::null_mut()","   }","   ","  let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = usize::MAX;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","    assert_eq!(result.is_empty(), true);","}"],[]],[["{","   use core::ptr::null_mut;","   use alloc::sync::Arc;","","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = usize::MAX;","   ","  fn fake_function(shared: *mut ()) -> *mut u8 {","      // Simulates the behavior of function `f`","      ptr::null_mut()","  }","  ","  let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = usize::MAX;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   assert_eq!(result.capacity(), 0);","}"],[]],[["{","   use core::ptr::null_mut;  ","   use alloc::sync::Arc;  "," ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = usize::MAX;  ","   ","   fn fake_function(_: *mut ()) -> *mut u8 {  ","       // Simulates the behavior of function `f`  ","       ptr::null_mut()  ","   }  "," ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = usize::MAX;  ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","  assert!(result.as_ptr().is_null());  ","}"],[]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = 10;","","   fn fake_function(_: *mut ()) -> *mut u8 {  ","       // Simulates the behavior of function `f`  ","       ptr::null_mut()  ","   }  "," ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = 10;  ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   assert!(result.len() > 0);  ","}"],[]],[["{","   use core::ptr::null_mut;","   use alloc::sync::Arc;","","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = 10;","  ","  fn fake_function(_: *mut ()) -> *mut u8 {","      // Simulates the behavior of function `f`","      ptr::null_mut()","  }","  ","  let _result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = 10;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   assert_eq!(result.capacity(), 0);","}"],[]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = 10;","","   fn fake_function(shared: *mut ()) -> *mut u8 {","       // Simulates the behavior of function `f`","       ptr::null_mut()","   }","   ","   let _result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = 10;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   assert!(result.is_empty());","}"],[]],[["{","  let data: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(())));","  let ptr = Box::into_raw(Box::new(1u8)) as *const u8; // Non-null pointer","  let len = 1usize; // Greater than 0 and <= usize::MAX","","  fn example_function(_: *mut ()) -> *mut u8 {","      Box::into_raw(Box::new(2u8)) // Returning a pointer to valid function","  }","","  let _ = unsafe { promotable_to_mut(&data, ptr, len, example_function) };","  let data: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(())));","  let ptr = Box::into_raw(Box::new(1u8)) as *const u8;","  let len = 1usize;","  let result = unsafe { promotable_to_mut(&data, ptr, len, example_function) };","  assert!(result.len() > 0);","}"],[1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1263,1265,1266,1267,1268,1269,1270,1271,1272,1274]],[["{"," let data: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(()))); // Mutable unit value  "," let ptr = Box::into_raw(Box::new(1u8)) as *const u8; // Non-null pointer  "," let len = 1usize; // Greater than 0 and <= usize::MAX  "," "," fn example_function(_: *mut ()) -> *mut u8 {  ","     Box::into_raw(Box::new(2u8)) // Returning a pointer to valid function  "," }  "," "," let _ = unsafe { promotable_to_mut(&data, ptr, len, example_function) };  "," let data: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(()))); // Mutable unit value  ","  let ptr = Box::into_raw(Box::new(1u8)) as *const u8;  ","  let len = 1usize;  ","  let result = unsafe { promotable_to_mut(&data, ptr, len, example_function) };  ","  assert_eq!(unsafe { *result.get(0).unwrap() }, 2u8);  ","}"],[1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1263,1265,1266,1267,1268,1269,1270,1271,1272,1274]]],"codes_branches":[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":true,"negative":true}],"codes_branches_covered":[[["{","   use core::ptr::null_mut;  ","   use std::sync::atomic::{AtomicPtr, Ordering};  "," ","   struct Dummy;  "," ","   // Prepare a scenario where the kind is KIND_VEC  ","   let vec = vec![0u8; 20];  ","   let buffer: *mut u8 = vec.as_ptr() as *mut u8;  ","   let shared_data = AtomicPtr::new(buffer as *mut ());  "," ","   let ptr: *const u8 = buffer;  ","   let len: usize = 10;  "," ","   fn dummy_function(shared: *mut ()) -> *mut u8 {  ","       shared as *mut u8  ","   }  "," ","   let _result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };  ","   let vec = vec![0u8; 20];  ","   let buffer: *mut u8 = vec.as_ptr() as *mut u8;  ","   let _shared_data = AtomicPtr::new(buffer as *mut ());  ","   let ptr: *const u8 = buffer;  ","   let len: usize = 10;  ","   let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };  ","   assert!(result.len() == len);  ","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":true,"negative":false}]],[["{","   use core::ptr::null_mut;","   use std::sync::atomic::{AtomicPtr, Ordering};","","   struct Dummy;","","   // Prepare a scenario where the kind is KIND_VEC","   let vec = vec![0u8; 20];","   let buffer: *mut u8 = vec.as_ptr() as *mut u8;","   let shared_data = AtomicPtr::<()>::new(buffer as *mut ());","","   let ptr: *const u8 = buffer;","   let len: usize = 10;","","   fn dummy_function(shared: *mut ()) -> *mut u8 {","       shared as *mut u8","   }","","   let _result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };","   let vec = vec![0u8; 20];","   let buffer: *mut u8 = vec.as_ptr() as *mut u8;","   let shared_data = AtomicPtr::<()>::new(buffer as *mut ());","   let ptr: *const u8 = buffer;","   let len: usize = 10;","  let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };  ","   assert!(result.len() == len);  ","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":true,"negative":false}]],[["{","   use std::sync::atomic::{AtomicPtr, Ordering};  "," ","   struct Dummy;  "," ","   let shared_data: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)) as *mut ());  ","   let ptr: *const u8 = core::ptr::null();  ","   let len: usize = 10;  "," ","   fn dummy_function(_: *mut ()) -> *mut u8 {  ","      let mut buffer = vec![0u8; 20]; // Simulated buffer  ","      buffer.as_mut_ptr()  ","  }  "," ","   let _result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };  ","   let shared = shared_data.load(Ordering::Acquire);  ","   assert_eq!(len, 10);  ","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":true}]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","   let len = 1;","   ","  fn fake_function(_: *mut ()) -> *mut u8 {","      // Simulates the behavior of function `f`","      ptr::null_mut()","  }","  ","  let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = 1;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   assert!(result.capacity() == 0);","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","   use core::ptr::null_mut;  ","   use alloc::sync::Arc;  "," ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = 1;  ","   ","  fn fake_function(shared: *mut ()) -> *mut u8 {  ","      // Simulates the behavior of function `f`  ","      ptr::null_mut()  ","  }  ","  ","  let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = 1;  ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   assert!(result.is_empty());  ","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = 1;","    ","   fn fake_function(shared: *mut ()) -> *mut u8 {","       // Simulates the behavior of function `f`","       ptr::null_mut()","   }","","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = 1;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   assert!(result.as_ptr() == ptr::null_mut());","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = 0;","    ","   fn fake_function(shared: *mut ()) -> *mut u8 {","       // Simulates the behavior of function `f`","       ptr::null_mut()","   }","   ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = 0;  ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","    assert_eq!(result.len(), 0);","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = 0;","    ","   fn fake_function(_: *mut ()) -> *mut u8 {","       // Simulates the behavior of function `f`","       ptr::null_mut()","   }","   ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = 0;  ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","    assert!(result.is_empty());","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = usize::MAX;","    ","   fn fake_function(_: *mut ()) -> *mut u8 {","       // Simulates the behavior of function `f`","       ptr::null_mut()","   }","   ","  let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = usize::MAX;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","    assert_eq!(result.is_empty(), true);","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","   use core::ptr::null_mut;","   use alloc::sync::Arc;","","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = usize::MAX;","   ","  fn fake_function(shared: *mut ()) -> *mut u8 {","      // Simulates the behavior of function `f`","      ptr::null_mut()","  }","  ","  let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = usize::MAX;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   assert_eq!(result.capacity(), 0);","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","   use core::ptr::null_mut;  ","   use alloc::sync::Arc;  "," ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = usize::MAX;  ","   ","   fn fake_function(_: *mut ()) -> *mut u8 {  ","       // Simulates the behavior of function `f`  ","       ptr::null_mut()  ","   }  "," ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = usize::MAX;  ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","  assert!(result.as_ptr().is_null());  ","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = 10;","","   fn fake_function(_: *mut ()) -> *mut u8 {  ","       // Simulates the behavior of function `f`  ","       ptr::null_mut()  ","   }  "," ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   let data = Arc::new(AtomicPtr::new(null_mut()));  ","   let ptr: *const u8 = ptr::null();  ","   let len = 10;  ","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };  ","   assert!(result.len() > 0);  ","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","   use core::ptr::null_mut;","   use alloc::sync::Arc;","","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = 10;","  ","  fn fake_function(_: *mut ()) -> *mut u8 {","      // Simulates the behavior of function `f`","      ptr::null_mut()","  }","  ","  let _result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = 10;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   assert_eq!(result.capacity(), 0);","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","    use core::ptr::null_mut;","    use alloc::sync::Arc;","","    let data = Arc::new(AtomicPtr::new(null_mut()));","    let ptr: *const u8 = ptr::null();","    let len = 10;","","   fn fake_function(shared: *mut ()) -> *mut u8 {","       // Simulates the behavior of function `f`","       ptr::null_mut()","   }","   ","   let _result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   let data = Arc::new(AtomicPtr::new(null_mut()));","   let ptr: *const u8 = ptr::null();","   let len = 10;","   let result = unsafe { promotable_to_mut(&data, ptr, len, fake_function) };","   assert!(result.is_empty());","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":false}]],[["{","  let data: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(())));","  let ptr = Box::into_raw(Box::new(1u8)) as *const u8; // Non-null pointer","  let len = 1usize; // Greater than 0 and <= usize::MAX","","  fn example_function(_: *mut ()) -> *mut u8 {","      Box::into_raw(Box::new(2u8)) // Returning a pointer to valid function","  }","","  let _ = unsafe { promotable_to_mut(&data, ptr, len, example_function) };","  let data: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(())));","  let ptr = Box::into_raw(Box::new(1u8)) as *const u8;","  let len = 1usize;","  let result = unsafe { promotable_to_mut(&data, ptr, len, example_function) };","  assert!(result.len() > 0);","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":true}]],[["{"," let data: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(()))); // Mutable unit value  "," let ptr = Box::into_raw(Box::new(1u8)) as *const u8; // Non-null pointer  "," let len = 1usize; // Greater than 0 and <= usize::MAX  "," "," fn example_function(_: *mut ()) -> *mut u8 {  ","     Box::into_raw(Box::new(2u8)) // Returning a pointer to valid function  "," }  "," "," let _ = unsafe { promotable_to_mut(&data, ptr, len, example_function) };  "," let data: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(()))); // Mutable unit value  ","  let ptr = Box::into_raw(Box::new(1u8)) as *const u8;  ","  let len = 1usize;  ","  let result = unsafe { promotable_to_mut(&data, ptr, len, example_function) };  ","  assert_eq!(unsafe { *result.get(0).unwrap() }, 2u8);  ","}"],[{"start_line":1256,"start_column":8,"end_line":1256,"end_column":24,"positive":false,"negative":true}]]]}