{"function_name":"bytes::bytes::promotable_even_clone","file_path":"/home/abezbm/rust-utgen-test-crates-new/bytes/src/bytes.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/bytes","tests":46,"tests_lines":[20,20,20,19,19,19,19,20,20,20,20,15,15,15,21,21,21,21,25,25,25,25,25,25,25,19,19,19,19,19,19,19,19,19,19,19,19,19,19,21,21,21,21,21,21,21],"oracles":11,"oracles_compiled":10,"oracles_compiled_rate":90.9090909090909,"tests_compiled":24,"tests_compiled_rate":52.17391304347826,"oracles_run":10,"oracles_passed":8,"oracles_passed_rate":80.0,"tests_run":24,"tests_passed":16,"tests_passed_rate":66.66666666666666,"lines":10,"lines_covered":7,"lines_coveraged_rate":70.0,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[1208,1209,1210,1211,1212,1213,1215,1216,1217,1219],"codes_lines_covered":[[["{","   let shared_data = Box::new(Shared {","       buf: Box::into_raw(Box::new(0u8)),","       cap: 1,","       ref_cnt: AtomicUsize::new(1),","   });","   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);","   let ptr = Box::into_raw(Box::new(1u8));","   let len = 1;","","   unsafe {","      let _result = unsafe { promotable_even_clone(&atomic_ptr, ptr, len) };","  }","  let shared_data = Box::new(Shared { buf: Box::into_raw(Box::new(0u8)), cap: 1, ref_cnt: AtomicUsize::new(1) });","  let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);","   let ptr = Box::into_raw(Box::new(1u8));","   let len = 1;","   let result = unsafe { promotable_even_clone(&atomic_ptr, ptr, len) };","    assert_eq!(result.len, len);","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","   let shared_data = Box::new(Shared {","       buf: Box::into_raw(Box::new(0u8)),","       cap: 1,","       ref_cnt: AtomicUsize::new(1),","   });","   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);","   let ptr = Box::into_raw(Box::new(1u8));","   let len = 1;","","   unsafe {","      let _result = promotable_even_clone(&atomic_ptr, ptr, len);  ","  }  ","  let shared_data = Box::new(Shared { buf: Box::into_raw(Box::new(0u8)), cap: 1, ref_cnt: AtomicUsize::new(1) });  ","  let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);  ","   let ptr = Box::into_raw(Box::new(1u8));  ","   let len = 1;  ","   let result = unsafe { promotable_even_clone(&atomic_ptr, ptr, len) };  ","    assert!(result.data.load(Ordering::Acquire) as usize & KIND_MASK == KIND_ARC);","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","   let shared_data = Box::new(Shared {  ","       buf: Box::into_raw(Box::new(0u8)),  ","       cap: 1,  ","       ref_cnt: AtomicUsize::new(1),  ","   });  ","   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);  ","   let ptr = Box::into_raw(Box::new(1u8));  ","   let len = 0;  "," ","   unsafe {  ","       let _result = promotable_even_clone(&atomic_ptr, ptr, len);  ","   }  ","   let shared_data = Box::new(Shared { buf: Box::into_raw(Box::new(0u8)), cap: 1, ref_cnt: AtomicUsize::new(1), });  ","   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);  ","    let ptr = Box::into_raw(Box::new(1u8));","    let len = 0;","    assert!(unsafe { atomic_ptr.load(Ordering::Acquire) as usize & KIND_MASK } == KIND_ARC);","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","  let shared_data = Box::new(Shared {","      buf: Box::into_raw(Box::new(0u8)),","      cap: 1,","      ref_cnt: AtomicUsize::new(1),","  });","  let shared_data_ptr = Box::into_raw(shared_data);","  let atomic_ptr = AtomicPtr::new(shared_data_ptr as *mut _);","  let ptr = Box::into_raw(Box::new(1u8));","  let len = 0;","  ","  unsafe {","      let _result = promotable_even_clone(&atomic_ptr, ptr, len);","  }","  let shared_data = unsafe { Box::from_raw(shared_data_ptr) };","  let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);","  let ptr = Box::into_raw(Box::new(1u8));","  assert!(unsafe { (*shared_data_ptr).ref_cnt.load(Ordering::Relaxed) } == 1);","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","  let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());  ","  let ptr = Box::into_raw(Box::new(1u8));  ","  let len = 1;  "," ","  unsafe {  ","      let _result = promotable_even_clone(&atomic_ptr, ptr, len);  ","  }  ","  let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());  ","  let ptr = Box::into_raw(Box::new(1u8));  ","  let len = 1;  ","  let shared = atomic_ptr.load(Ordering::Acquire);  ","  let kind = shared as usize & KIND_MASK;  ","   assert_eq!(kind, KIND_ARC);  ","}"],[]],[["{","  let atomic_ptr = AtomicPtr::new(std::ptr::null_mut::<()>());  ","  let ptr = Box::into_raw(Box::new(1u8));  ","  let len = 1;  "," ","  unsafe {  ","      let _result = promotable_even_clone(&atomic_ptr, ptr, len);  ","   }  ","   let atomic_ptr = AtomicPtr::new(std::ptr::null_mut::<u8>());  ","    let ptr = Box::into_raw(Box::new(1u8));","    let len = 1;","    let shared = atomic_ptr.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert!(ptr.is_null() == false);","}"],[]],[["{","  let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(0 as *mut _);  ","  let ptr = Box::into_raw(Box::new(1u8));  ","  let len = 1;  "," ","  unsafe {  ","      let _result = promotable_even_clone(&atomic_ptr, ptr, len);  ","  }  ","  let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(0 as *mut _);  ","  let ptr = Box::into_raw(Box::new(1u8));  ","  let len = 1;  ","  let shared = atomic_ptr.load(Ordering::Acquire);  ","  let kind = shared as usize & KIND_MASK;  ","   assert!(len > 0);  ","}"],[]],[["{","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared { buf: buffer.as_ptr() as *mut u8, cap: buffer.len(), ref_cnt: AtomicUsize::new(1), });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert_eq!(result.len, len);","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared { buf: buffer.as_ptr() as *mut u8, cap: buffer.len(), ref_cnt: AtomicUsize::new(1), });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert_eq!(result.ptr, valid_memory_address);","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared { buf: buffer.as_ptr() as *mut u8, cap: buffer.len(), ref_cnt: AtomicUsize::new(1), });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert!(result.data.load(Ordering::Acquire) != atomic_ptr.load(Ordering::Acquire));","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert_eq!(result.len, len);","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert!(!result.data.load(Ordering::Acquire).is_null());","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert_eq!(result.ptr, valid_memory_address);","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert!(result.ptr == valid_memory_address);","}"],[]],[["{","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert!(result.len == len);","}"],[]],[["{","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert!(result.data.load(Ordering::Acquire) as usize & KIND_MASK == KIND_VEC);","}"],[]],[["{","   let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {  ","       buf: Box::into_raw(Box::new([1u8; 10])) as *mut u8,  ","       cap: 10,  ","       ref_cnt: AtomicUsize::new(1),  ","   })) as _);  "," ","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([2u8; 5])) as *const u8 }; // This pointer points to different data  ","  let len = 5;  "," ","  let result;  ","  unsafe {  ","      result = promotable_even_clone(&data, valid_ptr, len);  ","  }  ","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([1u8; 10])) as *mut u8, cap: 10, ref_cnt: AtomicUsize::new(1), })) as _);  ","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([2u8; 5])) as *const u8 };  ","   let len = 5;  ","   let result = unsafe { promotable_even_clone(&data, valid_ptr, len) };  ","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {  ","      buf: Box::into_raw(Box::new([1u8; 10])) as *mut u8,  ","      cap: 10,  ","      ref_cnt: AtomicUsize::new(1),  ","  })) as _);  ","","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([2u8; 5])) } as *const u8; // This pointer points to different data  ","  let len = 5;  ","","  unsafe {  ","      let result = promotable_even_clone(&data, valid_ptr, len);  ","  }  ","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([1u8; 10])) as *mut u8, cap: 10, ref_cnt: AtomicUsize::new(1), })) as _);  ","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([2u8; 5])) } as *const u8;  ","  let len = 5;  ","  let result; ","  unsafe { result = promotable_even_clone(&data, valid_ptr, len); }  ","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","   let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {","       buf: Box::into_raw(Box::new([3u8; 100])) as *mut u8,","       cap: 100,","       ref_cnt: AtomicUsize::new(1),","   })) as _);","","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([4u8; 20])) as *const u8 };","  let len = 20; // Large length","","  let result = unsafe {","      promotable_even_clone(&data, valid_ptr, len)","  };","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([3u8; 100])) as *mut u8, cap: 100, ref_cnt: AtomicUsize::new(1), })) as _);","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([4u8; 20])) as *const u8 };","   let len = 20;","   let result = unsafe { promotable_even_clone(&data, valid_ptr, len) };","   assert_eq!(result.len, len);","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {","        buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8,","        cap: 3,","        ref_cnt: AtomicUsize::new(1),","    })) as _);","","   let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };","   let len = 3;","","   unsafe {","       let result = promotable_even_clone(&data, valid_ptr, len);","   }","   let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8, cap: 3, ref_cnt: AtomicUsize::new(1), })) as _);","   let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };","    let len = 3;","    let kind = (data.load(Ordering::Acquire) as usize) & KIND_MASK;","    assert_eq!(kind, KIND_VEC);","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {  ","      buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8,  ","      cap: 3,  ","      ref_cnt: AtomicUsize::new(1),  ","  })) as _);  ","","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };  ","  let len = 3;  ","","  let result;  ","  unsafe {  ","      result = promotable_even_clone(&data, valid_ptr, len);  ","  }  ","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8, cap: 3, ref_cnt: AtomicUsize::new(1), })) as _);  ","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };  ","  let len = 3;  ","  assert!(result.ptr != valid_ptr);  ","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {","        buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8,","        cap: 3,","        ref_cnt: AtomicUsize::new(1),","    })) as _);","","   let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };","   let len = 3;","   ","  let result;  ","  unsafe {  ","      result = promotable_even_clone(&data, valid_ptr, len);  ","  }  ","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8, cap: 3, ref_cnt: AtomicUsize::new(1), })) as _);  ","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };  ","  let len = 3;  ","  let kind = (data.load(Ordering::Acquire) as usize) & KIND_MASK;  ","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {","        buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8,","        cap: 3,","        ref_cnt: AtomicUsize::new(1),","    })) as _);","","   let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };","   let len = 3;","   ","  let result;","  unsafe {","      result = promotable_even_clone(&data, valid_ptr, len);","  }","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8, cap: 3, ref_cnt: AtomicUsize::new(1), })) as _);","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };","  let len = 3;","  let kind = (data.load(Ordering::Acquire) as usize) & KIND_MASK;","}"],[1208,1209,1210,1211,1212,1213,1219]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {","        buf: Box::into_raw(Box::new([7u8; 10])) as *mut u8,","        cap: 10,","        ref_cnt: AtomicUsize::new(1),","    })) as _);","","   let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([8u8; 10])) as *const u8 };  ","   let len = 10; // Matching the buffer size  "," ","   unsafe {  ","       let result1 = promotable_even_clone(&data, valid_ptr, len);  ","       let result2 = promotable_even_clone(&data, valid_ptr, len);  ","   }  ","  // Removed duplicate lines of code that were not needed","  // let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([8u8; 10])) };","  // let len = 10;","  // let result1 = promotable_even_clone(&data, valid_ptr, len);","  // let result2 = promotable_even_clone(&data, valid_ptr, len);","  // assert_eq!(result2.ptr as *const u8, valid_ptr);","}"],[1208,1209,1210,1211,1212,1213,1219]]],"codes_branches":[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}],"codes_branches_covered":[[["{","   let shared_data = Box::new(Shared {","       buf: Box::into_raw(Box::new(0u8)),","       cap: 1,","       ref_cnt: AtomicUsize::new(1),","   });","   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);","   let ptr = Box::into_raw(Box::new(1u8));","   let len = 1;","","   unsafe {","      let _result = unsafe { promotable_even_clone(&atomic_ptr, ptr, len) };","  }","  let shared_data = Box::new(Shared { buf: Box::into_raw(Box::new(0u8)), cap: 1, ref_cnt: AtomicUsize::new(1) });","  let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);","   let ptr = Box::into_raw(Box::new(1u8));","   let len = 1;","   let result = unsafe { promotable_even_clone(&atomic_ptr, ptr, len) };","    assert_eq!(result.len, len);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","   let shared_data = Box::new(Shared {","       buf: Box::into_raw(Box::new(0u8)),","       cap: 1,","       ref_cnt: AtomicUsize::new(1),","   });","   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);","   let ptr = Box::into_raw(Box::new(1u8));","   let len = 1;","","   unsafe {","      let _result = promotable_even_clone(&atomic_ptr, ptr, len);  ","  }  ","  let shared_data = Box::new(Shared { buf: Box::into_raw(Box::new(0u8)), cap: 1, ref_cnt: AtomicUsize::new(1) });  ","  let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);  ","   let ptr = Box::into_raw(Box::new(1u8));  ","   let len = 1;  ","   let result = unsafe { promotable_even_clone(&atomic_ptr, ptr, len) };  ","    assert!(result.data.load(Ordering::Acquire) as usize & KIND_MASK == KIND_ARC);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","   let shared_data = Box::new(Shared {  ","       buf: Box::into_raw(Box::new(0u8)),  ","       cap: 1,  ","       ref_cnt: AtomicUsize::new(1),  ","   });  ","   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);  ","   let ptr = Box::into_raw(Box::new(1u8));  ","   let len = 0;  "," ","   unsafe {  ","       let _result = promotable_even_clone(&atomic_ptr, ptr, len);  ","   }  ","   let shared_data = Box::new(Shared { buf: Box::into_raw(Box::new(0u8)), cap: 1, ref_cnt: AtomicUsize::new(1), });  ","   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);  ","    let ptr = Box::into_raw(Box::new(1u8));","    let len = 0;","    assert!(unsafe { atomic_ptr.load(Ordering::Acquire) as usize & KIND_MASK } == KIND_ARC);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","  let shared_data = Box::new(Shared {","      buf: Box::into_raw(Box::new(0u8)),","      cap: 1,","      ref_cnt: AtomicUsize::new(1),","  });","  let shared_data_ptr = Box::into_raw(shared_data);","  let atomic_ptr = AtomicPtr::new(shared_data_ptr as *mut _);","  let ptr = Box::into_raw(Box::new(1u8));","  let len = 0;","  ","  unsafe {","      let _result = promotable_even_clone(&atomic_ptr, ptr, len);","  }","  let shared_data = unsafe { Box::from_raw(shared_data_ptr) };","  let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_data) as *mut _);","  let ptr = Box::into_raw(Box::new(1u8));","  assert!(unsafe { (*shared_data_ptr).ref_cnt.load(Ordering::Relaxed) } == 1);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","  let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());  ","  let ptr = Box::into_raw(Box::new(1u8));  ","  let len = 1;  "," ","  unsafe {  ","      let _result = promotable_even_clone(&atomic_ptr, ptr, len);  ","  }  ","  let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());  ","  let ptr = Box::into_raw(Box::new(1u8));  ","  let len = 1;  ","  let shared = atomic_ptr.load(Ordering::Acquire);  ","  let kind = shared as usize & KIND_MASK;  ","   assert_eq!(kind, KIND_ARC);  ","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":false,"negative":false}]],[["{","  let atomic_ptr = AtomicPtr::new(std::ptr::null_mut::<()>());  ","  let ptr = Box::into_raw(Box::new(1u8));  ","  let len = 1;  "," ","  unsafe {  ","      let _result = promotable_even_clone(&atomic_ptr, ptr, len);  ","   }  ","   let atomic_ptr = AtomicPtr::new(std::ptr::null_mut::<u8>());  ","    let ptr = Box::into_raw(Box::new(1u8));","    let len = 1;","    let shared = atomic_ptr.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert!(ptr.is_null() == false);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":false,"negative":false}]],[["{","  let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(0 as *mut _);  ","  let ptr = Box::into_raw(Box::new(1u8));  ","  let len = 1;  "," ","  unsafe {  ","      let _result = promotable_even_clone(&atomic_ptr, ptr, len);  ","  }  ","  let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(0 as *mut _);  ","  let ptr = Box::into_raw(Box::new(1u8));  ","  let len = 1;  ","  let shared = atomic_ptr.load(Ordering::Acquire);  ","  let kind = shared as usize & KIND_MASK;  ","   assert!(len > 0);  ","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":false,"negative":false}]],[["{","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared { buf: buffer.as_ptr() as *mut u8, cap: buffer.len(), ref_cnt: AtomicUsize::new(1), });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert_eq!(result.len, len);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared { buf: buffer.as_ptr() as *mut u8, cap: buffer.len(), ref_cnt: AtomicUsize::new(1), });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert_eq!(result.ptr, valid_memory_address);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![1, 2, 3, 4];","    let shared = Box::new(Shared { buf: buffer.as_ptr() as *mut u8, cap: buffer.len(), ref_cnt: AtomicUsize::new(1), });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 4;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert!(result.data.load(Ordering::Acquire) != atomic_ptr.load(Ordering::Acquire));","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert_eq!(result.len, len);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert!(!result.data.load(Ordering::Acquire).is_null());","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![5, 6, 7, 8];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = 1;","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert_eq!(result.ptr, valid_memory_address);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert!(result.ptr == valid_memory_address);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":false,"negative":false}]],[["{","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert!(result.len == len);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":false,"negative":false}]],[["{","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","        buf: buffer.as_ptr() as *mut u8,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    ","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    let buffer: Vec<u8> = vec![9; usize::MAX];","    let shared = Box::new(Shared {","    buf: buffer.as_ptr() as *mut u8,","    cap: buffer.len(),","    ref_cnt: AtomicUsize::new(1),","    });","    let atomic_ptr = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let valid_memory_address: *const u8 = buffer.as_ptr();","    let len: usize = buffer.len();","    let result = unsafe { promotable_even_clone(&atomic_ptr, valid_memory_address, len) };","    assert!(result.data.load(Ordering::Acquire) as usize & KIND_MASK == KIND_VEC);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":false,"negative":false}]],[["{","   let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {  ","       buf: Box::into_raw(Box::new([1u8; 10])) as *mut u8,  ","       cap: 10,  ","       ref_cnt: AtomicUsize::new(1),  ","   })) as _);  "," ","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([2u8; 5])) as *const u8 }; // This pointer points to different data  ","  let len = 5;  "," ","  let result;  ","  unsafe {  ","      result = promotable_even_clone(&data, valid_ptr, len);  ","  }  ","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([1u8; 10])) as *mut u8, cap: 10, ref_cnt: AtomicUsize::new(1), })) as _);  ","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([2u8; 5])) as *const u8 };  ","   let len = 5;  ","   let result = unsafe { promotable_even_clone(&data, valid_ptr, len) };  ","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {  ","      buf: Box::into_raw(Box::new([1u8; 10])) as *mut u8,  ","      cap: 10,  ","      ref_cnt: AtomicUsize::new(1),  ","  })) as _);  ","","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([2u8; 5])) } as *const u8; // This pointer points to different data  ","  let len = 5;  ","","  unsafe {  ","      let result = promotable_even_clone(&data, valid_ptr, len);  ","  }  ","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([1u8; 10])) as *mut u8, cap: 10, ref_cnt: AtomicUsize::new(1), })) as _);  ","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([2u8; 5])) } as *const u8;  ","  let len = 5;  ","  let result; ","  unsafe { result = promotable_even_clone(&data, valid_ptr, len); }  ","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","   let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {","       buf: Box::into_raw(Box::new([3u8; 100])) as *mut u8,","       cap: 100,","       ref_cnt: AtomicUsize::new(1),","   })) as _);","","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([4u8; 20])) as *const u8 };","  let len = 20; // Large length","","  let result = unsafe {","      promotable_even_clone(&data, valid_ptr, len)","  };","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([3u8; 100])) as *mut u8, cap: 100, ref_cnt: AtomicUsize::new(1), })) as _);","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([4u8; 20])) as *const u8 };","   let len = 20;","   let result = unsafe { promotable_even_clone(&data, valid_ptr, len) };","   assert_eq!(result.len, len);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {","        buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8,","        cap: 3,","        ref_cnt: AtomicUsize::new(1),","    })) as _);","","   let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };","   let len = 3;","","   unsafe {","       let result = promotable_even_clone(&data, valid_ptr, len);","   }","   let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8, cap: 3, ref_cnt: AtomicUsize::new(1), })) as _);","   let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };","    let len = 3;","    let kind = (data.load(Ordering::Acquire) as usize) & KIND_MASK;","    assert_eq!(kind, KIND_VEC);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {  ","      buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8,  ","      cap: 3,  ","      ref_cnt: AtomicUsize::new(1),  ","  })) as _);  ","","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };  ","  let len = 3;  ","","  let result;  ","  unsafe {  ","      result = promotable_even_clone(&data, valid_ptr, len);  ","  }  ","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8, cap: 3, ref_cnt: AtomicUsize::new(1), })) as _);  ","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };  ","  let len = 3;  ","  assert!(result.ptr != valid_ptr);  ","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {","        buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8,","        cap: 3,","        ref_cnt: AtomicUsize::new(1),","    })) as _);","","   let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };","   let len = 3;","   ","  let result;  ","  unsafe {  ","      result = promotable_even_clone(&data, valid_ptr, len);  ","  }  ","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8, cap: 3, ref_cnt: AtomicUsize::new(1), })) as _);  ","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };  ","  let len = 3;  ","  let kind = (data.load(Ordering::Acquire) as usize) & KIND_MASK;  ","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {","        buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8,","        cap: 3,","        ref_cnt: AtomicUsize::new(1),","    })) as _);","","   let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };","   let len = 3;","   ","  let result;","  unsafe {","      result = promotable_even_clone(&data, valid_ptr, len);","  }","  let data = AtomicPtr::new(Box::into_raw(Box::new(Shared { buf: Box::into_raw(Box::new([5u8; 3])) as *mut u8, cap: 3, ref_cnt: AtomicUsize::new(1), })) as _);","  let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([6u8; 3])) as *const u8 };","  let len = 3;","  let kind = (data.load(Ordering::Acquire) as usize) & KIND_MASK;","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(Shared {","        buf: Box::into_raw(Box::new([7u8; 10])) as *mut u8,","        cap: 10,","        ref_cnt: AtomicUsize::new(1),","    })) as _);","","   let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([8u8; 10])) as *const u8 };  ","   let len = 10; // Matching the buffer size  "," ","   unsafe {  ","       let result1 = promotable_even_clone(&data, valid_ptr, len);  ","       let result2 = promotable_even_clone(&data, valid_ptr, len);  ","   }  ","  // Removed duplicate lines of code that were not needed","  // let valid_ptr: *const u8 = unsafe { Box::into_raw(Box::new([8u8; 10])) };","  // let len = 10;","  // let result1 = promotable_even_clone(&data, valid_ptr, len);","  // let result2 = promotable_even_clone(&data, valid_ptr, len);","  // assert_eq!(result2.ptr as *const u8, valid_ptr);","}"],[{"start_line":1212,"start_column":8,"end_line":1212,"end_column":24,"positive":true,"negative":false}]]]}