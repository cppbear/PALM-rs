[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct BufMutImpl {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "    ",
          "    unsafe impl BufMut for BufMutImpl {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
          "            unimplemented!()",
          "        }",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "    }",
          "    ",
          "    let buf_a = BufMutImpl { buffer: vec![0; 5], position: 0 };",
          "    let buf_b = BufMutImpl { buffer: vec![0; 10], position: 0 };",
          "    ",
          "    let mut chain = Chain { a: buf_a, b: buf_b };",
          "    let cnt = 6; // a_rem = 5, cnt = 6",
          "",
          "    unsafe {",
          "        chain.advance_mut(cnt);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let a_rem = chain.a.remaining_mut();",
            "    assert_eq!(a_rem, 5);"
          ],
          [
            "    let a_rem = chain.a.remaining_mut();",
            "    assert_eq!(chain.a.position, 5);"
          ],
          [
            "    let a_rem = chain.a.remaining_mut();",
            "    assert_eq!(chain.b.position, 6);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "    ",
            "    let buf_a = BufMutImpl { buffer: vec![0; 5], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 10], position: 0 };",
            "    ",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 6; // a_rem = 5, cnt = 6",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_rem = chain.a.remaining_mut();",
            "    assert_eq!(a_rem, 5);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "    ",
            "    let buf_a = BufMutImpl { buffer: vec![0; 5], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 10], position: 0 };",
            "    ",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 6; // a_rem = 5, cnt = 6",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_rem = chain.a.remaining_mut();",
            "    assert_eq!(chain.a.position, 5);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "    ",
            "    let buf_a = BufMutImpl { buffer: vec![0; 5], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 10], position: 0 };",
            "    ",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 6; // a_rem = 5, cnt = 6",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_rem = chain.a.remaining_mut();",
            "    assert_eq!(chain.b.position, 6);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct BufMutImpl {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "    ",
          "    unsafe impl BufMut for BufMutImpl {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
          "            unimplemented!()",
          "        }",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "    }",
          "    ",
          "    let buf_a = BufMutImpl { buffer: vec![0; 7], position: 0 };",
          "    let buf_b = BufMutImpl { buffer: vec![0; 3], position: 0 };",
          "    ",
          "    let mut chain = Chain { a: buf_a, b: buf_b };",
          "    let cnt = 8; // a_rem = 7, cnt = 8",
          "",
          "    unsafe {",
          "        chain.advance_mut(cnt);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let a_rem = 7;",
            "    let cnt = 8;",
            "    let expected_position_a = 7;",
            "    let expected_position_b = 1;",
            "    assert_eq!(chain.a.position, expected_position_a);"
          ],
          [
            "    let a_rem = 7;",
            "    let cnt = 8;",
            "    let expected_position_a = 7;",
            "    let expected_position_b = 1;",
            "    assert_eq!(chain.b.position, expected_position_b);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "    ",
            "    let buf_a = BufMutImpl { buffer: vec![0; 7], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 3], position: 0 };",
            "    ",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 8; // a_rem = 7, cnt = 8",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_rem = 7;",
            "    let cnt = 8;",
            "    let expected_position_a = 7;",
            "    let expected_position_b = 1;",
            "    assert_eq!(chain.a.position, expected_position_a);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "    ",
            "    let buf_a = BufMutImpl { buffer: vec![0; 7], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 3], position: 0 };",
            "    ",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 8; // a_rem = 7, cnt = 8",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_rem = 7;",
            "    let cnt = 8;",
            "    let expected_position_a = 7;",
            "    let expected_position_b = 1;",
            "    assert_eq!(chain.b.position, expected_position_b);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct BufMutImpl {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "    ",
          "    unsafe impl BufMut for BufMutImpl {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
          "            unimplemented!()",
          "        }",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "    }",
          "",
          "    let buf_a = BufMutImpl { buffer: vec![0; 15], position: 0 };",
          "    let buf_b = BufMutImpl { buffer: vec![0; 5], position: 0 };",
          "",
          "    let mut chain = Chain { a: buf_a, b: buf_b };",
          "    let cnt = 16; // a_rem = 15, cnt = 16",
          "",
          "    unsafe {",
          "        chain.advance_mut(cnt);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let buf_a_rem = chain.a.remaining_mut();",
            "    let buf_b_rem = chain.b.remaining_mut();",
            "    let expected_a_position = 15;",
            "    let expected_b_position = 1;",
            "    assert_eq!(buf_a_rem, expected_a_position);"
          ],
          [
            "    let buf_a_rem = chain.a.remaining_mut();",
            "    let buf_b_rem = chain.b.remaining_mut();",
            "    let expected_a_position = 15;",
            "    let expected_b_position = 1;",
            "    assert_eq!(buf_b_rem, expected_b_position);"
          ],
          [
            "    let buf_a_rem = chain.a.remaining_mut();",
            "    let buf_b_rem = chain.b.remaining_mut();",
            "    let expected_a_position = 15;",
            "    let expected_b_position = 1;",
            "    assert_eq!(chain.a.position, expected_a_position);"
          ],
          [
            "    let buf_a_rem = chain.a.remaining_mut();",
            "    let buf_b_rem = chain.b.remaining_mut();",
            "    let expected_a_position = 15;",
            "    let expected_b_position = 1;",
            "    assert_eq!(chain.b.position, expected_b_position);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "",
            "    let buf_a = BufMutImpl { buffer: vec![0; 15], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 5], position: 0 };",
            "",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 16; // a_rem = 15, cnt = 16",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let buf_a_rem = chain.a.remaining_mut();",
            "    let buf_b_rem = chain.b.remaining_mut();",
            "    let expected_a_position = 15;",
            "    let expected_b_position = 1;",
            "    assert_eq!(buf_a_rem, expected_a_position);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "",
            "    let buf_a = BufMutImpl { buffer: vec![0; 15], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 5], position: 0 };",
            "",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 16; // a_rem = 15, cnt = 16",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let buf_a_rem = chain.a.remaining_mut();",
            "    let buf_b_rem = chain.b.remaining_mut();",
            "    let expected_a_position = 15;",
            "    let expected_b_position = 1;",
            "    assert_eq!(buf_b_rem, expected_b_position);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "",
            "    let buf_a = BufMutImpl { buffer: vec![0; 15], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 5], position: 0 };",
            "",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 16; // a_rem = 15, cnt = 16",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let buf_a_rem = chain.a.remaining_mut();",
            "    let buf_b_rem = chain.b.remaining_mut();",
            "    let expected_a_position = 15;",
            "    let expected_b_position = 1;",
            "    assert_eq!(chain.a.position, expected_a_position);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "",
            "    let buf_a = BufMutImpl { buffer: vec![0; 15], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 5], position: 0 };",
            "",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 16; // a_rem = 15, cnt = 16",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let buf_a_rem = chain.a.remaining_mut();",
            "    let buf_b_rem = chain.b.remaining_mut();",
            "    let expected_a_position = 15;",
            "    let expected_b_position = 1;",
            "    assert_eq!(chain.b.position, expected_b_position);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct BufMutImpl {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "    ",
          "    unsafe impl BufMut for BufMutImpl {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
          "            unimplemented!()",
          "        }",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "    }",
          "",
          "    let buf_a = BufMutImpl { buffer: vec![0; 3], position: 0 };",
          "    let buf_b = BufMutImpl { buffer: vec![0; 8], position: 0 };",
          "",
          "    let mut chain = Chain { a: buf_a, b: buf_b };",
          "    let cnt = 4; // a_rem = 3, cnt = 4",
          "",
          "    unsafe {",
          "        chain.advance_mut(cnt);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let a_remaining = chain.a.remaining_mut();",
            "    assert_eq!(a_remaining, 3);"
          ],
          [
            "    let a_remaining = chain.a.remaining_mut();",
            "    let b_position_after_advance = chain.b.position;",
            "    assert_eq!(b_position_after_advance, 0);"
          ],
          [
            "    let a_remaining = chain.a.remaining_mut();",
            "    let b_position_after_advance = chain.b.position;",
            "    let a_position_after_advance = chain.a.position;",
            "    assert_eq!(a_position_after_advance, 3);"
          ],
          [
            "    let a_remaining = chain.a.remaining_mut();",
            "    let b_position_after_advance = chain.b.position;",
            "    let a_position_after_advance = chain.a.position;",
            "    let b_remaining_after_advance = chain.b.remaining_mut();",
            "    assert_eq!(b_remaining_after_advance, 8);"
          ],
          [
            "    let a_remaining = chain.a.remaining_mut();",
            "    let b_position_after_advance = chain.b.position;",
            "    let a_position_after_advance = chain.a.position;",
            "    let b_remaining_after_advance = chain.b.remaining_mut();",
            "    let cnt_remaining = 4 - a_remaining;",
            "    assert_eq!(cnt_remaining, 1);"
          ],
          [
            "    let a_remaining = chain.a.remaining_mut();",
            "    let b_position_after_advance = chain.b.position;",
            "    let a_position_after_advance = chain.a.position;",
            "    let b_remaining_after_advance = chain.b.remaining_mut();",
            "    let cnt_remaining = 4 - a_remaining;",
            "    unsafe { chain.b.advance_mut(cnt_remaining); }",
            "    assert_eq!(chain.b.position, 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "",
            "    let buf_a = BufMutImpl { buffer: vec![0; 3], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 8], position: 0 };",
            "",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 4; // a_rem = 3, cnt = 4",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_remaining = chain.a.remaining_mut();",
            "    assert_eq!(a_remaining, 3);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "",
            "    let buf_a = BufMutImpl { buffer: vec![0; 3], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 8], position: 0 };",
            "",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 4; // a_rem = 3, cnt = 4",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_remaining = chain.a.remaining_mut();",
            "    let b_position_after_advance = chain.b.position;",
            "    assert_eq!(b_position_after_advance, 0);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "",
            "    let buf_a = BufMutImpl { buffer: vec![0; 3], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 8], position: 0 };",
            "",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 4; // a_rem = 3, cnt = 4",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_remaining = chain.a.remaining_mut();",
            "    let b_position_after_advance = chain.b.position;",
            "    let a_position_after_advance = chain.a.position;",
            "    assert_eq!(a_position_after_advance, 3);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "",
            "    let buf_a = BufMutImpl { buffer: vec![0; 3], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 8], position: 0 };",
            "",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 4; // a_rem = 3, cnt = 4",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_remaining = chain.a.remaining_mut();",
            "    let b_position_after_advance = chain.b.position;",
            "    let a_position_after_advance = chain.a.position;",
            "    let b_remaining_after_advance = chain.b.remaining_mut();",
            "    assert_eq!(b_remaining_after_advance, 8);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "",
            "    let buf_a = BufMutImpl { buffer: vec![0; 3], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 8], position: 0 };",
            "",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 4; // a_rem = 3, cnt = 4",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_remaining = chain.a.remaining_mut();",
            "    let b_position_after_advance = chain.b.position;",
            "    let a_position_after_advance = chain.a.position;",
            "    let b_remaining_after_advance = chain.b.remaining_mut();",
            "    let cnt_remaining = 4 - a_remaining;",
            "    assert_eq!(cnt_remaining, 1);",
            "}"
          ],
          [
            "{",
            "    struct BufMutImpl {",
            "        buffer: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    unsafe impl BufMut for BufMutImpl {",
            "        fn remaining_mut(&self) -> usize {",
            "            self.buffer.len() - self.position",
            "        }",
            "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
            "            unimplemented!()",
            "        }",
            "        unsafe fn advance_mut(&mut self, cnt: usize) {",
            "            self.position += cnt;",
            "        }",
            "    }",
            "",
            "    let buf_a = BufMutImpl { buffer: vec![0; 3], position: 0 };",
            "    let buf_b = BufMutImpl { buffer: vec![0; 8], position: 0 };",
            "",
            "    let mut chain = Chain { a: buf_a, b: buf_b };",
            "    let cnt = 4; // a_rem = 3, cnt = 4",
            "",
            "    unsafe {",
            "        chain.advance_mut(cnt);",
            "    }",
            "    let a_remaining = chain.a.remaining_mut();",
            "    let b_position_after_advance = chain.b.position;",
            "    let a_position_after_advance = chain.a.position;",
            "    let b_remaining_after_advance = chain.b.remaining_mut();",
            "    let cnt_remaining = 4 - a_remaining;",
            "    unsafe { chain.b.advance_mut(cnt_remaining); }",
            "    assert_eq!(chain.b.position, 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]