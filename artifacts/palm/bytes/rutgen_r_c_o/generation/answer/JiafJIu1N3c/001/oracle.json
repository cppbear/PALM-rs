[
  {
    "uses": [
      "use core::ptr::null_mut;",
      "use std::sync::atomic::AtomicPtr;",
      "use std::sync::atomic::Ordering;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::null_mut;",
          "    use std::sync::atomic::{AtomicPtr, Ordering};",
          "",
          "    struct Dummy;",
          "",
          "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
          "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
          "    let len: usize = 10;",
          "",
          "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
          "        let buffer = vec![0u8; 20]; // Simulated buffer",
          "        buffer.as_mut_ptr()",
          "    }",
          "",
          "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
          "}"
        ],
        "oracles": [
          [
            "    let shared_data = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len = 10;",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    assert!(!shared_data.load(Ordering::Acquire).is_null());"
          ],
          [
            "    let shared_data = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len = 10;",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    assert_eq!(_result.len(), len);"
          ],
          [
            "    let shared_data = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len = 10;",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    assert!(unsafe { _result.ptr.as_ptr() } == dummy_function(shared_data.load(Ordering::Acquire)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared_data = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len = 10;",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    assert!(!shared_data.load(Ordering::Acquire).is_null());",
            "}"
          ],
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared_data = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len = 10;",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    assert_eq!(_result.len(), len);",
            "}"
          ],
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared_data = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len = 10;",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    assert!(unsafe { _result.ptr.as_ptr() } == dummy_function(shared_data.load(Ordering::Acquire)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::null_mut;",
          "    use std::sync::atomic::{AtomicPtr, Ordering};",
          "",
          "    struct Dummy;",
          "",
          "    // Prepare a scenario where the kind is KIND_VEC",
          "    let vec = vec![0u8; 20];",
          "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
          "    let shared_data = AtomicPtr::new(buffer);",
          "",
          "    let ptr: *const u8 = buffer;",
          "    let len: usize = 10;",
          "",
          "    unsafe fn dummy_function(shared: *mut ()) -> *mut u8 {",
          "        shared as *mut u8",
          "    }",
          "",
          "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
          "}"
        ],
        "oracles": [
          [
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    assert!(buffer.is_null() == false);"
          ],
          [
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    assert!(len > 0);"
          ],
          [
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };",
            "    assert!(result.len() == len);"
          ],
          [
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };",
            "    assert!(result.capacity() >= len);"
          ],
          [
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };",
            "    assert!(result.is_empty() == false);"
          ],
          [
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };",
            "    assert!(result.as_slice().len() == len);"
          ],
          [
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };",
            "    assert!(result.as_slice().iter().all(|&x| x == 0));"
          ]
        ],
        "codes": [
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    // Prepare a scenario where the kind is KIND_VEC",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let shared_data = AtomicPtr::new(buffer);",
            "",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(shared: *mut ()) -> *mut u8 {",
            "        shared as *mut u8",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    assert!(buffer.is_null() == false);",
            "}"
          ],
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    // Prepare a scenario where the kind is KIND_VEC",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let shared_data = AtomicPtr::new(buffer);",
            "",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(shared: *mut ()) -> *mut u8 {",
            "        shared as *mut u8",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    assert!(len > 0);",
            "}"
          ],
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    // Prepare a scenario where the kind is KIND_VEC",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let shared_data = AtomicPtr::new(buffer);",
            "",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(shared: *mut ()) -> *mut u8 {",
            "        shared as *mut u8",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };",
            "    assert!(result.len() == len);",
            "}"
          ],
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    // Prepare a scenario where the kind is KIND_VEC",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let shared_data = AtomicPtr::new(buffer);",
            "",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(shared: *mut ()) -> *mut u8 {",
            "        shared as *mut u8",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };",
            "    assert!(result.capacity() >= len);",
            "}"
          ],
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    // Prepare a scenario where the kind is KIND_VEC",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let shared_data = AtomicPtr::new(buffer);",
            "",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(shared: *mut ()) -> *mut u8 {",
            "        shared as *mut u8",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };",
            "    assert!(result.is_empty() == false);",
            "}"
          ],
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    // Prepare a scenario where the kind is KIND_VEC",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let shared_data = AtomicPtr::new(buffer);",
            "",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(shared: *mut ()) -> *mut u8 {",
            "        shared as *mut u8",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };",
            "    assert!(result.as_slice().len() == len);",
            "}"
          ],
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    // Prepare a scenario where the kind is KIND_VEC",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let shared_data = AtomicPtr::new(buffer);",
            "",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(shared: *mut ()) -> *mut u8 {",
            "        shared as *mut u8",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let vec = vec![0u8; 20];",
            "    let buffer: *mut u8 = vec.as_ptr() as *mut u8;",
            "    let _shared_data = AtomicPtr::new(buffer);",
            "    let ptr: *const u8 = buffer;",
            "    let len: usize = 10;",
            "    let result = unsafe { promotable_to_mut(&shared_data, ptr, len, dummy_function) };",
            "    assert!(result.as_slice().iter().all(|&x| x == 0));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    use core::ptr::null_mut;",
          "    use std::sync::atomic::{AtomicPtr, Ordering};",
          "",
          "    struct Dummy;",
          "",
          "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
          "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
          "    let len: usize = usize::MAX; // Invalid length",
          "",
          "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
          "        let buffer = vec![0u8; 20]; // Simulated buffer",
          "        buffer.as_mut_ptr()",
          "    }",
          "",
          "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
          "}"
        ],
        "oracles": [
          [
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len: usize = usize::MAX; // Invalid length",
            "    let result = std::panic::catch_unwind(|| {",
            "    promotable_to_mut(&shared_data, ptr, len, dummy_function)",
            "    });",
            "    assert!(result.is_err());"
          ],
          [
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len: usize = usize::MAX; // Invalid length",
            "    let result = std::panic::catch_unwind(|| {",
            "    promotable_to_mut(&shared_data, ptr, len, dummy_function)",
            "    });",
            "    assert_eq!(result.unwrap_err().downcast_ref::<&str>(), None);"
          ]
        ],
        "codes": [
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len: usize = usize::MAX; // Invalid length",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len: usize = usize::MAX; // Invalid length",
            "    let result = std::panic::catch_unwind(|| {",
            "    promotable_to_mut(&shared_data, ptr, len, dummy_function)",
            "    });",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    use core::ptr::null_mut;",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len: usize = usize::MAX; // Invalid length",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = shared_data.load(Ordering::Acquire) as *const u8;",
            "    let len: usize = usize::MAX; // Invalid length",
            "    let result = std::panic::catch_unwind(|| {",
            "    promotable_to_mut(&shared_data, ptr, len, dummy_function)",
            "    });",
            "    assert_eq!(result.unwrap_err().downcast_ref::<&str>(), None);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    use std::sync::atomic::{AtomicPtr, Ordering};",
          "",
          "    struct Dummy;",
          "",
          "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
          "    let ptr: *const u8 = core::ptr::null();",
          "    let len: usize = 10;",
          "",
          "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
          "        let buffer = vec![0u8; 20]; // Simulated buffer",
          "        buffer.as_mut_ptr()",
          "    }",
          "",
          "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
          "}"
        ],
        "oracles": [
          [
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    assert_eq!(shared as usize & KIND_MASK, KIND_ARC);"
          ],
          [
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    assert!(ptr.is_null());"
          ],
          [
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    assert_eq!(len, 10);"
          ],
          [
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    assert!(!buf.is_null());"
          ],
          [
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    assert!(off <= 20);"
          ],
          [
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    let cap = off + len;",
            "    assert!(cap <= 20);"
          ],
          [
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    let cap = off + len;",
            "    let v = Vec::from_raw_parts(buf, cap, cap);",
            "    assert_eq!(v.len(), cap);"
          ],
          [
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    let cap = off + len;",
            "    let v = Vec::from_raw_parts(buf, cap, cap);",
            "    let b = BytesMut::from_vec(v);",
            "    assert_eq!(b.len(), len);"
          ],
          [
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    let cap = off + len;",
            "    let v = Vec::from_raw_parts(buf, cap, cap);",
            "    let b = BytesMut::from_vec(v);",
            "    assert_eq!(b.capacity(), cap);"
          ],
          [
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    let cap = off + len;",
            "    let v = Vec::from_raw_parts(buf, cap, cap);",
            "    let b = BytesMut::from_vec(v);",
            "    assert!(b.is_empty() == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = core::ptr::null();",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    assert_eq!(shared as usize & KIND_MASK, KIND_ARC);",
            "}"
          ],
          [
            "{",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = core::ptr::null();",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    assert!(ptr.is_null());",
            "}"
          ],
          [
            "{",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = core::ptr::null();",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    assert_eq!(len, 10);",
            "}"
          ],
          [
            "{",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = core::ptr::null();",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    assert!(!buf.is_null());",
            "}"
          ],
          [
            "{",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = core::ptr::null();",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    assert!(off <= 20);",
            "}"
          ],
          [
            "{",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = core::ptr::null();",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    let cap = off + len;",
            "    assert!(cap <= 20);",
            "}"
          ],
          [
            "{",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = core::ptr::null();",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    let cap = off + len;",
            "    let v = Vec::from_raw_parts(buf, cap, cap);",
            "    assert_eq!(v.len(), cap);",
            "}"
          ],
          [
            "{",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = core::ptr::null();",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    let cap = off + len;",
            "    let v = Vec::from_raw_parts(buf, cap, cap);",
            "    let b = BytesMut::from_vec(v);",
            "    assert_eq!(b.len(), len);",
            "}"
          ],
          [
            "{",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = core::ptr::null();",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    let cap = off + len;",
            "    let v = Vec::from_raw_parts(buf, cap, cap);",
            "    let b = BytesMut::from_vec(v);",
            "    assert_eq!(b.capacity(), cap);",
            "}"
          ],
          [
            "{",
            "    use std::sync::atomic::{AtomicPtr, Ordering};",
            "",
            "    struct Dummy;",
            "",
            "    let shared_data: AtomicPtr<Dummy> = AtomicPtr::new(Box::into_raw(Box::new(Dummy)));",
            "    let ptr: *const u8 = core::ptr::null();",
            "    let len: usize = 10;",
            "",
            "    unsafe fn dummy_function(_: *mut ()) -> *mut u8 {",
            "        let buffer = vec![0u8; 20]; // Simulated buffer",
            "        buffer.as_mut_ptr()",
            "    }",
            "",
            "    let _result = promotable_to_mut(&shared_data, ptr, len, dummy_function);",
            "    let shared = shared_data.load(Ordering::Acquire);",
            "    let buf = dummy_function(shared.cast());",
            "    let off = offset_from(ptr, buf);",
            "    let cap = off + len;",
            "    let v = Vec::from_raw_parts(buf, cap, cap);",
            "    let b = BytesMut::from_vec(v);",
            "    assert!(b.is_empty() == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]