{
  "name": "bytes::bytes_mut::<bytes_mut::BytesMut as buf::buf_mut::BufMut>::put",
  "name_with_impl": "bytes::bytes_mut::{impl#3}::put",
  "mod_info": {
    "name": "bytes_mut",
    "loc": "src/lib.rs:83:1:83:15"
  },
  "visible": true,
  "loc": "src/bytes_mut.rs:1201:5:1211:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: src.has_remaining() is true\n",
        "// constraint: src.has_remaining() is false\n"
      ],
      "input_infer": "0 to 1 for src.has_remaining()\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dest = BytesMut::new();",
                "    let src_data = vec![1u8, 2, 3, 4, 5];",
                "    let mut src = BytesMut::from_vec(src_data);",
                "    dest.put(src);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(dest.len(), 0);"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert!(dest.is_empty());"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(dest.capacity(), 0);"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert_eq!(dest.len(), 5);"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(!dest.is_empty());"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(dest.capacity() > 0);"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert_eq!(dest.as_slice(), &[1, 2, 3, 4, 5]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(dest.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert!(dest.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(dest.capacity(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert_eq!(dest.len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(!dest.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(dest.capacity() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert_eq!(dest.as_slice(), &[1, 2, 3, 4, 5]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dest = BytesMut::new();",
                "    let src_data: Vec<u8> = vec![];",
                "    let mut src = BytesMut::from_vec(src_data);",
                "    dest.put(src);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(dest.len(), 0);"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(src.len(), 0);"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert!(src.has_remaining() == false);"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert!(dest.capacity() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(dest.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(src.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert!(src.has_remaining() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data: Vec<u8> = vec![];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert!(dest.capacity() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dest = BytesMut::new();",
                "    let src_data = vec![10u8];",
                "    let mut src = BytesMut::from_vec(src_data);",
                "    dest.put(src);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(dest.len(), 0);"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(src.len(), 1);"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert!(src.has_remaining());"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert_eq!(dest.len(), 1);"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(src.is_empty());"
                ],
                [
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(!src.has_remaining());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(dest.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(src.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    assert!(src.has_remaining());",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert_eq!(dest.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(src.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![10u8];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(!src.has_remaining());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n    --> src/bytes_mut.rs:1931:9\n     |\n1931 |     let mut src = BytesMut::from_vec(src_data);\n     |         ----^^^\n     |         |\n     |         help: remove this `mut`\n     |\n     = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n    --> src/bytes_mut.rs:1935:9\n     |\n1935 |     let mut src = BytesMut::from_vec(src_data);\n     |         ----^^^\n     |         |\n     |         help: remove this `mut`\n\nerror[E0382]: borrow of moved value: `src`\n    --> src/bytes_mut.rs:1937:13\n     |\n1935 |     let mut src = BytesMut::from_vec(src_data);\n     |         ------- move occurs because `src` has type `bytes_mut::BytesMut`, which does not implement the `Copy` trait\n1936 |     dest.put(src);\n     |              --- value moved here\n1937 |     assert!(src.is_empty());\n     |             ^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `put` to borrow instead if owning the value isn't necessary\n    --> src/buf/buf_mut.rs:202:47\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |        --- in this method                     ^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1936 |     dest.put(src.clone());\n     |                 ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `bytes` (lib test) generated 4 warnings\nerror: could not compile `bytes` (lib test) due to 1 previous error; 4 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n    --> src/bytes_mut.rs:1931:9\n     |\n1931 |     let mut src = BytesMut::from_vec(src_data);\n     |         ----^^^\n     |         |\n     |         help: remove this `mut`\n     |\n     = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n    --> src/bytes_mut.rs:1935:9\n     |\n1935 |     let mut src = BytesMut::from_vec(src_data);\n     |         ----^^^\n     |         |\n     |         help: remove this `mut`\n\nerror[E0382]: borrow of moved value: `src`\n    --> src/bytes_mut.rs:1937:14\n     |\n1935 |     let mut src = BytesMut::from_vec(src_data);\n     |         ------- move occurs because `src` has type `bytes_mut::BytesMut`, which does not implement the `Copy` trait\n1936 |     dest.put(src);\n     |              --- value moved here\n1937 |     assert!(!src.has_remaining());\n     |              ^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `put` to borrow instead if owning the value isn't necessary\n    --> src/buf/buf_mut.rs:202:47\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |        --- in this method                     ^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1936 |     dest.put(src.clone());\n     |                 ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `bytes` (lib test) generated 4 warnings\nerror: could not compile `bytes` (lib test) due to 1 previous error; 4 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dest = BytesMut::new();",
                "    let src_data = vec![0u8; 1024]; // Large buffer of 1024 zeroes",
                "    let mut src = BytesMut::from_vec(src_data);",
                "    dest.put(src);",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dest = BytesMut::new();",
                "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                "    let mut src = BytesMut::from_vec(src_data);",
                "    dest.put(src);",
                "}"
              ],
              "oracles": [
                [
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(dest.len(), 0);"
                ],
                [
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    assert!(src.has_remaining());"
                ],
                [
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(src.remaining(), src_data.len());"
                ],
                [
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert_eq!(dest.len(), src_data.len());"
                ],
                [
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(src.is_empty());"
                ],
                [
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(!dest.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(dest.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    assert!(src.has_remaining());",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    assert_eq!(src.remaining(), src_data.len());",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert_eq!(dest.len(), src_data.len());",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(src.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let mut src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    let dest = BytesMut::new();",
                  "    let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                  "    let src = BytesMut::from_vec(src_data);",
                  "    dest.put(src);",
                  "    assert!(!dest.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused variable: `dest`\n    --> src/bytes_mut.rs:1933:9\n     |\n1933 |     let dest = BytesMut::new();\n     |         ^^^^ help: if this is intentional, prefix it with an underscore: `_dest`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> src/bytes_mut.rs:1931:9\n     |\n1931 |     let mut src = BytesMut::from_vec(src_data);\n     |         ----^^^\n     |         |\n     |         help: remove this `mut`\n     |\n     = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved value: `src_data`\n    --> src/bytes_mut.rs:1936:33\n     |\n1934 |     let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     |         -------- move occurs because `src_data` has type `Vec<u8>`, which does not implement the `Copy` trait\n1935 |     let src = BytesMut::from_vec(src_data);\n     |                                  -------- value moved here\n1936 |     assert_eq!(src.remaining(), src_data.len());\n     |                                 ^^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `from_vec` to borrow instead if owning the value isn't necessary\n    --> src/bytes_mut.rs:924:33\n     |\n924  |     pub(crate) fn from_vec(vec: Vec<u8>) -> BytesMut {\n     |                   --------      ^^^^^^^ this parameter takes ownership of the value\n     |                   |\n     |                   in this method\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1935 |     let src = BytesMut::from_vec(src_data.clone());\n     |                                          ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `bytes` (lib test) generated 4 warnings\nerror: could not compile `bytes` (lib test) due to 1 previous error; 4 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n    --> src/bytes_mut.rs:1931:9\n     |\n1931 |     let mut src = BytesMut::from_vec(src_data);\n     |         ----^^^\n     |         |\n     |         help: remove this `mut`\n     |\n     = note: `#[warn(unused_mut)]` on by default\n\nerror[E0596]: cannot borrow `dest` as mutable, as it is not declared as mutable\n    --> src/bytes_mut.rs:1936:5\n     |\n1936 |     dest.put(src);\n     |     ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1933 |     let mut dest = BytesMut::new();\n     |         +++\n\nerror[E0382]: borrow of moved value: `src_data`\n    --> src/bytes_mut.rs:1937:28\n     |\n1934 |     let src_data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     |         -------- move occurs because `src_data` has type `Vec<u8>`, which does not implement the `Copy` trait\n1935 |     let src = BytesMut::from_vec(src_data);\n     |                                  -------- value moved here\n1936 |     dest.put(src);\n1937 |     assert_eq!(dest.len(), src_data.len());\n     |                            ^^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `from_vec` to borrow instead if owning the value isn't necessary\n    --> src/bytes_mut.rs:924:33\n     |\n924  |     pub(crate) fn from_vec(vec: Vec<u8>) -> BytesMut {\n     |                   --------      ^^^^^^^ this parameter takes ownership of the value\n     |                   |\n     |                   in this method\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1935 |     let src = BytesMut::from_vec(src_data.clone());\n     |                                          ++++++++\n\nSome errors have detailed explanations: E0382, E0596.\nFor more information about an error, try `rustc --explain E0382`.\nwarning: `bytes` (lib test) generated 3 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 3 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling equivalent v1.0.2\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n    --> src/bytes_mut.rs:1931:9\n     |\n1931 |     let mut src = BytesMut::from_vec(src_data);\n     |         ----^^^\n     |         |\n     |         help: remove this `mut`\n     |\n     = note: `#[warn(unused_mut)]` on by default\n\nerror[E0596]: cannot borrow `dest` as mutable, as it is not declared as mutable\n    --> src/bytes_mut.rs:1936:5\n     |\n1936 |     dest.put(src);\n     |     ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1933 |     let mut dest = BytesMut::new();\n     |         +++\n\nerror[E0382]: borrow of moved value: `src`\n    --> src/bytes_mut.rs:1937:13\n     |\n1935 |     let src = BytesMut::from_vec(src_data);\n     |         --- move occurs because `src` has type `bytes_mut::BytesMut`, which does not implement the `Copy` trait\n1936 |     dest.put(src);\n     |              --- value moved here\n1937 |     assert!(src.is_empty());\n     |             ^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `put` to borrow instead if owning the value isn't necessary\n    --> src/buf/buf_mut.rs:202:47\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |        --- in this method                     ^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1936 |     dest.put(src.clone());\n     |                 ++++++++\n\nSome errors have detailed explanations: E0382, E0596.\nFor more information about an error, try `rustc --explain E0382`.\nwarning: `bytes` (lib test) generated 3 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 3 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n    --> src/bytes_mut.rs:1931:9\n     |\n1931 |     let mut src = BytesMut::from_vec(src_data);\n     |         ----^^^\n     |         |\n     |         help: remove this `mut`\n     |\n     = note: `#[warn(unused_mut)]` on by default\n\nerror[E0596]: cannot borrow `dest` as mutable, as it is not declared as mutable\n    --> src/bytes_mut.rs:1936:5\n     |\n1936 |     dest.put(src);\n     |     ^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1933 |     let mut dest = BytesMut::new();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `bytes` (lib test) generated 3 warnings\nerror: could not compile `bytes` (lib test) due to 1 previous error; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: src.has_remaining() is false\n"
      ],
      "input_infer": "0, 1, 2, ..., usize::MAX\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    let empty_src = vec![].into_iter();",
                "    bytes_mut.put(empty_src);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let empty_src = vec![].into_iter();",
                  "    assert_eq!(bytes_mut.len(), 0);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let empty_src = vec![].into_iter();",
                  "    assert_eq!(bytes_mut.capacity(), 0);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let empty_src = vec![].into_iter();",
                  "    assert!(bytes_mut.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let empty_src = vec![].into_iter();",
                  "    bytes_mut.put(empty_src);",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let empty_src = vec![].into_iter();",
                  "    assert_eq!(bytes_mut.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let empty_src = vec![].into_iter();",
                  "    bytes_mut.put(empty_src);",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let empty_src = vec![].into_iter();",
                  "    assert_eq!(bytes_mut.capacity(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let empty_src = vec![].into_iter();",
                  "    bytes_mut.put(empty_src);",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let empty_src = vec![].into_iter();",
                  "    assert!(bytes_mut.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<_>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(empty_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<_>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling syn v1.0.109\n   Compiling equivalent v1.0.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<_>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(empty_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<_>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<_>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(empty_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<_>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 1 previous error; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    let single_elem_src = vec![42].into_iter();",
                "    bytes_mut.put(single_elem_src);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let single_elem_src = vec![42].into_iter();",
                  "    bytes_mut.put(single_elem_src);",
                  "    assert_eq!(bytes_mut.len(), 1);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let single_elem_src = vec![42].into_iter();",
                  "    bytes_mut.put(single_elem_src);",
                  "    assert_eq!(bytes_mut.as_slice()[0], 42);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let single_elem_src = vec![42].into_iter();",
                  "    bytes_mut.put(single_elem_src);",
                  "    assert!(bytes_mut.has_remaining() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let single_elem_src = vec![42].into_iter();",
                  "    bytes_mut.put(single_elem_src);",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let single_elem_src = vec![42].into_iter();",
                  "    bytes_mut.put(single_elem_src);",
                  "    assert_eq!(bytes_mut.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let single_elem_src = vec![42].into_iter();",
                  "    bytes_mut.put(single_elem_src);",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let single_elem_src = vec![42].into_iter();",
                  "    bytes_mut.put(single_elem_src);",
                  "    assert_eq!(bytes_mut.as_slice()[0], 42);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let single_elem_src = vec![42].into_iter();",
                  "    bytes_mut.put(single_elem_src);",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let single_elem_src = vec![42].into_iter();",
                  "    bytes_mut.put(single_elem_src);",
                  "    assert!(bytes_mut.has_remaining() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(single_elem_src);\n     |               --- ^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1934:19\n     |\n1934 |     bytes_mut.put(single_elem_src);\n     |               --- ^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling syn v1.0.109\n   Compiling equivalent v1.0.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(single_elem_src);\n     |               --- ^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1934:19\n     |\n1934 |     bytes_mut.put(single_elem_src);\n     |               --- ^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: buf_impl::Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(single_elem_src);\n     |               --- ^^^^^^^^^^^^^^^ the trait `buf_impl::Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `buf_impl::Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: buf_impl::Buf` is not satisfied\n    --> src/bytes_mut.rs:1934:19\n     |\n1934 |     bytes_mut.put(single_elem_src);\n     |               --- ^^^^^^^^^^^^^^^ the trait `buf_impl::Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `buf_impl::Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    let two_elems_src = vec![1, 2].into_iter();",
                "    bytes_mut.put(two_elems_src);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    assert_eq!(bytes_mut.len(), 2);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    assert_eq!(bytes_mut.as_slice(), &[1, 2]);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    assert!(bytes_mut.capacity() >= 2);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    assert!(!bytes_mut.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    assert_eq!(bytes_mut.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    assert_eq!(bytes_mut.as_slice(), &[1, 2]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    assert!(bytes_mut.capacity() >= 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let two_elems_src = vec![1, 2].into_iter();",
                  "    bytes_mut.put(two_elems_src);",
                  "    assert!(!bytes_mut.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(two_elems_src);\n     |               --- ^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1934:19\n     |\n1934 |     bytes_mut.put(two_elems_src);\n     |               --- ^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(two_elems_src);\n     |               --- ^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1934:19\n     |\n1934 |     bytes_mut.put(two_elems_src);\n     |               --- ^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(two_elems_src);\n     |               --- ^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1934:19\n     |\n1934 |     bytes_mut.put(two_elems_src);\n     |               --- ^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(two_elems_src);\n     |               --- ^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1934:19\n     |\n1934 |     bytes_mut.put(two_elems_src);\n     |               --- ^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut bytes_mut = BytesMut::with_capacity(1024);",
                "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                "    bytes_mut.put(large_src);",
                "}"
              ],
              "oracles": [
                [
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    assert_eq!(bytes_mut.len(), 0);"
                ],
                [
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    assert_eq!(bytes_mut.capacity(), 1024);"
                ],
                [
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    assert!(bytes_mut.is_empty());"
                ],
                [
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    assert_eq!(bytes_mut.len(), 1024);"
                ],
                [
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    assert!(!bytes_mut.is_empty());"
                ],
                [
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    assert_eq!(bytes_mut.capacity(), 1024);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    assert_eq!(bytes_mut.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    assert_eq!(bytes_mut.capacity(), 1024);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    assert!(bytes_mut.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    assert_eq!(bytes_mut.len(), 1024);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    assert!(!bytes_mut.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    let bytes_mut = BytesMut::with_capacity(1024);",
                  "    let large_src = (0..1024).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(large_src);",
                  "    assert_eq!(bytes_mut.capacity(), 1024);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.15.2\n   Compiling syn v1.0.109\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(large_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling syn v1.0.109\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(large_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling syn v1.0.109\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(large_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.15.2\n   Compiling syn v1.0.109\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(large_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1934:19\n     |\n1934 |     bytes_mut.put(large_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(large_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1934:19\n     |\n1934 |     bytes_mut.put(large_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling syn v1.0.109\n   Compiling equivalent v1.0.2\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1931:19\n     |\n1931 |     bytes_mut.put(large_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1934:19\n     |\n1934 |     bytes_mut.put(large_src);\n     |               --- ^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let capacity = 16;",
                "    let mut bytes_mut = BytesMut::with_capacity(capacity);",
                "    let full_capacity_src = (0..capacity).collect::<Vec<u8>>().into_iter();",
                "    bytes_mut.put(full_capacity_src);",
                "}"
              ],
              "oracles": [
                [
                  "    let capacity = 16;",
                  "    let bytes_mut = BytesMut::with_capacity(capacity);",
                  "    assert_eq!(bytes_mut.len(), 0);"
                ],
                [
                  "    let capacity = 16;",
                  "    let bytes_mut = BytesMut::with_capacity(capacity);",
                  "    assert!(bytes_mut.is_empty());"
                ],
                [
                  "    let capacity = 16;",
                  "    let bytes_mut = BytesMut::with_capacity(capacity);",
                  "    assert_eq!(bytes_mut.capacity(), capacity);"
                ],
                [
                  "    let capacity = 16;",
                  "    let bytes_mut = BytesMut::with_capacity(capacity);",
                  "    assert!(bytes_mut.has_remaining() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let capacity = 16;",
                  "    let mut bytes_mut = BytesMut::with_capacity(capacity);",
                  "    let full_capacity_src = (0..capacity).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(full_capacity_src);",
                  "    let capacity = 16;",
                  "    let bytes_mut = BytesMut::with_capacity(capacity);",
                  "    assert_eq!(bytes_mut.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let capacity = 16;",
                  "    let mut bytes_mut = BytesMut::with_capacity(capacity);",
                  "    let full_capacity_src = (0..capacity).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(full_capacity_src);",
                  "    let capacity = 16;",
                  "    let bytes_mut = BytesMut::with_capacity(capacity);",
                  "    assert!(bytes_mut.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let capacity = 16;",
                  "    let mut bytes_mut = BytesMut::with_capacity(capacity);",
                  "    let full_capacity_src = (0..capacity).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(full_capacity_src);",
                  "    let capacity = 16;",
                  "    let bytes_mut = BytesMut::with_capacity(capacity);",
                  "    assert_eq!(bytes_mut.capacity(), capacity);",
                  "}"
                ],
                [
                  "{",
                  "    let capacity = 16;",
                  "    let mut bytes_mut = BytesMut::with_capacity(capacity);",
                  "    let full_capacity_src = (0..capacity).collect::<Vec<u8>>().into_iter();",
                  "    bytes_mut.put(full_capacity_src);",
                  "    let capacity = 16;",
                  "    let bytes_mut = BytesMut::with_capacity(capacity);",
                  "    assert!(bytes_mut.has_remaining() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling syn v1.0.109\n   Compiling equivalent v1.0.2\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: a value of type `alloc::vec::Vec<u8>` cannot be built from an iterator over elements of type `usize`\n    --> src/bytes_mut.rs:1931:53\n     |\n1931 |     let full_capacity_src = (0..capacity).collect::<Vec<u8>>().into_iter();\n     |                                           -------   ^^^^^^^ value of type `alloc::vec::Vec<u8>` cannot be built from `std::iter::Iterator<Item=usize>`\n     |                                           |\n     |                                           required by a bound introduced by this call\n     |\n     = help: the trait `FromIterator<usize>` is not implemented for `alloc::vec::Vec<u8>`\n     = help: the trait `FromIterator<u8>` is implemented for `alloc::vec::Vec<u8>`\n     = help: for that trait implementation, expected `u8`, found `usize`\nnote: required by a bound in `collect`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2001:19\n     |\n2001 |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1932:19\n     |\n1932 |     bytes_mut.put(full_capacity_src);\n     |               --- ^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.15.2\n   Compiling syn v1.0.109\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: a value of type `alloc::vec::Vec<u8>` cannot be built from an iterator over elements of type `usize`\n    --> src/bytes_mut.rs:1931:53\n     |\n1931 |     let full_capacity_src = (0..capacity).collect::<Vec<u8>>().into_iter();\n     |                                           -------   ^^^^^^^ value of type `alloc::vec::Vec<u8>` cannot be built from `std::iter::Iterator<Item=usize>`\n     |                                           |\n     |                                           required by a bound introduced by this call\n     |\n     = help: the trait `FromIterator<usize>` is not implemented for `alloc::vec::Vec<u8>`\n     = help: the trait `FromIterator<u8>` is implemented for `alloc::vec::Vec<u8>`\n     = help: for that trait implementation, expected `u8`, found `usize`\nnote: required by a bound in `collect`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2001:19\n     |\n2001 |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1932:19\n     |\n1932 |     bytes_mut.put(full_capacity_src);\n     |               --- ^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling hashbrown v0.15.2\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: a value of type `alloc::vec::Vec<u8>` cannot be built from an iterator over elements of type `usize`\n    --> src/bytes_mut.rs:1931:53\n     |\n1931 |     let full_capacity_src = (0..capacity).collect::<Vec<u8>>().into_iter();\n     |                                           -------   ^^^^^^^ value of type `alloc::vec::Vec<u8>` cannot be built from `std::iter::Iterator<Item=usize>`\n     |                                           |\n     |                                           required by a bound introduced by this call\n     |\n     = help: the trait `FromIterator<usize>` is not implemented for `alloc::vec::Vec<u8>`\n     = help: the trait `FromIterator<u8>` is implemented for `alloc::vec::Vec<u8>`\n     = help: for that trait implementation, expected `u8`, found `usize`\nnote: required by a bound in `collect`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2001:19\n     |\n2001 |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1932:19\n     |\n1932 |     bytes_mut.put(full_capacity_src);\n     |               --- ^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling syn v1.0.109\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: a value of type `alloc::vec::Vec<u8>` cannot be built from an iterator over elements of type `usize`\n    --> src/bytes_mut.rs:1931:53\n     |\n1931 |     let full_capacity_src = (0..capacity).collect::<Vec<u8>>().into_iter();\n     |                                           -------   ^^^^^^^ value of type `alloc::vec::Vec<u8>` cannot be built from `std::iter::Iterator<Item=usize>`\n     |                                           |\n     |                                           required by a bound introduced by this call\n     |\n     = help: the trait `FromIterator<usize>` is not implemented for `alloc::vec::Vec<u8>`\n     = help: the trait `FromIterator<u8>` is implemented for `alloc::vec::Vec<u8>`\n     = help: for that trait implementation, expected `u8`, found `usize`\nnote: required by a bound in `collect`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2001:19\n     |\n2001 |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<u8>: buf_impl::Buf` is not satisfied\n    --> src/bytes_mut.rs:1932:19\n     |\n1932 |     bytes_mut.put(full_capacity_src);\n     |               --- ^^^^^^^^^^^^^^^^^ the trait `buf_impl::Buf` is not implemented for `alloc::vec::IntoIter<u8>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `buf_impl::Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                "    for chunk in chunks {",
                "        bytes_mut.put(chunk.into_iter());",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.len(), 3);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.as_slice(), &[1, 2, 3]);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.len(), 5);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.as_slice(), &[1, 2, 3, 4, 5]);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.len(), 6);"
                ],
                [
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.as_slice(), &[1, 2, 3, 4, 5, 6]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    for chunk in chunks {",
                  "        bytes_mut.put(chunk.into_iter());",
                  "    }",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    for chunk in chunks {",
                  "        bytes_mut.put(chunk.into_iter());",
                  "    }",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.as_slice(), &[1, 2, 3]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    for chunk in chunks {",
                  "        bytes_mut.put(chunk.into_iter());",
                  "    }",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    for chunk in chunks {",
                  "        bytes_mut.put(chunk.into_iter());",
                  "    }",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.as_slice(), &[1, 2, 3, 4, 5]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    for chunk in chunks {",
                  "        bytes_mut.put(chunk.into_iter());",
                  "    }",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.len(), 6);",
                  "}"
                ],
                [
                  "{",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    for chunk in chunks {",
                  "        bytes_mut.put(chunk.into_iter());",
                  "    }",
                  "    let mut bytes_mut = BytesMut::new();",
                  "    let chunks = vec![vec![1, 2, 3], vec![4, 5], vec![6]].into_iter();",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    bytes_mut.put(chunks.next().unwrap().into_iter());",
                  "    assert_eq!(bytes_mut.as_slice(), &[1, 2, 3, 4, 5, 6]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling equivalent v1.0.2\n   Compiling winnow v0.7.6\n   Compiling toml_datetime v0.6.8\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1932:23\n     |\n1932 |         bytes_mut.put(chunk.into_iter());\n     |                   --- ^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |                   |\n     |                   required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1936:19\n     |\n1936 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling syn v1.0.109\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1932:23\n     |\n1932 |         bytes_mut.put(chunk.into_iter());\n     |                   --- ^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |                   |\n     |                   required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1936:19\n     |\n1936 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling equivalent v1.0.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1932:23\n     |\n1932 |         bytes_mut.put(chunk.into_iter());\n     |                   --- ^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |                   |\n     |                   required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1936:19\n     |\n1936 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1937:19\n     |\n1937 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 3 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.15.2\n   Compiling syn v1.0.109\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1932:23\n     |\n1932 |         bytes_mut.put(chunk.into_iter());\n     |                   --- ^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |                   |\n     |                   required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1936:19\n     |\n1936 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1937:19\n     |\n1937 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 3 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling syn v1.0.109\n   Compiling hashbrown v0.15.2\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1932:23\n     |\n1932 |         bytes_mut.put(chunk.into_iter());\n     |                   --- ^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |                   |\n     |                   required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1936:19\n     |\n1936 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1937:19\n     |\n1937 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1938:19\n     |\n1938 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 4 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling unicode-ident v1.0.18\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.15.2\n   Compiling syn v1.0.109\n   Compiling toml_datetime v0.6.8\n   Compiling winnow v0.7.6\n   Compiling serde v1.0.219\n   Compiling indexmap v2.9.0\n   Compiling quote v1.0.40\n   Compiling toml_edit v0.22.24\n   Compiling serde_test v1.0.177\n   Compiling proc-macro-crate v3.3.0\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/bytes_mut.rs:1925:8\n     |\n1925 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1932:23\n     |\n1932 |         bytes_mut.put(chunk.into_iter());\n     |                   --- ^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |                   |\n     |                   required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1936:19\n     |\n1936 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1937:19\n     |\n1937 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nerror[E0277]: the trait bound `alloc::vec::IntoIter<{integer}>: Buf` is not satisfied\n    --> src/bytes_mut.rs:1938:19\n     |\n1938 |     bytes_mut.put(chunks.next().unwrap().into_iter());\n     |               --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Buf` is not implemented for `alloc::vec::IntoIter<{integer}>`\n     |               |\n     |               required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `Buf`:\n               &[u8]\n               &mut T\n               Box<T>\n               VecDeque<u8>\n               bytes::Bytes\n               bytes_mut::BytesMut\n               chain::Chain<T, U>\n               std::io::Cursor<T>\n               take::Take<T>\nnote: required by a bound in `buf_mut::BufMut::put`\n    --> src/buf/buf_mut.rs:202:15\n     |\n202  |     fn put<T: super::Buf>(&mut self, mut src: T)\n     |               ^^^^^^^^^^ required by this bound in `BufMut::put`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 4 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}