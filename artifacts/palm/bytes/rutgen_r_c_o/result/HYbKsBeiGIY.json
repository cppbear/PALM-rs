{"function_name":"bytes::buf::vec_deque::buf::vec_deque::<impl buf::buf_impl::Buf for alloc::collections::VecDeque<u8>>::chunks_vectored","tests":32,"tests_lines":[9,9,9,13,9,9,9,9,9,9,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,16,17,17],"oracles":11,"oracles_compiled":1,"oracles_compiled_rate":9.090909090909092,"tests_compiled":3,"tests_compiled_rate":9.375,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":14,"lines_covered":9,"lines_coveraged_rate":64.28571428571429,"branches":8,"branches_covered":3,"branches_coverage_rate":37.5,"codes_lines":[22,23,24,25,26,27,28,29,30,31,32,33,34,35],"codes_lines_covered":[[["{","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","","    let mut io_slices = [io::IoSlice::new(&[])];","","    let result = deque.chunks_vectored(&mut io_slices);","","    // The return value is not asserted as per the guidelines.","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","    let mut io_slices = [io::IoSlice::new(&[])];","    assert!(io_slices.len() == 1);","}"],[22,23,25,26,27,28,29,30,35]],[["{","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","","    let mut io_slices = [io::IoSlice::new(&[])];","","    let result = deque.chunks_vectored(&mut io_slices);","","    // The return value is not asserted as per the guidelines.","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","    let mut io_slices = [io::IoSlice::new(&[])];","    let result = deque.chunks_vectored(&mut io_slices);","    assert!(io_slices[0].len() == 2);","}"],[22,23,25,26,27,28,29,30,35]],[["{","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","","    let mut io_slices = [io::IoSlice::new(&[])];","","    let result = deque.chunks_vectored(&mut io_slices);","","    // The return value is not asserted as per the guidelines.","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","    let mut io_slices = [io::IoSlice::new(&[])];","    let result = deque.chunks_vectored(&mut io_slices);","    assert!(result == 2);","}"],[22,23,25,26,27,28,29,30,35]]],"codes_branches":[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":true},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":true},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":true,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","","    let mut io_slices = [io::IoSlice::new(&[])];","","    let result = deque.chunks_vectored(&mut io_slices);","","    // The return value is not asserted as per the guidelines.","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","    let mut io_slices = [io::IoSlice::new(&[])];","    assert!(io_slices.len() == 1);","}"],[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":true},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":true},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":true,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}]],[["{","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","","    let mut io_slices = [io::IoSlice::new(&[])];","","    let result = deque.chunks_vectored(&mut io_slices);","","    // The return value is not asserted as per the guidelines.","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","    let mut io_slices = [io::IoSlice::new(&[])];","    let result = deque.chunks_vectored(&mut io_slices);","    assert!(io_slices[0].len() == 2);","}"],[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":true},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":true},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":true,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}]],[["{","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","","    let mut io_slices = [io::IoSlice::new(&[])];","","    let result = deque.chunks_vectored(&mut io_slices);","","    // The return value is not asserted as per the guidelines.","    let mut deque: VecDeque<u8> = VecDeque::new();","    deque.push_back(1);","    deque.push_back(2);","    let mut io_slices = [io::IoSlice::new(&[])];","    let result = deque.chunks_vectored(&mut io_slices);","    assert!(result == 2);","}"],[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":true},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":true},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":true,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}]]]}