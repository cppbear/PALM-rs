{"function_name":"bytes::bytes_mut::shared_v_to_mut","tests":41,"tests_lines":[23,23,23,23,23,23,23,23,23,23,24,24,24,24,23,23,23,23,21,21,21,21,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25],"oracles":9,"oracles_compiled":1,"oracles_compiled_rate":11.11111111111111,"tests_compiled":3,"tests_compiled_rate":7.317073170731707,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":26,"lines_covered":8,"lines_coveraged_rate":30.76923076923077,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1838,1839,1840,1842],"codes_lines_covered":[[["{","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared {","        vec: vec.clone(),","        original_capacity_repr: vec.capacity(),","        ref_count: AtomicUsize::new(2), // Non-unique","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","","    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","    let result = unsafe { shared_v_to_mut(&data, ptr, len) };","    assert_eq!(result.len(), len);","}"],[1815,1816,1817,1818,1838,1839,1840,1842]],[["{","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared {","        vec: vec.clone(),","        original_capacity_repr: vec.capacity(),","        ref_count: AtomicUsize::new(2), // Non-unique","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","","    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","    let result = unsafe { shared_v_to_mut(&data, ptr, len) };","    assert_eq!(result.cap, vec.len() - len);","}"],[1815,1816,1817,1818,1838,1839,1840,1842]],[["{","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared {","        vec: vec.clone(),","        original_capacity_repr: vec.capacity(),","        ref_count: AtomicUsize::new(2), // Non-unique","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","","    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","    let result = unsafe { shared_v_to_mut(&data, ptr, len) };","    assert_eq!(result.as_slice(), &[1, 2, 3]);","}"],[1815,1816,1817,1818,1838,1839,1840,1842]]],"codes_branches":[{"start_line":1818,"start_column":8,"end_line":1818,"end_column":29,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared {","        vec: vec.clone(),","        original_capacity_repr: vec.capacity(),","        ref_count: AtomicUsize::new(2), // Non-unique","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","","    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","    let result = unsafe { shared_v_to_mut(&data, ptr, len) };","    assert_eq!(result.len(), len);","}"],[{"start_line":1818,"start_column":8,"end_line":1818,"end_column":29,"positive":false,"negative":true}]],[["{","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared {","        vec: vec.clone(),","        original_capacity_repr: vec.capacity(),","        ref_count: AtomicUsize::new(2), // Non-unique","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","","    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","    let result = unsafe { shared_v_to_mut(&data, ptr, len) };","    assert_eq!(result.cap, vec.len() - len);","}"],[{"start_line":1818,"start_column":8,"end_line":1818,"end_column":29,"positive":false,"negative":true}]],[["{","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared {","        vec: vec.clone(),","        original_capacity_repr: vec.capacity(),","        ref_count: AtomicUsize::new(2), // Non-unique","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","","    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };","    let vec = vec![1, 2, 3, 4, 5];","    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec.as_ptr();","    let len: usize = 3;","    let result = unsafe { shared_v_to_mut(&data, ptr, len) };","    assert_eq!(result.as_slice(), &[1, 2, 3]);","}"],[{"start_line":1818,"start_column":8,"end_line":1818,"end_column":29,"positive":false,"negative":true}]]]}