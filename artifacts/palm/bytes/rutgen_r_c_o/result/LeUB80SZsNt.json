{"function_name":"bytes::buf::take::<buf::take::Take<T> as buf::buf_impl::Buf>::chunks_vectored","tests":24,"tests_lines":[45,20,21,29,29,29,29,29,29,29,28,28,28,27,30,31,31,46,46,43,43,46,46,46],"oracles":10,"oracles_compiled":5,"oracles_compiled_rate":50.0,"tests_compiled":14,"tests_compiled_rate":58.333333333333336,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":14,"tests_passed":10,"tests_passed_rate":71.42857142857143,"lines":40,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[160,161,162,163,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,192,193,194,195,196,197,198,199,200,202,203],"codes_lines_covered":[[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { false }","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","    }","","    let buf = MockBuf { limit: 0 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 0 };","    assert_eq!(result, 0);","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { false }","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","    }","","    let buf = MockBuf { limit: 0 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 0 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    assert!(slices[0].len() == 0);","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 1 }","        fn chunk(&self) -> &[u8] { &[1] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(result, 0);","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 1 }","        fn chunk(&self) -> &[u8] { &[1] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    assert!(slices.is_empty());","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 1 }","        fn chunk(&self) -> &[u8] { &[1] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(buf.remaining(), 1);","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 1 }","        fn chunk(&self) -> &[u8] { &[1] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    assert!(buf.has_remaining());","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 2 }","        fn chunk(&self) -> &[u8] { &[1, 2] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(result, 1);","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 2 }","        fn chunk(&self) -> &[u8] { &[1, 2] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(slices[0].as_ptr(), buf.chunk().as_ptr());","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 2 }","        fn chunk(&self) -> &[u8] { &[1, 2] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(slices[0].len(), buf.chunk().len());","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 4 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 2 };","    let mut slices: [IoSlice; 2] = [IoSlice::new(&[]), IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 2 };","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(result, 1);","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 4 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 2 };","    let mut slices: [IoSlice; 2] = [IoSlice::new(&[]), IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 2 };","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(slices[0].len(), 4);","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 4 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 2 };","    let mut slices: [IoSlice; 2] = [IoSlice::new(&[]), IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 2 };","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(slices[1].len(), 0);","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 3 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 3 };","    let mut slices: [IoSlice; 3] = [IoSlice::new(&[]), IoSlice::new(&[]), IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 0 };","    assert_eq!(buf.chunks_vectored(&mut slices), 0);","}"],[]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 3 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 3 };","    let mut slices: [IoSlice; 3] = [IoSlice::new(&[]), IoSlice::new(&[]), IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 0 };","    let buf = MockBuf { limit: 3 };","    let mut slices: [IoSlice; 3] = [IoSlice::new(&[]), IoSlice::new(&[]), IoSlice::new(&[])];","    let cnt = buf.chunks_vectored(&mut slices);","    assert!(cnt > 0);","}"],[]]],"codes_branches":[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { false }","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","    }","","    let buf = MockBuf { limit: 0 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 0 };","    assert_eq!(result, 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { false }","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","    }","","    let buf = MockBuf { limit: 0 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 0 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    assert!(slices[0].len() == 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 1 }","        fn chunk(&self) -> &[u8] { &[1] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(result, 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 1 }","        fn chunk(&self) -> &[u8] { &[1] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    assert!(slices.is_empty());","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 1 }","        fn chunk(&self) -> &[u8] { &[1] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(buf.remaining(), 1);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 1 }","        fn chunk(&self) -> &[u8] { &[1] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 0] = [];","    let result = buf.chunks_vectored(&mut slices);","    assert!(buf.has_remaining());","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 2 }","        fn chunk(&self) -> &[u8] { &[1, 2] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(result, 1);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 2 }","        fn chunk(&self) -> &[u8] { &[1, 2] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(slices[0].as_ptr(), buf.chunk().as_ptr());","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 2 }","        fn chunk(&self) -> &[u8] { &[1, 2] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 1 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(slices[0].len(), buf.chunk().len());","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 4 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 2 };","    let mut slices: [IoSlice; 2] = [IoSlice::new(&[]), IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 2 };","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(result, 1);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 4 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 2 };","    let mut slices: [IoSlice; 2] = [IoSlice::new(&[]), IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 2 };","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(slices[0].len(), 4);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 4 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 2 };","    let mut slices: [IoSlice; 2] = [IoSlice::new(&[]), IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 2 };","    let result = buf.chunks_vectored(&mut slices);","    assert_eq!(slices[1].len(), 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 3 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 3 };","    let mut slices: [IoSlice; 3] = [IoSlice::new(&[]), IoSlice::new(&[]), IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 0 };","    assert_eq!(buf.chunks_vectored(&mut slices), 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        limit: usize,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize { 3 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","        fn has_remaining(&self) -> bool { true }","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize { ","            if self.limit > 0 {","                dst[0] = IoSlice::new(self.chunk());","                1 ","            } else { ","                0 ","            }","        }","    }","","    let buf = MockBuf { limit: 3 };","    let mut slices: [IoSlice; 3] = [IoSlice::new(&[]), IoSlice::new(&[]), IoSlice::new(&[])];","    let result = buf.chunks_vectored(&mut slices);","    let buf = MockBuf { limit: 0 };","    let buf = MockBuf { limit: 3 };","    let mut slices: [IoSlice; 3] = [IoSlice::new(&[]), IoSlice::new(&[]), IoSlice::new(&[])];","    let cnt = buf.chunks_vectored(&mut slices);","    assert!(cnt > 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]]]}