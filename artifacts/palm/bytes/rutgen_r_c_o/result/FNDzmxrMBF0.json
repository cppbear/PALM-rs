{"function_name":"bytes::buf::buf_mut::BufMut::put_slice","tests":57,"tests_lines":[13,13,13,12,12,9,10,10,10,10,10,11,11,13,18,18,16,16,17,9,9,9,10,11,11,12,12,12,12,12,12,12,12,12,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,11,11,11,11,11,12,12],"oracles":14,"oracles_compiled":4,"oracles_compiled_rate":28.57142857142857,"tests_compiled":7,"tests_compiled_rate":12.280701754385964,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":7,"tests_passed":7,"tests_passed_rate":100.0,"lines":18,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[246,247,248,249,250,251,252,254,255,256,257,258,259,260,261,262,263,264],"codes_lines_covered":[[["{","    let mut buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 6];","    let input = b\"hello!\";","    unsafe {","        buf.put_slice(&input[..5]); // Only putting \"hello\"","    }","    let remaining_mut = buf.remaining_mut();","    assert_eq!(remaining_mut, 1);","}"],[]],[["{","    let mut buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 6];","    let input = b\"hello!\";","    unsafe {","        buf.put_slice(&input[..5]); // Only putting \"hello\"","    }","    let remaining_mut = buf.remaining_mut();","    let dst = unsafe { buf.chunk_mut() };","    assert_eq!(dst.len(), 1);","}"],[]],[["{","    let mut buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 5];","    let input: &[u8] = &[];","    unsafe {","        buf.put_slice(input);","    }","    let buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 5];","    let input: &[u8] = &[];","    assert_eq!(buf.remaining_mut(), 5);","}"],[]],[["{","    let mut buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 5];","    let input: &[u8] = &[];","    unsafe {","        buf.put_slice(input);","    }","    let buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 5];","    let input: &[u8] = &[];","    assert!(buf.has_remaining_mut());","}"],[]],[["{","    let mut dst = [0; 6];","    let src = b\"hello\";","","    {","        let mut buf = &mut dst[..];","        buf.put_slice(src);","    }","","    // The destination buffer should now contain the bytes from src","    let mut dst = [0; 6];","    let src = b\"hello\";","    let mut buf = &mut dst[..];","    buf.put_slice(src);","    assert_eq!(1, buf.remaining_mut());","}"],[]],[["{","    let mut dst = [0; 6];","    let src = b\"hello\";","","    {","        let mut buf = &mut dst[..];","        buf.put_slice(src);","    }","","    // The destination buffer should now contain the bytes from src","    let mut dst = [0; 6];","    let src = b\"hello\";","    let mut buf = &mut dst[..];","    buf.put_slice(src);","    assert_eq!(b\"hello\\0\", &dst);","}"],[]],[["{","    let mut dst = [0; 6];","    let src: &[u8] = b\"\";","","    {","        let mut buf = &mut dst[..];","        buf.put_slice(src);","    }","","    // The destination buffer should remain unchanged","    assert_eq!(b\"\\0\\0\\0\\0\\0\\0\", &dst);","    let mut dst = [0; 6];","    let src: &[u8] = b\"\";","    let mut buf = &mut dst[..];","    buf.put_slice(src);","    assert_eq!(b\"\\0\\0\\0\\0\\0\\0\", &dst);","}"],[]]],"codes_branches":[{"start_line":247,"start_column":12,"end_line":247,"end_column":44,"positive":false,"negative":false},{"start_line":254,"start_column":15,"end_line":254,"end_column":30,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 6];","    let input = b\"hello!\";","    unsafe {","        buf.put_slice(&input[..5]); // Only putting \"hello\"","    }","    let remaining_mut = buf.remaining_mut();","    assert_eq!(remaining_mut, 1);","}"],[{"start_line":247,"start_column":12,"end_line":247,"end_column":44,"positive":false,"negative":false},{"start_line":254,"start_column":15,"end_line":254,"end_column":30,"positive":false,"negative":false}]],[["{","    let mut buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 6];","    let input = b\"hello!\";","    unsafe {","        buf.put_slice(&input[..5]); // Only putting \"hello\"","    }","    let remaining_mut = buf.remaining_mut();","    let dst = unsafe { buf.chunk_mut() };","    assert_eq!(dst.len(), 1);","}"],[{"start_line":247,"start_column":12,"end_line":247,"end_column":44,"positive":false,"negative":false},{"start_line":254,"start_column":15,"end_line":254,"end_column":30,"positive":false,"negative":false}]],[["{","    let mut buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 5];","    let input: &[u8] = &[];","    unsafe {","        buf.put_slice(input);","    }","    let buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 5];","    let input: &[u8] = &[];","    assert_eq!(buf.remaining_mut(), 5);","}"],[{"start_line":247,"start_column":12,"end_line":247,"end_column":44,"positive":false,"negative":false},{"start_line":254,"start_column":15,"end_line":254,"end_column":30,"positive":false,"negative":false}]],[["{","    let mut buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 5];","    let input: &[u8] = &[];","    unsafe {","        buf.put_slice(input);","    }","    let buf: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 5];","    let input: &[u8] = &[];","    assert!(buf.has_remaining_mut());","}"],[{"start_line":247,"start_column":12,"end_line":247,"end_column":44,"positive":false,"negative":false},{"start_line":254,"start_column":15,"end_line":254,"end_column":30,"positive":false,"negative":false}]],[["{","    let mut dst = [0; 6];","    let src = b\"hello\";","","    {","        let mut buf = &mut dst[..];","        buf.put_slice(src);","    }","","    // The destination buffer should now contain the bytes from src","    let mut dst = [0; 6];","    let src = b\"hello\";","    let mut buf = &mut dst[..];","    buf.put_slice(src);","    assert_eq!(1, buf.remaining_mut());","}"],[{"start_line":247,"start_column":12,"end_line":247,"end_column":44,"positive":false,"negative":false},{"start_line":254,"start_column":15,"end_line":254,"end_column":30,"positive":false,"negative":false}]],[["{","    let mut dst = [0; 6];","    let src = b\"hello\";","","    {","        let mut buf = &mut dst[..];","        buf.put_slice(src);","    }","","    // The destination buffer should now contain the bytes from src","    let mut dst = [0; 6];","    let src = b\"hello\";","    let mut buf = &mut dst[..];","    buf.put_slice(src);","    assert_eq!(b\"hello\\0\", &dst);","}"],[{"start_line":247,"start_column":12,"end_line":247,"end_column":44,"positive":false,"negative":false},{"start_line":254,"start_column":15,"end_line":254,"end_column":30,"positive":false,"negative":false}]],[["{","    let mut dst = [0; 6];","    let src: &[u8] = b\"\";","","    {","        let mut buf = &mut dst[..];","        buf.put_slice(src);","    }","","    // The destination buffer should remain unchanged","    assert_eq!(b\"\\0\\0\\0\\0\\0\\0\", &dst);","    let mut dst = [0; 6];","    let src: &[u8] = b\"\";","    let mut buf = &mut dst[..];","    buf.put_slice(src);","    assert_eq!(b\"\\0\\0\\0\\0\\0\\0\", &dst);","}"],[{"start_line":247,"start_column":12,"end_line":247,"end_column":44,"positive":false,"negative":false},{"start_line":254,"start_column":15,"end_line":254,"end_column":30,"positive":false,"negative":false}]]]}