{"function_name":"bytes::bytes_mut::shared_v_to_vec","tests":27,"tests_lines":[17,17,17,17,17,17,17,17,21,21,17,17,17,17,17,21,21,21,23,26,26,21,21,21,21,21,21],"oracles":10,"oracles_compiled":7,"oracles_compiled_rate":70.0,"tests_compiled":18,"tests_compiled_rate":66.66666666666666,"oracles_run":7,"oracles_passed":4,"oracles_passed_rate":57.14285714285714,"tests_run":18,"tests_passed":7,"tests_passed_rate":38.88888888888889,"lines":19,"lines_covered":19,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1809,1810,1811,1813],"codes_lines_covered":[[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr(); // Valid non-null pointer with len 0","    let len = 0;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr();","    let len = 0;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(result.is_empty());","}"],[1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1813]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr(); // Valid non-null pointer with len 0","    let len = 0;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr();","    let len = 0;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result.len(), 0);","}"],[1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1813]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr(); // Valid non-null pointer with len 0","    let len = 0;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr();","    let len = 0;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(data.load(Ordering::Relaxed).is_null());","}"],[1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1813]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 1,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr(); // Valid non-null pointer with len 1","    let len = 1;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 1, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr();","    let len = 1;","    let vec_result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(vec_result, vec![1u8; 1]);","}"],[]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 1,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr(); // Valid non-null pointer with len 1","    let len = 1;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 1, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr();","    let len = 1;","    let vec_result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(vec_result.len() == len);","}"],[]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 1,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr(); // Valid non-null pointer with len 1","    let len = 1;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 1, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr();","    let len = 1;","    let vec_result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(vec_result.as_ptr() != ptr);","}"],[]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 1,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr(); // Valid non-null pointer with len 1","    let len = 1;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 1, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr();","    let len = 1;","    let vec_result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(data.load(Ordering::Relaxed).is_null() == false);","}"],[]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: MAX_VEC_POS,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; MAX_VEC_POS].as_ptr(); // Valid non-null pointer with len MAX_VEC_POS","    let len = MAX_VEC_POS;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared {","    vec: Vec::new(),","    original_capacity_repr: MAX_VEC_POS,","    ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; MAX_VEC_POS].as_ptr();","    let len = MAX_VEC_POS;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result.len(), MAX_VEC_POS);","}"],[]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 17,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr(); // Valid non-null pointer with len 10","    let len = 10;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 17, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr();","    let len = 10;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result.len(), len);","}"],[]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 17,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr(); // Valid non-null pointer with len 10","    let len = 10;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 17, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr();","    let len = 10;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result, vec![1u8; 10]);","}"],[]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 17,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr(); // Valid non-null pointer with len 10","    let len = 10;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 17, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr();","    let len = 10;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(result.as_ptr() != ptr);","}"],[]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 17,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr(); // Valid non-null pointer with len 10","    let len = 10;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 17, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr();","    let len = 10;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(result.capacity() >= len);","}"],[]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = Vec::<u8>::new().as_ptr(); // Valid non-null pointer with len 0","    let len = 0;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = Vec::<u8>::new().as_ptr(); // Valid non-null pointer with len 0","    let len = 0;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result, Vec::<u8>::new());","}"],[1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1813]],[["{","    let mut shared_instance = Shared {","        vec: vec![0, 1, 2],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    let ptr: *const u8 = [3, 4, 5].as_ptr();","    let len: usize = 3;","","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","","    unsafe {","        let result = shared_v_to_vec(&data, ptr, len);","    }","    let mut shared_instance = Shared { vec: vec![0, 1, 2], original_capacity_repr: 0, ref_count: AtomicUsize::new(2) };","    let ptr: *const u8 = [3, 4, 5].as_ptr();","    let len: usize = 3;","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","    unsafe { let result = shared_v_to_vec(&data, ptr, len); }","    assert_eq!(shared_instance.vec, Vec::new());","}"],[1793,1794,1795,1796,1809,1810,1811,1813]],[["{","    let mut shared_instance = Shared {","        vec: vec![0, 1, 2],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    let ptr: *const u8 = [3, 4, 5].as_ptr();","    let len: usize = 3;","","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","","    unsafe {","        let result = shared_v_to_vec(&data, ptr, len);","    }","    let mut shared_instance = Shared { vec: vec![0, 1, 2], original_capacity_repr: 0, ref_count: AtomicUsize::new(2) };","    let ptr: *const u8 = [3, 4, 5].as_ptr();","    let len: usize = 3;","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","    unsafe { let result = shared_v_to_vec(&data, ptr, len); }","    assert_eq!(shared_instance.ref_count.load(Ordering::Relaxed), 1);","}"],[1793,1794,1795,1796,1809,1810,1811,1813]],[["{","    let mut shared_instance = Shared {","        vec: vec![0],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","","    unsafe {","        let result = shared_v_to_vec(&data, ptr, len);","    }","    let mut shared_instance = Shared { vec: vec![0], original_capacity_repr: 0, ref_count: AtomicUsize::new(2) };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result, vec![]);","}"],[1793,1794,1795,1796,1809,1810,1811,1813]],[["{","    let mut shared_instance = Shared {","        vec: vec![0],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","","    unsafe {","        let result = shared_v_to_vec(&data, ptr, len);","    }","    let mut shared_instance = Shared { vec: vec![0], original_capacity_repr: 0, ref_count: AtomicUsize::new(2) };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(shared_instance.ref_count.load(Ordering::Relaxed), 1);","}"],[1793,1794,1795,1796,1809,1810,1811,1813]],[["{","    let mut shared_instance = Shared {","        vec: vec![0],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","","    unsafe {","        let result = shared_v_to_vec(&data, ptr, len);","    }","    let mut shared_instance = Shared { vec: vec![0], original_capacity_repr: 0, ref_count: AtomicUsize::new(2) };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(shared_instance.vec, vec![0]);","}"],[1793,1794,1795,1796,1809,1810,1811,1813]]],"codes_branches":[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr(); // Valid non-null pointer with len 0","    let len = 0;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr();","    let len = 0;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(result.is_empty());","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":true,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr(); // Valid non-null pointer with len 0","    let len = 0;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr();","    let len = 0;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result.len(), 0);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":true,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr(); // Valid non-null pointer with len 0","    let len = 0;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 0].as_ptr();","    let len = 0;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(data.load(Ordering::Relaxed).is_null());","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":true,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 1,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr(); // Valid non-null pointer with len 1","    let len = 1;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 1, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr();","    let len = 1;","    let vec_result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(vec_result, vec![1u8; 1]);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 1,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr(); // Valid non-null pointer with len 1","    let len = 1;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 1, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr();","    let len = 1;","    let vec_result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(vec_result.len() == len);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 1,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr(); // Valid non-null pointer with len 1","    let len = 1;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 1, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr();","    let len = 1;","    let vec_result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(vec_result.as_ptr() != ptr);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 1,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr(); // Valid non-null pointer with len 1","    let len = 1;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 1, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 1].as_ptr();","    let len = 1;","    let vec_result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(data.load(Ordering::Relaxed).is_null() == false);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: MAX_VEC_POS,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; MAX_VEC_POS].as_ptr(); // Valid non-null pointer with len MAX_VEC_POS","    let len = MAX_VEC_POS;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared {","    vec: Vec::new(),","    original_capacity_repr: MAX_VEC_POS,","    ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; MAX_VEC_POS].as_ptr();","    let len = MAX_VEC_POS;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result.len(), MAX_VEC_POS);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 17,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr(); // Valid non-null pointer with len 10","    let len = 10;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 17, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr();","    let len = 10;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result.len(), len);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 17,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr(); // Valid non-null pointer with len 10","    let len = 10;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 17, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr();","    let len = 10;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result, vec![1u8; 10]);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 17,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr(); // Valid non-null pointer with len 10","    let len = 10;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 17, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr();","    let len = 10;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(result.as_ptr() != ptr);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 17,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr(); // Valid non-null pointer with len 10","    let len = 10;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 17, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = vec![1u8; 10].as_ptr();","    let len = 10;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert!(result.capacity() >= len);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":false}]],[["{","    let shared = Box::new(Shared {","        vec: Vec::new(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = Vec::<u8>::new().as_ptr(); // Valid non-null pointer with len 0","    let len = 0;","    unsafe { shared_v_to_vec(&data, ptr, len) };","    let shared = Box::new(Shared { vec: Vec::new(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });","    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());","    let ptr: *const u8 = Vec::<u8>::new().as_ptr(); // Valid non-null pointer with len 0","    let len = 0;","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result, Vec::<u8>::new());","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":true,"negative":false}]],[["{","    let mut shared_instance = Shared {","        vec: vec![0, 1, 2],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    let ptr: *const u8 = [3, 4, 5].as_ptr();","    let len: usize = 3;","","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","","    unsafe {","        let result = shared_v_to_vec(&data, ptr, len);","    }","    let mut shared_instance = Shared { vec: vec![0, 1, 2], original_capacity_repr: 0, ref_count: AtomicUsize::new(2) };","    let ptr: *const u8 = [3, 4, 5].as_ptr();","    let len: usize = 3;","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","    unsafe { let result = shared_v_to_vec(&data, ptr, len); }","    assert_eq!(shared_instance.vec, Vec::new());","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":true}]],[["{","    let mut shared_instance = Shared {","        vec: vec![0, 1, 2],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    let ptr: *const u8 = [3, 4, 5].as_ptr();","    let len: usize = 3;","","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","","    unsafe {","        let result = shared_v_to_vec(&data, ptr, len);","    }","    let mut shared_instance = Shared { vec: vec![0, 1, 2], original_capacity_repr: 0, ref_count: AtomicUsize::new(2) };","    let ptr: *const u8 = [3, 4, 5].as_ptr();","    let len: usize = 3;","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","    unsafe { let result = shared_v_to_vec(&data, ptr, len); }","    assert_eq!(shared_instance.ref_count.load(Ordering::Relaxed), 1);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":true}]],[["{","    let mut shared_instance = Shared {","        vec: vec![0],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","","    unsafe {","        let result = shared_v_to_vec(&data, ptr, len);","    }","    let mut shared_instance = Shared { vec: vec![0], original_capacity_repr: 0, ref_count: AtomicUsize::new(2) };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(result, vec![]);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":true}]],[["{","    let mut shared_instance = Shared {","        vec: vec![0],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","","    unsafe {","        let result = shared_v_to_vec(&data, ptr, len);","    }","    let mut shared_instance = Shared { vec: vec![0], original_capacity_repr: 0, ref_count: AtomicUsize::new(2) };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(shared_instance.ref_count.load(Ordering::Relaxed), 1);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":true}]],[["{","    let mut shared_instance = Shared {","        vec: vec![0],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","","    unsafe {","        let result = shared_v_to_vec(&data, ptr, len);","    }","    let mut shared_instance = Shared { vec: vec![0], original_capacity_repr: 0, ref_count: AtomicUsize::new(2) };","    let ptr: *const u8 = [].as_ptr();","    let len: usize = 0;","    let data = AtomicPtr::new(&mut shared_instance as *mut _ as *mut ());","    let result = unsafe { shared_v_to_vec(&data, ptr, len) };","    assert_eq!(shared_instance.vec, vec![0]);","}"],[{"start_line":1796,"start_column":8,"end_line":1796,"end_column":29,"positive":false,"negative":true}]]]}