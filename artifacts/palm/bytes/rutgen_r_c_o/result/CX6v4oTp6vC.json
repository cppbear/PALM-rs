{"function_name":"bytes::bytes::promotable_odd_clone","tests":55,"tests_lines":[19,19,19,19,19,19,19,19,18,19,19,19,19,19,20,20,20,20,28,28,28,28,27,27,27,27,32,32,32,32,30,30,30,30,22,22,28,29,13,13,13,13,13,13,13,13,10,12,15,15,15,15,15,15,15],"oracles":14,"oracles_compiled":4,"oracles_compiled_rate":28.57142857142857,"tests_compiled":13,"tests_compiled_rate":23.636363636363637,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":13,"tests_passed":8,"tests_passed_rate":61.53846153846154,"lines":9,"lines_covered":7,"lines_coveraged_rate":77.77777777777779,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[1303,1304,1305,1306,1307,1308,1310,1311,1313],"codes_lines_covered":[[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;","    assert_eq!(kind, KIND_VEC);","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;","    assert!(data.load(Ordering::Acquire) != ptr as *mut ());","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;","    assert!(len == 1);","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    let shared = data.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert_eq!(kind, KIND_VEC);","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    let shared = data.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert!(!ptr.is_null());","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    let shared = data.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert!(len != 0);","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    let shared = data.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert!(data.load(Ordering::Acquire) as usize & KIND_MASK != KIND_ARC);","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    let shared = data.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert_eq!(ptr as usize, 10u8 as usize);","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(15u8)) as *const u8;","    let len = 42;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    assert_eq!(data.load(Ordering::Acquire) as usize & KIND_MASK, KIND_ARC);","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;","    let len1 = 1;","    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;","    let len2 = 2;","","    unsafe {","        let _result1 = promotable_odd_clone(&data, ptr1, len1);","        let _result2 = promotable_odd_clone(&data, ptr2, len2);","    }","    let shared_value = data.load(Ordering::Acquire);","    let kind = shared_value as usize & KIND_MASK;","    assert_eq!(kind, KIND_VEC);","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;","    let len1 = 1;","    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;","    let len2 = 2;","","    unsafe {","        let _result1 = promotable_odd_clone(&data, ptr1, len1);","        let _result2 = promotable_odd_clone(&data, ptr2, len2);","    }","    let shared_value = data.load(Ordering::Acquire);","    let kind = shared_value as usize & KIND_MASK;","    assert!(!ptr::eq(ptr1, ptr2));","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;","    let len1 = 1;","    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;","    let len2 = 2;","","    unsafe {","        let _result1 = promotable_odd_clone(&data, ptr1, len1);","        let _result2 = promotable_odd_clone(&data, ptr2, len2);","    }","    let shared_value = data.load(Ordering::Acquire);","    let kind = shared_value as usize & KIND_MASK;","    assert_eq!(len1, 1);","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;","    let len1 = 1;","    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;","    let len2 = 2;","","    unsafe {","        let _result1 = promotable_odd_clone(&data, ptr1, len1);","        let _result2 = promotable_odd_clone(&data, ptr2, len2);","    }","    let shared_value = data.load(Ordering::Acquire);","    let kind = shared_value as usize & KIND_MASK;","    assert_eq!(len2, 2);","}"],[1303,1304,1305,1306,1307,1308,1313]]],"codes_branches":[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;","    assert_eq!(kind, KIND_VEC);","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;","    assert!(data.load(Ordering::Acquire) != ptr as *mut ());","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;","    let len = 1;","    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;","    assert!(len == 1);","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    let shared = data.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert_eq!(kind, KIND_VEC);","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    let shared = data.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert!(!ptr.is_null());","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    let shared = data.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert!(len != 0);","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    let shared = data.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert!(data.load(Ordering::Acquire) as usize & KIND_MASK != KIND_ARC);","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;","    let len = usize::MAX - 1;","    let shared = data.load(Ordering::Acquire);","    let kind = shared as usize & KIND_MASK;","    assert_eq!(ptr as usize, 10u8 as usize);","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr = Box::into_raw(Box::new(15u8)) as *const u8;","    let len = 42;","    unsafe {","        let _result = promotable_odd_clone(&data, ptr, len);","    }","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    assert_eq!(data.load(Ordering::Acquire) as usize & KIND_MASK, KIND_ARC);","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;","    let len1 = 1;","    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;","    let len2 = 2;","","    unsafe {","        let _result1 = promotable_odd_clone(&data, ptr1, len1);","        let _result2 = promotable_odd_clone(&data, ptr2, len2);","    }","    let shared_value = data.load(Ordering::Acquire);","    let kind = shared_value as usize & KIND_MASK;","    assert_eq!(kind, KIND_VEC);","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;","    let len1 = 1;","    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;","    let len2 = 2;","","    unsafe {","        let _result1 = promotable_odd_clone(&data, ptr1, len1);","        let _result2 = promotable_odd_clone(&data, ptr2, len2);","    }","    let shared_value = data.load(Ordering::Acquire);","    let kind = shared_value as usize & KIND_MASK;","    assert!(!ptr::eq(ptr1, ptr2));","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;","    let len1 = 1;","    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;","    let len2 = 2;","","    unsafe {","        let _result1 = promotable_odd_clone(&data, ptr1, len1);","        let _result2 = promotable_odd_clone(&data, ptr2, len2);","    }","    let shared_value = data.load(Ordering::Acquire);","    let kind = shared_value as usize & KIND_MASK;","    assert_eq!(len1, 1);","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());","    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;","    let len1 = 1;","    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;","    let len2 = 2;","","    unsafe {","        let _result1 = promotable_odd_clone(&data, ptr1, len1);","        let _result2 = promotable_odd_clone(&data, ptr2, len2);","    }","    let shared_value = data.load(Ordering::Acquire);","    let kind = shared_value as usize & KIND_MASK;","    assert_eq!(len2, 2);","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]]]}