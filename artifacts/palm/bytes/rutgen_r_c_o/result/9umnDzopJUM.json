{"function_name":"bytes::bytes::shallow_clone_vec","tests":79,"tests_lines":[13,13,13,13,13,13,17,17,17,17,14,14,14,14,19,19,15,24,25,25,25,25,28,29,29,29,29,24,24,24,24,24,24,32,33,33,24,24,24,24,21,21,21,17,17,17,17,17,17,17,17,17,18,19,19,19,16,17,18,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16],"oracles":20,"oracles_compiled":2,"oracles_compiled_rate":10.0,"tests_compiled":6,"tests_compiled_rate":7.59493670886076,"oracles_run":2,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":6,"tests_passed":0,"tests_passed_rate":0.0,"lines":53,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1538,1539,1540,1543,1544,1545,1546,1547,1548,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1562],"codes_lines_covered":[[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","    let shared = Box::new(Shared {","    buf,","    cap: offset_from(offset, buf) + len,","    ref_cnt: AtomicUsize::new(2),","    });","    let shared = Box::into_raw(shared);","    assert!(shared as usize & KIND_MASK == 0);","}"],[]],[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","    let shared = Box::new(Shared {","    buf,","    cap: offset_from(offset, buf) + len,","    ref_cnt: AtomicUsize::new(2),","    });","    let shared = Box::into_raw(shared);","    assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());","}"],[]],[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","    let shared = Box::new(Shared {","    buf,","    cap: offset_from(offset, buf) + len,","    ref_cnt: AtomicUsize::new(2),","    });","    let shared = Box::into_raw(shared);","    assert_eq!(atom.load(Ordering::Acquire), buf as _);","}"],[]],[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5","    let len: usize = 12; // length of 12","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) };","    let len: usize = 12;","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });","    let shared_ptr = Box::into_raw(shared);","    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");","    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };","    assert!(result.ptr == offset);","}"],[]],[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5","    let len: usize = 12; // length of 12","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) };","    let len: usize = 12;","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });","    let shared_ptr = Box::into_raw(shared);","    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");","    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };","    assert!(result.len == len);","}"],[]],[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5","    let len: usize = 12; // length of 12","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) };","    let len: usize = 12;","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });","    let shared_ptr = Box::into_raw(shared);","    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");","    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };","    assert_eq!(atom.load(Ordering::Relaxed) as usize, shared_ptr as usize);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","    let shared = Box::new(Shared {","    buf,","    cap: offset_from(offset, buf) + len,","    ref_cnt: AtomicUsize::new(2),","    });","    let shared = Box::into_raw(shared);","    assert!(shared as usize & KIND_MASK == 0);","}"],[]],[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","    let shared = Box::new(Shared {","    buf,","    cap: offset_from(offset, buf) + len,","    ref_cnt: AtomicUsize::new(2),","    });","    let shared = Box::into_raw(shared);","    assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());","}"],[]],[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1","    let len: usize = 5; // length of 5","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());","    let shared = Box::new(Shared {","    buf,","    cap: offset_from(offset, buf) + len,","    ref_cnt: AtomicUsize::new(2),","    });","    let shared = Box::into_raw(shared);","    assert_eq!(atom.load(Ordering::Acquire), buf as _);","}"],[]],[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5","    let len: usize = 12; // length of 12","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) };","    let len: usize = 12;","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });","    let shared_ptr = Box::into_raw(shared);","    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");","    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };","    assert!(result.ptr == offset);","}"],[]],[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5","    let len: usize = 12; // length of 12","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) };","    let len: usize = 12;","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });","    let shared_ptr = Box::into_raw(shared);","    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");","    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };","    assert!(result.len == len);","}"],[]],[["{","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5","    let len: usize = 12; // length of 12","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","","    unsafe {","        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);","    }","    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;","    let offset: *const u8 = unsafe { buf.add(5) };","    let len: usize = 12;","    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());","    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });","    let shared_ptr = Box::into_raw(shared);","    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");","    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };","    assert_eq!(atom.load(Ordering::Relaxed) as usize, shared_ptr as usize);","}"],[]]]}