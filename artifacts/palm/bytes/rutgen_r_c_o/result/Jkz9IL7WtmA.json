{"function_name":"bytes::buf::take::<buf::take::Take<T> as buf::buf_impl::Buf>::advance","tests":14,"tests_lines":[42,42,42,42,42,42,41,41,38,35,38,38,38,35],"oracles":7,"oracles_compiled":3,"oracles_compiled_rate":42.857142857142854,"tests_compiled":7,"tests_compiled_rate":50.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":7,"tests_passed":5,"tests_passed_rate":71.42857142857143,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[145,146,147,148,149],"codes_lines_covered":[[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","    ","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit; // cnt == limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit;","    buf.advance(cnt);","    assert_eq!(buf.advanced, 5);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","    ","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit; // cnt == limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit;","    buf.advance(cnt);","    assert_eq!(buf.remaining(), 0);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","    ","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit; // cnt == limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit;","    buf.advance(cnt);","    assert_eq!(buf.limit, 0);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4; // cnt < limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4;","    buf.advance(cnt);","    assert_eq!(buf.advanced, 4);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4; // cnt < limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4;","    buf.advance(cnt);","    assert_eq!(buf.remaining(), 1);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4; // cnt < limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4;","    buf.advance(cnt);","    assert!(buf.has_remaining());","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 6; // cnt > limit, should panic","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 6;","    assert!(cnt > buf.limit);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","    ","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit; // cnt == limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit;","    buf.advance(cnt);","    assert_eq!(buf.advanced, 5);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","    ","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit; // cnt == limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit;","    buf.advance(cnt);","    assert_eq!(buf.remaining(), 0);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","    ","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit; // cnt == limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = buf.limit;","    buf.advance(cnt);","    assert_eq!(buf.limit, 0);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4; // cnt < limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4;","    buf.advance(cnt);","    assert_eq!(buf.advanced, 4);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4; // cnt < limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4;","    buf.advance(cnt);","    assert_eq!(buf.remaining(), 1);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4; // cnt < limit","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 4;","    buf.advance(cnt);","    assert!(buf.has_remaining());","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        advanced: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.limit - self.advanced","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.advanced += cnt;","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","        ","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn get_u8(&mut self) -> u8 {","            unimplemented!()","        }","        ","        // Other trait methods can be omitted for brevity","    }","","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 6; // cnt > limit, should panic","    buf.advance(cnt);","    let mut buf = TestBuf { limit: 5, advanced: 0 };","    let cnt = 6;","    assert!(cnt > buf.limit);","}"],[]]]}