{"function_name":"bytes::buf::take::<buf::take::Take<T> as buf::buf_impl::Buf>::copy_to_bytes","tests":2,"tests_lines":[44,42],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[151,152,154,155,156,157],"codes_lines_covered":[[["{","    struct Inner {","        data: Vec<u8>,","        position: usize,","    }","","    impl Inner {","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            let bytes = self.data[self.position..self.position + len].to_vec();","            self.position += len;","            crate::Bytes::from(bytes)","        }","    }","","    struct Buffer {","        inner: Inner,","        limit: usize,","    }","","    impl Buffer {","        fn remaining(&self) -> usize {","            self.limit","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            assert!(len <= self.remaining(), \"`len` greater than remaining\");","            let r = self.inner.copy_to_bytes(len);","            self.limit -= len;","            r","        }","    }","","    let mut buffer = Buffer {","        inner: Inner {","            data: vec![1, 2, 3, 4, 5],","            position: 0,","        },","        limit: 5,","    };","    ","    let bytes = buffer.copy_to_bytes(3);","    assert_eq!(buffer.limit, 2);","    assert_eq!(bytes.to_vec(), vec![1, 2, 3]);","}"],[]],[["{","    struct Inner {","        data: Vec<u8>,","        position: usize,","    }","","    impl Inner {","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            let bytes = self.data[self.position..self.position + len].to_vec();","            self.position += len;","            crate::Bytes::from(bytes)","        }","    }","","    struct Buffer {","        inner: Inner,","        limit: usize,","    }","","    impl Buffer {","        fn remaining(&self) -> usize {","            self.limit","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            assert!(len <= self.remaining(), \"`len` greater than remaining\");","            let r = self.inner.copy_to_bytes(len);","            self.limit -= len;","            r","        }","    }","","    let mut buffer = Buffer {","        inner: Inner {","            data: vec![1, 2, 3, 4, 5],","            position: 0,","        },","        limit: 2,","    };","    ","    let _ = buffer.copy_to_bytes(3);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Inner {","        data: Vec<u8>,","        position: usize,","    }","","    impl Inner {","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            let bytes = self.data[self.position..self.position + len].to_vec();","            self.position += len;","            crate::Bytes::from(bytes)","        }","    }","","    struct Buffer {","        inner: Inner,","        limit: usize,","    }","","    impl Buffer {","        fn remaining(&self) -> usize {","            self.limit","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            assert!(len <= self.remaining(), \"`len` greater than remaining\");","            let r = self.inner.copy_to_bytes(len);","            self.limit -= len;","            r","        }","    }","","    let mut buffer = Buffer {","        inner: Inner {","            data: vec![1, 2, 3, 4, 5],","            position: 0,","        },","        limit: 5,","    };","    ","    let bytes = buffer.copy_to_bytes(3);","    assert_eq!(buffer.limit, 2);","    assert_eq!(bytes.to_vec(), vec![1, 2, 3]);","}"],[]],[["{","    struct Inner {","        data: Vec<u8>,","        position: usize,","    }","","    impl Inner {","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            let bytes = self.data[self.position..self.position + len].to_vec();","            self.position += len;","            crate::Bytes::from(bytes)","        }","    }","","    struct Buffer {","        inner: Inner,","        limit: usize,","    }","","    impl Buffer {","        fn remaining(&self) -> usize {","            self.limit","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            assert!(len <= self.remaining(), \"`len` greater than remaining\");","            let r = self.inner.copy_to_bytes(len);","            self.limit -= len;","            r","        }","    }","","    let mut buffer = Buffer {","        inner: Inner {","            data: vec![1, 2, 3, 4, 5],","            position: 0,","        },","        limit: 2,","    };","    ","    let _ = buffer.copy_to_bytes(3);","}"],[]]]}