{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::get_vec_pos","tests":2,"tests_lines":[30,30],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1069,1070,1072,1073],"codes_lines_covered":[[["{","    struct BytesMut {","        kind_value: usize,","        data: *const u8,","    }","","    const KIND_VEC: usize = 1; // Example constant for kind","    const VEC_POS_OFFSET: usize = 4; // Example offset","","    impl BytesMut {","        fn kind(&self) -> usize {","            self.kind_value","        }","","        unsafe fn get_vec_pos(&self) -> usize {","            debug_assert_eq!(self.kind(), KIND_VEC);","            self.data as usize >> VEC_POS_OFFSET","        }","    }","","    unsafe {","        let data_value: *const u8 = 16 as *const u8; // Example data value","        let bytes_mut = BytesMut {","            kind_value: KIND_VEC,","            data: data_value,","        };","","        assert_eq!(bytes_mut.get_vec_pos(), 1); // 16 >> 4 == 1","    }","}"],[]],[["{","    struct BytesMut {","        kind_value: usize,","        data: *const u8,","    }","","    const KIND_VEC: usize = 1; // Example constant for kind","    const VEC_POS_OFFSET: usize = 4; // Example offset","","    impl BytesMut {","        fn kind(&self) -> usize {","            self.kind_value","        }","","        unsafe fn get_vec_pos(&self) -> usize {","            debug_assert_eq!(self.kind(), KIND_VEC);","            self.data as usize >> VEC_POS_OFFSET","        }","    }","","    unsafe {","        let data_value: *const u8 = 16 as *const u8; // Example data value","        let bytes_mut = BytesMut {","            kind_value: 0, // Invalid kind","            data: data_value,","        };","","        bytes_mut.get_vec_pos(); // This should panic due to invalid kind","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct BytesMut {","        kind_value: usize,","        data: *const u8,","    }","","    const KIND_VEC: usize = 1; // Example constant for kind","    const VEC_POS_OFFSET: usize = 4; // Example offset","","    impl BytesMut {","        fn kind(&self) -> usize {","            self.kind_value","        }","","        unsafe fn get_vec_pos(&self) -> usize {","            debug_assert_eq!(self.kind(), KIND_VEC);","            self.data as usize >> VEC_POS_OFFSET","        }","    }","","    unsafe {","        let data_value: *const u8 = 16 as *const u8; // Example data value","        let bytes_mut = BytesMut {","            kind_value: KIND_VEC,","            data: data_value,","        };","","        assert_eq!(bytes_mut.get_vec_pos(), 1); // 16 >> 4 == 1","    }","}"],[]],[["{","    struct BytesMut {","        kind_value: usize,","        data: *const u8,","    }","","    const KIND_VEC: usize = 1; // Example constant for kind","    const VEC_POS_OFFSET: usize = 4; // Example offset","","    impl BytesMut {","        fn kind(&self) -> usize {","            self.kind_value","        }","","        unsafe fn get_vec_pos(&self) -> usize {","            debug_assert_eq!(self.kind(), KIND_VEC);","            self.data as usize >> VEC_POS_OFFSET","        }","    }","","    unsafe {","        let data_value: *const u8 = 16 as *const u8; // Example data value","        let bytes_mut = BytesMut {","            kind_value: 0, // Invalid kind","            data: data_value,","        };","","        bytes_mut.get_vec_pos(); // This should panic due to invalid kind","    }","}"],[]]]}