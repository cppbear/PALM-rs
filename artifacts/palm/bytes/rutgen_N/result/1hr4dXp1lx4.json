{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::shallow_clone","tests":2,"tests_lines":[47,47],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1058,1059,1060,1061,1063,1064,1066],"codes_lines_covered":[[["{","    use std::ptr;","","    struct BytesMut {","        data: *mut u8,","        ref_count: usize,","        kind: usize,","    }","","    const KIND_ARC: usize = 1;","","    impl BytesMut {","        fn kind(&self) -> usize {","            self.kind","        }","","        unsafe fn shallow_clone(&mut self) -> BytesMut {","            if self.kind() == KIND_ARC {","                increment_shared(self.data);","                ptr::read(self)","            } else {","                self.promote_to_shared(2);","                ptr::read(self)","            }","        }","","        unsafe fn promote_to_shared(&mut self, ref_count: usize) {","            self.ref_count = ref_count;","        }","    }","    ","    unsafe fn increment_shared(data: *mut u8) {","        // Simulate incrementing a shared reference count.","    }","","    let mut original = BytesMut {","        data: ptr::null_mut(),","        ref_count: 1,","        kind: KIND_ARC,","    };","","    let cloned = unsafe { original.shallow_clone() };","","    assert_eq!(original.ref_count, 1);","    assert_eq!(cloned.ref_count, 1);","    assert_eq!(original.kind(), KIND_ARC);","}"],[]],[["{","    use std::ptr;","","    struct BytesMut {","        data: *mut u8,","        ref_count: usize,","        kind: usize,","    }","","    const KIND_OTHER: usize = 0;","","    impl BytesMut {","        fn kind(&self) -> usize {","            self.kind","        }","","        unsafe fn shallow_clone(&mut self) -> BytesMut {","            if self.kind() == KIND_ARC {","                increment_shared(self.data);","                ptr::read(self)","            } else {","                self.promote_to_shared(2);","                ptr::read(self)","            }","        }","","        unsafe fn promote_to_shared(&mut self, ref_count: usize) {","            self.ref_count = ref_count;","        }","    }","    ","    unsafe fn increment_shared(data: *mut u8) {","        // Simulate incrementing a shared reference count.","    }","","    let mut original = BytesMut {","        data: ptr::null_mut(),","        ref_count: 1,","        kind: KIND_OTHER,","    };","","    let cloned = unsafe { original.shallow_clone() };","","    assert_eq!(original.ref_count, 2);","    assert_eq!(cloned.ref_count, 2);","    assert_eq!(original.kind(), KIND_OTHER);","}"],[]]],"codes_branches":[{"start_line":1059,"start_column":12,"end_line":1059,"end_column":35,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    use std::ptr;","","    struct BytesMut {","        data: *mut u8,","        ref_count: usize,","        kind: usize,","    }","","    const KIND_ARC: usize = 1;","","    impl BytesMut {","        fn kind(&self) -> usize {","            self.kind","        }","","        unsafe fn shallow_clone(&mut self) -> BytesMut {","            if self.kind() == KIND_ARC {","                increment_shared(self.data);","                ptr::read(self)","            } else {","                self.promote_to_shared(2);","                ptr::read(self)","            }","        }","","        unsafe fn promote_to_shared(&mut self, ref_count: usize) {","            self.ref_count = ref_count;","        }","    }","    ","    unsafe fn increment_shared(data: *mut u8) {","        // Simulate incrementing a shared reference count.","    }","","    let mut original = BytesMut {","        data: ptr::null_mut(),","        ref_count: 1,","        kind: KIND_ARC,","    };","","    let cloned = unsafe { original.shallow_clone() };","","    assert_eq!(original.ref_count, 1);","    assert_eq!(cloned.ref_count, 1);","    assert_eq!(original.kind(), KIND_ARC);","}"],[{"start_line":1059,"start_column":12,"end_line":1059,"end_column":35,"positive":false,"negative":false}]],[["{","    use std::ptr;","","    struct BytesMut {","        data: *mut u8,","        ref_count: usize,","        kind: usize,","    }","","    const KIND_OTHER: usize = 0;","","    impl BytesMut {","        fn kind(&self) -> usize {","            self.kind","        }","","        unsafe fn shallow_clone(&mut self) -> BytesMut {","            if self.kind() == KIND_ARC {","                increment_shared(self.data);","                ptr::read(self)","            } else {","                self.promote_to_shared(2);","                ptr::read(self)","            }","        }","","        unsafe fn promote_to_shared(&mut self, ref_count: usize) {","            self.ref_count = ref_count;","        }","    }","    ","    unsafe fn increment_shared(data: *mut u8) {","        // Simulate incrementing a shared reference count.","    }","","    let mut original = BytesMut {","        data: ptr::null_mut(),","        ref_count: 1,","        kind: KIND_OTHER,","    };","","    let cloned = unsafe { original.shallow_clone() };","","    assert_eq!(original.ref_count, 2);","    assert_eq!(cloned.ref_count, 2);","    assert_eq!(original.kind(), KIND_OTHER);","}"],[{"start_line":1059,"start_column":12,"end_line":1059,"end_column":35,"positive":false,"negative":false}]]]}