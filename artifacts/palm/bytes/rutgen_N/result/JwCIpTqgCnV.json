{"function_name":"bytes::buf::buf_mut::<alloc::vec::Vec<u8> as buf::buf_mut::BufMut>::advance_mut","tests":2,"tests_lines":[55,54],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":14,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620],"codes_lines_covered":[[["{","    struct BufMut {","        data: Vec<u8>,","        len: usize,","        capacity: usize,","    }","","    impl BufMut {","        fn new(capacity: usize) -> Self {","            let data = Vec::with_capacity(capacity);","            Self { data, len: 0, capacity }","        }","","        fn len(&self) -> usize {","            self.len","        }","","        fn capacity(&self) -> usize {","            self.capacity","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            let len = self.len();","            let remaining = self.capacity() - len;","","            if remaining < cnt {","                panic_advance(&TryGetError {","                    requested: cnt,","                    available: remaining,","                });","            }","","            self.set_len(len + cnt);","        }","","        fn set_len(&mut self, new_len: usize) {","            self.len = new_len;","        }","    }","","    struct TryGetError {","        requested: usize,","        available: usize,","    }","","    fn panic_advance(err: &TryGetError) {","        panic!(\"Requested {}, but only {} available\", err.requested, err.available);","    }","","    let mut buf = BufMut::new(10);","    unsafe {","        buf.advance_mut(5);","    }","    assert_eq!(buf.len(), 5);","}"],[]],[["{","    struct BufMut {","        data: Vec<u8>,","        len: usize,","        capacity: usize,","    }","","    impl BufMut {","        fn new(capacity: usize) -> Self {","            let data = Vec::with_capacity(capacity);","            Self { data, len: 0, capacity }","        }","","        fn len(&self) -> usize {","            self.len","        }","","        fn capacity(&self) -> usize {","            self.capacity","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            let len = self.len();","            let remaining = self.capacity() - len;","","            if remaining < cnt {","                panic_advance(&TryGetError {","                    requested: cnt,","                    available: remaining,","                });","            }","","            self.set_len(len + cnt);","        }","","        fn set_len(&mut self, new_len: usize) {","            self.len = new_len;","        }","    }","","    struct TryGetError {","        requested: usize,","        available: usize,","    }","","    fn panic_advance(err: &TryGetError) {","        panic!(\"Requested {}, but only {} available\", err.requested, err.available);","    }","","    let mut buf = BufMut::new(5);","    unsafe {","        buf.advance_mut(6);","    }","}"],[]]],"codes_branches":[{"start_line":1611,"start_column":12,"end_line":1611,"end_column":27,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct BufMut {","        data: Vec<u8>,","        len: usize,","        capacity: usize,","    }","","    impl BufMut {","        fn new(capacity: usize) -> Self {","            let data = Vec::with_capacity(capacity);","            Self { data, len: 0, capacity }","        }","","        fn len(&self) -> usize {","            self.len","        }","","        fn capacity(&self) -> usize {","            self.capacity","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            let len = self.len();","            let remaining = self.capacity() - len;","","            if remaining < cnt {","                panic_advance(&TryGetError {","                    requested: cnt,","                    available: remaining,","                });","            }","","            self.set_len(len + cnt);","        }","","        fn set_len(&mut self, new_len: usize) {","            self.len = new_len;","        }","    }","","    struct TryGetError {","        requested: usize,","        available: usize,","    }","","    fn panic_advance(err: &TryGetError) {","        panic!(\"Requested {}, but only {} available\", err.requested, err.available);","    }","","    let mut buf = BufMut::new(10);","    unsafe {","        buf.advance_mut(5);","    }","    assert_eq!(buf.len(), 5);","}"],[{"start_line":1611,"start_column":12,"end_line":1611,"end_column":27,"positive":false,"negative":false}]],[["{","    struct BufMut {","        data: Vec<u8>,","        len: usize,","        capacity: usize,","    }","","    impl BufMut {","        fn new(capacity: usize) -> Self {","            let data = Vec::with_capacity(capacity);","            Self { data, len: 0, capacity }","        }","","        fn len(&self) -> usize {","            self.len","        }","","        fn capacity(&self) -> usize {","            self.capacity","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            let len = self.len();","            let remaining = self.capacity() - len;","","            if remaining < cnt {","                panic_advance(&TryGetError {","                    requested: cnt,","                    available: remaining,","                });","            }","","            self.set_len(len + cnt);","        }","","        fn set_len(&mut self, new_len: usize) {","            self.len = new_len;","        }","    }","","    struct TryGetError {","        requested: usize,","        available: usize,","    }","","    fn panic_advance(err: &TryGetError) {","        panic!(\"Requested {}, but only {} available\", err.requested, err.available);","    }","","    let mut buf = BufMut::new(5);","    unsafe {","        buf.advance_mut(6);","    }","}"],[{"start_line":1611,"start_column":12,"end_line":1611,"end_column":27,"positive":false,"negative":false}]]]}