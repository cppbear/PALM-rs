{"function_name":"bytes::bytes_mut::shared_v_clone","tests":1,"tests_lines":[44],"oracles":1,"oracles_compiled":1,"oracles_compiled_rate":100.0,"tests_compiled":1,"tests_compiled_rate":100.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1785,1786,1787,1788,1789,1790,1791],"codes_lines_covered":[[["{","    use std::sync::atomic::{AtomicPtr, Ordering};","    use std::ptr;","","    struct Bytes {","        ptr: *const u8,","        len: usize,","        data: AtomicPtr<()>,","        vtable: *const VTable,","    }","","    struct VTable;","","    impl Bytes {","        fn with_vtable(ptr: *const u8, len: usize, data: AtomicPtr<()>, vtable: &VTable) -> Bytes {","            Bytes { ptr, len, data, vtable: vtable as *const _ }","        }","    }","","    unsafe fn increment_shared(shared: *mut Shared) {","        // Implementation of the function","    }","","    struct Shared;","","    unsafe fn shared_v_clone(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Bytes {","        let shared = data.load(Ordering::Relaxed) as *mut Shared;","        increment_shared(shared);","","        let data = AtomicPtr::new(shared as *mut ());","        Bytes::with_vtable(ptr, len, data, &SHARED_VTABLE)","    }","","    static SHARED_VTABLE: VTable = VTable;","","    let atomic_ptr = AtomicPtr::new(ptr::null_mut());","    let test_ptr: *const u8 = b\"test_data\\0\".as_ptr();","    let len: usize = 9; // Length of \"test_data\"","","    let bytes = unsafe { shared_v_clone(&atomic_ptr, test_ptr, len) };","","    assert_eq!(bytes.len, len);","    assert_eq!(bytes.ptr, test_ptr);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::sync::atomic::{AtomicPtr, Ordering};","    use std::ptr;","","    struct Bytes {","        ptr: *const u8,","        len: usize,","        data: AtomicPtr<()>,","        vtable: *const VTable,","    }","","    struct VTable;","","    impl Bytes {","        fn with_vtable(ptr: *const u8, len: usize, data: AtomicPtr<()>, vtable: &VTable) -> Bytes {","            Bytes { ptr, len, data, vtable: vtable as *const _ }","        }","    }","","    unsafe fn increment_shared(shared: *mut Shared) {","        // Implementation of the function","    }","","    struct Shared;","","    unsafe fn shared_v_clone(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Bytes {","        let shared = data.load(Ordering::Relaxed) as *mut Shared;","        increment_shared(shared);","","        let data = AtomicPtr::new(shared as *mut ());","        Bytes::with_vtable(ptr, len, data, &SHARED_VTABLE)","    }","","    static SHARED_VTABLE: VTable = VTable;","","    let atomic_ptr = AtomicPtr::new(ptr::null_mut());","    let test_ptr: *const u8 = b\"test_data\\0\".as_ptr();","    let len: usize = 9; // Length of \"test_data\"","","    let bytes = unsafe { shared_v_clone(&atomic_ptr, test_ptr, len) };","","    assert_eq!(bytes.len, len);","    assert_eq!(bytes.ptr, test_ptr);","}"],[]]]}