{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::from_vec","tests":2,"tests_lines":[46,47],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":16,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939],"codes_lines_covered":[[["{","    use std::mem::ManuallyDrop;","","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","        data: *mut u8,","    }","","    const ORIGINAL_CAPACITY_OFFSET: usize = 8;","    const KIND_VEC: usize = 0x1;","    ","    fn original_capacity_to_repr(cap: usize) -> usize {","        cap // Assume this is a mock implementation","    }","","    fn vptr(ptr: *mut u8) -> *mut u8 {","        ptr // Assume this is a mock implementation","    }","","    fn invalid_ptr(data: usize) -> *mut u8 {","        data as *mut u8 // Assume this is a mock implementation","    }","","    fn from_vec(vec: Vec<u8>) -> BytesMut {","        let mut vec = ManuallyDrop::new(vec);","        let ptr = vptr(vec.as_mut_ptr());","        let len = vec.len();","        let cap = vec.capacity();","    ","        let original_capacity_repr = original_capacity_to_repr(cap);","        let data = (original_capacity_repr << ORIGINAL_CAPACITY_OFFSET) | KIND_VEC;","    ","        BytesMut {","            ptr,","            len,","            cap,","            data: invalid_ptr(data),","        }","    }","","    let bytesmut = from_vec(Vec::new());","    assert_eq!(bytesmut.len, 0);","    assert_eq!(bytesmut.cap, 0);","}"],[]],[["{","    use std::mem::ManuallyDrop;","","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","        data: *mut u8,","    }","","    const ORIGINAL_CAPACITY_OFFSET: usize = 8;","    const KIND_VEC: usize = 0x1;","    ","    fn original_capacity_to_repr(cap: usize) -> usize {","        cap // Assume this is a mock implementation","    }","","    fn vptr(ptr: *mut u8) -> *mut u8 {","        ptr // Assume this is a mock implementation","    }","","    fn invalid_ptr(data: usize) -> *mut u8 {","        data as *mut u8 // Assume this is a mock implementation","    }","","    fn from_vec(vec: Vec<u8>) -> BytesMut {","        let mut vec = ManuallyDrop::new(vec);","        let ptr = vptr(vec.as_mut_ptr());","        let len = vec.len();","        let cap = vec.capacity();","    ","        let original_capacity_repr = original_capacity_to_repr(cap);","        let data = (original_capacity_repr << ORIGINAL_CAPACITY_OFFSET) | KIND_VEC;","    ","        BytesMut {","            ptr,","            len,","            cap,","            data: invalid_ptr(data),","        }","    }","","    let vec = vec![1, 2, 3];","    let bytesmut = from_vec(vec);","    assert_eq!(bytesmut.len, 3);","    assert!(bytesmut.cap >= 3); // Ensure capacity is at least as large as length","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::mem::ManuallyDrop;","","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","        data: *mut u8,","    }","","    const ORIGINAL_CAPACITY_OFFSET: usize = 8;","    const KIND_VEC: usize = 0x1;","    ","    fn original_capacity_to_repr(cap: usize) -> usize {","        cap // Assume this is a mock implementation","    }","","    fn vptr(ptr: *mut u8) -> *mut u8 {","        ptr // Assume this is a mock implementation","    }","","    fn invalid_ptr(data: usize) -> *mut u8 {","        data as *mut u8 // Assume this is a mock implementation","    }","","    fn from_vec(vec: Vec<u8>) -> BytesMut {","        let mut vec = ManuallyDrop::new(vec);","        let ptr = vptr(vec.as_mut_ptr());","        let len = vec.len();","        let cap = vec.capacity();","    ","        let original_capacity_repr = original_capacity_to_repr(cap);","        let data = (original_capacity_repr << ORIGINAL_CAPACITY_OFFSET) | KIND_VEC;","    ","        BytesMut {","            ptr,","            len,","            cap,","            data: invalid_ptr(data),","        }","    }","","    let bytesmut = from_vec(Vec::new());","    assert_eq!(bytesmut.len, 0);","    assert_eq!(bytesmut.cap, 0);","}"],[]],[["{","    use std::mem::ManuallyDrop;","","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","        data: *mut u8,","    }","","    const ORIGINAL_CAPACITY_OFFSET: usize = 8;","    const KIND_VEC: usize = 0x1;","    ","    fn original_capacity_to_repr(cap: usize) -> usize {","        cap // Assume this is a mock implementation","    }","","    fn vptr(ptr: *mut u8) -> *mut u8 {","        ptr // Assume this is a mock implementation","    }","","    fn invalid_ptr(data: usize) -> *mut u8 {","        data as *mut u8 // Assume this is a mock implementation","    }","","    fn from_vec(vec: Vec<u8>) -> BytesMut {","        let mut vec = ManuallyDrop::new(vec);","        let ptr = vptr(vec.as_mut_ptr());","        let len = vec.len();","        let cap = vec.capacity();","    ","        let original_capacity_repr = original_capacity_to_repr(cap);","        let data = (original_capacity_repr << ORIGINAL_CAPACITY_OFFSET) | KIND_VEC;","    ","        BytesMut {","            ptr,","            len,","            cap,","            data: invalid_ptr(data),","        }","    }","","    let vec = vec![1, 2, 3];","    let bytesmut = from_vec(vec);","    assert_eq!(bytesmut.len, 3);","    assert!(bytesmut.cap >= 3); // Ensure capacity is at least as large as length","}"],[]]]}