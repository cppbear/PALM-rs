{"function_name":"bytes::buf::vec_deque::buf::vec_deque::<impl buf::buf_impl::Buf for alloc::collections::VecDeque<u8>>::chunks_vectored","tests":3,"tests_lines":[34,35,36],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":14,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":8,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[22,23,24,25,26,27,28,29,30,31,32,33,34,35],"codes_lines_covered":[[["{","    struct VecDeque {","        data: Vec<u8>,","    }","","    impl VecDeque {","        fn is_empty(&self) -> bool {","            self.data.is_empty()","        }","","        fn as_slices(&self) -> (&[u8], &[u8]) {","            (self.data.as_slice(), &[])","        }","","        fn chunks_vectored<'a>(&'a self, dst: &mut [std::io::IoSlice<'a>]) -> usize {","            if self.is_empty() || dst.is_empty() {","                return 0;","            }","","            let (s1, s2) = self.as_slices();","            dst[0] = std::io::IoSlice::new(s1);","            if s2.is_empty() || dst.len() == 1 {","                return 1;","            }","","            dst[1] = std::io::IoSlice::new(s2);","            2","        }","    }","","    let vec_deque = VecDeque { data: Vec::new() };","    let mut dst = vec![std::io::IoSlice::new(&[])]; ","    assert_eq!(vec_deque.chunks_vectored(&mut dst), 0);","}"],[]],[["{","    struct VecDeque {","        data: Vec<u8>,","    }","","    impl VecDeque {","        fn is_empty(&self) -> bool {","            self.data.is_empty()","        }","","        fn as_slices(&self) -> (&[u8], &[u8]) {","            (self.data.as_slice(), &[])","        }","","        fn chunks_vectored<'a>(&'a self, dst: &mut [std::io::IoSlice<'a>]) -> usize {","            if self.is_empty() || dst.is_empty() {","                return 0;","            }","","            let (s1, s2) = self.as_slices();","            dst[0] = std::io::IoSlice::new(s1);","            if s2.is_empty() || dst.len() == 1 {","                return 1;","            }","","            dst[1] = std::io::IoSlice::new(s2);","            2","        }","    }","","    let vec_deque = VecDeque { data: vec![1, 2, 3] };","    let mut dst = vec![std::io::IoSlice::new(&[])]; ","    assert_eq!(vec_deque.chunks_vectored(&mut dst), 1);","    assert_eq!(dst[0].as_ref(), &[1, 2, 3]);","}"],[]],[["{","    struct VecDeque {","        data: Vec<u8>,","    }","","    impl VecDeque {","        fn is_empty(&self) -> bool {","            self.data.is_empty()","        }","","        fn as_slices(&self) -> (&[u8], &[u8]) {","            (self.data.as_slice(), &[4, 5, 6])","        }","","        fn chunks_vectored<'a>(&'a self, dst: &mut [std::io::IoSlice<'a>]) -> usize {","            if self.is_empty() || dst.is_empty() {","                return 0;","            }","","            let (s1, s2) = self.as_slices();","            dst[0] = std::io::IoSlice::new(s1);","            if s2.is_empty() || dst.len() == 1 {","                return 1;","            }","","            dst[1] = std::io::IoSlice::new(s2);","            2","        }","    }","","    let vec_deque = VecDeque { data: vec![1, 2, 3] };","    let mut dst = vec![std::io::IoSlice::new(&[]), std::io::IoSlice::new(&[])]; ","    assert_eq!(vec_deque.chunks_vectored(&mut dst), 2);","    assert_eq!(dst[0].as_ref(), &[1, 2, 3]);","    assert_eq!(dst[1].as_ref(), &[4, 5, 6]);","}"],[]]],"codes_branches":[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":false},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":false},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":false,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct VecDeque {","        data: Vec<u8>,","    }","","    impl VecDeque {","        fn is_empty(&self) -> bool {","            self.data.is_empty()","        }","","        fn as_slices(&self) -> (&[u8], &[u8]) {","            (self.data.as_slice(), &[])","        }","","        fn chunks_vectored<'a>(&'a self, dst: &mut [std::io::IoSlice<'a>]) -> usize {","            if self.is_empty() || dst.is_empty() {","                return 0;","            }","","            let (s1, s2) = self.as_slices();","            dst[0] = std::io::IoSlice::new(s1);","            if s2.is_empty() || dst.len() == 1 {","                return 1;","            }","","            dst[1] = std::io::IoSlice::new(s2);","            2","        }","    }","","    let vec_deque = VecDeque { data: Vec::new() };","    let mut dst = vec![std::io::IoSlice::new(&[])]; ","    assert_eq!(vec_deque.chunks_vectored(&mut dst), 0);","}"],[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":false},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":false},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":false,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}]],[["{","    struct VecDeque {","        data: Vec<u8>,","    }","","    impl VecDeque {","        fn is_empty(&self) -> bool {","            self.data.is_empty()","        }","","        fn as_slices(&self) -> (&[u8], &[u8]) {","            (self.data.as_slice(), &[])","        }","","        fn chunks_vectored<'a>(&'a self, dst: &mut [std::io::IoSlice<'a>]) -> usize {","            if self.is_empty() || dst.is_empty() {","                return 0;","            }","","            let (s1, s2) = self.as_slices();","            dst[0] = std::io::IoSlice::new(s1);","            if s2.is_empty() || dst.len() == 1 {","                return 1;","            }","","            dst[1] = std::io::IoSlice::new(s2);","            2","        }","    }","","    let vec_deque = VecDeque { data: vec![1, 2, 3] };","    let mut dst = vec![std::io::IoSlice::new(&[])]; ","    assert_eq!(vec_deque.chunks_vectored(&mut dst), 1);","    assert_eq!(dst[0].as_ref(), &[1, 2, 3]);","}"],[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":false},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":false},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":false,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}]],[["{","    struct VecDeque {","        data: Vec<u8>,","    }","","    impl VecDeque {","        fn is_empty(&self) -> bool {","            self.data.is_empty()","        }","","        fn as_slices(&self) -> (&[u8], &[u8]) {","            (self.data.as_slice(), &[4, 5, 6])","        }","","        fn chunks_vectored<'a>(&'a self, dst: &mut [std::io::IoSlice<'a>]) -> usize {","            if self.is_empty() || dst.is_empty() {","                return 0;","            }","","            let (s1, s2) = self.as_slices();","            dst[0] = std::io::IoSlice::new(s1);","            if s2.is_empty() || dst.len() == 1 {","                return 1;","            }","","            dst[1] = std::io::IoSlice::new(s2);","            2","        }","    }","","    let vec_deque = VecDeque { data: vec![1, 2, 3] };","    let mut dst = vec![std::io::IoSlice::new(&[]), std::io::IoSlice::new(&[])]; ","    assert_eq!(vec_deque.chunks_vectored(&mut dst), 2);","    assert_eq!(dst[0].as_ref(), &[1, 2, 3]);","    assert_eq!(dst[1].as_ref(), &[4, 5, 6]);","}"],[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":false},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":false},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":false,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}]]]}