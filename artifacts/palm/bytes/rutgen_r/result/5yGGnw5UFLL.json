{"function_name":"bytes::buf::take::buf::take::Take<T>::set_limit","tests":3,"tests_lines":[40,34,34],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[130,131,132],"codes_lines_covered":[[["{","    struct TestBuf {","        limit: usize,","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, limit: usize) -> Self {","            Self { limit, data, position: 0 }","        }","","        fn take(&mut self, _lim: usize) -> &mut Self {","            self","        }","","        fn put(&mut self, dst: &mut Vec<u8>) {","            let bytes_to_copy = self.data[self.position..].len().min(self.limit);","            dst.extend_from_slice(&self.data[self.position..self.position + bytes_to_copy]);","            self.position += bytes_to_copy;","        }","","        fn set_limit(&mut self, lim: usize) {","            self.limit = lim;","        }","    }","","    let mut buf = TestBuf::new(b\"hello world\".to_vec(), 2);","    let mut dst = vec![];","","    buf.take(2);","    buf.put(&mut dst);","    assert_eq!(*dst, b\"he\"[..]);","","    dst.clear();","","    buf.set_limit(3);","    buf.put(&mut dst);","    assert_eq!(*dst, b\"llo\"[..]);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, limit: usize) -> Self {","            Self { limit, data, position: 0 }","        }","","        fn take(&mut self, _lim: usize) -> &mut Self {","            self","        }","","        fn put(&mut self, dst: &mut Vec<u8>) {","            let bytes_to_copy = self.data[self.position..].len().min(self.limit);","            dst.extend_from_slice(&self.data[self.position..self.position + bytes_to_copy]);","            self.position += bytes_to_copy;","        }","","        fn set_limit(&mut self, lim: usize) {","            self.limit = lim;","        }","    }","","    let mut buf = TestBuf::new(b\"hello world\".to_vec(), 2);","    let mut dst = vec![];","","    buf.set_limit(0);","    buf.put(&mut dst);","    assert_eq!(dst.len(), 0);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, limit: usize) -> Self {","            Self { limit, data, position: 0 }","        }","","        fn take(&mut self, _lim: usize) -> &mut Self {","            self","        }","","        fn put(&mut self, dst: &mut Vec<u8>) {","            let bytes_to_copy = self.data[self.position..].len().min(self.limit);","            dst.extend_from_slice(&self.data[self.position..self.position + bytes_to_copy]);","            self.position += bytes_to_copy;","        }","","        fn set_limit(&mut self, lim: usize) {","            self.limit = lim;","        }","    }","","    let mut buf = TestBuf::new(b\"hello world\".to_vec(), 2);","    let mut dst = vec![];","","    buf.set_limit(12); // Exceeding the length of \"hello world\"","    buf.put(&mut dst);","    assert_eq!(*dst, b\"hello world\"[..]);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        limit: usize,","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, limit: usize) -> Self {","            Self { limit, data, position: 0 }","        }","","        fn take(&mut self, _lim: usize) -> &mut Self {","            self","        }","","        fn put(&mut self, dst: &mut Vec<u8>) {","            let bytes_to_copy = self.data[self.position..].len().min(self.limit);","            dst.extend_from_slice(&self.data[self.position..self.position + bytes_to_copy]);","            self.position += bytes_to_copy;","        }","","        fn set_limit(&mut self, lim: usize) {","            self.limit = lim;","        }","    }","","    let mut buf = TestBuf::new(b\"hello world\".to_vec(), 2);","    let mut dst = vec![];","","    buf.take(2);","    buf.put(&mut dst);","    assert_eq!(*dst, b\"he\"[..]);","","    dst.clear();","","    buf.set_limit(3);","    buf.put(&mut dst);","    assert_eq!(*dst, b\"llo\"[..]);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, limit: usize) -> Self {","            Self { limit, data, position: 0 }","        }","","        fn take(&mut self, _lim: usize) -> &mut Self {","            self","        }","","        fn put(&mut self, dst: &mut Vec<u8>) {","            let bytes_to_copy = self.data[self.position..].len().min(self.limit);","            dst.extend_from_slice(&self.data[self.position..self.position + bytes_to_copy]);","            self.position += bytes_to_copy;","        }","","        fn set_limit(&mut self, lim: usize) {","            self.limit = lim;","        }","    }","","    let mut buf = TestBuf::new(b\"hello world\".to_vec(), 2);","    let mut dst = vec![];","","    buf.set_limit(0);","    buf.put(&mut dst);","    assert_eq!(dst.len(), 0);","}"],[]],[["{","    struct TestBuf {","        limit: usize,","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, limit: usize) -> Self {","            Self { limit, data, position: 0 }","        }","","        fn take(&mut self, _lim: usize) -> &mut Self {","            self","        }","","        fn put(&mut self, dst: &mut Vec<u8>) {","            let bytes_to_copy = self.data[self.position..].len().min(self.limit);","            dst.extend_from_slice(&self.data[self.position..self.position + bytes_to_copy]);","            self.position += bytes_to_copy;","        }","","        fn set_limit(&mut self, lim: usize) {","            self.limit = lim;","        }","    }","","    let mut buf = TestBuf::new(b\"hello world\".to_vec(), 2);","    let mut dst = vec![];","","    buf.set_limit(12); // Exceeding the length of \"hello world\"","    buf.put(&mut dst);","    assert_eq!(*dst, b\"hello world\"[..]);","}"],[]]]}