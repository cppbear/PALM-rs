{"function_name":"bytes::fmt::debug::fmt::debug::<impl core::fmt::Debug for fmt::BytesRef<'_>>::fmt","tests":67,"tests_lines":[19,19,19,19,19,13,6,7,7,7,3,15,7,5,6,7,7,7,7,3,3,3,3,10,10,10,10,10,7,3,34,34,34,34,34,34,34,23,23,23,23,23,23,23,6,6,6,6,6,6,6,6,8,8,8,8,8,8,8,8,32,32,16,32,32,32,32],"oracles":67,"oracles_compiled":7,"oracles_compiled_rate":10.44776119402985,"tests_compiled":7,"tests_compiled_rate":10.44776119402985,"oracles_run":7,"oracles_passed":3,"oracles_passed_rate":42.857142857142854,"tests_run":7,"tests_passed":3,"tests_passed_rate":42.857142857142854,"lines":19,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":14,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[13,14,15,17,18,19,20,21,22,23,24,25,26,28,29,31,34,35,36],"codes_lines_covered":[[["{","    struct TestBytes(Vec<u8>);","","    impl std::fmt::Debug for TestBytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let test_bytes = TestBytes(vec![]);","    let result = format!(\"{:?}\", test_bytes);","    assert_eq!(result, r#\"b\"\"\"\"#);","}"],[]],[["{","    struct TestBytes(Vec<u8>);","","    impl std::fmt::Debug for TestBytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let test_bytes = TestBytes(vec![0x00, 0x01, 0x02, 0x03, 0x7F, 0x80]);","    let result = format!(\"{:?}\", test_bytes);","    assert_eq!(result, r#\"b\"\\0\\xx01\\xx02\\xx03\\xx7f\\xx80\"\"#);","}"],[]],[["{","    struct TestBytes(Vec<u8>);","","    impl std::fmt::Debug for TestBytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            // Simulating a panic by forcing a condition that will trigger an error","            if self.0.is_empty() {","                return write!(f, \"\\\"\");  // This does not start with b\" so it should fail based on constraints","            }","            Ok(())","        }","    }","","    let test_bytes = TestBytes(vec![]);","    let _ = format!(\"{:?}\", test_bytes); // This should trigger a panic","}"],[]],[["{","    struct Bytes(Vec<u8>);","    ","    impl std::fmt::Debug for Bytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let bytes = Bytes(vec![]);","    let result = format!(\"{:?}\", bytes);","    assert_eq!(result, \"b\\\"\\\"\");","}"],[]],[["{","    struct Bytes(Vec<u8>);","    ","    impl std::fmt::Debug for Bytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let bytes = Bytes(vec![b'a', b'b', b'c']);","    let result = format!(\"{:?}\", bytes);","    assert_eq!(result, \"b\\\"abc\\\"\");","}"],[]],[["{","    struct Bytes(Vec<u8>);","    ","    impl std::fmt::Debug for Bytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let bytes = Bytes(vec![b'\\n', b'\\r', b'\\t', b'\\\\', b'\"', b'\\0', b'k']);","    let result = format!(\"{:?}\", bytes);","    assert_eq!(result, \"b\\\"\\\\n\\\\r\\\\tk\\\\0\\\\\\\"\\\\\\\\\\\"\");","}"],[]],[["{","    struct Bytes(Vec<u8>);","    ","    impl std::fmt::Debug for Bytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let bytes = Bytes(vec![b'\\x01', b'\\x02', b'\\x03']);","    let result = format!(\"{:?}\", bytes);","    assert_eq!(result, \"b\\\"\\\\x01\\\\x02\\\\x03\\\"\");","}"],[]]],"codes_branches":[{"start_line":17,"start_column":16,"end_line":17,"end_column":26,"positive":false,"negative":false},{"start_line":19,"start_column":23,"end_line":19,"end_column":33,"positive":false,"negative":false},{"start_line":21,"start_column":23,"end_line":21,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":23,"end_line":23,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":37,"end_line":23,"end_column":46,"positive":false,"negative":false},{"start_line":25,"start_column":23,"end_line":25,"end_column":33,"positive":false,"negative":false},{"start_line":28,"start_column":23,"end_line":28,"end_column":48,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestBytes(Vec<u8>);","","    impl std::fmt::Debug for TestBytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let test_bytes = TestBytes(vec![]);","    let result = format!(\"{:?}\", test_bytes);","    assert_eq!(result, r#\"b\"\"\"\"#);","}"],[{"start_line":17,"start_column":16,"end_line":17,"end_column":26,"positive":false,"negative":false},{"start_line":19,"start_column":23,"end_line":19,"end_column":33,"positive":false,"negative":false},{"start_line":21,"start_column":23,"end_line":21,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":23,"end_line":23,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":37,"end_line":23,"end_column":46,"positive":false,"negative":false},{"start_line":25,"start_column":23,"end_line":25,"end_column":33,"positive":false,"negative":false},{"start_line":28,"start_column":23,"end_line":28,"end_column":48,"positive":false,"negative":false}]],[["{","    struct TestBytes(Vec<u8>);","","    impl std::fmt::Debug for TestBytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let test_bytes = TestBytes(vec![0x00, 0x01, 0x02, 0x03, 0x7F, 0x80]);","    let result = format!(\"{:?}\", test_bytes);","    assert_eq!(result, r#\"b\"\\0\\xx01\\xx02\\xx03\\xx7f\\xx80\"\"#);","}"],[{"start_line":17,"start_column":16,"end_line":17,"end_column":26,"positive":false,"negative":false},{"start_line":19,"start_column":23,"end_line":19,"end_column":33,"positive":false,"negative":false},{"start_line":21,"start_column":23,"end_line":21,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":23,"end_line":23,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":37,"end_line":23,"end_column":46,"positive":false,"negative":false},{"start_line":25,"start_column":23,"end_line":25,"end_column":33,"positive":false,"negative":false},{"start_line":28,"start_column":23,"end_line":28,"end_column":48,"positive":false,"negative":false}]],[["{","    struct TestBytes(Vec<u8>);","","    impl std::fmt::Debug for TestBytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            // Simulating a panic by forcing a condition that will trigger an error","            if self.0.is_empty() {","                return write!(f, \"\\\"\");  // This does not start with b\" so it should fail based on constraints","            }","            Ok(())","        }","    }","","    let test_bytes = TestBytes(vec![]);","    let _ = format!(\"{:?}\", test_bytes); // This should trigger a panic","}"],[{"start_line":17,"start_column":16,"end_line":17,"end_column":26,"positive":false,"negative":false},{"start_line":19,"start_column":23,"end_line":19,"end_column":33,"positive":false,"negative":false},{"start_line":21,"start_column":23,"end_line":21,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":23,"end_line":23,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":37,"end_line":23,"end_column":46,"positive":false,"negative":false},{"start_line":25,"start_column":23,"end_line":25,"end_column":33,"positive":false,"negative":false},{"start_line":28,"start_column":23,"end_line":28,"end_column":48,"positive":false,"negative":false}]],[["{","    struct Bytes(Vec<u8>);","    ","    impl std::fmt::Debug for Bytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let bytes = Bytes(vec![]);","    let result = format!(\"{:?}\", bytes);","    assert_eq!(result, \"b\\\"\\\"\");","}"],[{"start_line":17,"start_column":16,"end_line":17,"end_column":26,"positive":false,"negative":false},{"start_line":19,"start_column":23,"end_line":19,"end_column":33,"positive":false,"negative":false},{"start_line":21,"start_column":23,"end_line":21,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":23,"end_line":23,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":37,"end_line":23,"end_column":46,"positive":false,"negative":false},{"start_line":25,"start_column":23,"end_line":25,"end_column":33,"positive":false,"negative":false},{"start_line":28,"start_column":23,"end_line":28,"end_column":48,"positive":false,"negative":false}]],[["{","    struct Bytes(Vec<u8>);","    ","    impl std::fmt::Debug for Bytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let bytes = Bytes(vec![b'a', b'b', b'c']);","    let result = format!(\"{:?}\", bytes);","    assert_eq!(result, \"b\\\"abc\\\"\");","}"],[{"start_line":17,"start_column":16,"end_line":17,"end_column":26,"positive":false,"negative":false},{"start_line":19,"start_column":23,"end_line":19,"end_column":33,"positive":false,"negative":false},{"start_line":21,"start_column":23,"end_line":21,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":23,"end_line":23,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":37,"end_line":23,"end_column":46,"positive":false,"negative":false},{"start_line":25,"start_column":23,"end_line":25,"end_column":33,"positive":false,"negative":false},{"start_line":28,"start_column":23,"end_line":28,"end_column":48,"positive":false,"negative":false}]],[["{","    struct Bytes(Vec<u8>);","    ","    impl std::fmt::Debug for Bytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let bytes = Bytes(vec![b'\\n', b'\\r', b'\\t', b'\\\\', b'\"', b'\\0', b'k']);","    let result = format!(\"{:?}\", bytes);","    assert_eq!(result, \"b\\\"\\\\n\\\\r\\\\tk\\\\0\\\\\\\"\\\\\\\\\\\"\");","}"],[{"start_line":17,"start_column":16,"end_line":17,"end_column":26,"positive":false,"negative":false},{"start_line":19,"start_column":23,"end_line":19,"end_column":33,"positive":false,"negative":false},{"start_line":21,"start_column":23,"end_line":21,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":23,"end_line":23,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":37,"end_line":23,"end_column":46,"positive":false,"negative":false},{"start_line":25,"start_column":23,"end_line":25,"end_column":33,"positive":false,"negative":false},{"start_line":28,"start_column":23,"end_line":28,"end_column":48,"positive":false,"negative":false}]],[["{","    struct Bytes(Vec<u8>);","    ","    impl std::fmt::Debug for Bytes {","        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","            write!(f, \"b\\\"\")?;","            for &b in &self.0 {","                if b == b'\\n' {","                    write!(f, \"\\\\n\")?;","                } else if b == b'\\r' {","                    write!(f, \"\\\\r\")?;","                } else if b == b'\\t' {","                    write!(f, \"\\\\t\")?;","                } else if b == b'\\\\' || b == b'\"' {","                    write!(f, \"\\\\{}\", b as char)?;","                } else if b == b'\\0' {","                    write!(f, \"\\\\0\")?;","                } else if (0x20..0x7f).contains(&b) {","                    write!(f, \"{}\", b as char)?;","                } else {","                    write!(f, \"\\\\x{:02x}\", b)?;","                }","            }","            write!(f, \"\\\"\")?;","            Ok(())","        }","    }","","    let bytes = Bytes(vec![b'\\x01', b'\\x02', b'\\x03']);","    let result = format!(\"{:?}\", bytes);","    assert_eq!(result, \"b\\\"\\\\x01\\\\x02\\\\x03\\\"\");","}"],[{"start_line":17,"start_column":16,"end_line":17,"end_column":26,"positive":false,"negative":false},{"start_line":19,"start_column":23,"end_line":19,"end_column":33,"positive":false,"negative":false},{"start_line":21,"start_column":23,"end_line":21,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":23,"end_line":23,"end_column":33,"positive":false,"negative":false},{"start_line":23,"start_column":37,"end_line":23,"end_column":46,"positive":false,"negative":false},{"start_line":25,"start_column":23,"end_line":25,"end_column":33,"positive":false,"negative":false},{"start_line":28,"start_column":23,"end_line":28,"end_column":48,"positive":false,"negative":false}]]]}