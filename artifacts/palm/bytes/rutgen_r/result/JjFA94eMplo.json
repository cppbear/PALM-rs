{"function_name":"bytes::bytes::shared_to_mut_impl","tests":3,"tests_lines":[49,44,64],"oracles":3,"oracles_compiled":1,"oracles_compiled_rate":33.33333333333333,"tests_compiled":1,"tests_compiled_rate":33.33333333333333,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":30,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1455,1456,1457,1459],"codes_lines_covered":[[["{","    use std::sync::atomic::{AtomicUsize, Ordering};","    use std::ptr::null_mut;","    use std::mem::ManuallyDrop;","","    struct Shared {","        ref_cnt: AtomicUsize,","        buf: *mut u8,","        cap: usize,","    }","","    struct BytesMut {","        vec: Vec<u8>,","    }","","    impl BytesMut {","        fn from_vec(vec: Vec<u8>) -> Self {","            BytesMut { vec }","        }","        ","        fn advance_unchecked(&mut self, offset: usize) {","            self.vec.drain(..offset);","        }","    }","","    unsafe fn release_shared(shared: *mut Shared) {","        // Stub release function for test.","        drop(Box::from_raw(shared));","    }","","    unsafe fn shared_to_mut_impl(shared: *mut Shared, ptr: *const u8, len: usize) -> BytesMut {","        if (*shared).ref_cnt.load(Ordering::Acquire) == 1 {","            let shared = *Box::from_raw(shared);","            let shared = ManuallyDrop::new(shared);","            let buf = shared.buf;","            let cap = shared.cap;","            let off = 0; // Assume offset is 0 for simplicity","            let v = Vec::from_raw_parts(buf, len + off, cap);","            let mut b = BytesMut::from_vec(v);","            b.advance_unchecked(off);","            b","        } else {","            let v = std::slice::from_raw_parts(ptr, len).to_vec();","            release_shared(shared);","            BytesMut::from_vec(v)","        }","    }","","    unsafe {","        let buf = Box::into_raw(Box::new(42u8)) as *mut u8; // Simulating buffer allocation","        let shared = Box::into_raw(Box::new(Shared {","            ref_cnt: AtomicUsize::new(1),","            buf: buf,","            cap: 1,","        }));","","        let result = shared_to_mut_impl(shared, buf, 1);","        assert_eq!(result.vec.len(), 1);","        assert_eq!(result.vec[0], 42);","","        // Clean up","        release_shared(shared);","    }","}"],[]]],"codes_branches":[{"start_line":1439,"start_column":8,"end_line":1439,"end_column":54,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    use std::sync::atomic::{AtomicUsize, Ordering};","    use std::ptr::null_mut;","    use std::mem::ManuallyDrop;","","    struct Shared {","        ref_cnt: AtomicUsize,","        buf: *mut u8,","        cap: usize,","    }","","    struct BytesMut {","        vec: Vec<u8>,","    }","","    impl BytesMut {","        fn from_vec(vec: Vec<u8>) -> Self {","            BytesMut { vec }","        }","        ","        fn advance_unchecked(&mut self, offset: usize) {","            self.vec.drain(..offset);","        }","    }","","    unsafe fn release_shared(shared: *mut Shared) {","        // Stub release function for test.","        drop(Box::from_raw(shared));","    }","","    unsafe fn shared_to_mut_impl(shared: *mut Shared, ptr: *const u8, len: usize) -> BytesMut {","        if (*shared).ref_cnt.load(Ordering::Acquire) == 1 {","            let shared = *Box::from_raw(shared);","            let shared = ManuallyDrop::new(shared);","            let buf = shared.buf;","            let cap = shared.cap;","            let off = 0; // Assume offset is 0 for simplicity","            let v = Vec::from_raw_parts(buf, len + off, cap);","            let mut b = BytesMut::from_vec(v);","            b.advance_unchecked(off);","            b","        } else {","            let v = std::slice::from_raw_parts(ptr, len).to_vec();","            release_shared(shared);","            BytesMut::from_vec(v)","        }","    }","","    unsafe {","        let buf = Box::into_raw(Box::new(42u8)) as *mut u8; // Simulating buffer allocation","        let shared = Box::into_raw(Box::new(Shared {","            ref_cnt: AtomicUsize::new(1),","            buf: buf,","            cap: 1,","        }));","","        let result = shared_to_mut_impl(shared, buf, 1);","        assert_eq!(result.vec.len(), 1);","        assert_eq!(result.vec[0], 42);","","        // Clean up","        release_shared(shared);","    }","}"],[{"start_line":1439,"start_column":8,"end_line":1439,"end_column":54,"positive":false,"negative":false}]]]}