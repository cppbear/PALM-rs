{"function_name":"bytes::buf::buf_mut::<&mut T as buf::buf_mut::BufMut>::chunk_mut","tests":4,"tests_lines":[15,15,15,15],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1361,1362,1363],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl TestBuf {","        fn chunk_mut(&mut self) -> &mut [u8] {","            &mut self.data","        }","    }","","    let mut buf = TestBuf { data: Vec::new() };","    let chunk = buf.chunk_mut();","    assert!(chunk.is_empty());","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl TestBuf {","        fn chunk_mut(&mut self) -> &mut [u8] {","            &mut self.data","        }","    }","","    let mut buf = TestBuf { data: vec![1, 2, 3] };","    let chunk = buf.chunk_mut();","    assert_eq!(chunk, [1, 2, 3]);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl TestBuf {","        fn chunk_mut(&mut self) -> &mut [u8] {","            &mut self.data","        }","    }","","    let mut buf = TestBuf { data: vec![42] };","    let chunk = buf.chunk_mut();","    assert_eq!(chunk, [42]);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl TestBuf {","        fn chunk_mut(&mut self) -> &mut [u8] {","            &mut self.data","        }","    }","","    let mut buf = TestBuf { data: vec![1] };","    let _chunk = buf.chunk_mut();","    buf.data.push(2); // This should panic due to interior mutability.","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl TestBuf {","        fn chunk_mut(&mut self) -> &mut [u8] {","            &mut self.data","        }","    }","","    let mut buf = TestBuf { data: Vec::new() };","    let chunk = buf.chunk_mut();","    assert!(chunk.is_empty());","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl TestBuf {","        fn chunk_mut(&mut self) -> &mut [u8] {","            &mut self.data","        }","    }","","    let mut buf = TestBuf { data: vec![1, 2, 3] };","    let chunk = buf.chunk_mut();","    assert_eq!(chunk, [1, 2, 3]);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl TestBuf {","        fn chunk_mut(&mut self) -> &mut [u8] {","            &mut self.data","        }","    }","","    let mut buf = TestBuf { data: vec![42] };","    let chunk = buf.chunk_mut();","    assert_eq!(chunk, [42]);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl TestBuf {","        fn chunk_mut(&mut self) -> &mut [u8] {","            &mut self.data","        }","    }","","    let mut buf = TestBuf { data: vec![1] };","    let _chunk = buf.chunk_mut();","    buf.data.push(2); // This should panic due to interior mutability.","}"],[]]]}