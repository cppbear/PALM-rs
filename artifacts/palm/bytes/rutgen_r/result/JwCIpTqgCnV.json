{"function_name":"bytes::buf::buf_mut::<alloc::vec::Vec<u8> as buf::buf_mut::BufMut>::advance_mut","tests":2,"tests_lines":[42,63],"oracles":2,"oracles_compiled":1,"oracles_compiled_rate":50.0,"tests_compiled":1,"tests_compiled_rate":50.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":14,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620],"codes_lines_covered":[[["{","    struct Buffer {","        data: Vec<u8>,","        len: usize,","        capacity: usize,","    }","","    impl Buffer {","        fn new(capacity: usize) -> Self {","            Self {","                data: Vec::with_capacity(capacity),","                len: 0,","                capacity,","            }","        }","","        fn len(&self) -> usize {","            self.len","        }","","        fn capacity(&self) -> usize {","            self.capacity","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            let len = self.len();","            let remaining = self.capacity() - len;","","            if remaining < cnt {","                panic_advance(&TryGetError {","                    requested: cnt,","                    available: remaining,","                });","            }","","            self.set_len(len + cnt);","        }","","        fn set_len(&mut self, new_len: usize) {","            self.len = new_len;","        }","    }","","    struct TryGetError {","        requested: usize,","        available: usize,","    }","","    fn panic_advance(error: &TryGetError) {","        panic!(\"Requested: {}, Available: {}\", error.requested, error.available);","    }","","    let capacity = 10;","    let mut buffer = Buffer::new(capacity);","    ","    // Force the length to be maxed out so that remaining == cnt","    let cnt = buffer.capacity() - buffer.len(); // remaining == cnt","    unsafe {","        buffer.advance_mut(cnt);","    }","    ","    assert_eq!(buffer.len(), capacity);","}"],[]]],"codes_branches":[{"start_line":1611,"start_column":12,"end_line":1611,"end_column":27,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct Buffer {","        data: Vec<u8>,","        len: usize,","        capacity: usize,","    }","","    impl Buffer {","        fn new(capacity: usize) -> Self {","            Self {","                data: Vec::with_capacity(capacity),","                len: 0,","                capacity,","            }","        }","","        fn len(&self) -> usize {","            self.len","        }","","        fn capacity(&self) -> usize {","            self.capacity","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            let len = self.len();","            let remaining = self.capacity() - len;","","            if remaining < cnt {","                panic_advance(&TryGetError {","                    requested: cnt,","                    available: remaining,","                });","            }","","            self.set_len(len + cnt);","        }","","        fn set_len(&mut self, new_len: usize) {","            self.len = new_len;","        }","    }","","    struct TryGetError {","        requested: usize,","        available: usize,","    }","","    fn panic_advance(error: &TryGetError) {","        panic!(\"Requested: {}, Available: {}\", error.requested, error.available);","    }","","    let capacity = 10;","    let mut buffer = Buffer::new(capacity);","    ","    // Force the length to be maxed out so that remaining == cnt","    let cnt = buffer.capacity() - buffer.len(); // remaining == cnt","    unsafe {","        buffer.advance_mut(cnt);","    }","    ","    assert_eq!(buffer.len(), capacity);","}"],[{"start_line":1611,"start_column":12,"end_line":1611,"end_column":27,"positive":false,"negative":false}]]]}