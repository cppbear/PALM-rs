{"function_name":"bytes::buf::limit::<buf::limit::Limit<T> as buf::buf_mut::BufMut>::chunk_mut","tests":4,"tests_lines":[22,22,22,21],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[64,65,66,67,68],"codes_lines_covered":[[["{","    struct TestStruct {","        inner: Vec<u8>,","        limit: usize,","    }","","    impl TestStruct {","        fn new(inner: Vec<u8>, limit: usize) -> Self {","            Self { inner, limit }","        }","","        fn chunk_mut(&mut self) -> &mut [u8] {","            let bytes = &mut self.inner;","            let end = std::cmp::min(bytes.len(), self.limit);","            &mut bytes[..end]","        }","    }","","    let mut test_struct = TestStruct::new(vec![1, 2, 3, 4, 5], 3);","    let chunk = test_struct.chunk_mut();","    assert_eq!(chunk, &[1, 2, 3]);","}"],[]],[["{","    struct TestStruct {","        inner: Vec<u8>,","        limit: usize,","    }","","    impl TestStruct {","        fn new(inner: Vec<u8>, limit: usize) -> Self {","            Self { inner, limit }","        }","","        fn chunk_mut(&mut self) -> &mut [u8] {","            let bytes = &mut self.inner;","            let end = std::cmp::min(bytes.len(), self.limit);","            &mut bytes[..end]","        }","    }","","    let mut test_struct = TestStruct::new(vec![1, 2, 3], 3);","    let chunk = test_struct.chunk_mut();","    assert_eq!(chunk, &[1, 2, 3]);","}"],[]],[["{","    struct TestStruct {","        inner: Vec<u8>,","        limit: usize,","    }","","    impl TestStruct {","        fn new(inner: Vec<u8>, limit: usize) -> Self {","            Self { inner, limit }","        }","","        fn chunk_mut(&mut self) -> &mut [u8] {","            let bytes = &mut self.inner;","            let end = std::cmp::min(bytes.len(), self.limit);","            &mut bytes[..end]","        }","    }","","    let mut test_struct = TestStruct::new(vec![1, 2], 4);","    let chunk = test_struct.chunk_mut();","    assert_eq!(chunk, &[1, 2]);","}"],[]],[["{","    struct TestStruct {","        inner: Vec<u8>,","        limit: usize,","    }","","    impl TestStruct {","        fn new(inner: Vec<u8>, limit: usize) -> Self {","            Self { inner, limit }","        }","","        fn chunk_mut(&mut self) -> &mut [u8] {","            let bytes = &mut self.inner;","            let end = std::cmp::min(bytes.len(), self.limit);","            &mut bytes[..end]  // This will panic if inner is empty and limit is more than 0.","        }","    }","","    let mut test_struct = TestStruct::new(Vec::new(), 1);","    test_struct.chunk_mut();","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestStruct {","        inner: Vec<u8>,","        limit: usize,","    }","","    impl TestStruct {","        fn new(inner: Vec<u8>, limit: usize) -> Self {","            Self { inner, limit }","        }","","        fn chunk_mut(&mut self) -> &mut [u8] {","            let bytes = &mut self.inner;","            let end = std::cmp::min(bytes.len(), self.limit);","            &mut bytes[..end]","        }","    }","","    let mut test_struct = TestStruct::new(vec![1, 2, 3, 4, 5], 3);","    let chunk = test_struct.chunk_mut();","    assert_eq!(chunk, &[1, 2, 3]);","}"],[]],[["{","    struct TestStruct {","        inner: Vec<u8>,","        limit: usize,","    }","","    impl TestStruct {","        fn new(inner: Vec<u8>, limit: usize) -> Self {","            Self { inner, limit }","        }","","        fn chunk_mut(&mut self) -> &mut [u8] {","            let bytes = &mut self.inner;","            let end = std::cmp::min(bytes.len(), self.limit);","            &mut bytes[..end]","        }","    }","","    let mut test_struct = TestStruct::new(vec![1, 2, 3], 3);","    let chunk = test_struct.chunk_mut();","    assert_eq!(chunk, &[1, 2, 3]);","}"],[]],[["{","    struct TestStruct {","        inner: Vec<u8>,","        limit: usize,","    }","","    impl TestStruct {","        fn new(inner: Vec<u8>, limit: usize) -> Self {","            Self { inner, limit }","        }","","        fn chunk_mut(&mut self) -> &mut [u8] {","            let bytes = &mut self.inner;","            let end = std::cmp::min(bytes.len(), self.limit);","            &mut bytes[..end]","        }","    }","","    let mut test_struct = TestStruct::new(vec![1, 2], 4);","    let chunk = test_struct.chunk_mut();","    assert_eq!(chunk, &[1, 2]);","}"],[]],[["{","    struct TestStruct {","        inner: Vec<u8>,","        limit: usize,","    }","","    impl TestStruct {","        fn new(inner: Vec<u8>, limit: usize) -> Self {","            Self { inner, limit }","        }","","        fn chunk_mut(&mut self) -> &mut [u8] {","            let bytes = &mut self.inner;","            let end = std::cmp::min(bytes.len(), self.limit);","            &mut bytes[..end]  // This will panic if inner is empty and limit is more than 0.","        }","    }","","    let mut test_struct = TestStruct::new(Vec::new(), 1);","    test_struct.chunk_mut();","}"],[]]]}