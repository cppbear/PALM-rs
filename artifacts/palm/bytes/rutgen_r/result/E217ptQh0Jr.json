{"function_name":"bytes::bytes::free_boxed_slice","tests":3,"tests_lines":[18,13,13],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":1,"oracles_passed_rate":33.33333333333333,"tests_run":3,"tests_passed":1,"tests_passed_rate":33.33333333333333,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1350,1351,1352,1353],"codes_lines_covered":[[["{","    use std::alloc::{dealloc, Layout};","    use std::ptr;","","    unsafe {","        let len = 10;","        let buf: *mut u8 = std::alloc::alloc(Layout::from_size_align(len, 1).unwrap());","        let offset: *const u8 = buf.add(2); // Offset within the allocated buffer","","        // Ensure that the allocated buffer is valid and contains enough space","        for i in 0..len {","            *buf.add(i) = i as u8;","        }","","        // Free the boxed slice without panic","        free_boxed_slice(buf, offset, 5);","    }","}"],[1350,1351,1352,1353]],[["{","    use std::alloc::{dealloc, Layout};","    use std::ptr;","","    unsafe {","        let len = 10;","        let buf: *mut u8 = std::alloc::alloc(Layout::from_size_align(len, 1).unwrap());","        let offset: *const u8 = buf.add(11); // Invalid offset, out of bounds","","        // This should cause a panic in Layout::from_size_align","        free_boxed_slice(buf, offset, 5);","    }","}"],[1350,1351,1352,1353]],[["{","    use std::alloc::{dealloc, Layout};","    use std::ptr;","","    unsafe {","        let len = 0;","        let buf: *mut u8 = std::alloc::alloc(Layout::from_size_align(1, 1).unwrap());","        let offset: *const u8 = buf; // Valid offset at the start","","        // This should cause a panic in Layout::from_size_align when cap is invalid","        free_boxed_slice(buf, offset, len);","    }","}"],[1350,1351,1352,1353]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::alloc::{dealloc, Layout};","    use std::ptr;","","    unsafe {","        let len = 10;","        let buf: *mut u8 = std::alloc::alloc(Layout::from_size_align(len, 1).unwrap());","        let offset: *const u8 = buf.add(2); // Offset within the allocated buffer","","        // Ensure that the allocated buffer is valid and contains enough space","        for i in 0..len {","            *buf.add(i) = i as u8;","        }","","        // Free the boxed slice without panic","        free_boxed_slice(buf, offset, 5);","    }","}"],[]],[["{","    use std::alloc::{dealloc, Layout};","    use std::ptr;","","    unsafe {","        let len = 10;","        let buf: *mut u8 = std::alloc::alloc(Layout::from_size_align(len, 1).unwrap());","        let offset: *const u8 = buf.add(11); // Invalid offset, out of bounds","","        // This should cause a panic in Layout::from_size_align","        free_boxed_slice(buf, offset, 5);","    }","}"],[]],[["{","    use std::alloc::{dealloc, Layout};","    use std::ptr;","","    unsafe {","        let len = 0;","        let buf: *mut u8 = std::alloc::alloc(Layout::from_size_align(1, 1).unwrap());","        let offset: *const u8 = buf; // Valid offset at the start","","        // This should cause a panic in Layout::from_size_align when cap is invalid","        free_boxed_slice(buf, offset, len);","    }","}"],[]]]}