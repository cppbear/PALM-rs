{"function_name":"bytes::buf::chain::<buf::chain::Chain<T, U> as buf::buf_mut::BufMut>::advance_mut","tests":4,"tests_lines":[63,63,62,45],"oracles":4,"oracles_compiled":3,"oracles_compiled_rate":75.0,"tests_compiled":3,"tests_compiled_rate":75.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":16,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[210,211,212,213,214,215,216,217,218,219,220,221,222,223,225,226],"codes_lines_covered":[[["{","    struct MockBuffer {","        data: Vec<u8>,","        pos: usize,","    }","","    impl MockBuffer {","        fn new(size: usize) -> Self {","            MockBuffer {","                data: vec![0; size],","                pos: 0,","            }","        }","","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.pos","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.pos += cnt;","        }","    }","","    struct Chain {","        a: MockBuffer,","        b: MockBuffer,","    }","","    impl Chain {","        fn new(a_size: usize, b_size: usize) -> Self {","            Chain {","                a: MockBuffer::new(a_size),","                b: MockBuffer::new(b_size),","            }","        }","","        unsafe fn advance_mut(&mut self, mut cnt: usize) {","            let a_rem = self.a.remaining_mut();","","            if a_rem != 0 {","                if a_rem >= cnt {","                    self.a.advance_mut(cnt);","                    return;","                }","","                self.a.advance_mut(a_rem);","                cnt -= a_rem;","            }","","            self.b.advance_mut(cnt);","        }","    }","","    let mut chain = Chain::new(5, 3); // a has 5 remaining units, b has 3","    let mut cnt = 5; // This equals to a_rem","","    unsafe {","        chain.advance_mut(cnt);","    }","","    assert_eq!(chain.a.pos, 5); // a should have advanced by 5","    assert_eq!(chain.b.pos, 0); // b should not have advanced","}"],[]],[["{","    struct MockBuffer {","        data: Vec<u8>,","        pos: usize,","    }","","    impl MockBuffer {","        fn new(size: usize) -> Self {","            MockBuffer {","                data: vec![0; size],","                pos: 0,","            }","        }","","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.pos","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.pos += cnt;","        }","    }","","    struct Chain {","        a: MockBuffer,","        b: MockBuffer,","    }","","    impl Chain {","        fn new(a_size: usize, b_size: usize) -> Self {","            Chain {","                a: MockBuffer::new(a_size),","                b: MockBuffer::new(b_size),","            }","        }","","        unsafe fn advance_mut(&mut self, mut cnt: usize) {","            let a_rem = self.a.remaining_mut();","","            if a_rem != 0 {","                if a_rem >= cnt {","                    self.a.advance_mut(cnt);","                    return;","                }","","                self.a.advance_mut(a_rem);","                cnt -= a_rem;","            }","","            self.b.advance_mut(cnt);","        }","    }","","    let mut chain = Chain::new(3, 0); // a has 3 remaining units, b has 0","    let cnt = 3; // This equals to a_rem","","    unsafe {","        chain.advance_mut(cnt);","    }","","    assert_eq!(chain.a.pos, 3); // a should have advanced by 3","    assert_eq!(chain.b.pos, 0); // b should not have advanced","}"],[]],[["{","    struct Buffer {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buffer {","        fn new(size: usize) -> Self {","            Buffer {","                data: vec![0; size],","                position: 0,","            }","        }","","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.position","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.position += cnt;","        }","    }","","    struct Chain {","        a: Buffer,","        b: Buffer,","    }","","    impl Chain {","        fn new(a_size: usize, b_size: usize) -> Self {","            Chain {","                a: Buffer::new(a_size),","                b: Buffer::new(b_size),","            }","        }","","        unsafe fn advance_mut(&mut self, mut cnt: usize) {","            let a_rem = self.a.remaining_mut();","","            if a_rem != 0 {","                if a_rem >= cnt {","                    self.a.advance_mut(cnt);","                    return;","                }","                ","                self.a.advance_mut(a_rem);","                cnt -= a_rem;","            }","","            self.b.advance_mut(cnt);","        }","    }","","    let mut chain = Chain::new(5, 10);","","    unsafe {","        chain.advance_mut(10); // This should consume all of a and then proceed to b","    }","","    assert_eq!(chain.a.remaining_mut(), 0);","    assert_eq!(chain.b.position, 5); // Since a had 5 and it was entirely consumed","}"],[]]],"codes_branches":[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":false,"negative":false},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockBuffer {","        data: Vec<u8>,","        pos: usize,","    }","","    impl MockBuffer {","        fn new(size: usize) -> Self {","            MockBuffer {","                data: vec![0; size],","                pos: 0,","            }","        }","","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.pos","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.pos += cnt;","        }","    }","","    struct Chain {","        a: MockBuffer,","        b: MockBuffer,","    }","","    impl Chain {","        fn new(a_size: usize, b_size: usize) -> Self {","            Chain {","                a: MockBuffer::new(a_size),","                b: MockBuffer::new(b_size),","            }","        }","","        unsafe fn advance_mut(&mut self, mut cnt: usize) {","            let a_rem = self.a.remaining_mut();","","            if a_rem != 0 {","                if a_rem >= cnt {","                    self.a.advance_mut(cnt);","                    return;","                }","","                self.a.advance_mut(a_rem);","                cnt -= a_rem;","            }","","            self.b.advance_mut(cnt);","        }","    }","","    let mut chain = Chain::new(5, 3); // a has 5 remaining units, b has 3","    let mut cnt = 5; // This equals to a_rem","","    unsafe {","        chain.advance_mut(cnt);","    }","","    assert_eq!(chain.a.pos, 5); // a should have advanced by 5","    assert_eq!(chain.b.pos, 0); // b should not have advanced","}"],[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":false,"negative":false},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":false,"negative":false}]],[["{","    struct MockBuffer {","        data: Vec<u8>,","        pos: usize,","    }","","    impl MockBuffer {","        fn new(size: usize) -> Self {","            MockBuffer {","                data: vec![0; size],","                pos: 0,","            }","        }","","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.pos","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.pos += cnt;","        }","    }","","    struct Chain {","        a: MockBuffer,","        b: MockBuffer,","    }","","    impl Chain {","        fn new(a_size: usize, b_size: usize) -> Self {","            Chain {","                a: MockBuffer::new(a_size),","                b: MockBuffer::new(b_size),","            }","        }","","        unsafe fn advance_mut(&mut self, mut cnt: usize) {","            let a_rem = self.a.remaining_mut();","","            if a_rem != 0 {","                if a_rem >= cnt {","                    self.a.advance_mut(cnt);","                    return;","                }","","                self.a.advance_mut(a_rem);","                cnt -= a_rem;","            }","","            self.b.advance_mut(cnt);","        }","    }","","    let mut chain = Chain::new(3, 0); // a has 3 remaining units, b has 0","    let cnt = 3; // This equals to a_rem","","    unsafe {","        chain.advance_mut(cnt);","    }","","    assert_eq!(chain.a.pos, 3); // a should have advanced by 3","    assert_eq!(chain.b.pos, 0); // b should not have advanced","}"],[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":false,"negative":false},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":false,"negative":false}]],[["{","    struct Buffer {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buffer {","        fn new(size: usize) -> Self {","            Buffer {","                data: vec![0; size],","                position: 0,","            }","        }","","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.position","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.position += cnt;","        }","    }","","    struct Chain {","        a: Buffer,","        b: Buffer,","    }","","    impl Chain {","        fn new(a_size: usize, b_size: usize) -> Self {","            Chain {","                a: Buffer::new(a_size),","                b: Buffer::new(b_size),","            }","        }","","        unsafe fn advance_mut(&mut self, mut cnt: usize) {","            let a_rem = self.a.remaining_mut();","","            if a_rem != 0 {","                if a_rem >= cnt {","                    self.a.advance_mut(cnt);","                    return;","                }","                ","                self.a.advance_mut(a_rem);","                cnt -= a_rem;","            }","","            self.b.advance_mut(cnt);","        }","    }","","    let mut chain = Chain::new(5, 10);","","    unsafe {","        chain.advance_mut(10); // This should consume all of a and then proceed to b","    }","","    assert_eq!(chain.a.remaining_mut(), 0);","    assert_eq!(chain.b.position, 5); // Since a had 5 and it was entirely consumed","}"],[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":false,"negative":false},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":false,"negative":false}]]]}