{"function_name":"bytes::buf::chain::<buf::chain::Chain<T, U> as buf::buf_impl::Buf>::copy_to_bytes","tests":7,"tests_lines":[75,60,76,74,70,53,20],"oracles":7,"oracles_compiled":1,"oracles_compiled_rate":14.285714285714285,"tests_compiled":1,"tests_compiled_rate":14.285714285714285,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":15,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[172,173,174,175,176,177,179,180,181,182,183,184,185,186,188],"codes_lines_covered":[[["{","    struct MockA {","        remaining: usize,","    }","    ","    impl MockA {","        fn remaining(&self) -> usize {","            self.remaining","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            // Implementation not needed for this test","            crate::Bytes::new()","        }","    }","    ","    struct MockB {","        remaining: usize,","    }","    ","    impl MockB {","        fn remaining(&self) -> usize {","            self.remaining","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            // Implementation not needed for this test","            crate::Bytes::new()","        }","    }","    ","    struct MockChain {","        a: MockA,","        b: MockB,","    }","    ","    impl MockChain {","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            let a_rem = self.a.remaining();","            if a_rem >= len {","                self.a.copy_to_bytes(len)","            } else if a_rem == 0 {","                self.b.copy_to_bytes(len)","            } else {","                assert!(","                    len - a_rem <= self.b.remaining(),","                    \"`len` greater than remaining\"","                );","                crate::Bytes::new()","            }","        }","    }","    ","    let mut chain = MockChain {","        a: MockA { remaining: 2 },","        b: MockB { remaining: 1 },","    };","    ","    chain.copy_to_bytes(4);","}"],[]]],"codes_branches":[{"start_line":174,"start_column":12,"end_line":174,"end_column":24,"positive":false,"negative":false},{"start_line":176,"start_column":19,"end_line":176,"end_column":29,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockA {","        remaining: usize,","    }","    ","    impl MockA {","        fn remaining(&self) -> usize {","            self.remaining","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            // Implementation not needed for this test","            crate::Bytes::new()","        }","    }","    ","    struct MockB {","        remaining: usize,","    }","    ","    impl MockB {","        fn remaining(&self) -> usize {","            self.remaining","        }","        ","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            // Implementation not needed for this test","            crate::Bytes::new()","        }","    }","    ","    struct MockChain {","        a: MockA,","        b: MockB,","    }","    ","    impl MockChain {","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            let a_rem = self.a.remaining();","            if a_rem >= len {","                self.a.copy_to_bytes(len)","            } else if a_rem == 0 {","                self.b.copy_to_bytes(len)","            } else {","                assert!(","                    len - a_rem <= self.b.remaining(),","                    \"`len` greater than remaining\"","                );","                crate::Bytes::new()","            }","        }","    }","    ","    let mut chain = MockChain {","        a: MockA { remaining: 2 },","        b: MockB { remaining: 1 },","    };","    ","    chain.copy_to_bytes(4);","}"],[{"start_line":174,"start_column":12,"end_line":174,"end_column":24,"positive":false,"negative":false},{"start_line":176,"start_column":19,"end_line":176,"end_column":29,"positive":false,"negative":false}]]]}