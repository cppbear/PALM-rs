{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::set_len","tests":7,"tests_lines":[18,18,11,18,27,32,31],"oracles":7,"oracles_compiled":3,"oracles_compiled_rate":42.857142857142854,"tests_compiled":3,"tests_compiled_rate":42.857142857142854,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[528,529,530,531],"codes_lines_covered":[[["{","    struct BytesMut {","        cap: usize,","        len: usize,","    }","","    impl BytesMut {","        fn from(slice: &[u8]) -> Self {","            BytesMut {","                cap: slice.len(),","                len: slice.len(),","            }","        }","","        unsafe fn set_len(&mut self, len: usize) {","            debug_assert!(len <= self.cap, \"set_len out of bounds\");","            self.len = len;","        }","    }","","    let mut b = BytesMut::from(&b\"hello\"[..]);","","    unsafe {","        // Attempt to set a length greater than capacity","        b.set_len(10);","    }","}"],[]],[["{","    struct BytesMut {","        cap: usize,","        len: usize,","    }","","    impl BytesMut {","        fn from(slice: &[u8]) -> Self {","            BytesMut {","                cap: slice.len(),","                len: slice.len(),","            }","        }","","        unsafe fn set_len(&mut self, len: usize) {","            debug_assert!(len <= self.cap, \"set_len out of bounds\");","            self.len = len;","        }","    }","","    let mut b = BytesMut::from(&b\"hello\"[..]);","","    unsafe {","        // Set a valid length","        b.set_len(5);","        assert_eq!(b.len, 5);","","        // Set back to the original length","        b.set_len(5);","        assert_eq!(b.len, 5);","    }","}"],[]],[["{","    struct BytesMut {","        cap: usize,","        len: usize,","    }","","    impl BytesMut {","        fn from(slice: &[u8]) -> Self {","            BytesMut {","                cap: slice.len(),","                len: slice.len(),","            }","        }","","        unsafe fn set_len(&mut self, len: usize) {","            debug_assert!(len <= self.cap, \"set_len out of bounds\");","            self.len = len;","        }","    }","","    let mut b = BytesMut::from(&b\"hello\"[..]);","","    unsafe {","        // Attempt to set length to 0, which is valid for this context","        b.set_len(0);","        assert_eq!(b.len, 0);","        ","        // Set length beyond initial capacity","        b.set_len(6); // This should panic","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct BytesMut {","        cap: usize,","        len: usize,","    }","","    impl BytesMut {","        fn from(slice: &[u8]) -> Self {","            BytesMut {","                cap: slice.len(),","                len: slice.len(),","            }","        }","","        unsafe fn set_len(&mut self, len: usize) {","            debug_assert!(len <= self.cap, \"set_len out of bounds\");","            self.len = len;","        }","    }","","    let mut b = BytesMut::from(&b\"hello\"[..]);","","    unsafe {","        // Attempt to set a length greater than capacity","        b.set_len(10);","    }","}"],[]],[["{","    struct BytesMut {","        cap: usize,","        len: usize,","    }","","    impl BytesMut {","        fn from(slice: &[u8]) -> Self {","            BytesMut {","                cap: slice.len(),","                len: slice.len(),","            }","        }","","        unsafe fn set_len(&mut self, len: usize) {","            debug_assert!(len <= self.cap, \"set_len out of bounds\");","            self.len = len;","        }","    }","","    let mut b = BytesMut::from(&b\"hello\"[..]);","","    unsafe {","        // Set a valid length","        b.set_len(5);","        assert_eq!(b.len, 5);","","        // Set back to the original length","        b.set_len(5);","        assert_eq!(b.len, 5);","    }","}"],[]],[["{","    struct BytesMut {","        cap: usize,","        len: usize,","    }","","    impl BytesMut {","        fn from(slice: &[u8]) -> Self {","            BytesMut {","                cap: slice.len(),","                len: slice.len(),","            }","        }","","        unsafe fn set_len(&mut self, len: usize) {","            debug_assert!(len <= self.cap, \"set_len out of bounds\");","            self.len = len;","        }","    }","","    let mut b = BytesMut::from(&b\"hello\"[..]);","","    unsafe {","        // Attempt to set length to 0, which is valid for this context","        b.set_len(0);","        assert_eq!(b.len, 0);","        ","        // Set length beyond initial capacity","        b.set_len(6); // This should panic","    }","}"],[]]]}