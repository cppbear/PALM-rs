{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::advance_unchecked","tests":13,"tests_lines":[67,55,7,7,10,13,13,14,8,8,38,35,33],"oracles":13,"oracles_compiled":8,"oracles_compiled_rate":61.53846153846154,"tests_compiled":8,"tests_compiled_rate":61.53846153846154,"oracles_run":8,"oracles_passed":5,"oracles_passed_rate":62.5,"tests_run":8,"tests_passed":5,"tests_passed_rate":62.5,"lines":27,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":6,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[956,957,958,959,960,961,962,963,965,966,967,972,973,974,975,976,977,978,979,980,981,982,983,988,989,990,991],"codes_lines_covered":[[["{","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","        kind: usize,","    }","","    impl BytesMut {","        fn new(len: usize, cap: usize) -> Self {","            // For simplicity, we're using a simple calculation for ptr","            let ptr = 0 as *mut u8; // Dummy pointer for the example","            Self { ptr, len, cap, kind: 1 }","        }","","        fn get_vec_pos(&self) -> usize {","            // Dummy implementation, since we don't care about exact values in this test","            0","        }","","        fn set_vec_pos(&mut self, pos: usize) {","            // No operation, just for the sake of the trait methods","        }","        ","        fn promote_to_shared(&mut self, _ref_count: usize) {","            // No operation, just for testing purpose","        }","","        fn kind(&self) -> usize {","            self.kind","        }","        ","        unsafe fn advance_unchecked(&mut self, count: usize) {","            if count == 0 {","                return;","            }","            let kind = self.kind();","            let pos = self.get_vec_pos() + count;","            ","            if pos <= 134217727 {","                self.set_vec_pos(pos);","            } else {","                self.promote_to_shared(1);","            }","            ","            self.ptr = (self.ptr as usize + count) as *mut u8;","            self.len = self.len.checked_sub(count).unwrap_or(0);","            self.cap -= count;","        }","    }","","    let mut bytes_mut = BytesMut::new(10, 10);","    ","    unsafe {","        bytes_mut.advance_unchecked(1);","        assert_eq!(bytes_mut.len, 9);","        assert_eq!(bytes_mut.cap, 9);","","        bytes_mut.advance_unchecked(5);","        assert_eq!(bytes_mut.len, 4);","        assert_eq!(bytes_mut.cap, 4);","","        bytes_mut.advance_unchecked(4);","        assert_eq!(bytes_mut.len, 0);","        assert_eq!(bytes_mut.cap, 0);","    }","}"],[]],[["{","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","        kind: usize,","    }","","    impl BytesMut {","        fn new(len: usize, cap: usize) -> Self {","            let ptr = 0 as *mut u8; // Dummy pointer for the example","            Self { ptr, len, cap, kind: 1 }","        }","","        fn get_vec_pos(&self) -> usize {","            0","        }","","        fn set_vec_pos(&mut self, pos: usize) {","            // No operation","        }","","        fn promote_to_shared(&mut self, _ref_count: usize) {","            // No operation","        }","","        fn kind(&self) -> usize {","            self.kind","        }","","        unsafe fn advance_unchecked(&mut self, count: usize) {","            if count == 0 {","                return;","            }","            let kind = self.kind();","","            let pos = self.get_vec_pos() + count;","            if pos <= 134217727 {","                self.set_vec_pos(pos);","            } else {","                self.promote_to_shared(1);","            }","","            self.ptr = (self.ptr as usize + count) as *mut u8;","            self.len = self.len.checked_sub(count).unwrap_or(0);","            self.cap -= count;","        }","    }","","    let mut bytes_mut = BytesMut::new(10, 10);","","    unsafe {","        bytes_mut.advance_unchecked(11); // Try to advance more than capacity.","    }","}"],[]],[["{","    let mut buffer = MyBuffer::new(10); // Assuming the buffer is initialized with capacity 10","    unsafe { buffer.advance_unchecked(0) }; // count == 0 should be a no-op","","    assert_eq!(buffer.len, 10);","    assert_eq!(buffer.cap, 10);","}"],[]],[["{","    let mut buffer = MyBuffer::new(5); // Initialize buffer with a capacity of 5","    unsafe { buffer.advance_unchecked(5) }; // count is equal to self.cap","","    assert_eq!(buffer.len, 0);","    assert_eq!(buffer.cap, 0);","}"],[]],[["{","    let mut buffer = MyBuffer::new(100); // Initialize with more than MAX_VEC_POS","    buffer.set_vec_pos(MAX_VEC_POS - 5); // Set position below max","","    unsafe { buffer.advance_unchecked(5) }; // Move to exact MAX_VEC_POS","","    assert_eq!(buffer.get_vec_pos(), MAX_VEC_POS);","    assert_eq!(buffer.len, 95); // 100 - 5","    assert_eq!(buffer.cap, 95);","}"],[]],[["{","    struct NonVecBuffer {","        ptr: *mut u8,","        len: usize,","        cap: usize,","        kind: usize,","    }","","    impl NonVecBuffer {","        fn new(len: usize, cap: usize) -> Self {","            let vec = vec![0u8; cap];","            let ptr = vec.as_ptr() as *mut u8;","            std::mem::forget(vec);","            NonVecBuffer { ptr, len, cap, kind: 0 } // assume kind indicates non-vec","        }","","        unsafe fn advance_unchecked(&mut self, count: usize) {","            if count == 0 {","                return;","            }","","            if self.kind != 1 { // KIND_VEC = 1, so ensure kind indicates not vec","                return;","            }","","            self.ptr = self.ptr.add(count);","            self.len = self.len.checked_sub(count).unwrap_or(0);","            self.cap -= count;","        }","    }","    ","    let mut buffer = NonVecBuffer::new(5, 5); // capacity is 5","    unsafe {","        buffer.advance_unchecked(3); // should not panic","    }","    assert_eq!(buffer.len, 2); // length should be updated to 2","    assert_eq!(buffer.cap, 2); // capacity should be updated to 2","}"],[]],[["{","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","    }","","    impl BytesMut {","        fn new(cap: usize) -> Self {","            let buffer = vec![0u8; cap];","            let ptr = buffer.as_ptr() as *mut u8;","            std::mem::forget(buffer); // Prevent the buffer from being dropped","            BytesMut { ptr, len: cap, cap }","        }","","        unsafe fn advance_unchecked(&mut self, count: usize) {","            if count == 0 {","                return;","            }","","            debug_assert!(count <= self.cap, \"internal: set_start out of bounds\");","            // Simulating some behavior as the original code is not provided","            self.ptr = self.ptr.add(count);","            self.len = self.len.checked_sub(count).unwrap_or(0);","            self.cap -= count;","        }","    }","","    let mut bytes_mut = BytesMut::new(10);","    unsafe {","        bytes_mut.advance_unchecked(0);","    }","    assert_eq!(bytes_mut.len, 10);","    assert_eq!(bytes_mut.cap, 10);","}"],[]],[["{","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","    }","","    impl BytesMut {","        fn new(cap: usize) -> Self {","            let buffer = vec![0u8; cap];","            let ptr = buffer.as_ptr() as *mut u8;","            std::mem::forget(buffer); // Prevent the buffer from being dropped","            BytesMut { ptr, len: cap, cap }","        }","","        unsafe fn advance_unchecked(&mut self, count: usize) {","            if count == 0 {","                return;","            }","","            debug_assert!(count <= self.cap, \"internal: set_start out of bounds\");","            // Simulating some behavior","            self.ptr = self.ptr.add(count);","            self.len = self.len.checked_sub(count).unwrap_or(0);","            self.cap -= count;","        }","    }","","    let mut bytes_mut = BytesMut::new(10);","    unsafe {","        bytes_mut.advance_unchecked(15); // This should trigger a panic","    }","}"],[]]],"codes_branches":[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","        kind: usize,","    }","","    impl BytesMut {","        fn new(len: usize, cap: usize) -> Self {","            // For simplicity, we're using a simple calculation for ptr","            let ptr = 0 as *mut u8; // Dummy pointer for the example","            Self { ptr, len, cap, kind: 1 }","        }","","        fn get_vec_pos(&self) -> usize {","            // Dummy implementation, since we don't care about exact values in this test","            0","        }","","        fn set_vec_pos(&mut self, pos: usize) {","            // No operation, just for the sake of the trait methods","        }","        ","        fn promote_to_shared(&mut self, _ref_count: usize) {","            // No operation, just for testing purpose","        }","","        fn kind(&self) -> usize {","            self.kind","        }","        ","        unsafe fn advance_unchecked(&mut self, count: usize) {","            if count == 0 {","                return;","            }","            let kind = self.kind();","            let pos = self.get_vec_pos() + count;","            ","            if pos <= 134217727 {","                self.set_vec_pos(pos);","            } else {","                self.promote_to_shared(1);","            }","            ","            self.ptr = (self.ptr as usize + count) as *mut u8;","            self.len = self.len.checked_sub(count).unwrap_or(0);","            self.cap -= count;","        }","    }","","    let mut bytes_mut = BytesMut::new(10, 10);","    ","    unsafe {","        bytes_mut.advance_unchecked(1);","        assert_eq!(bytes_mut.len, 9);","        assert_eq!(bytes_mut.cap, 9);","","        bytes_mut.advance_unchecked(5);","        assert_eq!(bytes_mut.len, 4);","        assert_eq!(bytes_mut.cap, 4);","","        bytes_mut.advance_unchecked(4);","        assert_eq!(bytes_mut.len, 0);","        assert_eq!(bytes_mut.cap, 0);","    }","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","        kind: usize,","    }","","    impl BytesMut {","        fn new(len: usize, cap: usize) -> Self {","            let ptr = 0 as *mut u8; // Dummy pointer for the example","            Self { ptr, len, cap, kind: 1 }","        }","","        fn get_vec_pos(&self) -> usize {","            0","        }","","        fn set_vec_pos(&mut self, pos: usize) {","            // No operation","        }","","        fn promote_to_shared(&mut self, _ref_count: usize) {","            // No operation","        }","","        fn kind(&self) -> usize {","            self.kind","        }","","        unsafe fn advance_unchecked(&mut self, count: usize) {","            if count == 0 {","                return;","            }","            let kind = self.kind();","","            let pos = self.get_vec_pos() + count;","            if pos <= 134217727 {","                self.set_vec_pos(pos);","            } else {","                self.promote_to_shared(1);","            }","","            self.ptr = (self.ptr as usize + count) as *mut u8;","            self.len = self.len.checked_sub(count).unwrap_or(0);","            self.cap -= count;","        }","    }","","    let mut bytes_mut = BytesMut::new(10, 10);","","    unsafe {","        bytes_mut.advance_unchecked(11); // Try to advance more than capacity.","    }","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut buffer = MyBuffer::new(10); // Assuming the buffer is initialized with capacity 10","    unsafe { buffer.advance_unchecked(0) }; // count == 0 should be a no-op","","    assert_eq!(buffer.len, 10);","    assert_eq!(buffer.cap, 10);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut buffer = MyBuffer::new(5); // Initialize buffer with a capacity of 5","    unsafe { buffer.advance_unchecked(5) }; // count is equal to self.cap","","    assert_eq!(buffer.len, 0);","    assert_eq!(buffer.cap, 0);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut buffer = MyBuffer::new(100); // Initialize with more than MAX_VEC_POS","    buffer.set_vec_pos(MAX_VEC_POS - 5); // Set position below max","","    unsafe { buffer.advance_unchecked(5) }; // Move to exact MAX_VEC_POS","","    assert_eq!(buffer.get_vec_pos(), MAX_VEC_POS);","    assert_eq!(buffer.len, 95); // 100 - 5","    assert_eq!(buffer.cap, 95);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    struct NonVecBuffer {","        ptr: *mut u8,","        len: usize,","        cap: usize,","        kind: usize,","    }","","    impl NonVecBuffer {","        fn new(len: usize, cap: usize) -> Self {","            let vec = vec![0u8; cap];","            let ptr = vec.as_ptr() as *mut u8;","            std::mem::forget(vec);","            NonVecBuffer { ptr, len, cap, kind: 0 } // assume kind indicates non-vec","        }","","        unsafe fn advance_unchecked(&mut self, count: usize) {","            if count == 0 {","                return;","            }","","            if self.kind != 1 { // KIND_VEC = 1, so ensure kind indicates not vec","                return;","            }","","            self.ptr = self.ptr.add(count);","            self.len = self.len.checked_sub(count).unwrap_or(0);","            self.cap -= count;","        }","    }","    ","    let mut buffer = NonVecBuffer::new(5, 5); // capacity is 5","    unsafe {","        buffer.advance_unchecked(3); // should not panic","    }","    assert_eq!(buffer.len, 2); // length should be updated to 2","    assert_eq!(buffer.cap, 2); // capacity should be updated to 2","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","    }","","    impl BytesMut {","        fn new(cap: usize) -> Self {","            let buffer = vec![0u8; cap];","            let ptr = buffer.as_ptr() as *mut u8;","            std::mem::forget(buffer); // Prevent the buffer from being dropped","            BytesMut { ptr, len: cap, cap }","        }","","        unsafe fn advance_unchecked(&mut self, count: usize) {","            if count == 0 {","                return;","            }","","            debug_assert!(count <= self.cap, \"internal: set_start out of bounds\");","            // Simulating some behavior as the original code is not provided","            self.ptr = self.ptr.add(count);","            self.len = self.len.checked_sub(count).unwrap_or(0);","            self.cap -= count;","        }","    }","","    let mut bytes_mut = BytesMut::new(10);","    unsafe {","        bytes_mut.advance_unchecked(0);","    }","    assert_eq!(bytes_mut.len, 10);","    assert_eq!(bytes_mut.cap, 10);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    struct BytesMut {","        ptr: *mut u8,","        len: usize,","        cap: usize,","    }","","    impl BytesMut {","        fn new(cap: usize) -> Self {","            let buffer = vec![0u8; cap];","            let ptr = buffer.as_ptr() as *mut u8;","            std::mem::forget(buffer); // Prevent the buffer from being dropped","            BytesMut { ptr, len: cap, cap }","        }","","        unsafe fn advance_unchecked(&mut self, count: usize) {","            if count == 0 {","                return;","            }","","            debug_assert!(count <= self.cap, \"internal: set_start out of bounds\");","            // Simulating some behavior","            self.ptr = self.ptr.add(count);","            self.len = self.len.checked_sub(count).unwrap_or(0);","            self.cap -= count;","        }","    }","","    let mut bytes_mut = BytesMut::new(10);","    unsafe {","        bytes_mut.advance_unchecked(15); // This should trigger a panic","    }","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]]]}