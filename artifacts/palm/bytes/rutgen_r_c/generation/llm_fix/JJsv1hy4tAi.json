{
  "name": "bytes::fmt::hex::fmt::hex::<impl core::fmt::LowerHex for fmt::BytesRef<'_>>::fmt",
  "name_with_impl": "bytes::fmt::hex::{impl#0}::fmt",
  "mod_info": {
    "name": "fmt::hex",
    "loc": "src/fmt/mod.rs:12:1:12:9"
  },
  "visible": true,
  "loc": "src/fmt/hex.rs:7:5:12:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: &b in self.0 is true\n",
        "// constraint: write!(f, \"{:02x}\", b)? is Err/None\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestFormatter;",
                  "    ",
                  "    impl Formatter<'_> {",
                  "        fn new() -> Self {",
                  "            TestFormatter {}",
                  "        }",
                  "    }",
                  "",
                  "    let data = BytesRef(&[]);",
                  "    let mut formatter = TestFormatter::new();",
                  "    ",
                  "    let result = data.fmt(&mut formatter);",
                  "    ",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0116]: cannot define inherent `impl` for a type outside of the crate where the type is defined\n  --> src/fmt/hex.rs:40:5\n   |\n40 |     impl Formatter<'_> {\n   |     ^^^^^^^^^^^^^^^^^^ impl for type defined outside of crate\n   |\n   = note: define and implement a trait or new type instead\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut [IoSlice<'a>]`, but its trait bounds were not satisfied\n   --> src/buf/buf_impl.rs:208:16\n    |\n208 |         if dst.is_empty() {\n    |                ^^^^^^^^ method cannot be called on `&mut [IoSlice<'a>]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `[IoSlice<'a>]: ExactSizeIterator`\n            which is required by `&mut [IoSlice<'a>]: ExactSizeIterator`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n372 |           buf_get_impl!(self, u16::from_be_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u16` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u16`\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u16` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u16`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n392 |           buf_get_impl!(self, u16::from_le_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u16` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u16`\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u16` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u16`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n415 |           buf_get_impl!(self, u16::from_ne_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u16` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u16`\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u16` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u16`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n435 |           buf_get_impl!(self, i16::from_be_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i16` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i16`\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i16` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i16`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n455 |           buf_get_impl!(self, i16::from_le_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i16` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i16`\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i16` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i16`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n478 |           buf_get_impl!(self, i16::from_ne_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i16` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i16`\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i16` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i16`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n498 |           buf_get_impl!(self, u32::from_be_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u32` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u32`\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u32` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u32`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n518 |           buf_get_impl!(self, u32::from_le_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u32` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u32`\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u32` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u32`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n541 |           buf_get_impl!(self, u32::from_ne_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u32` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u32`\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u32` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u32`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n561 |           buf_get_impl!(self, i32::from_be_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i32` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i32`\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i32` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i32`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n581 |           buf_get_impl!(self, i32::from_le_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i32` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i32`\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i32` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i32`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n604 |           buf_get_impl!(self, i32::from_ne_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i32` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i32`\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i32` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i32`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n624 |           buf_get_impl!(self, u64::from_be_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u64` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u64`\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u64` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u64`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n644 |           buf_get_impl!(self, u64::from_le_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u64` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u64`\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u64` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u64`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n667 |           buf_get_impl!(self, u64::from_ne_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u64` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u64`\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u64` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u64`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n687 |           buf_get_impl!(self, i64::from_be_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i64` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i64`\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i64` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i64`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n707 |           buf_get_impl!(self, i64::from_le_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i64` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i64`\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i64` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i64`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n730 |           buf_get_impl!(self, i64::from_ne_bytes);\n    |           --------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i64` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i64`\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i64` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i64`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n750 |           buf_get_impl!(self, u128::from_be_bytes);\n    |           ---------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u128` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u128`\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u128` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u128`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n770 |           buf_get_impl!(self, u128::from_le_bytes);\n    |           ---------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u128` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u128`\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u128` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u128`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n793 |           buf_get_impl!(self, u128::from_ne_bytes);\n    |           ---------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u128` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `u128`\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u128` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `u128`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n813 |           buf_get_impl!(self, i128::from_be_bytes);\n    |           ---------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i128` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i128`\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i128` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i128`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n833 |           buf_get_impl!(self, i128::from_le_bytes);\n    |           ---------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i128` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i128`\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i128` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i128`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_impl.rs:29:14\n    |\n27  |           let ret = $this\n    |  ___________________-\n28  | |             .chunk()\n29  | |             .get(..SIZE)\n    | |_____________-^^^\n...\n856 |           buf_get_impl!(self, i128::from_ne_bytes);\n    |           ---------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n    |\n29  |             .ge(..SIZE)\n    |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i128` in the current scope\n  --> src/buf/buf_impl.rs:30:39\n   |\n30 |             .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n   |                                       ^^^^^ function or associated item not found in `i128`\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i128` in the current scope\n  --> src/buf/buf_impl.rs:40:29\n   |\n40 |             return Ok($typ::$conv(buf));\n   |                             ^^^^^ function or associated item not found in `i128`\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n   --> src/buf/buf_impl.rs:61:35\n    |\n61  |         let slice_at = match SIZE.checked_sub($len_to_read) {\n    |                                   ^^^^^^^^^^^ method not found in `usize`\n...\n877 |         buf_get_impl!(be => self, u64, nbytes);\n    |         -------------------------------------- in this macro invocation\n   --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n    |\n    = note: the method is available for `usize` here\n    |\n    = help: items from traits can only be used if the trait is in scope\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use gimli::read::reader::ReaderOffset;\n    |\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u64` in the current scope\n   --> src/buf/buf_impl.rs:68:25\n    |\n68  |         return Ok($typ::from_be_bytes(buf));\n    |                         ^^^^^^^^^^^^^ function or associated item not found in `u64`\n...\n877 |         buf_get_impl!(be => self, u64, nbytes);\n    |         -------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `get_mut` found for array `[{integer}; 8]` in the current scope\n   --> src/buf/buf_impl.rs:50:34\n    |\n50  |         let subslice = match buf.get_mut(..$len_to_read) {\n    |                                  ^^^^^^^ method not found in `[{integer}; 8]`\n...\n898 |         buf_get_impl!(le => self, u64, nbytes);\n    |         -------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u64` in the current scope\n   --> src/buf/buf_impl.rs:56:25\n    |\n56  |         return Ok($typ::from_le_bytes(buf));\n    |                         ^^^^^^^^^^^^^ function or associated item not found in `u64`\n...\n898 |         buf_get_impl!(le => self, u64, nbytes);\n    |         -------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `buf_try_get_impl` which comes from the expansion of the macro `buf_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f32` in the current scope\n    --> src/buf/buf_impl.rs:1017:14\n     |\n1017 |         f32::from_bits(self.get_u32())\n     |              ^^^^^^^^^ function or associated item not found in `f32`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n1017 |         f32::from_str(self.get_u32())\n     |              ~~~~~~~~\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f32` in the current scope\n    --> src/buf/buf_impl.rs:1038:14\n     |\n1038 |         f32::from_bits(self.get_u32_le())\n     |              ^^^^^^^^^ function or associated item not found in `f32`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n1038 |         f32::from_str(self.get_u32_le())\n     |              ~~~~~~~~\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f32` in the current scope\n    --> src/buf/buf_impl.rs:1062:14\n     |\n1062 |         f32::from_bits(self.get_u32_ne())\n     |              ^^^^^^^^^ function or associated item not found in `f32`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n1062 |         f32::from_str(self.get_u32_ne())\n     |              ~~~~~~~~\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f64` in the current scope\n    --> src/buf/buf_impl.rs:1083:14\n     |\n1083 |         f64::from_bits(self.get_u64())\n     |              ^^^^^^^^^ function or associated item not found in `f64`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n1083 |         f64::from_str(self.get_u64())\n     |              ~~~~~~~~\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f64` in the current scope\n    --> src/buf/buf_impl.rs:1104:14\n     |\n1104 |         f64::from_bits(self.get_u64_le())\n     |              ^^^^^^^^^ function or associated item not found in `f64`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n1104 |         f64::from_str(self.get_u64_le())\n     |              ~~~~~~~~\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f64` in the current scope\n    --> src/buf/buf_impl.rs:1128:14\n     |\n1128 |         f64::from_bits(self.get_u64_ne())\n     |              ^^^^^^^^^ function or associated item not found in `f64`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n1128 |         f64::from_str(self.get_u64_ne())\n     |              ~~~~~~~~\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:1162:35\n     |\n1162 |         if self.remaining() < dst.len() {\n     |                                   ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:1164:32\n     |\n1164 |                 requested: dst.len(),\n     |                                ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:1169:20\n     |\n1169 |         while !dst.is_empty() {\n     |                    ^^^^^^^^ method cannot be called on `&mut [u8]` due to unsatisfied trait bounds\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:1171:38\n     |\n1171 |             let cnt = usize::min(src.len(), dst.len());\n     |                                      ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:1171:49\n     |\n1171 |             let cnt = usize::min(src.len(), dst.len());\n     |                                                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `copy_from_slice` found for slice `[u8]` in the current scope\n    --> src/buf/buf_impl.rs:1173:24\n     |\n1173 |             dst[..cnt].copy_from_slice(&src[..cnt]);\n     |                        ^^^^^^^^^^^^^^^ method not found in `[u8]`\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1276 |           buf_try_get_impl!(self, u16::from_be_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u16` in the current scope\n    --> src/buf/buf_impl.rs:1276:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1275 | |     fn try_get_u16(&mut self) -> Result<u16, TryGetError> {\n1276 | |         buf_try_get_impl!(self, u16::from_be_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `u16`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1304 |           buf_try_get_impl!(self, u16::from_le_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u16` in the current scope\n    --> src/buf/buf_impl.rs:1304:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1303 | |     fn try_get_u16_le(&mut self) -> Result<u16, TryGetError> {\n1304 | |         buf_try_get_impl!(self, u16::from_le_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `u16`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1335 |           buf_try_get_impl!(self, u16::from_ne_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u16` in the current scope\n    --> src/buf/buf_impl.rs:1335:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1334 | |     fn try_get_u16_ne(&mut self) -> Result<u16, TryGetError> {\n1335 | |         buf_try_get_impl!(self, u16::from_ne_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `u16`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1363 |           buf_try_get_impl!(self, i16::from_be_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i16` in the current scope\n    --> src/buf/buf_impl.rs:1363:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1362 | |     fn try_get_i16(&mut self) -> Result<i16, TryGetError> {\n1363 | |         buf_try_get_impl!(self, i16::from_be_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `i16`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1391 |           buf_try_get_impl!(self, i16::from_le_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i16` in the current scope\n    --> src/buf/buf_impl.rs:1391:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1390 | |     fn try_get_i16_le(&mut self) -> Result<i16, TryGetError> {\n1391 | |         buf_try_get_impl!(self, i16::from_le_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `i16`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1422 |           buf_try_get_impl!(self, i16::from_ne_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i16` in the current scope\n    --> src/buf/buf_impl.rs:1422:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1421 | |     fn try_get_i16_ne(&mut self) -> Result<i16, TryGetError> {\n1422 | |         buf_try_get_impl!(self, i16::from_ne_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `i16`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1450 |           buf_try_get_impl!(self, u32::from_be_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u32` in the current scope\n    --> src/buf/buf_impl.rs:1450:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1449 | |     fn try_get_u32(&mut self) -> Result<u32, TryGetError> {\n1450 | |         buf_try_get_impl!(self, u32::from_be_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `u32`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1478 |           buf_try_get_impl!(self, u32::from_le_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u32` in the current scope\n    --> src/buf/buf_impl.rs:1478:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1477 | |     fn try_get_u32_le(&mut self) -> Result<u32, TryGetError> {\n1478 | |         buf_try_get_impl!(self, u32::from_le_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `u32`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1509 |           buf_try_get_impl!(self, u32::from_ne_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u32` in the current scope\n    --> src/buf/buf_impl.rs:1509:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1508 | |     fn try_get_u32_ne(&mut self) -> Result<u32, TryGetError> {\n1509 | |         buf_try_get_impl!(self, u32::from_ne_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `u32`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1537 |           buf_try_get_impl!(self, i32::from_be_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i32` in the current scope\n    --> src/buf/buf_impl.rs:1537:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1536 | |     fn try_get_i32(&mut self) -> Result<i32, TryGetError> {\n1537 | |         buf_try_get_impl!(self, i32::from_be_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `i32`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1565 |           buf_try_get_impl!(self, i32::from_le_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i32` in the current scope\n    --> src/buf/buf_impl.rs:1565:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1564 | |     fn try_get_i32_le(&mut self) -> Result<i32, TryGetError> {\n1565 | |         buf_try_get_impl!(self, i32::from_le_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `i32`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1596 |           buf_try_get_impl!(self, i32::from_ne_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i32` in the current scope\n    --> src/buf/buf_impl.rs:1596:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1595 | |     fn try_get_i32_ne(&mut self) -> Result<i32, TryGetError> {\n1596 | |         buf_try_get_impl!(self, i32::from_ne_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `i32`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1624 |           buf_try_get_impl!(self, u64::from_be_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u64` in the current scope\n    --> src/buf/buf_impl.rs:1624:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1623 | |     fn try_get_u64(&mut self) -> Result<u64, TryGetError> {\n1624 | |         buf_try_get_impl!(self, u64::from_be_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `u64`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1652 |           buf_try_get_impl!(self, u64::from_le_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u64` in the current scope\n    --> src/buf/buf_impl.rs:1652:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1651 | |     fn try_get_u64_le(&mut self) -> Result<u64, TryGetError> {\n1652 | |         buf_try_get_impl!(self, u64::from_le_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `u64`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1683 |           buf_try_get_impl!(self, u64::from_ne_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u64` in the current scope\n    --> src/buf/buf_impl.rs:1683:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1682 | |     fn try_get_u64_ne(&mut self) -> Result<u64, TryGetError> {\n1683 | |         buf_try_get_impl!(self, u64::from_ne_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `u64`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1711 |           buf_try_get_impl!(self, i64::from_be_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i64` in the current scope\n    --> src/buf/buf_impl.rs:1711:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1710 | |     fn try_get_i64(&mut self) -> Result<i64, TryGetError> {\n1711 | |         buf_try_get_impl!(self, i64::from_be_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `i64`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1739 |           buf_try_get_impl!(self, i64::from_le_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i64` in the current scope\n    --> src/buf/buf_impl.rs:1739:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1738 | |     fn try_get_i64_le(&mut self) -> Result<i64, TryGetError> {\n1739 | |         buf_try_get_impl!(self, i64::from_le_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `i64`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1770 |           buf_try_get_impl!(self, i64::from_ne_bytes)\n     |           ------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i64` in the current scope\n    --> src/buf/buf_impl.rs:1770:38\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1769 | |     fn try_get_i64_ne(&mut self) -> Result<i64, TryGetError> {\n1770 | |         buf_try_get_impl!(self, i64::from_ne_bytes)\n     | |                                     -^^^^^^^^^^^^^ function or associated item not found in `i64`\n     | |_____________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1798 |           buf_try_get_impl!(self, u128::from_be_bytes)\n     |           -------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u128` in the current scope\n    --> src/buf/buf_impl.rs:1798:39\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1797 | |     fn try_get_u128(&mut self) -> Result<u128, TryGetError> {\n1798 | |         buf_try_get_impl!(self, u128::from_be_bytes)\n     | |                                      -^^^^^^^^^^^^^ function or associated item not found in `u128`\n     | |______________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1826 |           buf_try_get_impl!(self, u128::from_le_bytes)\n     |           -------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u128` in the current scope\n    --> src/buf/buf_impl.rs:1826:39\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1825 | |     fn try_get_u128_le(&mut self) -> Result<u128, TryGetError> {\n1826 | |         buf_try_get_impl!(self, u128::from_le_bytes)\n     | |                                      -^^^^^^^^^^^^^ function or associated item not found in `u128`\n     | |______________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1857 |           buf_try_get_impl!(self, u128::from_ne_bytes)\n     |           -------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `u128` in the current scope\n    --> src/buf/buf_impl.rs:1857:39\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1856 | |     fn try_get_u128_ne(&mut self) -> Result<u128, TryGetError> {\n1857 | |         buf_try_get_impl!(self, u128::from_ne_bytes)\n     | |                                      -^^^^^^^^^^^^^ function or associated item not found in `u128`\n     | |______________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1885 |           buf_try_get_impl!(self, i128::from_be_bytes)\n     |           -------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i128` in the current scope\n    --> src/buf/buf_impl.rs:1885:39\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1884 | |     fn try_get_i128(&mut self) -> Result<i128, TryGetError> {\n1885 | |         buf_try_get_impl!(self, i128::from_be_bytes)\n     | |                                      -^^^^^^^^^^^^^ function or associated item not found in `i128`\n     | |______________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1913 |           buf_try_get_impl!(self, i128::from_le_bytes)\n     |           -------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i128` in the current scope\n    --> src/buf/buf_impl.rs:1913:39\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1912 | |     fn try_get_i128_le(&mut self) -> Result<i128, TryGetError> {\n1913 | |         buf_try_get_impl!(self, i128::from_le_bytes)\n     | |                                      -^^^^^^^^^^^^^ function or associated item not found in `i128`\n     | |______________________________________|\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:29:14\n     |\n27   |           let ret = $this\n     |  ___________________-\n28   | |             .chunk()\n29   | |             .get(..SIZE)\n     | |_____________-^^^\n...\n1944 |           buf_try_get_impl!(self, i128::from_ne_bytes)\n     |           -------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: there is a method `ge` with a similar name\n     |\n29   |             .ge(..SIZE)\n     |              ~~\n\nerror[E0599]: no function or associated item named `from_ne_bytes` found for type `i128` in the current scope\n    --> src/buf/buf_impl.rs:1944:39\n     |\n30   |               .map(|src| unsafe { $typ::$conv(*(src as *const _ as *const [_; SIZE])) });\n     |  _________________________________-\n31   | |\n32   | |         if let Some(ret) = ret {\n33   | |             // if the direct conversion was possible, advance and return\n...    |\n1943 | |     fn try_get_i128_ne(&mut self) -> Result<i128, TryGetError> {\n1944 | |         buf_try_get_impl!(self, i128::from_ne_bytes)\n     | |                                      -^^^^^^^^^^^^^ function or associated item not found in `i128`\n     | |______________________________________|\n     |\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n    --> src/buf/buf_impl.rs:61:35\n     |\n61   |         let slice_at = match SIZE.checked_sub($len_to_read) {\n     |                                   ^^^^^^^^^^^ method not found in `usize`\n...\n1976 |         buf_try_get_impl!(be => self, u64, nbytes);\n     |         ------------------------------------------ in this macro invocation\n    --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n     |\n     = note: the method is available for `usize` here\n     |\n     = help: items from traits can only be used if the trait is in scope\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use gimli::read::reader::ReaderOffset;\n     |\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `u64` in the current scope\n    --> src/buf/buf_impl.rs:68:25\n     |\n68   |         return Ok($typ::from_be_bytes(buf));\n     |                         ^^^^^^^^^^^^^ function or associated item not found in `u64`\n...\n1976 |         buf_try_get_impl!(be => self, u64, nbytes);\n     |         ------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `get_mut` found for array `[{integer}; 8]` in the current scope\n    --> src/buf/buf_impl.rs:50:34\n     |\n50   |         let subslice = match buf.get_mut(..$len_to_read) {\n     |                                  ^^^^^^^ method not found in `[{integer}; 8]`\n...\n2008 |         buf_try_get_impl!(le => self, u64, nbytes);\n     |         ------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `u64` in the current scope\n    --> src/buf/buf_impl.rs:56:25\n     |\n56   |         return Ok($typ::from_le_bytes(buf));\n     |                         ^^^^^^^^^^^^^ function or associated item not found in `u64`\n...\n2008 |         buf_try_get_impl!(le => self, u64, nbytes);\n     |         ------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n    --> src/buf/buf_impl.rs:61:35\n     |\n61   |         let slice_at = match SIZE.checked_sub($len_to_read) {\n     |                                   ^^^^^^^^^^^ method not found in `usize`\n...\n2082 |         buf_try_get_impl!(be => self, i64, nbytes);\n     |         ------------------------------------------ in this macro invocation\n    --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n     |\n     = note: the method is available for `usize` here\n     |\n     = help: items from traits can only be used if the trait is in scope\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use gimli::read::reader::ReaderOffset;\n     |\n\nerror[E0599]: no function or associated item named `from_be_bytes` found for type `i64` in the current scope\n    --> src/buf/buf_impl.rs:68:25\n     |\n68   |         return Ok($typ::from_be_bytes(buf));\n     |                         ^^^^^^^^^^^^^ function or associated item not found in `i64`\n...\n2082 |         buf_try_get_impl!(be => self, i64, nbytes);\n     |         ------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `get_mut` found for array `[{integer}; 8]` in the current scope\n    --> src/buf/buf_impl.rs:50:34\n     |\n50   |         let subslice = match buf.get_mut(..$len_to_read) {\n     |                                  ^^^^^^^ method not found in `[{integer}; 8]`\n...\n2114 |         buf_try_get_impl!(le => self, i64, nbytes);\n     |         ------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `from_le_bytes` found for type `i64` in the current scope\n    --> src/buf/buf_impl.rs:56:25\n     |\n56   |         return Ok($typ::from_le_bytes(buf));\n     |                         ^^^^^^^^^^^^^ function or associated item not found in `i64`\n...\n2114 |         buf_try_get_impl!(le => self, i64, nbytes);\n     |         ------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `buf_try_get_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f32` in the current scope\n    --> src/buf/buf_impl.rs:2185:17\n     |\n2185 |         Ok(f32::from_bits(self.try_get_u32()?))\n     |                 ^^^^^^^^^ function or associated item not found in `f32`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n2185 |         Ok(f32::from_str(self.try_get_u32()?))\n     |                 ~~~~~~~~\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f32` in the current scope\n    --> src/buf/buf_impl.rs:2214:17\n     |\n2214 |         Ok(f32::from_bits(self.try_get_u32_le()?))\n     |                 ^^^^^^^^^ function or associated item not found in `f32`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n2214 |         Ok(f32::from_str(self.try_get_u32_le()?))\n     |                 ~~~~~~~~\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f32` in the current scope\n    --> src/buf/buf_impl.rs:2246:17\n     |\n2246 |         Ok(f32::from_bits(self.try_get_u32_ne()?))\n     |                 ^^^^^^^^^ function or associated item not found in `f32`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n2246 |         Ok(f32::from_str(self.try_get_u32_ne()?))\n     |                 ~~~~~~~~\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f64` in the current scope\n    --> src/buf/buf_impl.rs:2275:17\n     |\n2275 |         Ok(f64::from_bits(self.try_get_u64()?))\n     |                 ^^^^^^^^^ function or associated item not found in `f64`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n2275 |         Ok(f64::from_str(self.try_get_u64()?))\n     |                 ~~~~~~~~\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f64` in the current scope\n    --> src/buf/buf_impl.rs:2304:17\n     |\n2304 |         Ok(f64::from_bits(self.try_get_u64_le()?))\n     |                 ^^^^^^^^^ function or associated item not found in `f64`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n2304 |         Ok(f64::from_str(self.try_get_u64_le()?))\n     |                 ~~~~~~~~\n\nerror[E0599]: no function or associated item named `from_bits` found for type `f64` in the current scope\n    --> src/buf/buf_impl.rs:2336:17\n     |\n2336 |         Ok(f64::from_bits(self.try_get_u64_ne()?))\n     |                 ^^^^^^^^^ function or associated item not found in `f64`\n     |\nhelp: there is an associated function `from_str` with a similar name\n     |\n2336 |         Ok(f64::from_str(self.try_get_u64_ne()?))\n     |                 ~~~~~~~~\n\nerror[E0599]: no function or associated item named `with_capacity` found for struct `BytesMut` in the current scope\n    --> src/buf/buf_impl.rs:2368:40\n     |\n2368 |         let mut ret = crate::BytesMut::with_capacity(len);\n     |                                        ^^^^^^^^^^^^^ function or associated item not found in `BytesMut`\n     |\n    ::: src/bytes_mut.rs:61:1\n     |\n61   | pub struct BytesMut {\n     | ------------------- function or associated item `with_capacity` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `chain::Chain` in the current scope\n    --> src/buf/buf_impl.rs:2420:16\n     |\n2420 |         Chain::new(self, next)\n     |                ^^^ function or associated item not found in `Chain<_, _>`\n     |\n    ::: src/buf/chain.rs:30:1\n     |\n30   | pub struct Chain<T, U> {\n     | ---------------------- function or associated item `new` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:2892:14\n     |\n2892 |         self.len()\n     |              ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &[u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:2902:17\n     |\n2902 |         if self.len() < cnt {\n     |                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `&[u8]: ExactSizeIterator`\n             which is required by `&mut &[u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &[u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:2905:33\n     |\n2905 |                 available: self.len(),\n     |                                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `&[u8]: ExactSizeIterator`\n             which is required by `&mut &[u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &[u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:2914:17\n     |\n2914 |         if self.len() < dst.len() {\n     |                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `&[u8]: ExactSizeIterator`\n             which is required by `&mut &[u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:2914:29\n     |\n2914 |         if self.len() < dst.len() {\n     |                             ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:2916:32\n     |\n2916 |                 requested: dst.len(),\n     |                                ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &[u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:2917:33\n     |\n2917 |                 available: self.len(),\n     |                                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `&[u8]: ExactSizeIterator`\n             which is required by `&mut &[u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `copy_from_slice` found for mutable reference `&mut [u8]` in the current scope\n    --> src/buf/buf_impl.rs:2921:13\n     |\n2921 |         dst.copy_from_slice(&self[..dst.len()]);\n     |             ^^^^^^^^^^^^^^^\n     |\nhelp: there is a method `put_slice` with a similar name\n     |\n2921 |         dst.put_slice(&self[..dst.len()]);\n     |             ~~~~~~~~~\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:2921:41\n     |\n2921 |         dst.copy_from_slice(&self[..dst.len()]);\n     |                                         ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_impl.rs:2922:26\n     |\n2922 |         self.advance(dst.len());\n     |                          ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:2930:58\n     |\n2930 |         saturating_sub_usize_u64(self.get_ref().as_ref().len(), self.position())\n     |                                                          ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:2936:56\n     |\n2936 |         let pos = min_u64_usize(self.position(), slice.len());\n     |                                                        ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_impl.rs:2942:43\n     |\n2942 |         let len = self.get_ref().as_ref().len();\n     |                                           ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:216:36\n     |\n216  |             let cnt = usize::min(s.len(), d.len());\n     |                                    ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut UninitSlice`, but its trait bounds were not satisfied\n   --> src/buf/buf_mut.rs:216:45\n    |\n216 |             let cnt = usize::min(s.len(), d.len());\n    |                                             ^^^ method cannot be called on `&mut UninitSlice` due to unsatisfied trait bounds\n    |\n   ::: src/buf/uninit_slice.rs:22:1\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- doesn't satisfy `UninitSlice: ExactSizeIterator`\n    |\n    = note: the following trait bounds were not satisfied:\n            `UninitSlice: ExactSizeIterator`\n            which is required by `&mut UninitSlice: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `len`, perhaps you need to implement it:\n            candidate #1: `ExactSizeIterator`\n\nerror[E0599]: no method named `copy_from_slice` found for struct `UninitSlice` in the current scope\n   --> src/buf/buf_mut.rs:218:22\n    |\n218 |             d[..cnt].copy_from_slice(&s[..cnt]);\n    |                      ^^^^^^^^^^^^^^^ method not found in `UninitSlice`\n    |\n   ::: src/buf/uninit_slice.rs:22:1\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- method `copy_from_slice` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:247:39\n     |\n247  |         if self.remaining_mut() < src.len() {\n     |                                       ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:249:32\n     |\n249  |                 requested: src.len(),\n     |                                ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n   --> src/buf/buf_mut.rs:254:20\n    |\n254 |         while !src.is_empty() {\n    |                    ^^^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:256:38\n     |\n256  |             let cnt = usize::min(src.len(), dst.len());\n     |                                      ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut UninitSlice`, but its trait bounds were not satisfied\n   --> src/buf/buf_mut.rs:256:49\n    |\n256 |             let cnt = usize::min(src.len(), dst.len());\n    |                                                 ^^^ method cannot be called on `&mut UninitSlice` due to unsatisfied trait bounds\n    |\n   ::: src/buf/uninit_slice.rs:22:1\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- doesn't satisfy `UninitSlice: ExactSizeIterator`\n    |\n    = note: the following trait bounds were not satisfied:\n            `UninitSlice: ExactSizeIterator`\n            which is required by `&mut UninitSlice: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `len`, perhaps you need to implement it:\n            candidate #1: `ExactSizeIterator`\n\nerror[E0599]: no method named `copy_from_slice` found for struct `UninitSlice` in the current scope\n   --> src/buf/buf_mut.rs:258:24\n    |\n258 |             dst[..cnt].copy_from_slice(&src[..cnt]);\n    |                        ^^^^^^^^^^^^^^^ method not found in `UninitSlice`\n    |\n   ::: src/buf/uninit_slice.rs:22:1\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- method `copy_from_slice` not found for this struct\n\nerror[E0599]: the method `len` exists for mutable reference `&mut UninitSlice`, but its trait bounds were not satisfied\n   --> src/buf/buf_mut.rs:302:42\n    |\n302 |             let dst_len = usize::min(dst.len(), cnt);\n    |                                          ^^^ method cannot be called on `&mut UninitSlice` due to unsatisfied trait bounds\n    |\n   ::: src/buf/uninit_slice.rs:22:1\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- doesn't satisfy `UninitSlice: ExactSizeIterator`\n    |\n    = note: the following trait bounds were not satisfied:\n            `UninitSlice: ExactSizeIterator`\n            which is required by `&mut UninitSlice: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `len`, perhaps you need to implement it:\n            candidate #1: `ExactSizeIterator`\n\nerror[E0599]: no method named `as_mut_ptr` found for mutable reference `&mut UninitSlice` in the current scope\n   --> src/buf/buf_mut.rs:304:49\n    |\n304 |             unsafe { core::ptr::write_bytes(dst.as_mut_ptr(), val, dst_len) };\n    |                                                 ^^^^^^^^^^ method not found in `&mut UninitSlice`\n\nerror[E0599]: no method named `to_be_bytes` found for type `u16` in the current scope\n   --> src/buf/buf_mut.rs:379:27\n    |\n379 |         self.put_slice(&n.to_be_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u16`\n\nerror[E0599]: no method named `to_le_bytes` found for type `u16` in the current scope\n   --> src/buf/buf_mut.rs:402:27\n    |\n402 |         self.put_slice(&n.to_le_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u16`\n\nerror[E0599]: no method named `to_ne_bytes` found for type `u16` in the current scope\n   --> src/buf/buf_mut.rs:429:27\n    |\n429 |         self.put_slice(&n.to_ne_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u16`\n\nerror[E0599]: no method named `to_be_bytes` found for type `i16` in the current scope\n   --> src/buf/buf_mut.rs:452:27\n    |\n452 |         self.put_slice(&n.to_be_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i16`\n\nerror[E0599]: no method named `to_le_bytes` found for type `i16` in the current scope\n   --> src/buf/buf_mut.rs:475:27\n    |\n475 |         self.put_slice(&n.to_le_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i16`\n\nerror[E0599]: no method named `to_ne_bytes` found for type `i16` in the current scope\n   --> src/buf/buf_mut.rs:502:27\n    |\n502 |         self.put_slice(&n.to_ne_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i16`\n\nerror[E0599]: no method named `to_be_bytes` found for type `u32` in the current scope\n   --> src/buf/buf_mut.rs:525:27\n    |\n525 |         self.put_slice(&n.to_be_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u32`\n\nerror[E0599]: no method named `to_le_bytes` found for type `u32` in the current scope\n   --> src/buf/buf_mut.rs:548:27\n    |\n548 |         self.put_slice(&n.to_le_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u32`\n\nerror[E0599]: no method named `to_ne_bytes` found for type `u32` in the current scope\n   --> src/buf/buf_mut.rs:575:27\n    |\n575 |         self.put_slice(&n.to_ne_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u32`\n\nerror[E0599]: no method named `to_be_bytes` found for type `i32` in the current scope\n   --> src/buf/buf_mut.rs:598:27\n    |\n598 |         self.put_slice(&n.to_be_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_le_bytes` found for type `i32` in the current scope\n   --> src/buf/buf_mut.rs:621:27\n    |\n621 |         self.put_slice(&n.to_le_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_ne_bytes` found for type `i32` in the current scope\n   --> src/buf/buf_mut.rs:648:27\n    |\n648 |         self.put_slice(&n.to_ne_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_be_bytes` found for type `u64` in the current scope\n   --> src/buf/buf_mut.rs:671:27\n    |\n671 |         self.put_slice(&n.to_be_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `to_le_bytes` found for type `u64` in the current scope\n   --> src/buf/buf_mut.rs:694:27\n    |\n694 |         self.put_slice(&n.to_le_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `to_ne_bytes` found for type `u64` in the current scope\n   --> src/buf/buf_mut.rs:721:27\n    |\n721 |         self.put_slice(&n.to_ne_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `to_be_bytes` found for type `i64` in the current scope\n   --> src/buf/buf_mut.rs:744:27\n    |\n744 |         self.put_slice(&n.to_be_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i64`\n\nerror[E0599]: no method named `to_le_bytes` found for type `i64` in the current scope\n   --> src/buf/buf_mut.rs:767:27\n    |\n767 |         self.put_slice(&n.to_le_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i64`\n\nerror[E0599]: no method named `to_ne_bytes` found for type `i64` in the current scope\n   --> src/buf/buf_mut.rs:794:27\n    |\n794 |         self.put_slice(&n.to_ne_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i64`\n\nerror[E0599]: no method named `to_be_bytes` found for type `u128` in the current scope\n   --> src/buf/buf_mut.rs:817:27\n    |\n817 |         self.put_slice(&n.to_be_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u128`\n\nerror[E0599]: no method named `to_le_bytes` found for type `u128` in the current scope\n   --> src/buf/buf_mut.rs:840:27\n    |\n840 |         self.put_slice(&n.to_le_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u128`\n\nerror[E0599]: no method named `to_ne_bytes` found for type `u128` in the current scope\n   --> src/buf/buf_mut.rs:867:27\n    |\n867 |         self.put_slice(&n.to_ne_bytes())\n    |                           ^^^^^^^^^^^ method not found in `u128`\n\nerror[E0599]: no method named `to_be_bytes` found for type `i128` in the current scope\n   --> src/buf/buf_mut.rs:890:27\n    |\n890 |         self.put_slice(&n.to_be_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i128`\n\nerror[E0599]: no method named `to_le_bytes` found for type `i128` in the current scope\n   --> src/buf/buf_mut.rs:913:27\n    |\n913 |         self.put_slice(&n.to_le_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i128`\n\nerror[E0599]: no method named `to_ne_bytes` found for type `i128` in the current scope\n   --> src/buf/buf_mut.rs:940:27\n    |\n940 |         self.put_slice(&n.to_ne_bytes())\n    |                           ^^^^^^^^^^^ method not found in `i128`\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n   --> src/buf/buf_mut.rs:963:48\n    |\n963 |         let start = match mem::size_of_val(&n).checked_sub(nbytes) {\n    |                                                ^^^^^^^^^^^ method not found in `usize`\n   --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n    |\n    = note: the method is available for `usize` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use gimli::read::reader::ReaderOffset;\n    |\n\nerror[E0599]: no method named `to_be_bytes` found for type `u64` in the current scope\n   --> src/buf/buf_mut.rs:968:27\n    |\n968 |         self.put_slice(&n.to_be_bytes()[start..]);\n    |                           ^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `to_le_bytes` found for type `u64` in the current scope\n   --> src/buf/buf_mut.rs:991:23\n    |\n991 |         let slice = n.to_le_bytes();\n    |                       ^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n    --> src/buf/buf_mut.rs:1051:48\n     |\n1051 |         let start = match mem::size_of_val(&n).checked_sub(nbytes) {\n     |                                                ^^^^^^^^^^^ method not found in `usize`\n    --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n     |\n     = note: the method is available for `usize` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use gimli::read::reader::ReaderOffset;\n     |\n\nerror[E0599]: no method named `to_be_bytes` found for type `i64` in the current scope\n    --> src/buf/buf_mut.rs:1056:27\n     |\n1056 |         self.put_slice(&n.to_be_bytes()[start..]);\n     |                           ^^^^^^^^^^^ method not found in `i64`\n\nerror[E0599]: no method named `to_le_bytes` found for type `i64` in the current scope\n    --> src/buf/buf_mut.rs:1079:23\n     |\n1079 |         let slice = n.to_le_bytes();\n     |                       ^^^^^^^^^^^ method not found in `i64`\n\nerror[E0599]: no method named `to_bits` found for type `f32` in the current scope\n    --> src/buf/buf_mut.rs:1140:24\n     |\n1140 |         self.put_u32(n.to_bits());\n     |                        ^^^^^^^ method not found in `f32`\n\nerror[E0599]: no method named `to_bits` found for type `f32` in the current scope\n    --> src/buf/buf_mut.rs:1164:27\n     |\n1164 |         self.put_u32_le(n.to_bits());\n     |                           ^^^^^^^ method not found in `f32`\n\nerror[E0599]: no method named `to_bits` found for type `f32` in the current scope\n    --> src/buf/buf_mut.rs:1192:27\n     |\n1192 |         self.put_u32_ne(n.to_bits());\n     |                           ^^^^^^^ method not found in `f32`\n\nerror[E0599]: no method named `to_bits` found for type `f64` in the current scope\n    --> src/buf/buf_mut.rs:1216:24\n     |\n1216 |         self.put_u64(n.to_bits());\n     |                        ^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `to_bits` found for type `f64` in the current scope\n    --> src/buf/buf_mut.rs:1240:27\n     |\n1240 |         self.put_u64_le(n.to_bits());\n     |                           ^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `to_bits` found for type `f64` in the current scope\n    --> src/buf/buf_mut.rs:1268:27\n     |\n1268 |         self.put_u64_ne(n.to_bits());\n     |                           ^^^^^^^ method not found in `f64`\n\nerror[E0599]: no function or associated item named `new` found for struct `chain::Chain` in the current scope\n    --> src/buf/buf_mut.rs:1349:16\n     |\n1349 |         Chain::new(self, next)\n     |                ^^^ function or associated item not found in `Chain<_, _>`\n     |\n    ::: src/buf/chain.rs:30:1\n     |\n30   | pub struct Chain<T, U> {\n     | ---------------------- function or associated item `new` not found for this struct\n\nerror[E0599]: the method `len` exists for reference `&&mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1488:14\n     |\n1488 |         self.len()\n     |              ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `new` found for struct `UninitSlice` in the current scope\n    --> src/buf/buf_mut.rs:1493:22\n     |\n1493 |         UninitSlice::new(self)\n     |                      ^^^ function or associated item not found in `UninitSlice`\n     |\n    ::: src/buf/uninit_slice.rs:22:1\n     |\n22   | pub struct UninitSlice([MaybeUninit<u8>]);\n     | ---------------------- function or associated item `new` not found for this struct\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1498:17\n     |\n1498 |         if self.len() < cnt {\n     |                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [u8]: ExactSizeIterator`\n             which is required by `&mut &mut [u8]: ExactSizeIterator`\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1501:33\n     |\n1501 |                 available: self.len(),\n     |                                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [u8]: ExactSizeIterator`\n             which is required by `&mut &mut [u8]: ExactSizeIterator`\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `split_at_mut` found for mutable reference `&mut [u8]` in the current scope\n    --> src/buf/buf_mut.rs:1506:56\n     |\n1506 |         let (_, b) = core::mem::replace(self, &mut []).split_at_mut(cnt);\n     |                                                        ^^^^^^^^^^^^\n     |\nhelp: there is a method `as_mut` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:372:5\n     |\n372  |     fn as_mut(&mut self) -> &mut T;\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1512:17\n     |\n1512 |         if self.len() < src.len() {\n     |                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [u8]: ExactSizeIterator`\n             which is required by `&mut &mut [u8]: ExactSizeIterator`\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:1512:29\n     |\n1512 |         if self.len() < src.len() {\n     |                             ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:1514:32\n     |\n1514 |                 requested: src.len(),\n     |                                ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1515:33\n     |\n1515 |                 available: self.len(),\n     |                                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [u8]: ExactSizeIterator`\n             which is required by `&mut &mut [u8]: ExactSizeIterator`\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:1519:20\n     |\n1519 |         self[..src.len()].copy_from_slice(src);\n     |                    ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:1521:39\n     |\n1521 |         unsafe { self.advance_mut(src.len()) };\n     |                                       ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1526:17\n     |\n1526 |         if self.len() < cnt {\n     |                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [u8]: ExactSizeIterator`\n             which is required by `&mut &mut [u8]: ExactSizeIterator`\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [u8]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1529:33\n     |\n1529 |                 available: self.len(),\n     |                                 ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [u8]: ExactSizeIterator`\n             which is required by `&mut &mut [u8]: ExactSizeIterator`\n             `[u8]: ExactSizeIterator`\n             which is required by `&mut [u8]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `as_mut_ptr` found for mutable reference `&mut &mut [u8]` in the current scope\n    --> src/buf/buf_mut.rs:1535:35\n     |\n1535 |             ptr::write_bytes(self.as_mut_ptr(), val, cnt);\n     |                                   ^^^^^^^^^^\n     |\nhelp: there is a method `as_mut` with a similar name\n     |\n1535 |             ptr::write_bytes(self.as_mut(), val, cnt);\n     |                                   ~~~~~~\n\nerror[E0599]: the method `len` exists for reference `&&mut [MaybeUninit<u8>]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1544:14\n     |\n1544 |         self.len()\n     |              ^^^ method cannot be called on `&&mut [MaybeUninit<u8>]` due to unsatisfied trait bounds\n     |\n     = note: the following trait bounds were not satisfied:\n             `[MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n\nerror[E0599]: no function or associated item named `uninit` found for struct `UninitSlice` in the current scope\n    --> src/buf/buf_mut.rs:1549:22\n     |\n1549 |         UninitSlice::uninit(self)\n     |                      ^^^^^^ function or associated item not found in `UninitSlice`\n     |\n    ::: src/buf/uninit_slice.rs:22:1\n     |\n22   | pub struct UninitSlice([MaybeUninit<u8>]);\n     | ---------------------- function or associated item `uninit` not found for this struct\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [MaybeUninit<u8>]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1554:17\n     |\n1554 |         if self.len() < cnt {\n     |                 ^^^ method cannot be called on `&mut &mut [MaybeUninit<u8>]` due to unsatisfied trait bounds\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut &mut [MaybeUninit<u8>]: ExactSizeIterator`\n             `[MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [MaybeUninit<u8>]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1557:33\n     |\n1557 |                 available: self.len(),\n     |                                 ^^^ method cannot be called on `&mut &mut [MaybeUninit<u8>]` due to unsatisfied trait bounds\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut &mut [MaybeUninit<u8>]: ExactSizeIterator`\n             `[MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n\nerror[E0599]: no method named `split_at_mut` found for mutable reference `&mut [MaybeUninit<u8>]` in the current scope\n    --> src/buf/buf_mut.rs:1562:56\n     |\n1562 |         let (_, b) = core::mem::replace(self, &mut []).split_at_mut(cnt);\n     |                                                        ^^^^^^^^^^^^\n     |\nhelp: there is a method `as_mut` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:372:5\n     |\n372  |     fn as_mut(&mut self) -> &mut T;\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [MaybeUninit<u8>]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1568:17\n     |\n1568 |         if self.len() < src.len() {\n     |                 ^^^ method cannot be called on `&mut &mut [MaybeUninit<u8>]` due to unsatisfied trait bounds\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut &mut [MaybeUninit<u8>]: ExactSizeIterator`\n             `[MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:1568:29\n     |\n1568 |         if self.len() < src.len() {\n     |                             ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:1570:32\n     |\n1570 |                 requested: src.len(),\n     |                                ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [MaybeUninit<u8>]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1571:33\n     |\n1571 |                 available: self.len(),\n     |                                 ^^^ method cannot be called on `&mut &mut [MaybeUninit<u8>]` due to unsatisfied trait bounds\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut &mut [MaybeUninit<u8>]: ExactSizeIterator`\n             `[MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n\nerror[E0599]: no method named `as_ptr` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:1577:42\n     |\n1577 |             ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr().cast(), src.len());\n     |                                          ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `as_mut_ptr` found for mutable reference `&mut &mut [MaybeUninit<u8>]` in the current scope\n    --> src/buf/buf_mut.rs:1577:57\n     |\n1577 |             ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr().cast(), src.len());\n     |                                                         ^^^^^^^^^^\n     |\nhelp: there is a method `as_mut` with a similar name\n     |\n1577 |             ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut().cast(), src.len());\n     |                                                         ~~~~~~\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:1577:82\n     |\n1577 |             ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr().cast(), src.len());\n     |                                                                                  ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:1578:34\n     |\n1578 |             self.advance_mut(src.len());\n     |                                  ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [MaybeUninit<u8>]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1584:17\n     |\n1584 |         if self.len() < cnt {\n     |                 ^^^ method cannot be called on `&mut &mut [MaybeUninit<u8>]` due to unsatisfied trait bounds\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut &mut [MaybeUninit<u8>]: ExactSizeIterator`\n             `[MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut &mut [MaybeUninit<u8>]`, but its trait bounds were not satisfied\n    --> src/buf/buf_mut.rs:1587:33\n     |\n1587 |                 available: self.len(),\n     |                                 ^^^ method cannot be called on `&mut &mut [MaybeUninit<u8>]` due to unsatisfied trait bounds\n     |\n     = note: the following trait bounds were not satisfied:\n             `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut &mut [MaybeUninit<u8>]: ExactSizeIterator`\n             `[MaybeUninit<u8>]: ExactSizeIterator`\n             which is required by `&mut [MaybeUninit<u8>]: ExactSizeIterator`\n\nerror[E0599]: no method named `as_mut_ptr` found for mutable reference `&mut &mut [MaybeUninit<u8>]` in the current scope\n    --> src/buf/buf_mut.rs:1593:35\n     |\n1593 |             ptr::write_bytes(self.as_mut_ptr() as *mut u8, val, cnt);\n     |                                   ^^^^^^^^^^\n     |\nhelp: there is a method `as_mut` with a similar name\n     |\n1593 |             ptr::write_bytes(self.as_mut() as *mut u8, val, cnt);\n     |                                   ~~~~~~\n\nerror[E0599]: no function or associated item named `from_raw_parts_mut` found for struct `UninitSlice` in the current scope\n    --> src/buf/buf_mut.rs:1635:31\n     |\n1635 |         unsafe { UninitSlice::from_raw_parts_mut(ptr.add(len), cap - len) }\n     |                               ^^^^^^^^^^^^^^^^^^ function or associated item not found in `UninitSlice`\n     |\n    ::: src/buf/uninit_slice.rs:22:1\n     |\n22   | pub struct UninitSlice([MaybeUninit<u8>]);\n     | ---------------------- function or associated item `from_raw_parts_mut` not found for this struct\n\nerror[E0599]: no method named `add` found for raw pointer `*mut u8` in the current scope\n    --> src/buf/buf_mut.rs:1635:54\n     |\n1635 |         unsafe { UninitSlice::from_raw_parts_mut(ptr.add(len), cap - len) }\n     |                                                      ^^^ method not found in `*mut u8`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/buf_mut.rs:1650:23\n     |\n1650 |             let l = s.len();\n     |                       ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `saturating_add` found for type `usize` in the current scope\n    --> src/buf/buf_mut.rs:1664:34\n     |\n1664 |         let new_len = self.len().saturating_add(cnt);\n     |                                  ^^^^^^^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named `saturating_add` found for type `usize` in the current scope\n   --> src/buf/chain.rs:136:28\n    |\n136 |         self.a.remaining().saturating_add(self.b.remaining())\n    |                            ^^^^^^^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no function or associated item named `with_capacity` found for struct `BytesMut` in the current scope\n   --> src/buf/chain.rs:183:44\n    |\n183 |             let mut ret = crate::BytesMut::with_capacity(len);\n    |                                            ^^^^^^^^^^^^^ function or associated item not found in `BytesMut`\n    |\n   ::: src/bytes_mut.rs:61:1\n    |\n61  | pub struct BytesMut {\n    | ------------------- function or associated item `with_capacity` not found for this struct\n\nerror[E0599]: no method named `saturating_add` found for type `usize` in the current scope\n   --> src/buf/chain.rs:199:14\n    |\n197 | /         self.a\n198 | |             .remaining_mut()\n199 | |             .saturating_add(self.b.remaining_mut())\n    | |             -^^^^^^^^^^^^^^ method not found in `usize`\n    | |_____________|\n    |\n\nerror[E0599]: no function or associated item named `new` found for struct `buf::iter::IntoIter` in the current scope\n   --> src/buf/chain.rs:238:19\n    |\n238 |         IntoIter::new(self)\n    |                   ^^^ function or associated item not found in `IntoIter<_>`\n    |\n   ::: src/buf/iter.rs:21:1\n    |\n21  | pub struct IntoIter<T> {\n    | ---------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name\n    |\n238 |         IntoIter::ne(self)\n    |                   ~~\n\nerror[E0599]: the method `len` exists for mutable reference `&mut UninitSlice`, but its trait bounds were not satisfied\n  --> src/buf/limit.rs:66:34\n   |\n66 |         let end = cmp::min(bytes.len(), self.limit);\n   |                                  ^^^ method cannot be called on `&mut UninitSlice` due to unsatisfied trait bounds\n   |\n  ::: src/buf/uninit_slice.rs:22:1\n   |\n22 | pub struct UninitSlice([MaybeUninit<u8>]);\n   | ---------------------- doesn't satisfy `UninitSlice: ExactSizeIterator`\n   |\n   = note: the following trait bounds were not satisfied:\n           `UninitSlice: ExactSizeIterator`\n           which is required by `&mut UninitSlice: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n  --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n   |\n86 | pub trait ExactSizeIterator: Iterator {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `len`, perhaps you need to implement it:\n           candidate #1: `ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [u8]`, but its trait bounds were not satisfied\n  --> src/buf/reader.rs:67:54\n   |\n67 |         let len = cmp::min(self.buf.remaining(), dst.len());\n   |                                                      ^^^\n   |\n   = note: the following trait bounds were not satisfied:\n           `[u8]: ExactSizeIterator`\n           which is required by `&mut [u8]: ExactSizeIterator`\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use object::read::read_ref::ReadRef;\n   |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/take.rs:142:33\n     |\n142  |         &bytes[..cmp::min(bytes.len(), self.limit)]\n     |                                 ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [IoSlice<'a>]`, but its trait bounds were not satisfied\n   --> src/buf/take.rs:187:48\n    |\n187 |             .chunks_vectored(&mut slices[..dst.len().min(LEN)]);\n    |                                                ^^^ method cannot be called on `&mut [IoSlice<'a>]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `[IoSlice<'a>]: ExactSizeIterator`\n            which is required by `&mut [IoSlice<'a>]: ExactSizeIterator`\n\nerror[E0599]: no method named `iter_mut` found for slice `[IoSlice<'a>]` in the current scope\n   --> src/buf/take.rs:189:45\n    |\n189 |         for (i, (dst, slice)) in dst[..cnt].iter_mut().zip(slices.iter()).enumerate() {\n    |                                             ^^^^^^^^ method not found in `[IoSlice<'a>]`\n\nerror[E0599]: no method named `iter` found for array `[IoSlice<'a>; 16]` in the current scope\n   --> src/buf/take.rs:189:67\n    |\n189 |         for (i, (dst, slice)) in dst[..cnt].iter_mut().zip(slices.iter()).enumerate() {\n    |                                                                   ^^^^ method not found in `[IoSlice<'a>; 16]`\n\nerror[E0599]: no function or associated item named `uninit` found for struct `UninitSlice` in the current scope\n  --> src/buf/uninit_slice.rs:85:15\n   |\n22 | pub struct UninitSlice([MaybeUninit<u8>]);\n   | ---------------------- function or associated item `uninit` not found for this struct\n...\n85 |         Self::uninit(maybe_init)\n   |               ^^^^^^ function or associated item not found in `UninitSlice`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut UninitSlice`, but its trait bounds were not satisfied\n   --> src/buf/uninit_slice.rs:108:30\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- doesn't satisfy `UninitSlice: ExactSizeIterator`\n...\n108 |         assert!(index < self.len());\n    |                              ^^^ method cannot be called on `&mut UninitSlice` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `UninitSlice: ExactSizeIterator`\n            which is required by `&mut UninitSlice: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `len`, perhaps you need to implement it:\n            candidate #1: `ExactSizeIterator`\n\nerror[E0599]: no method named `as_mut_ptr` found for struct `UninitSlice` in the current scope\n   --> src/buf/uninit_slice.rs:110:32\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- method `as_mut_ptr` not found for this struct\n...\n110 |         unsafe { self[index..].as_mut_ptr().write(byte) }\n    |                                ^^^^^^^^^^ method not found in `UninitSlice`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut UninitSlice`, but its trait bounds were not satisfied\n   --> src/buf/uninit_slice.rs:137:25\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- doesn't satisfy `UninitSlice: ExactSizeIterator`\n...\n137 |         assert_eq!(self.len(), src.len());\n    |                         ^^^ method cannot be called on `&mut UninitSlice` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `UninitSlice: ExactSizeIterator`\n            which is required by `&mut UninitSlice: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `len`, perhaps you need to implement it:\n            candidate #1: `ExactSizeIterator`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/uninit_slice.rs:137:36\n     |\n137  |         assert_eq!(self.len(), src.len());\n     |                                    ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `as_ptr` found for reference `&[u8]` in the current scope\n   --> src/buf/uninit_slice.rs:140:42\n    |\n140 |             ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.len());\n    |                                          ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `as_mut_ptr` found for mutable reference `&mut UninitSlice` in the current scope\n   --> src/buf/uninit_slice.rs:140:57\n    |\n140 |             ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.len());\n    |                                                         ^^^^^^^^^^ method not found in `&mut UninitSlice`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut UninitSlice`, but its trait bounds were not satisfied\n   --> src/buf/uninit_slice.rs:140:76\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- doesn't satisfy `UninitSlice: ExactSizeIterator`\n...\n140 |             ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.len());\n    |                                                                            ^^^ method cannot be called on `&mut UninitSlice` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `UninitSlice: ExactSizeIterator`\n            which is required by `&mut UninitSlice: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `len`, perhaps you need to implement it:\n            candidate #1: `ExactSizeIterator`\n\nerror[E0599]: no method named `as_mut_ptr` found for slice `[MaybeUninit<u8>]` in the current scope\n   --> src/buf/uninit_slice.rs:162:16\n    |\n162 |         self.0.as_mut_ptr() as *mut _\n    |                ^^^^^^^^^^\n    |\nhelp: there is a method `as_mut` with a similar name\n    |\n162 |         self.0.as_mut() as *mut _\n    |                ~~~~~~\n\nerror[E0599]: no method named `len` found for slice `[MaybeUninit<u8>]` in the current scope\n   --> src/buf/uninit_slice.rs:206:16\n    |\n206 |         self.0.len()\n    |                ^^^ method not found in `[MaybeUninit<u8>]`\n\nerror[E0599]: no function or associated item named `new` found for struct `UninitSlice` in the current scope\n   --> src/buf/uninit_slice.rs:218:22\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- function or associated item `new` not found for this struct\n...\n218 |         UninitSlice::new(slice)\n    |                      ^^^ function or associated item not found in `UninitSlice`\n\nerror[E0599]: no function or associated item named `uninit` found for struct `UninitSlice` in the current scope\n   --> src/buf/uninit_slice.rs:224:22\n    |\n22  | pub struct UninitSlice([MaybeUninit<u8>]);\n    | ---------------------- function or associated item `uninit` not found for this struct\n...\n224 |         UninitSlice::uninit(slice)\n    |                      ^^^^^^ function or associated item not found in `UninitSlice`\n\nerror[E0599]: no function or associated item named `uninit_ref` found for struct `UninitSlice` in the current scope\n   --> src/buf/uninit_slice.rs:236:34\n    |\n22  |   pub struct UninitSlice([MaybeUninit<u8>]);\n    |   ---------------------- function or associated item `uninit_ref` not found for this struct\n...\n236 |                       UninitSlice::uninit_ref(&self.0[index])\n    |                                    ^^^^^^^^^^ function or associated item not found in `UninitSlice`\n...\n250 | / impl_index!(\n251 | |     Range<usize>,\n252 | |     RangeFrom<usize>,\n253 | |     RangeFull,\n...   |\n256 | |     RangeToInclusive<usize>\n257 | | );\n    | |_- in this macro invocation\n    |\n    = note: this error originates in the macro `impl_index` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `uninit` found for struct `UninitSlice` in the current scope\n   --> src/buf/uninit_slice.rs:243:34\n    |\n22  |   pub struct UninitSlice([MaybeUninit<u8>]);\n    |   ---------------------- function or associated item `uninit` not found for this struct\n...\n243 |                       UninitSlice::uninit(&mut self.0[index])\n    |                                    ^^^^^^ function or associated item not found in `UninitSlice`\n...\n250 | / impl_index!(\n251 | |     Range<usize>,\n252 | |     RangeFrom<usize>,\n253 | |     RangeFull,\n...   |\n256 | |     RangeToInclusive<usize>\n257 | | );\n    | |_- in this macro invocation\n    |\n    = note: this error originates in the macro `impl_index` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n  --> src/buf/vec_deque.rs:14:15\n   |\n14 |         if s1.is_empty() {\n   |               ^^^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut [IoSlice<'a>]`, but its trait bounds were not satisfied\n  --> src/buf/vec_deque.rs:23:35\n   |\n23 |         if self.is_empty() || dst.is_empty() {\n   |                                   ^^^^^^^^ method cannot be called on `&mut [IoSlice<'a>]` due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n           `[IoSlice<'a>]: ExactSizeIterator`\n           which is required by `&mut [IoSlice<'a>]: ExactSizeIterator`\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n  --> src/buf/vec_deque.rs:29:15\n   |\n29 |         if s2.is_empty() || dst.len() == 1 {\n   |               ^^^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [IoSlice<'a>]`, but its trait bounds were not satisfied\n  --> src/buf/vec_deque.rs:29:33\n   |\n29 |         if s2.is_empty() || dst.len() == 1 {\n   |                                 ^^^ method cannot be called on `&mut [IoSlice<'a>]` due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n           `[IoSlice<'a>]: ExactSizeIterator`\n           which is required by `&mut [IoSlice<'a>]: ExactSizeIterator`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/buf/writer.rs:79:56\n     |\n79   |         let n = cmp::min(self.buf.remaining_mut(), src.len());\n     |                                                        ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `from_static` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:143:16\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `from_static` not found for this struct\n...\n143 |         Bytes::from_static(EMPTY)\n    |                ^^^^^^^^^^^ function or associated item not found in `Bytes`\n\nerror[E0599]: no method named `as_ptr` found for reference `&'static [u8]` in the current scope\n   --> src/bytes.rs:170:24\n    |\n170 |             ptr: bytes.as_ptr(),\n    |                        ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `len` found for reference `&'static [u8]` in the current scope\n    --> src/bytes.rs:171:24\n     |\n171  |             len: bytes.len(),\n     |                        ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `is_null` found for raw pointer `*const u8` in the current scope\n   --> src/bytes.rs:190:28\n    |\n190 |         debug_assert!(!ptr.is_null());\n    |                            ^^^^^^^ method not found in `*const u8`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut bytes::Owned<T>` in the current scope\n   --> src/bytes.rs:281:40\n    |\n281 |             data: AtomicPtr::new(owned.cast()),\n    |                                        ^^^^ method not found in `*mut Owned<T>`\n\nerror[E0599]: no method named `as_ptr` found for reference `&[u8]` in the current scope\n   --> src/bytes.rs:286:23\n    |\n286 |         ret.ptr = buf.as_ptr();\n    |                       ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/bytes.rs:287:23\n     |\n287  |         ret.len = buf.len();\n     |                       ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n   --> src/bytes.rs:348:14\n    |\n348 |         data.to_vec().into()\n    |              ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `len` found for reference `&bytes::Bytes` in the current scope\n    --> src/bytes.rs:376:24\n     |\n376  |         let len = self.len();\n     |                        ^^^ field, not a method\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: remove the arguments\n     |\n376  -         let len = self.len();\n376  +         let len = self.len;\n     |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `checked_add` found for type `usize` in the current scope\n   --> src/bytes.rs:380:38\n    |\n380 |             Bound::Excluded(&n) => n.checked_add(1).expect(\"out of range\"),\n    |                                      ^^^^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named `checked_add` found for type `usize` in the current scope\n   --> src/bytes.rs:385:38\n    |\n385 |             Bound::Included(&n) => n.checked_add(1).expect(\"out of range\"),\n    |                                      ^^^^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no function or associated item named `new` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:404:27\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `new` not found for this struct\n...\n404 |             return Bytes::new();\n    |                           ^^^ function or associated item not found in `Bytes`\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `add` found for raw pointer `*const u8` in the current scope\n   --> src/bytes.rs:410:36\n    |\n410 |         ret.ptr = unsafe { ret.ptr.add(begin) };\n    |                                    ^^^ method not found in `*const u8`\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n   --> src/bytes.rs:443:19\n    |\n443 |         if subset.is_empty() {\n    |                   ^^^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no function or associated item named `new` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:444:27\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `new` not found for this struct\n...\n444 |             return Bytes::new();\n    |                           ^^^ function or associated item not found in `Bytes`\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_ptr` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:447:28\n    |\n447 |         let bytes_p = self.as_ptr() as usize;\n    |                            ^^^^^^ method not found in `&Bytes`\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n447 |         let bytes_p = self.data.as_ptr() as usize;\n    |                            +++++\n\nerror[E0599]: no method named `len` found for reference `&bytes::Bytes` in the current scope\n    --> src/bytes.rs:448:30\n     |\n448  |         let bytes_len = self.len();\n     |                              ^^^ field, not a method\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: remove the arguments\n     |\n448  -         let bytes_len = self.len();\n448  +         let bytes_len = self.len;\n     |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `as_ptr` found for reference `&[u8]` in the current scope\n   --> src/bytes.rs:450:28\n    |\n450 |         let sub_p = subset.as_ptr() as usize;\n    |                            ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/bytes.rs:451:30\n     |\n451  |         let sub_len = subset.len();\n     |                              ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `as_ptr` found for reference `&[u8]` in the current scope\n   --> src/bytes.rs:456:20\n    |\n456 |             subset.as_ptr(),\n    |                    ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `as_ptr` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:457:18\n    |\n457 |             self.as_ptr(),\n    |                  ^^^^^^ method not found in `&Bytes`\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n457 |             self.data.as_ptr(),\n    |                  +++++\n\nerror[E0599]: no method named `as_ptr` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:462:18\n    |\n462 |             self.as_ptr(),\n    |                  ^^^^^^ method not found in `&Bytes`\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n462 |             self.data.as_ptr(),\n    |                  +++++\n\nerror[E0599]: no method named `as_ptr` found for reference `&[u8]` in the current scope\n   --> src/bytes.rs:464:20\n    |\n464 |             subset.as_ptr(),\n    |                    ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:470:14\n    |\n470 |         self.slice(sub_offset..(sub_offset + sub_len))\n    |              ^^^^^ method not found in `&Bytes`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut Bytes`, but its trait bounds were not satisfied\n   --> src/bytes.rs:500:23\n    |\n102 | pub struct Bytes {\n    | ---------------- doesn't satisfy `bytes::Bytes: ExactSizeIterator`\n...\n500 |         if at == self.len() {\n    |                       ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `bytes::Bytes: ExactSizeIterator`\n            which is required by `&mut bytes::Bytes: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n500 -         if at == self.len() {\n500 +         if at == self.len {\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no function or associated item named `new_empty_with_ptr` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:501:27\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `new_empty_with_ptr` not found for this struct\n...\n501 |             return Bytes::new_empty_with_ptr(self.ptr.wrapping_add(at));\n    |                           ^^^^^^^^^^^^^^^^^^ function or associated item not found in `Bytes`\n\nerror[E0599]: no method named `wrapping_add` found for raw pointer `*const u8` in the current scope\n   --> src/bytes.rs:501:55\n    |\n501 |             return Bytes::new_empty_with_ptr(self.ptr.wrapping_add(at));\n    |                                                       ^^^^^^^^^^^^ method not found in `*const u8`\n\nerror[E0599]: no function or associated item named `new_empty_with_ptr` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:505:46\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `new_empty_with_ptr` not found for this struct\n...\n505 |             return mem::replace(self, Bytes::new_empty_with_ptr(self.ptr));\n    |                                              ^^^^^^^^^^^^^^^^^^ function or associated item not found in `Bytes`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut Bytes`, but its trait bounds were not satisfied\n   --> src/bytes.rs:509:24\n    |\n102 | pub struct Bytes {\n    | ---------------- doesn't satisfy `bytes::Bytes: ExactSizeIterator`\n...\n509 |             at <= self.len(),\n    |                        ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `bytes::Bytes: ExactSizeIterator`\n            which is required by `&mut bytes::Bytes: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n509 -             at <= self.len(),\n509 +             at <= self.len,\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut Bytes`, but its trait bounds were not satisfied\n   --> src/bytes.rs:512:18\n    |\n102 | pub struct Bytes {\n    | ---------------- doesn't satisfy `bytes::Bytes: ExactSizeIterator`\n...\n512 |             self.len(),\n    |                  ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `bytes::Bytes: ExactSizeIterator`\n            which is required by `&mut bytes::Bytes: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n512 -             self.len(),\n512 +             self.len,\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `inc_start` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:519:22\n    |\n102 | pub struct Bytes {\n    | ---------------- method `inc_start` not found for this struct\n...\n519 |         unsafe { ret.inc_start(at) };\n    |                      ^^^^^^^^^ method not found in `Bytes`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut Bytes`, but its trait bounds were not satisfied\n   --> src/bytes.rs:549:23\n    |\n102 | pub struct Bytes {\n    | ---------------- doesn't satisfy `bytes::Bytes: ExactSizeIterator`\n...\n549 |         if at == self.len() {\n    |                       ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `bytes::Bytes: ExactSizeIterator`\n            which is required by `&mut bytes::Bytes: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n549 -         if at == self.len() {\n549 +         if at == self.len {\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `wrapping_add` found for raw pointer `*const u8` in the current scope\n   --> src/bytes.rs:550:36\n    |\n550 |             let end_ptr = self.ptr.wrapping_add(at);\n    |                                    ^^^^^^^^^^^^ method not found in `*const u8`\n\nerror[E0599]: no function or associated item named `new_empty_with_ptr` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:551:46\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `new_empty_with_ptr` not found for this struct\n...\n551 |             return mem::replace(self, Bytes::new_empty_with_ptr(end_ptr));\n    |                                              ^^^^^^^^^^^^^^^^^^ function or associated item not found in `Bytes`\n\nerror[E0599]: no function or associated item named `new_empty_with_ptr` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:555:27\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `new_empty_with_ptr` not found for this struct\n...\n555 |             return Bytes::new_empty_with_ptr(self.ptr);\n    |                           ^^^^^^^^^^^^^^^^^^ function or associated item not found in `Bytes`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut Bytes`, but its trait bounds were not satisfied\n   --> src/bytes.rs:559:24\n    |\n102 | pub struct Bytes {\n    | ---------------- doesn't satisfy `bytes::Bytes: ExactSizeIterator`\n...\n559 |             at <= self.len(),\n    |                        ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `bytes::Bytes: ExactSizeIterator`\n            which is required by `&mut bytes::Bytes: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n559 -             at <= self.len(),\n559 +             at <= self.len,\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut Bytes`, but its trait bounds were not satisfied\n   --> src/bytes.rs:562:18\n    |\n102 | pub struct Bytes {\n    | ---------------- doesn't satisfy `bytes::Bytes: ExactSizeIterator`\n...\n562 |             self.len(),\n    |                  ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `bytes::Bytes: ExactSizeIterator`\n            which is required by `&mut bytes::Bytes: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n562 -             self.len(),\n562 +             self.len,\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `inc_start` found for mutable reference `&mut bytes::Bytes` in the current scope\n   --> src/bytes.rs:567:23\n    |\n567 |         unsafe { self.inc_start(at) };\n    |                       ^^^^^^^^^ method not found in `&mut Bytes`\n\nerror[E0599]: no method named `split_off` found for mutable reference `&mut bytes::Bytes` in the current scope\n   --> src/bytes.rs:600:27\n    |\n600 |                 drop(self.split_off(len));\n    |                           ^^^^^^^^^\n    |\nhelp: there is a method `split` with a similar name\n    |\n600 |                 drop(self.split(len));\n    |                           ~~~~~\n\nerror[E0599]: no method named `truncate` found for mutable reference `&mut bytes::Bytes` in the current scope\n   --> src/bytes.rs:620:14\n    |\n620 |         self.truncate(0);\n    |              ^^^^^^^^ method not found in `&mut Bytes`\n\nerror[E0599]: no method named `is_unique` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:642:17\n    |\n102 | pub struct Bytes {\n    | ---------------- method `is_unique` not found for this struct\n...\n642 |         if self.is_unique() {\n    |                 ^^^^^^^^^ method not found in `Bytes`\n\nerror[E0599]: no method named `add` found for raw pointer `*const u8` in the current scope\n   --> src/bytes.rs:676:29\n    |\n676 |         self.ptr = self.ptr.add(by);\n    |                             ^^^ method not found in `*const u8`\n\nerror[E0599]: no method named `len` found for reference `&bytes::Bytes` in the current scope\n    --> src/bytes.rs:701:14\n     |\n701  |         self.len()\n     |              ^^^ field, not a method\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: remove the arguments\n     |\n701  -         self.len()\n701  +         self.len\n     |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:706:14\n    |\n706 |         self.as_slice()\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut Bytes`, but its trait bounds were not satisfied\n   --> src/bytes.rs:712:25\n    |\n102 | pub struct Bytes {\n    | ---------------- doesn't satisfy `bytes::Bytes: ExactSizeIterator`\n...\n712 |             cnt <= self.len(),\n    |                         ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `bytes::Bytes: ExactSizeIterator`\n            which is required by `&mut bytes::Bytes: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n712 -             cnt <= self.len(),\n712 +             cnt <= self.len,\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut Bytes`, but its trait bounds were not satisfied\n   --> src/bytes.rs:715:18\n    |\n102 | pub struct Bytes {\n    | ---------------- doesn't satisfy `bytes::Bytes: ExactSizeIterator`\n...\n715 |             self.len(),\n    |                  ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `bytes::Bytes: ExactSizeIterator`\n            which is required by `&mut bytes::Bytes: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n715 -             self.len(),\n715 +             self.len,\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `inc_start` found for mutable reference `&mut bytes::Bytes` in the current scope\n   --> src/bytes.rs:719:18\n    |\n719 |             self.inc_start(cnt);\n    |                  ^^^^^^^^^ method not found in `&mut Bytes`\n\nerror[E0599]: no method named `split_to` found for mutable reference `&mut bytes::Bytes` in the current scope\n   --> src/bytes.rs:724:14\n    |\n724 |         self.split_to(len)\n    |              ^^^^^^^^\n    |\nhelp: there is a method `split` with a similar name\n    |\n724 |         self.split(len)\n    |              ~~~~~\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:733:14\n    |\n733 |         self.as_slice()\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:740:14\n    |\n740 |         self.as_slice()\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:749:14\n    |\n749 |         self.as_slice().hash(state);\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:755:14\n    |\n755 |         self.as_slice()\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no function or associated item named `new` found for struct `buf::iter::IntoIter` in the current scope\n   --> src/bytes.rs:764:19\n    |\n764 |         IntoIter::new(self)\n    |                   ^^^ function or associated item not found in `IntoIter<_>`\n    |\n   ::: src/buf/iter.rs:21:1\n    |\n21  | pub struct IntoIter<T> {\n    | ---------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name\n    |\n764 |         IntoIter::ne(self)\n    |                   ~~\n\nerror[E0599]: no method named `as_slice` found for reference `&'a bytes::Bytes` in the current scope\n   --> src/bytes.rs:773:14\n    |\n773 |         self.as_slice().iter()\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:787:14\n    |\n787 |         self.as_slice() == other.as_slice()\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:787:34\n    |\n787 |         self.as_slice() == other.as_slice()\n    |                                  ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:793:14\n    |\n793 |         self.as_slice().partial_cmp(other.as_slice())\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:793:43\n    |\n793 |         self.as_slice().partial_cmp(other.as_slice())\n    |                                           ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:799:14\n    |\n799 |         self.as_slice().cmp(other.as_slice())\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:799:35\n    |\n799 |         self.as_slice().cmp(other.as_slice())\n    |                                   ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:807:14\n    |\n807 |         self.as_slice() == other\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:813:14\n    |\n813 |         self.as_slice().partial_cmp(other)\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:831:14\n    |\n831 |         self.as_slice() == other.as_bytes()\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/bytes.rs:831:34\n    |\n831 |         self.as_slice() == other.as_bytes()\n    |                                  ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:837:14\n    |\n837 |         self.as_slice().partial_cmp(other.as_bytes())\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/bytes.rs:837:43\n    |\n837 |         self.as_slice().partial_cmp(other.as_bytes())\n    |                                           ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/bytes.rs:849:54\n    |\n849 |         <[u8] as PartialOrd<[u8]>>::partial_cmp(self.as_bytes(), other)\n    |                                                      ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:861:14\n    |\n861 |         self.as_slice().partial_cmp(&other[..])\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_slice` found for reference `&bytes::Bytes` in the current scope\n   --> src/bytes.rs:885:14\n    |\n885 |         self.as_slice().partial_cmp(other.as_bytes())\n    |              ^^^^^^^^ method not found in `&Bytes`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use core::slice::SlicePattern;\n    |\n\nerror[E0599]: no method named `as_bytes` found for reference `&&str` in the current scope\n   --> src/bytes.rs:921:54\n    |\n921 |         <[u8] as PartialOrd<[u8]>>::partial_cmp(self.as_bytes(), other)\n    |                                                      ^^^^^^^^ method not found in `&&str`\n\nerror[E0599]: no function or associated item named `new` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:948:16\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `new` not found for this struct\n...\n948 |         Bytes::new()\n    |                ^^^ function or associated item not found in `Bytes`\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_static` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:954:16\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `from_static` not found for this struct\n...\n954 |         Bytes::from_static(slice)\n    |                ^^^^^^^^^^^ function or associated item not found in `Bytes`\n\nerror[E0599]: no function or associated item named `from_static` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes.rs:960:16\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `from_static` not found for this struct\n...\n960 |         Bytes::from_static(slice.as_bytes())\n    |                ^^^^^^^^^^^ function or associated item not found in `Bytes`\n\nerror[E0599]: no method named `as_bytes` found for reference `&'static str` in the current scope\n   --> src/bytes.rs:960:34\n    |\n960 |         Bytes::from_static(slice.as_bytes())\n    |                                  ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: the method `is_empty` exists for struct `Box<[u8]>`, but its trait bounds were not satisfied\n    --> src/bytes.rs:1004:18\n     |\n1004 |           if slice.is_empty() {\n     |                    ^^^^^^^^ method cannot be called on `Box<[u8]>` due to unsatisfied trait bounds\n     |\n    ::: /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:238:1\n     |\n238  | / pub struct Box<\n239  | |     T: ?Sized,\n240  | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n241  | | >(Unique<T>, A);\n     | |_- doesn't satisfy `Box<[u8]>: ExactSizeIterator`\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `Box<[u8]>: ExactSizeIterator`\n\nerror[E0599]: no function or associated item named `new` found for struct `bytes::Bytes` in the current scope\n    --> src/bytes.rs:1005:27\n     |\n102  | pub struct Bytes {\n     | ---------------- function or associated item `new` not found for this struct\n...\n1005 |             return Bytes::new();\n     |                           ^^^ function or associated item not found in `Bytes`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `len` exists for struct `Box<[u8]>`, but its trait bounds were not satisfied\n    --> src/bytes.rs:1008:25\n     |\n1008 |           let len = slice.len();\n     |                           ^^^\n     |\n    ::: /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:238:1\n     |\n238  | / pub struct Box<\n239  | |     T: ?Sized,\n240  | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n241  | | >(Unique<T>, A);\n     | |_- doesn't satisfy `Box<[u8]>: ExactSizeIterator`\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `Box<[u8]>: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut u8` in the current scope\n    --> src/bytes.rs:1016:43\n     |\n1016 |                 data: AtomicPtr::new(data.cast()),\n     |                                           ^^^^ method not found in `*mut u8`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut u8` in the current scope\n    --> src/bytes.rs:1023:42\n     |\n1023 |                 data: AtomicPtr::new(ptr.cast()),\n     |                                          ^^^^ method not found in `*mut u8`\n\nerror[E0599]: no function or associated item named `from_static` found for struct `bytes::Bytes` in the current scope\n    --> src/bytes.rs:1088:12\n     |\n102  | pub struct Bytes {\n     | ---------------- function or associated item `from_static` not found for this struct\n...\n1088 |     Bytes::from_static(slice)\n     |            ^^^^^^^^^^^ function or associated item not found in `Bytes`\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n    --> src/bytes.rs:1093:11\n     |\n1093 |     slice.to_vec()\n     |           ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1130:28\n     |\n1130 |     let ref_cnt = &(*owned.cast::<OwnedLifetime>()).ref_cnt;\n     |                            ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n    --> src/bytes.rs:1146:21\n     |\n1146 |     let vec = slice.to_vec();\n     |                     ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no function or associated item named `from_vec` found for struct `BytesMut` in the current scope\n    --> src/bytes.rs:1152:15\n     |\n1152 |     BytesMut::from_vec(owned_to_vec(data, ptr, len))\n     |               ^^^^^^^^ function or associated item not found in `BytesMut`\n     |\n    ::: src/bytes_mut.rs:61:1\n     |\n61   | pub struct BytesMut {\n     | ------------------- function or associated item `from_vec` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `from_vec`, perhaps you need to implement it:\n             candidate #1: `OsStringExt`\nhelp: there is an associated function `from` with a similar name\n     |\n1152 |     BytesMut::from(owned_to_vec(data, ptr, len))\n     |               ~~~~\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1160:26\n     |\n1160 |     let lifetime = owned.cast::<OwnedLifetime>();\n     |                          ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1213:34\n     |\n1213 |         shallow_clone_arc(shared.cast(), ptr, len)\n     |                                  ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1216:34\n     |\n1216 |         let buf = ptr_map(shared.cast(), |addr| addr & !KIND_MASK);\n     |                                  ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1231:35\n     |\n1231 |         shared_to_vec_impl(shared.cast(), ptr, len)\n     |                                   ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1257:35\n     |\n1257 |         shared_to_mut_impl(shared.cast(), ptr, len)\n     |                                   ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no function or associated item named `from_vec` found for struct `BytesMut` in the current scope\n    --> src/bytes.rs:1270:31\n     |\n1270 |         let mut b = BytesMut::from_vec(v);\n     |                               ^^^^^^^^ function or associated item not found in `BytesMut`\n     |\n    ::: src/bytes_mut.rs:61:1\n     |\n61   | pub struct BytesMut {\n     | ------------------- function or associated item `from_vec` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `from_vec`, perhaps you need to implement it:\n             candidate #1: `OsStringExt`\nhelp: there is an associated function `from` with a similar name\n     |\n1270 |         let mut b = BytesMut::from(v);\n     |                               ~~~~\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1278:24\n     |\n1278 |         ptr_map(shared.cast(), |addr| addr & !KIND_MASK)\n     |                        ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1284:24\n     |\n1284 |         ptr_map(shared.cast(), |addr| addr & !KIND_MASK)\n     |                        ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1294:35\n     |\n1294 |             release_shared(shared.cast());\n     |                                   ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1297:38\n     |\n1297 |             let buf = ptr_map(shared.cast(), |addr| addr & !KIND_MASK);\n     |                                      ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1311:48\n     |\n1311 |         shallow_clone_vec(data, shared, shared.cast(), ptr, len)\n     |                                                ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1316:55\n     |\n1316 |     promotable_to_vec(data, ptr, len, |shared| shared.cast())\n     |                                                       ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1320:55\n     |\n1320 |     promotable_to_mut(data, ptr, len, |shared| shared.cast())\n     |                                                       ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1329:35\n     |\n1329 |             release_shared(shared.cast());\n     |                                   ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1333:37\n     |\n1333 |             free_boxed_slice(shared.cast(), ptr, len);\n     |                                     ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1343:32\n     |\n1343 |         let ref_cnt = (*shared.cast::<Shared>()).ref_cnt.load(Ordering::Relaxed);\n     |                                ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n    --> src/bytes.rs:1416:49\n     |\n1416 |         let v = slice::from_raw_parts(ptr, len).to_vec();\n     |                                                 ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1423:53\n     |\n1423 |     shared_to_vec_impl(data.load(Ordering::Relaxed).cast(), ptr, len)\n     |                                                     ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no function or associated item named `from_vec` found for struct `BytesMut` in the current scope\n    --> src/bytes.rs:1450:31\n     |\n1450 |         let mut b = BytesMut::from_vec(v);\n     |                               ^^^^^^^^ function or associated item not found in `BytesMut`\n     |\n    ::: src/bytes_mut.rs:61:1\n     |\n61   | pub struct BytesMut {\n     | ------------------- function or associated item `from_vec` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `from_vec`, perhaps you need to implement it:\n             candidate #1: `OsStringExt`\nhelp: there is an associated function `from` with a similar name\n     |\n1450 |         let mut b = BytesMut::from(v);\n     |                               ~~~~\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n    --> src/bytes.rs:1455:49\n     |\n1455 |         let v = slice::from_raw_parts(ptr, len).to_vec();\n     |                                                 ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no function or associated item named `from_vec` found for struct `BytesMut` in the current scope\n    --> src/bytes.rs:1457:19\n     |\n1457 |         BytesMut::from_vec(v)\n     |                   ^^^^^^^^ function or associated item not found in `BytesMut`\n     |\n    ::: src/bytes_mut.rs:61:1\n     |\n61   | pub struct BytesMut {\n     | ------------------- function or associated item `from_vec` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `from_vec`, perhaps you need to implement it:\n             candidate #1: `OsStringExt`\nhelp: there is an associated function `from` with a similar name\n     |\n1457 |         BytesMut::from(v)\n     |                   ~~~~\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1462:53\n     |\n1462 |     shared_to_mut_impl(data.load(Ordering::Relaxed).cast(), ptr, len)\n     |                                                     ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes.rs:1467:28\n     |\n1467 |     let ref_cnt = (*shared.cast::<Shared>()).ref_cnt.load(Ordering::Relaxed);\n     |                            ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `cast` found for mutable reference `&mut *mut ()` in the current scope\n    --> src/bytes.rs:1473:31\n     |\n1473 |         release_shared(shared.cast());\n     |                               ^^^^ method not found in `&mut *mut ()`\n\nerror[E0599]: no method named `wrapping_add` found for raw pointer `*const u8` in the current scope\n    --> src/bytes.rs:1624:29\n     |\n1624 |     core::ptr::null::<u8>().wrapping_add(ptr)\n     |                             ^^^^^^^^^^^^ method not found in `*const u8`\n\nerror[E0599]: no function or associated item named `from_vec` found for struct `BytesMut` in the current scope\n   --> src/bytes_mut.rs:149:19\n    |\n61  | pub struct BytesMut {\n    | ------------------- function or associated item `from_vec` not found for this struct\n...\n149 |         BytesMut::from_vec(Vec::with_capacity(capacity))\n    |                   ^^^^^^^^ function or associated item not found in `BytesMut`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `from_vec`, perhaps you need to implement it:\n            candidate #1: `OsStringExt`\nhelp: there is an associated function `from` with a similar name\n    |\n149 |         BytesMut::from(Vec::with_capacity(capacity))\n    |                   ~~~~\n\nerror[E0599]: no function or associated item named `with_capacity` found for struct `BytesMut` in the current scope\n   --> src/bytes_mut.rs:173:19\n    |\n61  | pub struct BytesMut {\n    | ------------------- function or associated item `with_capacity` not found for this struct\n...\n173 |         BytesMut::with_capacity(0)\n    |                   ^^^^^^^^^^^^^ function or associated item not found in `BytesMut`\n\nerror[E0599]: no method named `kind` found for struct `ManuallyDrop<BytesMut>` in the current scope\n   --> src/bytes_mut.rs:248:18\n    |\n248 |         if bytes.kind() == KIND_VEC {\n    |                  ^^^^ method not found in `ManuallyDrop<BytesMut>`\n\nerror[E0599]: no method named `get_vec_pos` found for struct `ManuallyDrop<BytesMut>` in the current scope\n   --> src/bytes_mut.rs:251:33\n    |\n251 |                 let off = bytes.get_vec_pos();\n    |                                 ^^^^^^^^^^^ method not found in `ManuallyDrop<BytesMut>`\n\nerror[E0599]: no method named `kind` found for struct `ManuallyDrop<BytesMut>` in the current scope\n   --> src/bytes_mut.rs:258:36\n    |\n258 |             debug_assert_eq!(bytes.kind(), KIND_ARC);\n    |                                    ^^^^ method not found in `ManuallyDrop<BytesMut>`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut bytes_mut::Shared` in the current scope\n   --> src/bytes_mut.rs:262:50\n    |\n262 |             let data = AtomicPtr::new(bytes.data.cast());\n    |                                                  ^^^^ method not found in `*mut Shared`\n\nerror[E0599]: no function or associated item named `with_vtable` found for struct `bytes::Bytes` in the current scope\n   --> src/bytes_mut.rs:263:29\n    |\n263 |             unsafe { Bytes::with_vtable(ptr, len, data, &SHARED_VTABLE) }\n    |                             ^^^^^^^^^^^ function or associated item not found in `Bytes`\n    |\n   ::: src/bytes.rs:102:1\n    |\n102 | pub struct Bytes {\n    | ---------------- function or associated item `with_vtable` not found for this struct\n\nerror[E0599]: no function or associated item named `from_vec` found for struct `BytesMut` in the current scope\n   --> src/bytes_mut.rs:288:19\n    |\n61  | pub struct BytesMut {\n    | ------------------- function or associated item `from_vec` not found for this struct\n...\n288 |         BytesMut::from_vec(vec![0; len])\n    |                   ^^^^^^^^ function or associated item not found in `BytesMut`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `from_vec`, perhaps you need to implement it:\n            candidate #1: `OsStringExt`\nhelp: there is an associated function `from` with a similar name\n    |\n288 |         BytesMut::from(vec![0; len])\n    |                   ~~~~\n\nerror[E0599]: no method named `capacity` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:322:24\n    |\n322 |             at <= self.capacity(),\n    |                        ^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `capacity` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:325:18\n    |\n325 |             self.capacity(),\n    |                  ^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `shallow_clone` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:328:34\n    |\n328 |             let mut other = self.shallow_clone();\n    |                                  ^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:364:24\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n364 |         let len = self.len();\n    |                        ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n364 -         let len = self.len();\n364 +         let len = self.len;\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `split_to` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:365:14\n    |\n365 |         self.split_to(len)\n    |              ^^^^^^^^\n    |\nhelp: there is a method `split` with a similar name\n    |\n365 |         self.split(len)\n    |              ~~~~~\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:397:24\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n397 |             at <= self.len(),\n    |                        ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n397 -             at <= self.len(),\n397 +             at <= self.len,\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:400:18\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n400 |             self.len(),\n    |                  ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n400 -             self.len(),\n400 +             self.len,\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `shallow_clone` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:404:34\n    |\n404 |             let mut other = self.shallow_clone();\n    |                                  ^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `advance_unchecked` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:407:18\n    |\n407 |             self.advance_unchecked(at);\n    |                  ^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:435:24\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n435 |         if len <= self.len() {\n    |                        ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n435 -         if len <= self.len() {\n435 +         if len <= self.len {\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `set_len` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:437:27\n    |\n437 |             unsafe { self.set_len(len) };\n    |                           ^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `set_len` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:454:23\n    |\n454 |         unsafe { self.set_len(0) };\n    |                       ^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n   --> src/bytes_mut.rs:480:60\n    |\n480 |         let additional = if let Some(additional) = new_len.checked_sub(self.len()) {\n    |                                                            ^^^^^^^^^^^ method not found in `usize`\n   --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n    |\n    = note: the method is available for `usize` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use gimli::read::reader::ReaderOffset;\n    |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:480:77\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n480 |         let additional = if let Some(additional) = new_len.checked_sub(self.len()) {\n    |                                                                             ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n480 -         let additional = if let Some(additional) = new_len.checked_sub(self.len()) {\n480 +         let additional = if let Some(additional) = new_len.checked_sub(self.len) {\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `truncate` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:483:18\n    |\n483 |             self.truncate(new_len);\n    |                  ^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `reserve` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:491:14\n    |\n491 |         self.reserve(additional);\n    |              ^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `spare_capacity_mut` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:492:24\n    |\n492 |         let dst = self.spare_capacity_mut().as_mut_ptr();\n    |                        ^^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `set_len` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:499:23\n    |\n499 |         unsafe { self.set_len(new_len) };\n    |                       ^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:593:24\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n593 |         let len = self.len();\n    |                        ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n593 -         let len = self.len();\n593 +         let len = self.len;\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `capacity` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:594:24\n    |\n594 |         let rem = self.capacity() - len;\n    |                        ^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `reserve_inner` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:603:22\n    |\n603 |         let _ = self.reserve_inner(additional, true);\n    |                      ^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:609:24\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n609 |         let len = self.len();\n    |                        ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n609 -         let len = self.len();\n609 +         let len = self.len;\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `kind` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:610:25\n    |\n610 |         let kind = self.kind();\n    |                         ^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `get_vec_pos` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:622:32\n    |\n622 |                 let off = self.get_vec_pos();\n    |                                ^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `capacity` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:637:25\n    |\n637 |                 if self.capacity() - self.len() + off >= additional && off >= self.len() {\n    |                         ^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:637:43\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n637 |                 if self.capacity() - self.len() + off >= additional && off >= self.len() {\n    |                                           ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n637 -                 if self.capacity() - self.len() + off >= additional && off >= self.len() {\n637 +                 if self.capacity() - self.len + off >= additional && off >= self.len() {\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:637:84\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n637 |                 if self.capacity() - self.len() + off >= additional && off >= self.len() {\n    |                                                                                    ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n637 -                 if self.capacity() - self.len() + off >= additional && off >= self.len() {\n637 +                 if self.capacity() - self.len() + off >= additional && off >= self.len {\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `sub` found for raw pointer `*mut u8` in the current scope\n   --> src/bytes_mut.rs:643:54\n    |\n643 |                     let base_ptr = self.ptr.as_ptr().sub(off);\n    |                                    --------          ^^^ method not found in `*mut u8`\n    |                                    |\n    |                                    method `sub` is available on `NonNull<u8>`\n\nerror[E0599]: no method named `set_vec_pos` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:647:26\n    |\n647 |                     self.set_vec_pos(0);\n    |                          ^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `add` found for raw pointer `*mut u8` in the current scope\n   --> src/bytes_mut.rs:663:52\n    |\n663 |                     self.ptr = vptr(v.as_mut_ptr().add(off));\n    |                                                    ^^^ method not found in `*mut u8`\n\nerror[E0599]: no method named `is_unique` found for struct `bytes_mut::Shared` in the current scope\n   --> src/bytes_mut.rs:688:26\n    |\n77  | struct Shared {\n    | ------------- method `is_unique` not found for this struct\n...\n688 |             if (*shared).is_unique() {\n    |                          ^^^^^^^^^ method not found in `Shared`\n\nerror[E0599]: no method named `checked_add` found for type `usize` in the current scope\n   --> src/bytes_mut.rs:724:39\n    |\n724 |                     new_cap = new_cap.checked_add(off).expect(\"overflow\");\n    |                                       ^^^^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named `checked_shl` found for type `usize` in the current scope\n   --> src/bytes_mut.rs:734:47\n    |\n734 |                     let double = v.capacity().checked_shl(1).unwrap_or(new_cap);\n    |                                               ^^^^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named `add` found for raw pointer `*mut u8` in the current scope\n   --> src/bytes_mut.rs:751:52\n    |\n751 |                     self.ptr = vptr(v.as_mut_ptr().add(off));\n    |                                                    ^^^ method not found in `*mut u8`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:834:24\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n834 |         let len = self.len();\n    |                        ^^^ field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n    |\n834 -         let len = self.len();\n834 +         let len = self.len;\n    |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `capacity` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:835:24\n    |\n835 |         let rem = self.capacity() - len;\n    |                        ^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `reserve_inner` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:843:14\n    |\n843 |         self.reserve_inner(additional, false)\n    |              ^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/bytes_mut.rs:864:26\n     |\n864  |         let cnt = extend.len();\n     |                          ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `reserve` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:865:14\n    |\n865 |         self.reserve(cnt);\n    |              ^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `spare_capacity_mut` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:868:28\n    |\n868 |             let dst = self.spare_capacity_mut();\n    |                            ^^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `as_ptr` found for reference `&[u8]` in the current scope\n   --> src/bytes_mut.rs:872:45\n    |\n872 |             ptr::copy_nonoverlapping(extend.as_ptr(), dst.as_mut_ptr().cast(), cnt);\n    |                                             ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n   --> src/bytes_mut.rs:905:17\n    |\n61  | pub struct BytesMut {\n    | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n905 |         if self.is_empty() {\n    |                 ^^^^^^^^ method cannot be called on `&mut BytesMut` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `BytesMut: ExactSizeIterator`\n            which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n    |\n86  | pub trait ExactSizeIterator: Iterator {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `is_empty`, perhaps you need to implement it:\n            candidate #1: `ExactSizeIterator`\n\nerror[E0599]: no method named `try_unsplit` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:910:34\n    |\n910 |         if let Err(other) = self.try_unsplit(other) {\n    |                                  ^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `extend_from_slice` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:911:18\n    |\n911 |             self.extend_from_slice(other.as_ref());\n    |                  ^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `kind` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:965:25\n    |\n965 |         let kind = self.kind();\n    |                         ^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `get_vec_pos` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:972:28\n    |\n972 |             let pos = self.get_vec_pos() + count;\n    |                            ^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `set_vec_pos` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:975:22\n    |\n975 |                 self.set_vec_pos(pos);\n    |                      ^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `promote_to_shared` found for mutable reference `&mut BytesMut` in the current scope\n   --> src/bytes_mut.rs:981:22\n    |\n981 |                 self.promote_to_shared(/*ref_count = */ 1);\n    |                      ^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `add` found for raw pointer `*mut u8` in the current scope\n   --> src/bytes_mut.rs:988:43\n    |\n988 |         self.ptr = vptr(self.ptr.as_ptr().add(count));\n    |                         --------          ^^^ method not found in `*mut u8`\n    |                         |\n    |                         method `add` is available on `NonNull<u8>`\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n   --> src/bytes_mut.rs:989:29\n    |\n989 |         self.len = self.len.checked_sub(count).unwrap_or(0);\n    |                             ^^^^^^^^^^^ method not found in `usize`\n   --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n    |\n    = note: the method is available for `usize` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use gimli::read::reader::ReaderOffset;\n    |\n\nerror[E0599]: no method named `capacity` found for struct `BytesMut` in the current scope\n   --> src/bytes_mut.rs:994:18\n    |\n61  | pub struct BytesMut {\n    | ------------------- method `capacity` not found for this struct\n...\n994 |         if other.capacity() == 0 {\n    |                  ^^^^^^^^ method not found in `BytesMut`\n\nerror[E0599]: no method named `add` found for raw pointer `*mut u8` in the current scope\n   --> src/bytes_mut.rs:998:46\n    |\n998 |         let ptr = unsafe { self.ptr.as_ptr().add(self.len) };\n    |                            --------          ^^^ method not found in `*mut u8`\n    |                            |\n    |                            method `add` is available on `NonNull<u8>`\n\nerror[E0599]: no method named `kind` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1000:21\n     |\n1000 |             && self.kind() == KIND_ARC\n     |                     ^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `kind` found for struct `BytesMut` in the current scope\n    --> src/bytes_mut.rs:1001:22\n     |\n61   | pub struct BytesMut {\n     | ------------------- method `kind` not found for this struct\n...\n1001 |             && other.kind() == KIND_ARC\n     |                      ^^^^ method not found in `BytesMut`\n\nerror[E0599]: no method named `kind` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1019:31\n     |\n1019 |         debug_assert_eq!(self.kind(), KIND_VEC);\n     |                               ^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `kind` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1059:17\n     |\n1059 |         if self.kind() == KIND_ARC {\n     |                 ^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `promote_to_shared` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1063:18\n     |\n1063 |             self.promote_to_shared(/*ref_count = */ 2);\n     |                  ^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `kind` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1070:31\n     |\n1070 |         debug_assert_eq!(self.kind(), KIND_VEC);\n     |                               ^^^^ method not found in `&BytesMut`\n\nerror[E0599]: no method named `kind` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1077:31\n     |\n1077 |         debug_assert_eq!(self.kind(), KIND_VEC);\n     |                               ^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `add` found for raw pointer `*mut u8` in the current scope\n    --> src/bytes_mut.rs:1115:41\n     |\n1115 |             let ptr = self.ptr.as_ptr().add(self.len);\n     |                       --------          ^^^ method not found in `*mut u8`\n     |                       |\n     |                       method `add` is available on `NonNull<u8>`\n\nerror[E0599]: no method named `kind` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1125:25\n     |\n1125 |         let kind = self.kind();\n     |                         ^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `get_vec_pos` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1129:32\n     |\n1129 |                 let off = self.get_vec_pos();\n     |                                ^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `len` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1143:14\n     |\n1143 |         self.len()\n     |              ^^^ field, not a method\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: remove the arguments\n     |\n1143 -         self.len()\n1143 +         self.len\n     |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `as_slice` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1148:14\n     |\n1148 |         self.as_slice()\n     |              ^^^^^^^^ method not found in `&BytesMut`\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use core::slice::SlicePattern;\n     |\n\nerror[E0599]: no method named `advance_unchecked` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1162:18\n     |\n1162 |             self.advance_unchecked(cnt);\n     |                  ^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `split_to` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1167:14\n     |\n1167 |         self.split_to(len).freeze()\n     |              ^^^^^^^^\n     |\nhelp: there is a method `split` with a similar name\n     |\n1167 |         self.split(len).freeze()\n     |              ~~~~~\n\nerror[E0599]: no method named `len` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1174:27\n     |\n1174 |         usize::MAX - self.len()\n     |                           ^^^ field, not a method\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: remove the arguments\n     |\n1174 -         usize::MAX - self.len()\n1174 +         usize::MAX - self.len\n     |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n    --> src/bytes_mut.rs:1179:41\n     |\n61   | pub struct BytesMut {\n     | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n1179 |         let remaining = self.cap - self.len();\n     |                                         ^^^ field, not a method\n     |\n     = note: the following trait bounds were not satisfied:\n             `BytesMut: ExactSizeIterator`\n             which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n     |\n86   | pub trait ExactSizeIterator: Iterator {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n     |\n1179 -         let remaining = self.cap - self.len();\n1179 +         let remaining = self.cap - self.len;\n     |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n    --> src/bytes_mut.rs:1187:25\n     |\n61   | pub struct BytesMut {\n     | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n1187 |         self.len = self.len() + cnt;\n     |                         ^^^ field, not a method\n     |\n     = note: the following trait bounds were not satisfied:\n             `BytesMut: ExactSizeIterator`\n             which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n     |\n86   | pub trait ExactSizeIterator: Iterator {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n     |\n1187 -         self.len = self.len() + cnt;\n1187 +         self.len = self.len + cnt;\n     |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `capacity` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1192:17\n     |\n1192 |         if self.capacity() == self.len() {\n     |                 ^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut BytesMut`, but its trait bounds were not satisfied\n    --> src/bytes_mut.rs:1192:36\n     |\n61   | pub struct BytesMut {\n     | ------------------- doesn't satisfy `BytesMut: ExactSizeIterator`\n...\n1192 |         if self.capacity() == self.len() {\n     |                                    ^^^ field, not a method\n     |\n     = note: the following trait bounds were not satisfied:\n             `BytesMut: ExactSizeIterator`\n             which is required by `&mut BytesMut: ExactSizeIterator`\nnote: the trait `ExactSizeIterator` must be implemented\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:86:1\n     |\n86   | pub trait ExactSizeIterator: Iterator {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: remove the arguments\n     |\n1192 -         if self.capacity() == self.len() {\n1192 +         if self.capacity() == self.len {\n     |\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `reserve` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1193:18\n     |\n1193 |             self.reserve(64);\n     |                  ^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `spare_capacity_mut` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1195:14\n     |\n1195 |         self.spare_capacity_mut().into()\n     |              ^^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/bytes_mut.rs:1207:23\n     |\n1207 |             let l = s.len();\n     |                       ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `extend_from_slice` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1208:18\n     |\n1208 |             self.extend_from_slice(s);\n     |                  ^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `extend_from_slice` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1214:14\n     |\n1214 |         self.extend_from_slice(src);\n     |              ^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `reserve` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1218:14\n     |\n1218 |         self.reserve(cnt);\n     |              ^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `spare_capacity_mut` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1220:28\n     |\n1220 |             let dst = self.spare_capacity_mut();\n     |                            ^^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `as_slice` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1234:14\n     |\n1234 |         self.as_slice()\n     |              ^^^^^^^^ method not found in `&BytesMut`\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use core::slice::SlicePattern;\n     |\n\nerror[E0599]: no method named `as_slice_mut` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1250:14\n     |\n1250 |         self.as_slice_mut()\n     |              ^^^^^^^^^^^^\n     |\nhelp: there is a method `as_mut` with a similar name\n     |\n1250 |         self.as_mut()\n     |              ~~~~~~\n\nerror[E0599]: no function or associated item named `from_vec` found for struct `BytesMut` in the current scope\n    --> src/bytes_mut.rs:1263:19\n     |\n61   | pub struct BytesMut {\n     | ------------------- function or associated item `from_vec` not found for this struct\n...\n1263 |         BytesMut::from_vec(src.to_vec())\n     |                   ^^^^^^^^ function or associated item not found in `BytesMut`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `from_vec`, perhaps you need to implement it:\n             candidate #1: `OsStringExt`\nhelp: there is an associated function `from` with a similar name\n     |\n1263 |         BytesMut::from(src.to_vec())\n     |                   ~~~~\n\nerror[E0599]: no method named `to_vec` found for reference `&'a [u8]` in the current scope\n    --> src/bytes_mut.rs:1263:32\n     |\n1263 |         BytesMut::from_vec(src.to_vec())\n     |                                ^^^^^^ method not found in `&'a [u8]`\n\nerror[E0599]: no method named `as_bytes` found for reference `&'a str` in the current scope\n    --> src/bytes_mut.rs:1269:28\n     |\n1269 |         BytesMut::from(src.as_bytes())\n     |                            ^^^^^^^^ method not found in `&'a str`\n\nerror[E0599]: no method named `freeze` found for struct `BytesMut` in the current scope\n    --> src/bytes_mut.rs:1275:13\n     |\n61   | pub struct BytesMut {\n     | ------------------- method `freeze` not found for this struct\n...\n1275 |         src.freeze()\n     |             ^^^^^^ method not found in `BytesMut`\n\nerror[E0599]: no method named `as_slice` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1281:14\n     |\n1281 |         self.as_slice() == other.as_slice()\n     |              ^^^^^^^^ method not found in `&BytesMut`\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use core::slice::SlicePattern;\n     |\n\nerror[E0599]: no method named `as_slice` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1281:34\n     |\n1281 |         self.as_slice() == other.as_slice()\n     |                                  ^^^^^^^^ method not found in `&BytesMut`\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use core::slice::SlicePattern;\n     |\n\nerror[E0599]: no method named `as_slice` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1287:14\n     |\n1287 |         self.as_slice().partial_cmp(other.as_slice())\n     |              ^^^^^^^^ method not found in `&BytesMut`\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use core::slice::SlicePattern;\n     |\n\nerror[E0599]: no method named `as_slice` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1287:43\n     |\n1287 |         self.as_slice().partial_cmp(other.as_slice())\n     |                                           ^^^^^^^^ method not found in `&BytesMut`\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use core::slice::SlicePattern;\n     |\n\nerror[E0599]: no method named `as_slice` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1293:14\n     |\n1293 |         self.as_slice().cmp(other.as_slice())\n     |              ^^^^^^^^ method not found in `&BytesMut`\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use core::slice::SlicePattern;\n     |\n\nerror[E0599]: no method named `as_slice` found for reference `&BytesMut` in the current scope\n    --> src/bytes_mut.rs:1293:35\n     |\n1293 |         self.as_slice().cmp(other.as_slice())\n     |                                   ^^^^^^^^ method not found in `&BytesMut`\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `SlicePattern` which provides `as_slice` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use core::slice::SlicePattern;\n     |\n\nerror[E0599]: no function or associated item named `new` found for struct `BytesMut` in the current scope\n    --> src/bytes_mut.rs:1302:19\n     |\n61   | pub struct BytesMut {\n     | ------------------- function or associated item `new` not found for this struct\n...\n1302 |         BytesMut::new()\n     |                   ^^^ function or associated item not found in `BytesMut`\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&str` in the current scope\n    --> src/bytes_mut.rs:1331:38\n     |\n1331 |         if self.remaining_mut() >= s.len() {\n     |                                      ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n    --> src/bytes_mut.rs:1332:30\n     |\n1332 |             self.put_slice(s.as_bytes());\n     |                              ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no function or associated item named `new` found for struct `buf::iter::IntoIter` in the current scope\n    --> src/bytes_mut.rs:1356:19\n     |\n1356 |         IntoIter::new(self)\n     |                   ^^^ function or associated item not found in `IntoIter<_>`\n     |\n    ::: src/buf/iter.rs:21:1\n     |\n21   | pub struct IntoIter<T> {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name\n     |\n1356 |         IntoIter::ne(self)\n     |                   ~~\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n    --> src/bytes_mut.rs:1365:23\n     |\n1365 |         self.as_ref().iter()\n     |                       ^^^^\n     |\nhelp: there is a method `writer` with a similar name\n     |\n1365 |         self.as_ref().writer()\n     |                       ~~~~~~\n\nerror[E0599]: no method named `reserve` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1377:14\n     |\n1377 |         self.reserve(lower);\n     |              ^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no method named `extend_from_slice` found for mutable reference `&mut BytesMut` in the current scope\n    --> src/bytes_mut.rs:1402:18\n     |\n1402 |             self.extend_from_slice(&bytes)\n     |                  ^^^^^^^^^^^^^^^^^ method not found in `&mut BytesMut`\n\nerror[E0599]: no function or associated item named `from_vec` found for struct `BytesMut` in the current scope\n    --> src/bytes_mut.rs:1409:19\n     |\n61   | pub struct BytesMut {\n     | ------------------- function or associated item `from_vec` not found for this struct\n...\n1409 |         BytesMut::from_vec(Vec::from_iter(into_iter))\n     |                   ^^^^^^^^ function or associated item not found in `BytesMut`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `from_vec`, perhaps you need to implement it:\n             candidate #1: `OsStringExt`\nhelp: there is an associated function `from` with a similar name\n     |\n1409 |         BytesMut::from(Vec::from_iter(into_iter))\n     |                   ~~~~\n\nerror[E0599]: no method named `leading_zeros` found for type `usize` in the current scope\n    --> src/bytes_mut.rs:1483:67\n     |\n1483 |     let width = PTR_WIDTH - ((cap >> MIN_ORIGINAL_CAPACITY_WIDTH).leading_zeros() as usize);\n     |                                                                   ^^^^^^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n    --> src/bytes_mut.rs:1587:26\n     |\n1587 |         &**self == other.as_bytes()\n     |                          ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n    --> src/bytes_mut.rs:1593:36\n     |\n1593 |         (**self).partial_cmp(other.as_bytes())\n     |                                    ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n    --> src/bytes_mut.rs:1605:54\n     |\n1605 |         <[u8] as PartialOrd<[u8]>>::partial_cmp(self.as_bytes(), other)\n     |                                                      ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named `kind` found for struct `BytesMut` in the current scope\n    --> src/bytes_mut.rs:1713:26\n     |\n61   | pub struct BytesMut {\n     | ------------------- method `kind` not found for this struct\n...\n1713 |         let kind = bytes.kind();\n     |                          ^^^^ method not found in `BytesMut`\n\nerror[E0599]: no method named `get_vec_pos` found for struct `ManuallyDrop<BytesMut>` in the current scope\n    --> src/bytes_mut.rs:1718:33\n     |\n1718 |                 let off = bytes.get_vec_pos();\n     |                                 ^^^^^^^^^^^ method not found in `ManuallyDrop<BytesMut>`\n\nerror[E0599]: no method named `is_unique` found for struct `bytes_mut::Shared` in the current scope\n    --> src/bytes_mut.rs:1724:35\n     |\n77   | struct Shared {\n     | ------------- method `is_unique` not found for this struct\n...\n1724 |             if unsafe { (*shared).is_unique() } {\n     |                                   ^^^^^^^^^ method not found in `Shared`\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n    --> src/bytes_mut.rs:1731:64\n     |\n1731 |                 return ManuallyDrop::into_inner(bytes).deref().to_vec();\n     |                                                                ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `wrapping_add` found for raw pointer `*mut u8` in the current scope\n    --> src/bytes_mut.rs:1762:43\n     |\n1762 |     let ptr = core::ptr::null_mut::<u8>().wrapping_add(addr);\n     |                                           ^^^^^^^^^^^^ method not found in `*mut u8`\n\nerror[E0599]: no method named `sub` found for raw pointer `*mut u8` in the current scope\n    --> src/bytes_mut.rs:1768:19\n     |\n1768 |     let ptr = ptr.sub(off);\n     |                   ^^^ method not found in `*mut u8`\n\nerror[E0599]: no function or associated item named `with_vtable` found for struct `bytes::Bytes` in the current scope\n    --> src/bytes_mut.rs:1790:12\n     |\n1790 |     Bytes::with_vtable(ptr, len, data, &SHARED_VTABLE)\n     |            ^^^^^^^^^^^ function or associated item not found in `Bytes`\n     |\n    ::: src/bytes.rs:102:1\n     |\n102  | pub struct Bytes {\n     | ---------------- function or associated item `with_vtable` not found for this struct\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes_mut.rs:1794:60\n     |\n1794 |     let shared: *mut Shared = data.load(Ordering::Relaxed).cast();\n     |                                                            ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n    --> src/bytes_mut.rs:1809:49\n     |\n1809 |         let v = slice::from_raw_parts(ptr, len).to_vec();\n     |                                                 ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes_mut.rs:1816:60\n     |\n1816 |     let shared: *mut Shared = data.load(Ordering::Relaxed).cast();\n     |                                                            ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n    --> src/bytes_mut.rs:1838:49\n     |\n1838 |         let v = slice::from_raw_parts(ptr, len).to_vec();\n     |                                                 ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no function or associated item named `from_vec` found for struct `BytesMut` in the current scope\n    --> src/bytes_mut.rs:1840:19\n     |\n61   | pub struct BytesMut {\n     | ------------------- function or associated item `from_vec` not found for this struct\n...\n1840 |         BytesMut::from_vec(v)\n     |                   ^^^^^^^^ function or associated item not found in `BytesMut`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `from_vec`, perhaps you need to implement it:\n             candidate #1: `OsStringExt`\nhelp: there is an associated function `from` with a similar name\n     |\n1840 |         BytesMut::from(v)\n     |                   ~~~~\n\nerror[E0599]: no method named `cast` found for raw pointer `*mut ()` in the current scope\n    --> src/bytes_mut.rs:1846:30\n     |\n1846 |     let ref_count = (*shared.cast::<Shared>()).ref_count.load(Ordering::Relaxed);\n     |                              ^^^^ method not found in `*mut ()`\n\nerror[E0599]: no function or associated item named `new` found for struct `TestFormatter` in the current scope\n  --> src/fmt/hex.rs:47:40\n   |\n38 |     struct TestFormatter;\n   |     -------------------- function or associated item `new` not found for this struct\n...\n47 |     let mut formatter = TestFormatter::new();\n   |                                        ^^^ function or associated item not found in `TestFormatter`\n\nerror[E0034]: multiple applicable items in scope\n  --> src/fmt/hex.rs:49:23\n   |\n49 |     let result = data.fmt(&mut formatter);\n   |                       ^^^ multiple `fmt` found\n   |\nnote: candidate #1 is defined in an impl of the trait `std::fmt::LowerHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:7:5\n   |\n7  |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl of the trait `std::fmt::UpperHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:16:5\n   |\n16 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: disambiguate the method for candidate #1\n   |\n49 |     let result = std::fmt::LowerHex::fmt(&data, &mut formatter);\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: disambiguate the method for candidate #2\n   |\n49 |     let result = std::fmt::UpperHex::fmt(&data, &mut formatter);\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> src/fmt/hex.rs:42:13\n   |\n41 |         fn new() -> Self {\n   |                     ---- expected `std::fmt::Formatter<'_>` because of return type\n42 |             TestFormatter {}\n   |             ^^^^^^^^^^^^^^^^ expected `Formatter<'_>`, found `TestFormatter`\n\nerror[E0599]: no method named `saturating_sub` found for type `usize` in the current scope\n   --> src/lib.rs:119:20\n    |\n119 |         Ok(b) => a.saturating_sub(b),\n    |                    ^^^^^^^^^^^^^^ method not found in `usize`\n\nwarning: unused import: `super::BufMut`\n    --> src/buf/buf_impl.rs:2359:13\n     |\n2359 |         use super::BufMut;\n     |             ^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0034, E0116, E0308, E0599.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `bytes` (lib test) generated 2 warnings\nerror: could not compile `bytes` (lib test) due to 548 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestFormatter {",
                  "        output: String,",
                  "    }",
                  "    ",
                  "    impl TestFormatter {",
                  "        fn new() -> Self {",
                  "            TestFormatter { output: String::new() }",
                  "        }",
                  "        ",
                  "        fn write(&mut self, s: &str) -> Result<(), std::fmt::Error> {",
                  "            self.output.push_str(s);",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let data = BytesRef(&[0x01]);",
                  "    let mut formatter = TestFormatter::new();",
                  "",
                  "    let result = data.fmt(&mut formatter);",
                  "",
                  "    assert!(result.is_ok());",
                  "    assert_eq!(formatter.output, \"01\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0107]: type alias takes 0 generic arguments but 2 generic arguments were supplied\n  --> src/fmt/hex.rs:47:41\n   |\n47 |         fn write(&mut self, s: &str) -> Result<(), std::fmt::Error> {\n   |                                         ^^^^^^--------------------- help: remove these generics\n   |                                         |\n   |                                         expected 0 generic arguments\n   |\nnote: type alias defined here, with 0 generic parameters\n  --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:70:10\n   |\n70 | pub type Result = result::Result<(), Error>;\n   |          ^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n  --> src/fmt/hex.rs:56:23\n   |\n56 |     let result = data.fmt(&mut formatter);\n   |                       ^^^ multiple `fmt` found\n   |\nnote: candidate #1 is defined in an impl of the trait `std::fmt::LowerHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:7:5\n   |\n7  |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl of the trait `std::fmt::UpperHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:16:5\n   |\n16 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: disambiguate the method for candidate #1\n   |\n56 |     let result = std::fmt::LowerHex::fmt(&data, &mut formatter);\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: disambiguate the method for candidate #2\n   |\n56 |     let result = std::fmt::UpperHex::fmt(&data, &mut formatter);\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0034, E0107.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `bytes` (lib test) generated 1 warning\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestFormatter {",
                  "        output: String,",
                  "    }",
                  "    ",
                  "    impl TestFormatter {",
                  "        fn new() -> Self {",
                  "            TestFormatter { output: String::new() }",
                  "        }",
                  "        ",
                  "        fn write(&mut self, s: &str) -> Result<(), std::fmt::Error> {",
                  "            self.output.push_str(s);",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let data = BytesRef(&[0x0A, 0xFF, 0x1C]);",
                  "    let mut formatter = TestFormatter::new();",
                  "    ",
                  "    let result = data.fmt(&mut formatter);",
                  "",
                  "    assert!(result.is_ok());",
                  "    assert_eq!(formatter.output, \"0aff1c\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0107]: type alias takes 0 generic arguments but 2 generic arguments were supplied\n  --> src/fmt/hex.rs:47:41\n   |\n47 |         fn write(&mut self, s: &str) -> Result<(), std::fmt::Error> {\n   |                                         ^^^^^^--------------------- help: remove these generics\n   |                                         |\n   |                                         expected 0 generic arguments\n   |\nnote: type alias defined here, with 0 generic parameters\n  --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:70:10\n   |\n70 | pub type Result = result::Result<(), Error>;\n   |          ^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n  --> src/fmt/hex.rs:56:23\n   |\n56 |     let result = data.fmt(&mut formatter);\n   |                       ^^^ multiple `fmt` found\n   |\nnote: candidate #1 is defined in an impl of the trait `std::fmt::LowerHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:7:5\n   |\n7  |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl of the trait `std::fmt::UpperHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:16:5\n   |\n16 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: disambiguate the method for candidate #1\n   |\n56 |     let result = std::fmt::LowerHex::fmt(&data, &mut formatter);\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: disambiguate the method for candidate #2\n   |\n56 |     let result = std::fmt::UpperHex::fmt(&data, &mut formatter);\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0034, E0107.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `bytes` (lib test) generated 1 warning\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestFormatter;",
                  "    ",
                  "    impl core::fmt::Write for TestFormatter {",
                  "        fn write_str(&mut self, _s: &str) -> Result {",
                  "            Err(core::fmt::Error) // Simulate write error",
                  "        }",
                  "    }",
                  "",
                  "    let data = BytesRef(&[0x01, 0x02]);",
                  "    let mut formatter = TestFormatter;",
                  "",
                  "    let _ = data.fmt(&mut formatter);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0034]: multiple applicable items in scope\n  --> src/fmt/hex.rs:50:18\n   |\n50 |     let _ = data.fmt(&mut formatter);\n   |                  ^^^ multiple `fmt` found\n   |\nnote: candidate #1 is defined in an impl of the trait `std::fmt::LowerHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:7:5\n   |\n7  |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl of the trait `std::fmt::UpperHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:16:5\n   |\n16 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: disambiguate the method for candidate #1\n   |\n50 |     let _ = std::fmt::LowerHex::fmt(&data, &mut formatter);\n   |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: disambiguate the method for candidate #2\n   |\n50 |     let _ = std::fmt::UpperHex::fmt(&data, &mut formatter);\n   |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor more information about this error, try `rustc --explain E0034`.\nwarning: `bytes` (lib test) generated 1 warning\nerror: could not compile `bytes` (lib test) due to 1 previous error; 1 warning emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: &b in self.0 is true\n",
        "// constraint: write!(f, \"{:02x}\", b)? is Ok/Some\n",
        "// constraint: &b in self.0 is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "#[should_panic]",
                  "fn test_lower_hex_fmt_invalid() {",
                  "    // This test will panic if the underlying implementation doesn't support",
                  "    // a specific condition or if we introduce an invalid input format.",
                  "    let data = BytesRef(&[0xFF]); // Assuming this is a trigger for some invalid output",
                  "    let mut output = String::new();",
                  "    // We wrap this in a std::panic::catch_unwind if we are testing for panic",
                  "    data.fmt(&mut Formatter::new(&mut output));",
                  "}",
                  "    let data = BytesRef(&[0x0F, 0xA0, 0x1B]);",
                  "    let mut output = String::new();",
                  "    let result = data.fmt(&mut Formatter::new(&mut output));",
                  "    assert!(result.is_ok());",
                  "    assert_eq!(output, \"0fa01b\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0034]: multiple applicable items in scope\n  --> src/fmt/hex.rs:49:23\n   |\n49 |     let result = data.fmt(&mut Formatter::new(&mut output));\n   |                       ^^^ multiple `fmt` found\n   |\nnote: candidate #1 is defined in an impl of the trait `std::fmt::LowerHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:7:5\n   |\n7  |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl of the trait `std::fmt::UpperHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:16:5\n   |\n16 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: disambiguate the method for candidate #1\n   |\n49 |     let result = std::fmt::LowerHex::fmt(&data, &mut Formatter::new(&mut output));\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: disambiguate the method for candidate #2\n   |\n49 |     let result = std::fmt::UpperHex::fmt(&data, &mut Formatter::new(&mut output));\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n  --> src/fmt/hex.rs:49:32\n   |\n49 |     let result = data.fmt(&mut Formatter::new(&mut output));\n   |                                ^^^^^^^^^^^^^^\n   |\n   = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n   = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0034]: multiple applicable items in scope\n  --> src/fmt/hex.rs:45:10\n   |\n45 |     data.fmt(&mut Formatter::new(&mut output));\n   |          ^^^ multiple `fmt` found\n   |\nnote: candidate #1 is defined in an impl of the trait `std::fmt::LowerHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:7:5\n   |\n7  |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl of the trait `std::fmt::UpperHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:16:5\n   |\n16 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: disambiguate the method for candidate #1\n   |\n45 |     std::fmt::LowerHex::fmt(&data, &mut Formatter::new(&mut output));\n   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: disambiguate the method for candidate #2\n   |\n45 |     std::fmt::UpperHex::fmt(&data, &mut Formatter::new(&mut output));\n   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n  --> src/fmt/hex.rs:45:19\n   |\n45 |     data.fmt(&mut Formatter::new(&mut output));\n   |                   ^^^^^^^^^^^^^^\n   |\n   = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n   = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nSome errors have detailed explanations: E0034, E0658.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `bytes` (lib test) generated 1 warning\nerror: could not compile `bytes` (lib test) due to 4 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "#[should_panic]",
                  "fn test_lower_hex_fmt_invalid() {",
                  "    // This test will panic if the underlying implementation doesn't support",
                  "    // a specific condition or if we introduce an invalid input format.",
                  "    let data = BytesRef(&[0xFF]); // Assuming this is a trigger for some invalid output",
                  "    let mut output = String::new();",
                  "    // We wrap this in a std::panic::catch_unwind if we are testing for panic",
                  "    data.fmt(&mut Formatter::new(&mut output));",
                  "}",
                  "    let data = BytesRef(&[]);",
                  "    let mut output = String::new();",
                  "    let result = data.fmt(&mut Formatter::new(&mut output));",
                  "    assert!(result.is_ok());",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0034]: multiple applicable items in scope\n  --> src/fmt/hex.rs:49:23\n   |\n49 |     let result = data.fmt(&mut Formatter::new(&mut output));\n   |                       ^^^ multiple `fmt` found\n   |\nnote: candidate #1 is defined in an impl of the trait `std::fmt::LowerHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:7:5\n   |\n7  |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl of the trait `std::fmt::UpperHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:16:5\n   |\n16 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: disambiguate the method for candidate #1\n   |\n49 |     let result = std::fmt::LowerHex::fmt(&data, &mut Formatter::new(&mut output));\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: disambiguate the method for candidate #2\n   |\n49 |     let result = std::fmt::UpperHex::fmt(&data, &mut Formatter::new(&mut output));\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n  --> src/fmt/hex.rs:49:32\n   |\n49 |     let result = data.fmt(&mut Formatter::new(&mut output));\n   |                                ^^^^^^^^^^^^^^\n   |\n   = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n   = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0034]: multiple applicable items in scope\n  --> src/fmt/hex.rs:45:10\n   |\n45 |     data.fmt(&mut Formatter::new(&mut output));\n   |          ^^^ multiple `fmt` found\n   |\nnote: candidate #1 is defined in an impl of the trait `std::fmt::LowerHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:7:5\n   |\n7  |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl of the trait `std::fmt::UpperHex` for the type `fmt::BytesRef<'_>`\n  --> src/fmt/hex.rs:16:5\n   |\n16 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: disambiguate the method for candidate #1\n   |\n45 |     std::fmt::LowerHex::fmt(&data, &mut Formatter::new(&mut output));\n   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: disambiguate the method for candidate #2\n   |\n45 |     std::fmt::UpperHex::fmt(&data, &mut Formatter::new(&mut output));\n   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n  --> src/fmt/hex.rs:45:19\n   |\n45 |     data.fmt(&mut Formatter::new(&mut output));\n   |                   ^^^^^^^^^^^^^^\n   |\n   = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n   = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nSome errors have detailed explanations: E0034, E0658.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `bytes` (lib test) generated 1 warning\nerror: could not compile `bytes` (lib test) due to 4 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: &b in self.0 is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct BytesRef<'a>(&'a [u8]);",
                  "    ",
                  "    impl LowerHex for BytesRef<'_> {",
                  "        fn fmt(&self, f: &mut Formatter<'_>) -> Result {",
                  "            for &b in self.0 {",
                  "                write!(f, \"{:02x}\", b)?;",
                  "            }",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let bytes_ref = BytesRef(&[]);",
                  "    let mut formatter = Formatter::new();",
                  "    let result = bytes_ref.fmt(&mut formatter);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n  --> src/fmt/hex.rs:50:25\n   |\n50 |     let mut formatter = Formatter::new();\n   |                         ^^^^^^^^^^^^^^\n   |\n   = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n   = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> src/fmt/hex.rs:50:25\n    |\n50  |     let mut formatter = Formatter::new();\n    |                         ^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:286:12\n    |\n286 |     pub fn new(buf: &'a mut (dyn Write + 'a)) -> Formatter<'a> {\n    |            ^^^\nhelp: provide the argument\n    |\n50  |     let mut formatter = Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `bytes` (lib test) generated 1 warning\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct BytesRef<'a>(&'a [u8]);",
                  "    ",
                  "    impl LowerHex for BytesRef<'_> {",
                  "        fn fmt(&self, f: &mut Formatter<'_>) -> Result {",
                  "            for &b in self.0 {",
                  "                write!(f, \"{:02x}\", b)?;",
                  "            }",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let bytes_ref = BytesRef(&[0x01]);",
                  "    let mut formatter = Formatter::new();",
                  "    let result = bytes_ref.fmt(&mut formatter);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n  --> src/fmt/hex.rs:50:25\n   |\n50 |     let mut formatter = Formatter::new();\n   |                         ^^^^^^^^^^^^^^\n   |\n   = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n   = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> src/fmt/hex.rs:50:25\n    |\n50  |     let mut formatter = Formatter::new();\n    |                         ^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:286:12\n    |\n286 |     pub fn new(buf: &'a mut (dyn Write + 'a)) -> Formatter<'a> {\n    |            ^^^\nhelp: provide the argument\n    |\n50  |     let mut formatter = Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `bytes` (lib test) generated 1 warning\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct BytesRef<'a>(&'a [u8]);",
                  "    ",
                  "    impl LowerHex for BytesRef<'_> {",
                  "        fn fmt(&self, f: &mut Formatter<'_>) -> Result {",
                  "            for &b in self.0 {",
                  "                write!(f, \"{:02x}\", b)?;",
                  "            }",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let bytes_ref = BytesRef(&[0x01, 0xAB, 0xFF]);",
                  "    let mut formatter = Formatter::new();",
                  "    let result = bytes_ref.fmt(&mut formatter);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling bytes v1.10.1 (/home/abezbm/rust-utgen-test-crates-new/bytes)\nwarning: unused import: `super::*`\n    --> src/bytes_mut.rs:1500:9\n     |\n1500 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n  --> src/fmt/hex.rs:50:25\n   |\n50 |     let mut formatter = Formatter::new();\n   |                         ^^^^^^^^^^^^^^\n   |\n   = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n   = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> src/fmt/hex.rs:50:25\n    |\n50  |     let mut formatter = Formatter::new();\n    |                         ^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:286:12\n    |\n286 |     pub fn new(buf: &'a mut (dyn Write + 'a)) -> Formatter<'a> {\n    |            ^^^\nhelp: provide the argument\n    |\n50  |     let mut formatter = Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `bytes` (lib test) generated 1 warning\nerror: could not compile `bytes` (lib test) due to 2 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}