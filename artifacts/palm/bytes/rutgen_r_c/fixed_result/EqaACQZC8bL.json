{"function_name":"bytes::buf::chain::<buf::chain::Chain<T, U> as buf::buf_mut::BufMut>::advance_mut","tests":7,"tests_lines":[38,38,38,32,32,32,36],"oracles":7,"oracles_compiled":7,"oracles_compiled_rate":100.0,"tests_compiled":7,"tests_compiled_rate":100.0,"oracles_run":7,"oracles_passed":7,"oracles_passed_rate":100.0,"tests_run":7,"tests_passed":7,"tests_passed_rate":100.0,"lines":16,"lines_covered":16,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[210,211,212,213,214,215,216,217,218,219,220,221,222,223,225,226],"codes_lines_covered":[[["{","    struct BufMutImpl {","        data: Vec<u8>,","        position: usize,","    }","","    unsafe impl BufMut for BufMutImpl {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.position","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            // This will be a stub, as this test doesn't use it.","            unimplemented!()","        }","    }","","    let mut buf_a = BufMutImpl {","        data: vec![1, 2, 3, 4, 5],","        position: 0,","    };","    let mut buf_b = BufMutImpl {","        data: vec![6, 7, 8, 9, 10],","        position: 0,","    };","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(5);","    }","","    assert_eq!(chain.a.position, 5);","    assert_eq!(chain.b.position, 0);","}"],[210,211,212,213,214,215,216,226]],[["{","    struct BufMutImpl {","        data: Vec<u8>,","        position: usize,","    }","","    unsafe impl BufMut for BufMutImpl {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.position","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            // This will be a stub, as this test doesn't use it.","            unimplemented!()","        }","    }","","    let mut buf_a = BufMutImpl {","        data: vec![1, 2, 3, 4, 5],","        position: 0,","    };","    let mut buf_b = BufMutImpl {","        data: vec![6, 7, 8, 9, 10],","        position: 0,","    };","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(3);","    }","","    assert_eq!(chain.a.position, 3);","    assert_eq!(chain.b.position, 0);","}"],[210,211,212,213,214,215,216,226]],[["{","    struct BufMutImpl {","        data: Vec<u8>,","        position: usize,","    }","","    unsafe impl BufMut for BufMutImpl {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.position","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            // This will be a stub, as this test doesn't use it.","            unimplemented!()","        }","    }","","    let mut buf_a = BufMutImpl {","        data: vec![1, 2, 3, 4, 5],","        position: 5, // position points to the end","    };","    let mut buf_b = BufMutImpl {","        data: vec![6, 7, 8, 9, 10],","        position: 0,","    };","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(5);","    }","","    assert_eq!(chain.a.position, 5);","    assert_eq!(chain.b.position, 5); // All of b should be advanced","}"],[210,211,212,213,223,225,226]],[["{","    struct MockBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for MockBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.remaining = self.remaining.saturating_sub(cnt);","        }","    }","","    let mut buf_a = MockBufMut { remaining: 10 };","    let mut buf_b = MockBufMut { remaining: 0 };","","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(15);","    }","","    // Check the state after advance_mut","    assert_eq!(chain.a.remaining_mut(), 0); // a should be consumed completely","    assert_eq!(chain.b.remaining_mut(), 0); // b should still be unmodified","}"],[210,211,212,213,214,217,218,219,220,221,222,225,226]],[["{","    struct MockBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for MockBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.remaining = self.remaining.saturating_sub(cnt);","        }","    }","","    let mut buf_a = MockBufMut { remaining: 0 }; // A consumed","    let mut buf_b = MockBufMut { remaining: 20 }; // B has remaining bytes","","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(5);","    }","","    // Check the state after advance_mut","    assert_eq!(chain.a.remaining_mut(), 0); // a remains consumed","    assert_eq!(chain.b.remaining_mut(), 15); // b should have decreased","}"],[210,211,212,213,223,225,226]],[["{","    struct MockBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for MockBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.remaining = self.remaining.saturating_sub(cnt);","        }","    }","","    let mut buf_a = MockBufMut { remaining: 15 };","    let mut buf_b = MockBufMut { remaining: 5 };","","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(15);","    }","","    // Check state after advance_mut","    assert_eq!(chain.a.remaining_mut(), 0); // a should be fully advanced","    assert_eq!(chain.b.remaining_mut(), 5); // b remains unchanged","}"],[210,211,212,213,214,215,216,226]],[["{","    struct TestBuf {","        remaining: usize,","    }","","    unsafe impl BufMut for TestBuf {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            // Placeholder implementation","            unimplemented!()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            // Decrement the remaining count without going below zero","            if cnt <= self.remaining {","                self.remaining -= cnt;","            } else {","                self.remaining = 0;","            }","        }","    }","","    let buf_a = TestBuf { remaining: 0 };","    let mut buf_b = TestBuf { remaining: 10 }; // b has remaining bytes","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(5);","    }","    ","    // Check that buffer b has now 5 remaining since a had none to consume","    assert_eq!(chain.b.remaining_mut(), 5);","}"],[210,211,212,213,223,225,226]]],"codes_branches":[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":true,"negative":true},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct BufMutImpl {","        data: Vec<u8>,","        position: usize,","    }","","    unsafe impl BufMut for BufMutImpl {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.position","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            // This will be a stub, as this test doesn't use it.","            unimplemented!()","        }","    }","","    let mut buf_a = BufMutImpl {","        data: vec![1, 2, 3, 4, 5],","        position: 0,","    };","    let mut buf_b = BufMutImpl {","        data: vec![6, 7, 8, 9, 10],","        position: 0,","    };","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(5);","    }","","    assert_eq!(chain.a.position, 5);","    assert_eq!(chain.b.position, 0);","}"],[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":true,"negative":false},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":true,"negative":false}]],[["{","    struct BufMutImpl {","        data: Vec<u8>,","        position: usize,","    }","","    unsafe impl BufMut for BufMutImpl {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.position","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            // This will be a stub, as this test doesn't use it.","            unimplemented!()","        }","    }","","    let mut buf_a = BufMutImpl {","        data: vec![1, 2, 3, 4, 5],","        position: 0,","    };","    let mut buf_b = BufMutImpl {","        data: vec![6, 7, 8, 9, 10],","        position: 0,","    };","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(3);","    }","","    assert_eq!(chain.a.position, 3);","    assert_eq!(chain.b.position, 0);","}"],[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":true,"negative":false},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":true,"negative":false}]],[["{","    struct BufMutImpl {","        data: Vec<u8>,","        position: usize,","    }","","    unsafe impl BufMut for BufMutImpl {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.position","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            // This will be a stub, as this test doesn't use it.","            unimplemented!()","        }","    }","","    let mut buf_a = BufMutImpl {","        data: vec![1, 2, 3, 4, 5],","        position: 5, // position points to the end","    };","    let mut buf_b = BufMutImpl {","        data: vec![6, 7, 8, 9, 10],","        position: 0,","    };","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(5);","    }","","    assert_eq!(chain.a.position, 5);","    assert_eq!(chain.b.position, 5); // All of b should be advanced","}"],[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":false,"negative":true},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":false,"negative":false}]],[["{","    struct MockBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for MockBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.remaining = self.remaining.saturating_sub(cnt);","        }","    }","","    let mut buf_a = MockBufMut { remaining: 10 };","    let mut buf_b = MockBufMut { remaining: 0 };","","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(15);","    }","","    // Check the state after advance_mut","    assert_eq!(chain.a.remaining_mut(), 0); // a should be consumed completely","    assert_eq!(chain.b.remaining_mut(), 0); // b should still be unmodified","}"],[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":true,"negative":false},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":false,"negative":true}]],[["{","    struct MockBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for MockBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.remaining = self.remaining.saturating_sub(cnt);","        }","    }","","    let mut buf_a = MockBufMut { remaining: 0 }; // A consumed","    let mut buf_b = MockBufMut { remaining: 20 }; // B has remaining bytes","","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(5);","    }","","    // Check the state after advance_mut","    assert_eq!(chain.a.remaining_mut(), 0); // a remains consumed","    assert_eq!(chain.b.remaining_mut(), 15); // b should have decreased","}"],[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":false,"negative":true},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":false,"negative":false}]],[["{","    struct MockBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for MockBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.remaining = self.remaining.saturating_sub(cnt);","        }","    }","","    let mut buf_a = MockBufMut { remaining: 15 };","    let mut buf_b = MockBufMut { remaining: 5 };","","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(15);","    }","","    // Check state after advance_mut","    assert_eq!(chain.a.remaining_mut(), 0); // a should be fully advanced","    assert_eq!(chain.b.remaining_mut(), 5); // b remains unchanged","}"],[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":true,"negative":false},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":true,"negative":false}]],[["{","    struct TestBuf {","        remaining: usize,","    }","","    unsafe impl BufMut for TestBuf {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            // Placeholder implementation","            unimplemented!()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            // Decrement the remaining count without going below zero","            if cnt <= self.remaining {","                self.remaining -= cnt;","            } else {","                self.remaining = 0;","            }","        }","    }","","    let buf_a = TestBuf { remaining: 0 };","    let mut buf_b = TestBuf { remaining: 10 }; // b has remaining bytes","    let mut chain = Chain { a: buf_a, b: buf_b };","","    unsafe {","        chain.advance_mut(5);","    }","    ","    // Check that buffer b has now 5 remaining since a had none to consume","    assert_eq!(chain.b.remaining_mut(), 5);","}"],[{"start_line":213,"start_column":12,"end_line":213,"end_column":22,"positive":false,"negative":true},{"start_line":214,"start_column":16,"end_line":214,"end_column":28,"positive":false,"negative":false}]]]}