{"function_name":"bytes::buf::chain::<buf::chain::Chain<T, U> as buf::buf_impl::Buf>::advance","tests":6,"tests_lines":[119,119,29,29,27,62],"oracles":6,"oracles_compiled":4,"oracles_compiled_rate":66.66666666666666,"tests_compiled":4,"tests_compiled_rate":66.66666666666666,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":4,"tests_passed":2,"tests_passed_rate":50.0,"lines":16,"lines_covered":16,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","    }","","    let buf_a = TestBuf { data: vec![1, 2, 3], position: 0 };","    let buf_b = TestBuf { data: vec![4, 5, 6], position: 0 };","    let mut chain_buf = Chain { a: buf_a, b: buf_b };","","    // a_rem (3) >= cnt (2)","    chain_buf.advance(2);","    assert_eq!(chain_buf.a.position, 2);","    assert_eq!(chain_buf.b.position, 0);","}"],[147,148,149,150,151,152,153,163]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","    }","","    let buf_a = TestBuf { data: vec![1, 2], position: 0 };","    let buf_b = TestBuf { data: vec![3, 4, 5], position: 0 };","    let mut chain_buf = Chain { a: buf_a, b: buf_b };","","    // a_rem (2) < cnt (3)","    chain_buf.advance(3);","    assert_eq!(chain_buf.a.position, 2); // a should be fully advanced","    assert_eq!(chain_buf.b.position, 1); // b should be advanced by 1","}"],[147,148,149,150,151,154,155,156,157,158,159,162,163]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            0","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","    }","","    let buf_a = TestBuf { data: vec![1], position: 0 };","    let buf_b = TestBuf { data: vec![2, 3, 4], position: 0 };","    let mut chain_buf = Chain { a: buf_a, b: buf_b };","","    // This will panic since a's remaining is 0","    chain_buf.advance(1);","}"],[147,148,149,150,160,162,163]],[["{","    struct EmptyBuf;","    ","    impl Buf for EmptyBuf {","        fn remaining(&self) -> usize {","            0","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, _: usize) {}","        fn has_remaining(&self) -> bool {","            false","        }","        fn copy_to_slice(&mut self, _: &mut [u8]) {}","        fn get_u8(&mut self) -> u8 {","            panic!(\"Should not be called\");","        }","        // Other methods would also need to be implemented, but are not needed for this test.","    }","","    struct SimpleBuf {","        remaining: usize,","    }","    ","    impl Buf for SimpleBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, cnt: usize) {","            if cnt <= self.remaining {","                self.remaining -= cnt;","            } else {","                self.remaining = 0;","            }","        }","        fn has_remaining(&self) -> bool {","            self.remaining > 0","        }","        fn copy_to_slice(&mut self, _: &mut [u8]) {}","        fn get_u8(&mut self) -> u8 {","            panic!(\"Should not be called\");","        }","        // Other methods would also need to be implemented, but are not needed for this test.","    }","    ","    let empty_buf = EmptyBuf;","    let mut simple_buf = SimpleBuf { remaining: 10 };","    let mut chain_buf = Chain {","        a: empty_buf,","        b: simple_buf,","    };","    ","    // Testing advancing with an arbitrary value","    chain_buf.advance(5);","    ","    assert_eq!(chain_buf.b.remaining(), 10);  // b should remain unchanged","    assert!(!chain_buf.a.has_remaining()); // a should have no remaining","}"],[147,148,149,150,160,162,163]]],"codes_branches":[{"start_line":150,"start_column":12,"end_line":150,"end_column":22,"positive":true,"negative":true},{"start_line":151,"start_column":16,"end_line":151,"end_column":28,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","    }","","    let buf_a = TestBuf { data: vec![1, 2, 3], position: 0 };","    let buf_b = TestBuf { data: vec![4, 5, 6], position: 0 };","    let mut chain_buf = Chain { a: buf_a, b: buf_b };","","    // a_rem (3) >= cnt (2)","    chain_buf.advance(2);","    assert_eq!(chain_buf.a.position, 2);","    assert_eq!(chain_buf.b.position, 0);","}"],[{"start_line":150,"start_column":12,"end_line":150,"end_column":22,"positive":true,"negative":false},{"start_line":151,"start_column":16,"end_line":151,"end_column":28,"positive":true,"negative":false}]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","    }","","    let buf_a = TestBuf { data: vec![1, 2], position: 0 };","    let buf_b = TestBuf { data: vec![3, 4, 5], position: 0 };","    let mut chain_buf = Chain { a: buf_a, b: buf_b };","","    // a_rem (2) < cnt (3)","    chain_buf.advance(3);","    assert_eq!(chain_buf.a.position, 2); // a should be fully advanced","    assert_eq!(chain_buf.b.position, 1); // b should be advanced by 1","}"],[{"start_line":150,"start_column":12,"end_line":150,"end_column":22,"positive":true,"negative":false},{"start_line":151,"start_column":16,"end_line":151,"end_column":28,"positive":false,"negative":true}]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            0","        }","","        fn chunk(&self) -> &[u8] {","            &[]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","    }","","    let buf_a = TestBuf { data: vec![1], position: 0 };","    let buf_b = TestBuf { data: vec![2, 3, 4], position: 0 };","    let mut chain_buf = Chain { a: buf_a, b: buf_b };","","    // This will panic since a's remaining is 0","    chain_buf.advance(1);","}"],[{"start_line":150,"start_column":12,"end_line":150,"end_column":22,"positive":false,"negative":true},{"start_line":151,"start_column":16,"end_line":151,"end_column":28,"positive":false,"negative":false}]],[["{","    struct EmptyBuf;","    ","    impl Buf for EmptyBuf {","        fn remaining(&self) -> usize {","            0","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, _: usize) {}","        fn has_remaining(&self) -> bool {","            false","        }","        fn copy_to_slice(&mut self, _: &mut [u8]) {}","        fn get_u8(&mut self) -> u8 {","            panic!(\"Should not be called\");","        }","        // Other methods would also need to be implemented, but are not needed for this test.","    }","","    struct SimpleBuf {","        remaining: usize,","    }","    ","    impl Buf for SimpleBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, cnt: usize) {","            if cnt <= self.remaining {","                self.remaining -= cnt;","            } else {","                self.remaining = 0;","            }","        }","        fn has_remaining(&self) -> bool {","            self.remaining > 0","        }","        fn copy_to_slice(&mut self, _: &mut [u8]) {}","        fn get_u8(&mut self) -> u8 {","            panic!(\"Should not be called\");","        }","        // Other methods would also need to be implemented, but are not needed for this test.","    }","    ","    let empty_buf = EmptyBuf;","    let mut simple_buf = SimpleBuf { remaining: 10 };","    let mut chain_buf = Chain {","        a: empty_buf,","        b: simple_buf,","    };","    ","    // Testing advancing with an arbitrary value","    chain_buf.advance(5);","    ","    assert_eq!(chain_buf.b.remaining(), 10);  // b should remain unchanged","    assert!(!chain_buf.a.has_remaining()); // a should have no remaining","}"],[{"start_line":150,"start_column":12,"end_line":150,"end_column":22,"positive":false,"negative":true},{"start_line":151,"start_column":16,"end_line":151,"end_column":28,"positive":false,"negative":false}]]]}