{"function_name":"bytes::buf::writer::buf::writer::Writer<B>::get_mut","tests":2,"tests_lines":[45,46],"oracles":2,"oracles_compiled":1,"oracles_compiled_rate":50.0,"tests_compiled":1,"tests_compiled_rate":50.0,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[52,53,54],"codes_lines_covered":[[["{","  struct MockBufMut {","      data: Vec<u8>,","  }","  ","  unsafe impl BufMut for MockBufMut {","       fn remaining_mut(&self) -> usize {","           self.data.capacity() - self.data.len()","       }","","       unsafe fn advance_mut(&mut self, cnt: usize) {","           self.data.resize(self.data.len() + cnt, 0);","       }","","       fn has_remaining_mut(&self) -> bool {","           self.remaining_mut() > 0","       }","","       fn chunk_mut(&mut self) -> &mut crate::buf::UninitSlice {","           unimplemented!()","       }","","       fn put_slice(&mut self, _src: &[u8]) {","           unimplemented!()","       }","       ","       fn put_bytes(&mut self, val: u8, cnt: usize) {","           self.data.extend(vec![val; cnt]);","       }","","       fn put_u8(&mut self, n: u8) {","           self.data.push(n);","       }","       ","       // Other trait methods omitted for brevity","   }","","   let mut mock_buf = MockBufMut { data: Vec::new() };","   unsafe {","       mock_buf.advance_mut(1024);","   }","   let mut writer = Writer { buf: mock_buf };","","   let buf_mut = writer.get_mut();","   assert_eq!(buf_mut.remaining_mut(), 1024);","}"],[52,53,54]]],"codes_branches":[],"codes_branches_covered":[[["{","  struct MockBufMut {","      data: Vec<u8>,","  }","  ","  unsafe impl BufMut for MockBufMut {","       fn remaining_mut(&self) -> usize {","           self.data.capacity() - self.data.len()","       }","","       unsafe fn advance_mut(&mut self, cnt: usize) {","           self.data.resize(self.data.len() + cnt, 0);","       }","","       fn has_remaining_mut(&self) -> bool {","           self.remaining_mut() > 0","       }","","       fn chunk_mut(&mut self) -> &mut crate::buf::UninitSlice {","           unimplemented!()","       }","","       fn put_slice(&mut self, _src: &[u8]) {","           unimplemented!()","       }","       ","       fn put_bytes(&mut self, val: u8, cnt: usize) {","           self.data.extend(vec![val; cnt]);","       }","","       fn put_u8(&mut self, n: u8) {","           self.data.push(n);","       }","       ","       // Other trait methods omitted for brevity","   }","","   let mut mock_buf = MockBufMut { data: Vec::new() };","   unsafe {","       mock_buf.advance_mut(1024);","   }","   let mut writer = Writer { buf: mock_buf };","","   let buf_mut = writer.get_mut();","   assert_eq!(buf_mut.remaining_mut(), 1024);","}"],[]]]}