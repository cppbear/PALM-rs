{"function_name":"bytes::buf::limit::<buf::limit::Limit<T> as buf::buf_mut::BufMut>::remaining_mut","tests":4,"tests_lines":[22,22,22,22],"oracles":4,"oracles_compiled":2,"oracles_compiled_rate":50.0,"tests_compiled":2,"tests_compiled_rate":50.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[60,61,62],"codes_lines_covered":[[["{","    struct TestBufMut {","        remaining: usize,","    }","    ","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","           fn chunk_mut(&mut self) -> &mut UninitSlice {","               let slice: &mut [u8] = &mut [];","               UninitSlice::new(slice)","        }","        unsafe fn advance_mut(&mut self, _: usize) {","            // Dummy implementation","        }","    }","","    let buffer = TestBufMut { remaining: 0 };","    let limited_buffer = Limit { inner: buffer, limit: 0 };","    assert_eq!(limited_buffer.remaining_mut(), 0);","}"],[60,61,62]],[["{","    struct TestBufMut {","        remaining: usize,","    }","    ","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","       fn chunk_mut(&mut self) -> &mut UninitSlice {  ","           let bytes = &mut [0u8; 0];  ","           UninitSlice::new(bytes)  ","        }","        unsafe fn advance_mut(&mut self, _: usize) {","            // Dummy implementation","        }","    }","","    let buffer = TestBufMut { remaining: 5 };","    let limited_buffer = Limit { inner: buffer, limit: 10 };","    assert_eq!(limited_buffer.remaining_mut(), 5);","}"],[60,61,62]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBufMut {","        remaining: usize,","    }","    ","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","           fn chunk_mut(&mut self) -> &mut UninitSlice {","               let slice: &mut [u8] = &mut [];","               UninitSlice::new(slice)","        }","        unsafe fn advance_mut(&mut self, _: usize) {","            // Dummy implementation","        }","    }","","    let buffer = TestBufMut { remaining: 0 };","    let limited_buffer = Limit { inner: buffer, limit: 0 };","    assert_eq!(limited_buffer.remaining_mut(), 0);","}"],[]],[["{","    struct TestBufMut {","        remaining: usize,","    }","    ","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","       fn chunk_mut(&mut self) -> &mut UninitSlice {  ","           let bytes = &mut [0u8; 0];  ","           UninitSlice::new(bytes)  ","        }","        unsafe fn advance_mut(&mut self, _: usize) {","            // Dummy implementation","        }","    }","","    let buffer = TestBufMut { remaining: 5 };","    let limited_buffer = Limit { inner: buffer, limit: 10 };","    assert_eq!(limited_buffer.remaining_mut(), 5);","}"],[]]]}