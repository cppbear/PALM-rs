{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::advance_unchecked","tests":17,"tests_lines":[13,12,10,7,8,8,29,7,7,8,7,8,9,12,6,4,7],"oracles":17,"oracles_compiled":17,"oracles_compiled_rate":100.0,"tests_compiled":17,"tests_compiled_rate":100.0,"oracles_run":17,"oracles_passed":9,"oracles_passed_rate":52.94117647058824,"tests_run":17,"tests_passed":9,"tests_passed_rate":52.94117647058824,"lines":27,"lines_covered":20,"lines_coveraged_rate":74.07407407407408,"branches":6,"branches_covered":4,"branches_coverage_rate":66.66666666666666,"codes_lines":[956,957,958,959,960,961,962,963,965,966,967,972,973,974,975,976,977,978,979,980,981,982,983,988,989,990,991],"codes_lines_covered":[[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    let initial_ptr = bytes_mut.ptr;","    bytes_mut.len = 10;","    bytes_mut.cap = 10;","    let count = 5;","    unsafe { bytes_mut.advance_unchecked(count) };","","    assert_eq!(bytes_mut.len, 5);","    assert_eq!(bytes_mut.cap, 5);","    assert_ne!(bytes_mut.ptr, initial_ptr); ","    assert!(bytes_mut.ptr.as_ptr() > initial_ptr.as_ptr());","}"],[956,957,958,959,961,962,963,965,966,967,972,973,974,975,976,988,989,990,991]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    bytes_mut.len = 10;","    bytes_mut.cap = 10;","    let initial_len = bytes_mut.len;","    let initial_cap = bytes_mut.cap;","","    unsafe { bytes_mut.advance_unchecked(0) };","","    assert_eq!(bytes_mut.len, initial_len);","    assert_eq!(bytes_mut.cap, initial_cap);","}"],[956,957,958,959,960,991]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    bytes_mut.len = 10;","    bytes_mut.cap = 10;","    let large_count = 10; // Should trigger promotion","    unsafe { bytes_mut.advance_unchecked(large_count) };","","    // Ensure that the internal state indicates promotion to shared","    assert!(bytes_mut.kind() == KIND_ARC); // Assuming how kind is checked for ARC","}"],[956,957,958,959,961,962,963,965,966,967,972,973,974,975,976,988,989,990,991]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    bytes_mut.len = 10;","    bytes_mut.cap = 10;","    let count = 15; // Out of bounds","    unsafe { bytes_mut.advance_unchecked(count) };","}"],[956,957,958,959,961,962,963]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    unsafe {","        bytes_mut.advance_unchecked(0);","    }","    assert_eq!(bytes_mut.len(), 10);","    assert_eq!(bytes_mut.capacity(), 10);","}"],[956,957,958,959,960,991]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    unsafe {","        bytes_mut.advance_unchecked(10);","    }","    assert_eq!(bytes_mut.len(), 0);","    assert_eq!(bytes_mut.capacity(), 0);","}"],[956,957,958,959,961,962,963,965,966,967,972,973,974,975,976,988,989,990,991]],[["{","    struct VecWrapper {","        bytes_mut: BytesMut,","    }","","    impl VecWrapper {","        fn new() -> VecWrapper {","            let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","            unsafe { bytes_mut.set_vec_pos(2) }; // Set initial position","","            VecWrapper { bytes_mut }","        }","","        fn set_cap_and_advance(&mut self, count: usize) {","            // Assuming the capacity is at least 10 for this example","            unsafe {","                self.bytes_mut.advance_unchecked(count);","            }","        }","    }","","    let mut wrapper = VecWrapper::new();","    let original_capacity = wrapper.bytes_mut.capacity();","    let max_vec_pos = usize::MAX >> 5; // Assuming the original provided shift","    wrapper.set_cap_and_advance(max_vec_pos - 2); // Advancing to exactly MAX_VEC_POS","","    assert_eq!(wrapper.bytes_mut.len(), 0);","    assert_eq!(wrapper.bytes_mut.capacity(), original_capacity - (max_vec_pos - 2));","}"],[]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    unsafe {","        bytes_mut.advance_unchecked(0);","    }","    assert_eq!(bytes_mut.len(), 10);","}"],[956,957,958,959,960,991]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    unsafe {","        bytes_mut.advance_unchecked(10);","    }","    assert_eq!(bytes_mut.len(), 0);","}"],[956,957,958,959,961,962,963,965,966,967,972,973,974,975,976,988,989,990,991]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(5) };","    unsafe {","        // Simulating a condition where position exceeds MAX_VEC_POS","        bytes_mut.set_vec_pos(MAX_VEC_POS); // This must happen before advance_unchecked","        bytes_mut.advance_unchecked(10); // This should trigger panic","    }","}"],[]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(20) };","    unsafe {","        bytes_mut.advance_unchecked(5);","    }","    assert_eq!(bytes_mut.len(), 15);","}"],[956,957,958,959,961,962,963,965,966,967,972,973,974,975,976,988,989,990,991]],[["{","    let mut buffer = unsafe { BytesMut::with_capacity(10) }; // Initialize with some capacity","    unsafe {","        buffer.advance_unchecked(0); // Should return early","    }","    assert_eq!(buffer.len(), 0); // Ensure length remains unchanged","    assert_eq!(buffer.capacity(), 10); // Ensure capacity remains unchanged","}"],[956,957,958,959,960,991]],[["{","    let mut buffer = unsafe { BytesMut::with_capacity(5) }; // Initialize with capacity 5","    unsafe {","        buffer.resize(5, 0); // Resize to use full capacity","        buffer.advance_unchecked(5); // Advance by full capacity","    }","    assert_eq!(buffer.len(), 0); // All length should be consumed","    assert_eq!(buffer.capacity(), 5); // Capacity should remain unchanged","}"],[956,957,958,959,961,962,963,965,966,967,972,973,974,975,976,988,989,990,991]],[["{","    // Since we can't directly set the kind, we will create a `BytesMut` in a non-vec state and ensure the call does not panic.","    // Assuming BytesMut::new() creates a state where kind is not KIND_VEC.","    let mut buffer = BytesMut::new();","    buffer.reserve(10); // Reserve some capacity","    // Advance with count < cap, ensuring we are in a non-kind vec state.","    unsafe {","        buffer.advance_unchecked(1); // This should succeed as `kind` is not KIND_VEC","    }","    assert_eq!(buffer.len(), 0); // Length should remain unchanged","    assert_eq!(buffer.capacity(), 10); // Capacity should remain unchanged","}"],[956,957,958,959,961,962,963,965,966,967,972,973,974,975,976,988,989,990,991]],[["{","    let mut buffer = unsafe { BytesMut::with_capacity(10) };","    unsafe { buffer.advance_unchecked(0) };","    assert_eq!(buffer.len(), 0);","    assert_eq!(buffer.cap, 10);","}"],[956,957,958,959,960,991]],[["{","    let mut buffer = unsafe { BytesMut::with_capacity(5) };","    unsafe { buffer.advance_unchecked(6) };","}"],[956,957,958,959,961,962,963]],[["{","    let mut buffer = unsafe { BytesMut::with_capacity(10) };","    unsafe { buffer.set_len(10) }; // Set length to match capacity","    unsafe { buffer.advance_unchecked(5) };","    assert_eq!(buffer.len(), 5);","    assert_eq!(buffer.cap, 5);","}"],[956,957,958,959,961,962,963,965,966,967,972,973,974,975,976,988,989,990,991]]],"codes_branches":[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":true,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":true,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    let initial_ptr = bytes_mut.ptr;","    bytes_mut.len = 10;","    bytes_mut.cap = 10;","    let count = 5;","    unsafe { bytes_mut.advance_unchecked(count) };","","    assert_eq!(bytes_mut.len, 5);","    assert_eq!(bytes_mut.cap, 5);","    assert_ne!(bytes_mut.ptr, initial_ptr); ","    assert!(bytes_mut.ptr.as_ptr() > initial_ptr.as_ptr());","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":true,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":true,"negative":false}]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    bytes_mut.len = 10;","    bytes_mut.cap = 10;","    let initial_len = bytes_mut.len;","    let initial_cap = bytes_mut.cap;","","    unsafe { bytes_mut.advance_unchecked(0) };","","    assert_eq!(bytes_mut.len, initial_len);","    assert_eq!(bytes_mut.cap, initial_cap);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":true,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    bytes_mut.len = 10;","    bytes_mut.cap = 10;","    let large_count = 10; // Should trigger promotion","    unsafe { bytes_mut.advance_unchecked(large_count) };","","    // Ensure that the internal state indicates promotion to shared","    assert!(bytes_mut.kind() == KIND_ARC); // Assuming how kind is checked for ARC","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":true,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":true,"negative":false}]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    bytes_mut.len = 10;","    bytes_mut.cap = 10;","    let count = 15; // Out of bounds","    unsafe { bytes_mut.advance_unchecked(count) };","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    unsafe {","        bytes_mut.advance_unchecked(0);","    }","    assert_eq!(bytes_mut.len(), 10);","    assert_eq!(bytes_mut.capacity(), 10);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":true,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    unsafe {","        bytes_mut.advance_unchecked(10);","    }","    assert_eq!(bytes_mut.len(), 0);","    assert_eq!(bytes_mut.capacity(), 0);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":true,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":true,"negative":false}]],[["{","    struct VecWrapper {","        bytes_mut: BytesMut,","    }","","    impl VecWrapper {","        fn new() -> VecWrapper {","            let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","            unsafe { bytes_mut.set_vec_pos(2) }; // Set initial position","","            VecWrapper { bytes_mut }","        }","","        fn set_cap_and_advance(&mut self, count: usize) {","            // Assuming the capacity is at least 10 for this example","            unsafe {","                self.bytes_mut.advance_unchecked(count);","            }","        }","    }","","    let mut wrapper = VecWrapper::new();","    let original_capacity = wrapper.bytes_mut.capacity();","    let max_vec_pos = usize::MAX >> 5; // Assuming the original provided shift","    wrapper.set_cap_and_advance(max_vec_pos - 2); // Advancing to exactly MAX_VEC_POS","","    assert_eq!(wrapper.bytes_mut.len(), 0);","    assert_eq!(wrapper.bytes_mut.capacity(), original_capacity - (max_vec_pos - 2));","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    unsafe {","        bytes_mut.advance_unchecked(0);","    }","    assert_eq!(bytes_mut.len(), 10);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":true,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };","    unsafe {","        bytes_mut.advance_unchecked(10);","    }","    assert_eq!(bytes_mut.len(), 0);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":true,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":true,"negative":false}]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(5) };","    unsafe {","        // Simulating a condition where position exceeds MAX_VEC_POS","        bytes_mut.set_vec_pos(MAX_VEC_POS); // This must happen before advance_unchecked","        bytes_mut.advance_unchecked(10); // This should trigger panic","    }","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut bytes_mut = unsafe { BytesMut::with_capacity(20) };","    unsafe {","        bytes_mut.advance_unchecked(5);","    }","    assert_eq!(bytes_mut.len(), 15);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":true,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":true,"negative":false}]],[["{","    let mut buffer = unsafe { BytesMut::with_capacity(10) }; // Initialize with some capacity","    unsafe {","        buffer.advance_unchecked(0); // Should return early","    }","    assert_eq!(buffer.len(), 0); // Ensure length remains unchanged","    assert_eq!(buffer.capacity(), 10); // Ensure capacity remains unchanged","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":true,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut buffer = unsafe { BytesMut::with_capacity(5) }; // Initialize with capacity 5","    unsafe {","        buffer.resize(5, 0); // Resize to use full capacity","        buffer.advance_unchecked(5); // Advance by full capacity","    }","    assert_eq!(buffer.len(), 0); // All length should be consumed","    assert_eq!(buffer.capacity(), 5); // Capacity should remain unchanged","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":true,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":true,"negative":false}]],[["{","    // Since we can't directly set the kind, we will create a `BytesMut` in a non-vec state and ensure the call does not panic.","    // Assuming BytesMut::new() creates a state where kind is not KIND_VEC.","    let mut buffer = BytesMut::new();","    buffer.reserve(10); // Reserve some capacity","    // Advance with count < cap, ensuring we are in a non-kind vec state.","    unsafe {","        buffer.advance_unchecked(1); // This should succeed as `kind` is not KIND_VEC","    }","    assert_eq!(buffer.len(), 0); // Length should remain unchanged","    assert_eq!(buffer.capacity(), 10); // Capacity should remain unchanged","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":true,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":true,"negative":false}]],[["{","    let mut buffer = unsafe { BytesMut::with_capacity(10) };","    unsafe { buffer.advance_unchecked(0) };","    assert_eq!(buffer.len(), 0);","    assert_eq!(buffer.cap, 10);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":true,"negative":false},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut buffer = unsafe { BytesMut::with_capacity(5) };","    unsafe { buffer.advance_unchecked(6) };","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":false,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut buffer = unsafe { BytesMut::with_capacity(10) };","    unsafe { buffer.set_len(10) }; // Set length to match capacity","    unsafe { buffer.advance_unchecked(5) };","    assert_eq!(buffer.len(), 5);","    assert_eq!(buffer.cap, 5);","}"],[{"start_line":959,"start_column":12,"end_line":959,"end_column":22,"positive":false,"negative":true},{"start_line":967,"start_column":12,"end_line":967,"end_column":28,"positive":true,"negative":false},{"start_line":974,"start_column":16,"end_line":974,"end_column":34,"positive":true,"negative":false}]]]}