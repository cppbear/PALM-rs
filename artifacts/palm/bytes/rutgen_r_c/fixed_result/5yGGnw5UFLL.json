{"function_name":"bytes::buf::take::buf::take::Take<T>::set_limit","tests":4,"tests_lines":[25,24,23,32],"oracles":4,"oracles_compiled":1,"oracles_compiled_rate":25.0,"tests_compiled":1,"tests_compiled_rate":25.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[130,131,132],"codes_lines_covered":[[["{","   struct MockBuf {","       data: &'static [u8],","       pos: usize,","   }","","   impl MockBuf {","       fn new(data: &'static [u8]) -> Self {","           Self { data, pos: 0 }","       }","   }","","   impl Buf for MockBuf {","       fn remaining(&self) -> usize {","           self.data.len() - self.pos","       }","       fn chunk(&self) -> &[u8] {","           &self.data[self.pos..]","       }","       fn advance(&mut self, cnt: usize) {","           self.pos += cnt;","       }","   }","","    let mut buf = Take {","        inner: MockBuf::new(b\"hello world\"),","        limit: 10,","    };","","    buf.set_limit(0);","    assert_eq!(buf.limit, 0);","}"],[130,131,132]]],"codes_branches":[],"codes_branches_covered":[[["{","   struct MockBuf {","       data: &'static [u8],","       pos: usize,","   }","","   impl MockBuf {","       fn new(data: &'static [u8]) -> Self {","           Self { data, pos: 0 }","       }","   }","","   impl Buf for MockBuf {","       fn remaining(&self) -> usize {","           self.data.len() - self.pos","       }","       fn chunk(&self) -> &[u8] {","           &self.data[self.pos..]","       }","       fn advance(&mut self, cnt: usize) {","           self.pos += cnt;","       }","   }","","    let mut buf = Take {","        inner: MockBuf::new(b\"hello world\"),","        limit: 10,","    };","","    buf.set_limit(0);","    assert_eq!(buf.limit, 0);","}"],[]]]}