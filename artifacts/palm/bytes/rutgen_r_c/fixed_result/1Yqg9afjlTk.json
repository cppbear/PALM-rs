{"function_name":"bytes::bytes_mut::<bytes_mut::BytesMut as core::ops::Deref>::deref","tests":2,"tests_lines":[34,34],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":2,"tests_passed":0,"tests_passed_rate":0.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1242,1243,1244],"codes_lines_covered":[[["{","#[should_panic]","fn test_deref_with_invalid_pointer() {","   let shared = Shared {","       vec: vec![], // changed buf to vec, initialized with an empty vector","       original_capacity_repr: KIND_VEC,","       ref_count: AtomicUsize::new(1), // for consistency, replaced ref_cnt with ref_count ","   };","","   let bytes_mut = BytesMut {","       ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(), // updated from shared.buf to shared.vec","       len: 0,","       cap: 0,","        data: &shared as *const Shared as *mut Shared,","    };","","    let _result = bytes_mut.deref(); // This should panic due to dereferencing a null pointer ","}","   let shared = Shared {","       vec: vec![1, 2, 3, 4, 5],","       original_capacity_repr: KIND_VEC,","       ref_count: AtomicUsize::new(1), ","   };","","   let bytes_mut = BytesMut {","       ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),","       len: shared.vec.len(),","       cap: shared.vec.capacity(),","       data: &shared as *const Shared as *mut Shared,","   };","","    let result = bytes_mut.deref();","    assert_eq!(result, &[1, 2, 3, 4, 5]);","}"],[]],[["{","#[should_panic]","fn test_deref_with_invalid_pointer() {","   let shared = Shared {  ","       vec: vec![],  ","       original_capacity_repr: KIND_VEC,  ","       ref_count: AtomicUsize::new(1),  ","   };  "," ","   let bytes_mut = BytesMut {  ","       ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),  ","       len: 0,  ","       cap: shared.vec.capacity(),  ","       data: &shared as *const Shared as *mut Shared,  ","   };  ","","    let _result = bytes_mut.deref(); // This should panic due to dereferencing a null pointer ","}","    let shared = Shared {","        vec: vec![],","        original_capacity_repr: KIND_VEC,","        ref_count: AtomicUsize::new(1),","    };","","    let bytes_mut = BytesMut {","        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),","        len: 0,","        cap: shared.vec.capacity(),","        data: &shared as *const Shared as *mut Shared,","    };","","    let result = bytes_mut.deref();","    assert_eq!(result, &[]);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","#[should_panic]","fn test_deref_with_invalid_pointer() {","   let shared = Shared {","       vec: vec![], // changed buf to vec, initialized with an empty vector","       original_capacity_repr: KIND_VEC,","       ref_count: AtomicUsize::new(1), // for consistency, replaced ref_cnt with ref_count ","   };","","   let bytes_mut = BytesMut {","       ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(), // updated from shared.buf to shared.vec","       len: 0,","       cap: 0,","        data: &shared as *const Shared as *mut Shared,","    };","","    let _result = bytes_mut.deref(); // This should panic due to dereferencing a null pointer ","}","   let shared = Shared {","       vec: vec![1, 2, 3, 4, 5],","       original_capacity_repr: KIND_VEC,","       ref_count: AtomicUsize::new(1), ","   };","","   let bytes_mut = BytesMut {","       ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),","       len: shared.vec.len(),","       cap: shared.vec.capacity(),","       data: &shared as *const Shared as *mut Shared,","   };","","    let result = bytes_mut.deref();","    assert_eq!(result, &[1, 2, 3, 4, 5]);","}"],[]],[["{","#[should_panic]","fn test_deref_with_invalid_pointer() {","   let shared = Shared {  ","       vec: vec![],  ","       original_capacity_repr: KIND_VEC,  ","       ref_count: AtomicUsize::new(1),  ","   };  "," ","   let bytes_mut = BytesMut {  ","       ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),  ","       len: 0,  ","       cap: shared.vec.capacity(),  ","       data: &shared as *const Shared as *mut Shared,  ","   };  ","","    let _result = bytes_mut.deref(); // This should panic due to dereferencing a null pointer ","}","    let shared = Shared {","        vec: vec![],","        original_capacity_repr: KIND_VEC,","        ref_count: AtomicUsize::new(1),","    };","","    let bytes_mut = BytesMut {","        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),","        len: 0,","        cap: shared.vec.capacity(),","        data: &shared as *const Shared as *mut Shared,","    };","","    let result = bytes_mut.deref();","    assert_eq!(result, &[]);","}"],[]]]}