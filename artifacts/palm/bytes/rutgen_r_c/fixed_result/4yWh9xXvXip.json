{"function_name":"bytes::buf::chain::<buf::chain::Chain<T, U> as buf::buf_impl::Buf>::copy_to_bytes","tests":8,"tests_lines":[44,44,58,55,57,54,45,45],"oracles":8,"oracles_compiled":5,"oracles_compiled_rate":62.5,"tests_compiled":5,"tests_compiled_rate":62.5,"oracles_run":5,"oracles_passed":3,"oracles_passed_rate":60.0,"tests_run":5,"tests_passed":3,"tests_passed_rate":60.0,"lines":15,"lines_covered":14,"lines_coveraged_rate":93.33333333333333,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[172,173,174,175,176,177,179,180,181,182,183,184,185,186,188],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","   fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {  ","       let bytes = self.data[self.position..self.position + len].to_vec();  ","       self.position += len;  ","       crate::Bytes::from(bytes)  ","   }  ","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","    }","","    let buf_a = TestBuf {","        data: vec![], // Empty","        position: 0,","    };","    let buf_b = TestBuf {","        data: vec![6, 7, 8, 9, 10],","        position: 0,","    };","    let mut chain_buf = Chain { a: buf_a, b: buf_b };","","    let result = chain_buf.copy_to_bytes(5);","    assert_eq!(result.len(), 5);","    assert_eq!(result.chunk(), &[6, 7, 8, 9, 10]);","}"],[172,173,174,176,177,188]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            let len = dst.len().min(self.remaining());","            dst[..len].copy_from_slice(&self.data[self.position..self.position + len]);","            self.advance(len);","        }","","        fn get_u8(&mut self) -> u8 {","            let byte = self.chunk()[0];","            self.advance(1);","            byte","        }","        ","        // Other required methods can be omitted for brevity.","    }","","    let buf_a = TestBuf {","        data: vec![1, 2, 3, 4],","        position: 0,","    };","","    let buf_b = TestBuf {","        data: vec![5, 6, 7, 8],","        position: 0,","    };","","    let mut chain_buf = Chain {","        a: buf_a,","        b: buf_b,","    };","","    let result = chain_buf.copy_to_bytes(6);","","    assert_eq!(result.len(), 6);","    assert_eq!(result.as_ref(), &[1, 2, 3, 4, 5, 6]);","}"],[172,173,174,176,179,180,181,182,183,184,185,186,188]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            let len = dst.len().min(self.remaining());","            dst[..len].copy_from_slice(&self.data[self.position..self.position + len]);","            self.advance(len);","        }","","        fn get_u8(&mut self) -> u8 {","            let byte = self.chunk()[0];","            self.advance(1);","            byte","        }","        ","        // Other required methods can be omitted for brevity.","    }","","    let buf_a = TestBuf {","        data: vec![1, 2],","        position: 0,","    };","","    let buf_b = TestBuf {","        data: vec![3, 4],","        position: 0,","    };","","    let mut chain_buf = Chain {","        a: buf_a,","        b: buf_b,","    };","","    chain_buf.copy_to_bytes(5); // This should panic","}"],[172,173,174,176,179,180,181,182]],[["{","    struct BufA {","        remaining: usize,","    }","","    impl Buf for BufA {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","           crate::Bytes::new()","       }","    }","","    struct BufB {","        remaining: usize,","    }","","    impl Buf for BufB {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, _: usize) {}","       fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","           crate::Bytes::new()","        }","    }","","    let a = BufA { remaining: 0 };","    let b = BufB { remaining: 2 };","    let mut chain = Chain::new(a, b);","    ","   let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","       chain.copy_to_bytes(3); // len = 3, which should trigger the assertion","   }));","    ","    assert!(result.is_err());","}"],[172,173,174,176,177,188]],[["{","    struct BufA {","        remaining: usize,","    }","","    impl Buf for BufA {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, _: usize) {}","       fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","           crate::Bytes::new()","       }","    }","","    struct BufB {","        remaining: usize,","    }","","    impl Buf for BufB {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, _: usize) {}","       fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","           crate::Bytes::new()","       }","    }","","    let a = BufA { remaining: 0 };","    let b = BufB { remaining: 0 };","    let mut chain = Chain::new(a, b);","","   let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","       chain.copy_to_bytes(1); // len = 1, should not find data to copy","   }));","   ","   assert!(result.is_err());","}"],[172,173,174,176,177,188]]],"codes_branches":[{"start_line":174,"start_column":12,"end_line":174,"end_column":24,"positive":false,"negative":true},{"start_line":176,"start_column":19,"end_line":176,"end_column":29,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","   fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {  ","       let bytes = self.data[self.position..self.position + len].to_vec();  ","       self.position += len;  ","       crate::Bytes::from(bytes)  ","   }  ","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","    }","","    let buf_a = TestBuf {","        data: vec![], // Empty","        position: 0,","    };","    let buf_b = TestBuf {","        data: vec![6, 7, 8, 9, 10],","        position: 0,","    };","    let mut chain_buf = Chain { a: buf_a, b: buf_b };","","    let result = chain_buf.copy_to_bytes(5);","    assert_eq!(result.len(), 5);","    assert_eq!(result.chunk(), &[6, 7, 8, 9, 10]);","}"],[{"start_line":174,"start_column":12,"end_line":174,"end_column":24,"positive":false,"negative":true},{"start_line":176,"start_column":19,"end_line":176,"end_column":29,"positive":true,"negative":false}]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            let len = dst.len().min(self.remaining());","            dst[..len].copy_from_slice(&self.data[self.position..self.position + len]);","            self.advance(len);","        }","","        fn get_u8(&mut self) -> u8 {","            let byte = self.chunk()[0];","            self.advance(1);","            byte","        }","        ","        // Other required methods can be omitted for brevity.","    }","","    let buf_a = TestBuf {","        data: vec![1, 2, 3, 4],","        position: 0,","    };","","    let buf_b = TestBuf {","        data: vec![5, 6, 7, 8],","        position: 0,","    };","","    let mut chain_buf = Chain {","        a: buf_a,","        b: buf_b,","    };","","    let result = chain_buf.copy_to_bytes(6);","","    assert_eq!(result.len(), 6);","    assert_eq!(result.as_ref(), &[1, 2, 3, 4, 5, 6]);","}"],[{"start_line":174,"start_column":12,"end_line":174,"end_column":24,"positive":false,"negative":true},{"start_line":176,"start_column":19,"end_line":176,"end_column":29,"positive":false,"negative":true}]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn copy_to_slice(&mut self, dst: &mut [u8]) {","            let len = dst.len().min(self.remaining());","            dst[..len].copy_from_slice(&self.data[self.position..self.position + len]);","            self.advance(len);","        }","","        fn get_u8(&mut self) -> u8 {","            let byte = self.chunk()[0];","            self.advance(1);","            byte","        }","        ","        // Other required methods can be omitted for brevity.","    }","","    let buf_a = TestBuf {","        data: vec![1, 2],","        position: 0,","    };","","    let buf_b = TestBuf {","        data: vec![3, 4],","        position: 0,","    };","","    let mut chain_buf = Chain {","        a: buf_a,","        b: buf_b,","    };","","    chain_buf.copy_to_bytes(5); // This should panic","}"],[{"start_line":174,"start_column":12,"end_line":174,"end_column":24,"positive":false,"negative":true},{"start_line":176,"start_column":19,"end_line":176,"end_column":29,"positive":false,"negative":true}]],[["{","    struct BufA {","        remaining: usize,","    }","","    impl Buf for BufA {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","           crate::Bytes::new()","       }","    }","","    struct BufB {","        remaining: usize,","    }","","    impl Buf for BufB {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, _: usize) {}","       fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","           crate::Bytes::new()","        }","    }","","    let a = BufA { remaining: 0 };","    let b = BufB { remaining: 2 };","    let mut chain = Chain::new(a, b);","    ","   let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","       chain.copy_to_bytes(3); // len = 3, which should trigger the assertion","   }));","    ","    assert!(result.is_err());","}"],[{"start_line":174,"start_column":12,"end_line":174,"end_column":24,"positive":false,"negative":true},{"start_line":176,"start_column":19,"end_line":176,"end_column":29,"positive":true,"negative":false}]],[["{","    struct BufA {","        remaining: usize,","    }","","    impl Buf for BufA {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, _: usize) {}","       fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","           crate::Bytes::new()","       }","    }","","    struct BufB {","        remaining: usize,","    }","","    impl Buf for BufB {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] {","            &[]","        }","        fn advance(&mut self, _: usize) {}","       fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","           crate::Bytes::new()","       }","    }","","    let a = BufA { remaining: 0 };","    let b = BufB { remaining: 0 };","    let mut chain = Chain::new(a, b);","","   let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {","       chain.copy_to_bytes(1); // len = 1, should not find data to copy","   }));","   ","   assert!(result.is_err());","}"],[{"start_line":174,"start_column":12,"end_line":174,"end_column":24,"positive":false,"negative":true},{"start_line":176,"start_column":19,"end_line":176,"end_column":29,"positive":true,"negative":false}]]]}