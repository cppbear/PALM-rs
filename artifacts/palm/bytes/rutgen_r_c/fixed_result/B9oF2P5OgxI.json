{"function_name":"bytes::buf::chain::<buf::chain::Chain<T, U> as buf::buf_impl::Buf>::remaining","tests":5,"tests_lines":[12,20,20,20,20],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[135,136,137],"codes_lines_covered":[[["{","    struct EmptyBuf;","    impl Buf for EmptyBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let chain = Chain { a: EmptyBuf, b: EmptyBuf };","    assert_eq!(chain.remaining(), 0);","}"],[135,136,137]],[["{","    struct NonEmptyBufA;","    impl Buf for NonEmptyBufA {","        fn remaining(&self) -> usize { 5 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4, 5] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    struct EmptyBuf;","    impl Buf for EmptyBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let chain = Chain { a: NonEmptyBufA, b: EmptyBuf };","    assert_eq!(chain.remaining(), 5);","}"],[135,136,137]],[["{","    struct EmptyBuf;","    impl Buf for EmptyBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    struct NonEmptyBufB;","    impl Buf for NonEmptyBufB {","        fn remaining(&self) -> usize { 7 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4, 5, 6, 7] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let chain = Chain { a: EmptyBuf, b: NonEmptyBufB };","    assert_eq!(chain.remaining(), 7);","}"],[135,136,137]],[["{","    struct NonEmptyBufA;","    impl Buf for NonEmptyBufA {","        fn remaining(&self) -> usize { 5 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4, 5] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    struct NonEmptyBufB;","    impl Buf for NonEmptyBufB {","        fn remaining(&self) -> usize { 3 }","        fn chunk(&self) -> &[u8] { &[6, 7, 8] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let chain = Chain { a: NonEmptyBufA, b: NonEmptyBufB };","    assert_eq!(chain.remaining(), 8);","}"],[135,136,137]],[["{","    struct EmptyBuf;","    impl Buf for EmptyBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    struct NonEmptyBufC;","    impl Buf for NonEmptyBufC {","        fn remaining(&self) -> usize { 10 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let chain = Chain { a: EmptyBuf, b: NonEmptyBufC };","    assert_eq!(chain.remaining(), 10);","}"],[135,136,137]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct EmptyBuf;","    impl Buf for EmptyBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let chain = Chain { a: EmptyBuf, b: EmptyBuf };","    assert_eq!(chain.remaining(), 0);","}"],[]],[["{","    struct NonEmptyBufA;","    impl Buf for NonEmptyBufA {","        fn remaining(&self) -> usize { 5 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4, 5] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    struct EmptyBuf;","    impl Buf for EmptyBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let chain = Chain { a: NonEmptyBufA, b: EmptyBuf };","    assert_eq!(chain.remaining(), 5);","}"],[]],[["{","    struct EmptyBuf;","    impl Buf for EmptyBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    struct NonEmptyBufB;","    impl Buf for NonEmptyBufB {","        fn remaining(&self) -> usize { 7 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4, 5, 6, 7] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let chain = Chain { a: EmptyBuf, b: NonEmptyBufB };","    assert_eq!(chain.remaining(), 7);","}"],[]],[["{","    struct NonEmptyBufA;","    impl Buf for NonEmptyBufA {","        fn remaining(&self) -> usize { 5 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4, 5] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    struct NonEmptyBufB;","    impl Buf for NonEmptyBufB {","        fn remaining(&self) -> usize { 3 }","        fn chunk(&self) -> &[u8] { &[6, 7, 8] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let chain = Chain { a: NonEmptyBufA, b: NonEmptyBufB };","    assert_eq!(chain.remaining(), 8);","}"],[]],[["{","    struct EmptyBuf;","    impl Buf for EmptyBuf {","        fn remaining(&self) -> usize { 0 }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    struct NonEmptyBufC;","    impl Buf for NonEmptyBufC {","        fn remaining(&self) -> usize { 10 }","        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] }","        fn advance(&mut self, _: usize) {}","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let chain = Chain { a: EmptyBuf, b: NonEmptyBufC };","    assert_eq!(chain.remaining(), 10);","}"],[]]]}