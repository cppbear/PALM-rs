{"function_name":"bytes::bytes::promotable_odd_clone","tests":5,"tests_lines":[31,36,22,26,27],"oracles":5,"oracles_compiled":2,"oracles_compiled_rate":40.0,"tests_compiled":2,"tests_compiled_rate":40.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":9,"lines_covered":7,"lines_coveraged_rate":77.77777777777779,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[1303,1304,1305,1306,1307,1308,1310,1311,1313],"codes_lines_covered":[[["{","   use core::sync::atomic::AtomicPtr;  ","","","    // Prepare a shared buffer for the test.","    let buffer: Vec<u8> = vec![1, 2, 3, 4, 5]; // Example data","    let buffer_ptr = buffer.as_ptr() as *mut u8; // Cast to *mut u8 for shared buffer","","    // Create an AtomicPtr with KIND_VEC (0b1)","    let shared = Box::new(Shared {","        buf: buffer_ptr,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    let shared_ptr = Box::into_raw(shared); // Convert Box to raw pointer","","    // Create the AtomicPtr with kind being KIND_VEC","    let data = AtomicPtr::new(shared_ptr as _);","","    // Define pointer and length for cloning","    let clone_ptr = buffer_ptr;","    let clone_len = buffer.len();","","    // Call the function under test","    let cloned_bytes = unsafe { promotable_odd_clone(&data, clone_ptr, clone_len) };","","    // Validate results","    assert_eq!(cloned_bytes.len, clone_len);","    assert_eq!(cloned_bytes.ptr, clone_ptr);","","   let shared_clone = cloned_bytes.data.load(Ordering::Acquire) as *mut Shared;  ","   assert!(!shared_clone.is_null());  "," ","   // Verify reference count increased  ","   unsafe { assert_eq!((*shared_clone).ref_cnt.load(Ordering::Relaxed), 2); }","}"],[1303,1304,1305,1306,1307,1308,1313]],[["{","    use core::ptr::null_mut;","    use core::sync::atomic::AtomicPtr;","","    // Create an AtomicPtr with an invalid kind (0b0)","    let shared = Box::new(Shared {","        buf: null_mut(),","        cap: 0,","        ref_cnt: AtomicUsize::new(1),","    });","    let shared_ptr = Box::into_raw(shared); // Convert Box to raw pointer","","    // Create the AtomicPtr with kind being KIND_ARC (0b0)","    let data = AtomicPtr::new(shared_ptr as _);","","    // Define pointer and length for cloning","    let clone_ptr = null_mut();","    let clone_len = 0;","","    // Call the function under test, should panic","    let _ = unsafe { promotable_odd_clone(&data, clone_ptr, clone_len) };","}"],[1303,1304,1305,1306,1307,1308,1313]]],"codes_branches":[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}],"codes_branches_covered":[[["{","   use core::sync::atomic::AtomicPtr;  ","","","    // Prepare a shared buffer for the test.","    let buffer: Vec<u8> = vec![1, 2, 3, 4, 5]; // Example data","    let buffer_ptr = buffer.as_ptr() as *mut u8; // Cast to *mut u8 for shared buffer","","    // Create an AtomicPtr with KIND_VEC (0b1)","    let shared = Box::new(Shared {","        buf: buffer_ptr,","        cap: buffer.len(),","        ref_cnt: AtomicUsize::new(1),","    });","    let shared_ptr = Box::into_raw(shared); // Convert Box to raw pointer","","    // Create the AtomicPtr with kind being KIND_VEC","    let data = AtomicPtr::new(shared_ptr as _);","","    // Define pointer and length for cloning","    let clone_ptr = buffer_ptr;","    let clone_len = buffer.len();","","    // Call the function under test","    let cloned_bytes = unsafe { promotable_odd_clone(&data, clone_ptr, clone_len) };","","    // Validate results","    assert_eq!(cloned_bytes.len, clone_len);","    assert_eq!(cloned_bytes.ptr, clone_ptr);","","   let shared_clone = cloned_bytes.data.load(Ordering::Acquire) as *mut Shared;  ","   assert!(!shared_clone.is_null());  "," ","   // Verify reference count increased  ","   unsafe { assert_eq!((*shared_clone).ref_cnt.load(Ordering::Relaxed), 2); }","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]],[["{","    use core::ptr::null_mut;","    use core::sync::atomic::AtomicPtr;","","    // Create an AtomicPtr with an invalid kind (0b0)","    let shared = Box::new(Shared {","        buf: null_mut(),","        cap: 0,","        ref_cnt: AtomicUsize::new(1),","    });","    let shared_ptr = Box::into_raw(shared); // Convert Box to raw pointer","","    // Create the AtomicPtr with kind being KIND_ARC (0b0)","    let data = AtomicPtr::new(shared_ptr as _);","","    // Define pointer and length for cloning","    let clone_ptr = null_mut();","    let clone_len = 0;","","    // Call the function under test, should panic","    let _ = unsafe { promotable_odd_clone(&data, clone_ptr, clone_len) };","}"],[{"start_line":1307,"start_column":8,"end_line":1307,"end_column":24,"positive":true,"negative":false}]]]}