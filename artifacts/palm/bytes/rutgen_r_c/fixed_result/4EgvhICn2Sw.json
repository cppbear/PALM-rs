{"function_name":"bytes::buf::buf_impl::<std::io::Cursor<T> as buf::buf_impl::Buf>::remaining","tests":3,"tests_lines":[27,33,27],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[2929,2930,2931],"codes_lines_covered":[[["{","    struct CursorMock {","        position: u64,","        data: Vec<u8>,","    }","","    impl CursorMock {","        fn new(data: Vec<u8>) -> Self {","            Self { position: 0, data }","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> u64 {","            self.position","        }","","        fn remaining(&self) -> usize {","           saturating_sub_usize_u64(self.get_ref().len(), self.position())","        }","    }","","    let cursor = CursorMock::new(vec![]);","    assert_eq!(cursor.remaining(), 0);","}"],[]],[["{","    struct CursorMock {","        position: u64,","        data: Vec<u8>,","    }","","    impl CursorMock {","        fn new(data: Vec<u8>, position: u64) -> Self {","            Self { position, data }","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> u64 {","            self.position","        }","","        fn remaining(&self) -> usize {","           saturating_sub_usize_u64(self.get_ref().len(), self.position())","        }","    }","","    let cursor = CursorMock::new(vec![1, 2, 3, 4, 5], 2);","    assert_eq!(cursor.remaining(), 3);","","    let cursor = CursorMock::new(vec![1, 2, 3], 3);","    assert_eq!(cursor.remaining(), 0);","","    let cursor = CursorMock::new(vec![1, 2], 5);","    assert_eq!(cursor.remaining(), 0);","}"],[]],[["{","    struct CursorMock {","        position: u64,","        data: Vec<u8>,","    }","","    impl CursorMock {","        fn new(data: Vec<u8>, position: u64) -> Self {","            Self { position, data }","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> u64 {","            self.position","        }","","       fn remaining(&self) -> usize {","           saturating_sub_usize_u64(self.get_ref().len(), self.position())","       }","    }","","    let cursor = CursorMock::new(vec![1, 2, 3], u64::MAX);","    assert_eq!(cursor.remaining(), 0);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct CursorMock {","        position: u64,","        data: Vec<u8>,","    }","","    impl CursorMock {","        fn new(data: Vec<u8>) -> Self {","            Self { position: 0, data }","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> u64 {","            self.position","        }","","        fn remaining(&self) -> usize {","           saturating_sub_usize_u64(self.get_ref().len(), self.position())","        }","    }","","    let cursor = CursorMock::new(vec![]);","    assert_eq!(cursor.remaining(), 0);","}"],[]],[["{","    struct CursorMock {","        position: u64,","        data: Vec<u8>,","    }","","    impl CursorMock {","        fn new(data: Vec<u8>, position: u64) -> Self {","            Self { position, data }","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> u64 {","            self.position","        }","","        fn remaining(&self) -> usize {","           saturating_sub_usize_u64(self.get_ref().len(), self.position())","        }","    }","","    let cursor = CursorMock::new(vec![1, 2, 3, 4, 5], 2);","    assert_eq!(cursor.remaining(), 3);","","    let cursor = CursorMock::new(vec![1, 2, 3], 3);","    assert_eq!(cursor.remaining(), 0);","","    let cursor = CursorMock::new(vec![1, 2], 5);","    assert_eq!(cursor.remaining(), 0);","}"],[]],[["{","    struct CursorMock {","        position: u64,","        data: Vec<u8>,","    }","","    impl CursorMock {","        fn new(data: Vec<u8>, position: u64) -> Self {","            Self { position, data }","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> u64 {","            self.position","        }","","       fn remaining(&self) -> usize {","           saturating_sub_usize_u64(self.get_ref().len(), self.position())","       }","    }","","    let cursor = CursorMock::new(vec![1, 2, 3], u64::MAX);","    assert_eq!(cursor.remaining(), 0);","}"],[]]]}