{"function_name":"bytes::bytes::owned_to_mut","tests":4,"tests_lines":[20,13,20,16],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":4,"tests_passed":2,"tests_passed_rate":50.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1151,1152,1153],"codes_lines_covered":[[["{","    use core::ptr;","    use alloc::vec::Vec;","    use core::sync::atomic::{AtomicPtr, Ordering};","    ","    let mut data = Vec::new();","    data.push(1u8);","    data.push(2u8);","    data.push(3u8);","","    let ptr = data.as_ptr();","    let len = data.len();","    let atomic_ptr = AtomicPtr::new(ptr as *mut ());","","    // Safety: The data is valid and correctly initialized","    let bytes_mut = unsafe { owned_to_mut(&atomic_ptr, ptr, len) };","","    assert_eq!(bytes_mut.len(), len);","    assert!(!bytes_mut.is_empty());","}"],[1151,1152,1153]],[["{","    use core::ptr;","    use alloc::vec::Vec;","    use core::sync::atomic::{AtomicPtr, Ordering};","","    let data: Vec<u8> = Vec::new();","    let ptr = data.as_ptr();","    let len = data.len();","    let atomic_ptr = AtomicPtr::new(ptr as *mut ());","","    // Safety: This should panic due to length being zero","    let _bytes_mut = unsafe { owned_to_mut(&atomic_ptr, ptr, len) };","}"],[]],[["{","    use core::ptr;","    use alloc::vec::Vec;","    use core::sync::atomic::{AtomicPtr, Ordering};","","    let mut data = Vec::with_capacity(1024);","    for i in 0..1024 {","        data.push(i as u8);","    }","","    let ptr = data.as_ptr();","    let len = data.len();","    let atomic_ptr = AtomicPtr::new(ptr as *mut ());","","    // Safety: The data is valid and correctly initialized","    let bytes_mut = unsafe { owned_to_mut(&atomic_ptr, ptr, len) };","","    assert_eq!(bytes_mut.len(), len);","    assert!(!bytes_mut.is_empty());","}"],[1151,1152,1153]],[["{","    use core::ptr;","    use alloc::vec::Vec;","    use core::sync::atomic::{AtomicPtr, Ordering};","","    let data: Vec<u8> = Vec::new();","    let ptr = data.as_ptr();","    let len = data.len();","    let atomic_ptr = AtomicPtr::new(ptr as *mut ());","","    // Safety: Checking the behavior with empty data","    let bytes_mut = unsafe { owned_to_mut(&atomic_ptr, ptr, len) };","","    assert_eq!(bytes_mut.len(), len);","    assert!(bytes_mut.is_empty());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use core::ptr;","    use alloc::vec::Vec;","    use core::sync::atomic::{AtomicPtr, Ordering};","    ","    let mut data = Vec::new();","    data.push(1u8);","    data.push(2u8);","    data.push(3u8);","","    let ptr = data.as_ptr();","    let len = data.len();","    let atomic_ptr = AtomicPtr::new(ptr as *mut ());","","    // Safety: The data is valid and correctly initialized","    let bytes_mut = unsafe { owned_to_mut(&atomic_ptr, ptr, len) };","","    assert_eq!(bytes_mut.len(), len);","    assert!(!bytes_mut.is_empty());","}"],[]],[["{","    use core::ptr;","    use alloc::vec::Vec;","    use core::sync::atomic::{AtomicPtr, Ordering};","","    let data: Vec<u8> = Vec::new();","    let ptr = data.as_ptr();","    let len = data.len();","    let atomic_ptr = AtomicPtr::new(ptr as *mut ());","","    // Safety: This should panic due to length being zero","    let _bytes_mut = unsafe { owned_to_mut(&atomic_ptr, ptr, len) };","}"],[]],[["{","    use core::ptr;","    use alloc::vec::Vec;","    use core::sync::atomic::{AtomicPtr, Ordering};","","    let mut data = Vec::with_capacity(1024);","    for i in 0..1024 {","        data.push(i as u8);","    }","","    let ptr = data.as_ptr();","    let len = data.len();","    let atomic_ptr = AtomicPtr::new(ptr as *mut ());","","    // Safety: The data is valid and correctly initialized","    let bytes_mut = unsafe { owned_to_mut(&atomic_ptr, ptr, len) };","","    assert_eq!(bytes_mut.len(), len);","    assert!(!bytes_mut.is_empty());","}"],[]],[["{","    use core::ptr;","    use alloc::vec::Vec;","    use core::sync::atomic::{AtomicPtr, Ordering};","","    let data: Vec<u8> = Vec::new();","    let ptr = data.as_ptr();","    let len = data.len();","    let atomic_ptr = AtomicPtr::new(ptr as *mut ());","","    // Safety: Checking the behavior with empty data","    let bytes_mut = unsafe { owned_to_mut(&atomic_ptr, ptr, len) };","","    assert_eq!(bytes_mut.len(), len);","    assert!(bytes_mut.is_empty());","}"],[]]]}