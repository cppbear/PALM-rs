{"function_name":"bytes::buf::limit::buf::limit::Limit<T>::into_inner","tests":4,"tests_lines":[11,11,11,14],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[20,21,22],"codes_lines_covered":[[["{","    struct MyBuffer {","        data: Vec<u8>,","    }","","    let buffer = MyBuffer { data: vec![1, 2, 3, 4, 5] };","    let limit = Limit { inner: buffer, limit: 10 };","    let inner = limit.into_inner();","","    assert_eq!(inner.data, vec![1, 2, 3, 4, 5]);","}"],[20,21,22]],[["{","    struct MyBuffer {","        data: Vec<u8>,","    }","","    let buffer = MyBuffer { data: vec![] };","    let limit = Limit { inner: buffer, limit: 0 };","    let inner = limit.into_inner();","","    assert_eq!(inner.data, vec![]);","}"],[20,21,22]],[["{","    struct MyBuffer {","        data: Vec<u8>,","    }","","    let buffer = MyBuffer { data: vec![0; 1000] };","    let limit = Limit { inner: buffer, limit: 1000 };","    let inner = limit.into_inner();","","    assert_eq!(inner.data.len(), 1000);","}"],[20,21,22]],[["{","    struct MyBuffer {","        data: Vec<u8>,","    }","","    let buffer = MyBuffer { data: vec![1, 2, 3] };","    {","        let limit = Limit { inner: buffer, limit: 3 };","        // drop the limit before checking inner","    }","    // This should panic because the inner buffer has been moved","    // Uncomment the next line to trigger panic with use-after-drop","    // let _ = limit.into_inner();","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MyBuffer {","        data: Vec<u8>,","    }","","    let buffer = MyBuffer { data: vec![1, 2, 3, 4, 5] };","    let limit = Limit { inner: buffer, limit: 10 };","    let inner = limit.into_inner();","","    assert_eq!(inner.data, vec![1, 2, 3, 4, 5]);","}"],[]],[["{","    struct MyBuffer {","        data: Vec<u8>,","    }","","    let buffer = MyBuffer { data: vec![] };","    let limit = Limit { inner: buffer, limit: 0 };","    let inner = limit.into_inner();","","    assert_eq!(inner.data, vec![]);","}"],[]],[["{","    struct MyBuffer {","        data: Vec<u8>,","    }","","    let buffer = MyBuffer { data: vec![0; 1000] };","    let limit = Limit { inner: buffer, limit: 1000 };","    let inner = limit.into_inner();","","    assert_eq!(inner.data.len(), 1000);","}"],[]],[["{","    struct MyBuffer {","        data: Vec<u8>,","    }","","    let buffer = MyBuffer { data: vec![1, 2, 3] };","    {","        let limit = Limit { inner: buffer, limit: 3 };","        // drop the limit before checking inner","    }","    // This should panic because the inner buffer has been moved","    // Uncomment the next line to trigger panic with use-after-drop","    // let _ = limit.into_inner();","}"],[]]]}