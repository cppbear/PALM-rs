{"function_name":"bytes::bytes::shared_is_unique","tests":3,"tests_lines":[23,23,8],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1465,1466,1467,1468,1469],"codes_lines_covered":[[["{","    use core::ptr::null_mut;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct Shared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let shared_data: Shared = Shared {","        buf: null_mut(),","        cap: 0,","        ref_cnt: AtomicUsize::new(1),","    };","","    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(&shared_data as *const Shared as *mut ());","","    // Test that the shared_is_unique function returns true when ref_cnt is 1","    unsafe {","        assert!(shared_is_unique(&atomic_ptr));","    }","}"],[1465,1466,1467,1468,1469]],[["{","    use core::ptr::null_mut;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct Shared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let shared_data: Shared = Shared {","        buf: null_mut(),","        cap: 0,","        ref_cnt: AtomicUsize::new(2),","    };","","    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(&shared_data as *const Shared as *mut ());","","    // Test that the shared_is_unique function returns false when ref_cnt is more than 1","    unsafe {","        assert!(!shared_is_unique(&atomic_ptr));","    }","}"],[1465,1466,1467,1468,1469]],[["{","    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(0 as *mut ());","","    // This will panic because the pointer is invalid.","    unsafe {","        shared_is_unique(&atomic_ptr);","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use core::ptr::null_mut;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct Shared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let shared_data: Shared = Shared {","        buf: null_mut(),","        cap: 0,","        ref_cnt: AtomicUsize::new(1),","    };","","    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(&shared_data as *const Shared as *mut ());","","    // Test that the shared_is_unique function returns true when ref_cnt is 1","    unsafe {","        assert!(shared_is_unique(&atomic_ptr));","    }","}"],[]],[["{","    use core::ptr::null_mut;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct Shared {","        buf: *mut u8,","        cap: usize,","        ref_cnt: AtomicUsize,","    }","","    let shared_data: Shared = Shared {","        buf: null_mut(),","        cap: 0,","        ref_cnt: AtomicUsize::new(2),","    };","","    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(&shared_data as *const Shared as *mut ());","","    // Test that the shared_is_unique function returns false when ref_cnt is more than 1","    unsafe {","        assert!(!shared_is_unique(&atomic_ptr));","    }","}"],[]],[["{","    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(0 as *mut ());","","    // This will panic because the pointer is invalid.","    unsafe {","        shared_is_unique(&atomic_ptr);","    }","}"],[]]]}