{"function_name":"bytes::bytes_mut::<bytes_mut::BytesMut as buf::buf_impl::Buf>::advance","tests":6,"tests_lines":[9,8,9,10,15,17],"oracles":6,"oracles_compiled":4,"oracles_compiled_rate":66.66666666666666,"tests_compiled":4,"tests_compiled_rate":66.66666666666666,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":12,"lines_covered":12,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1152,1153,1154,1155,1156,1157,1159,1160,1161,1162,1163,1164],"codes_lines_covered":[[["{","    let mut bytes_mut = BytesMut::with_capacity(10);","    bytes_mut.resize(5, 0); // Set len to 5; cap is 10","","    // Check remaining is 5 and advancing by 5 should not panic","    let cnt = bytes_mut.remaining(); // Should be 5","    bytes_mut.advance(cnt);","    assert_eq!(bytes_mut.len(), 0); // length after advancing should be 0","}"],[1152,1153,1154,1159,1160,1161,1162,1163,1164]],[["{","    let mut bytes_mut = BytesMut::with_capacity(10);","    bytes_mut.resize(5, 0); // Set len to 5; cap is 10","","    // Attempt to advance beyond the remaining length","    let cnt = bytes_mut.remaining() + 1; // Should be 6","    bytes_mut.advance(cnt);","}"],[1152,1153,1154,1155,1156,1157]],[["{","    let mut bytes_mut = BytesMut::with_capacity(10);","    bytes_mut.resize(5, 0); // Set len to 5; cap is 10","","    // Advancing by 0 should be a no-op","    bytes_mut.advance(0);","    assert_eq!(bytes_mut.len(), 5); // Length should remain unchanged","    assert_eq!(bytes_mut.remaining(), 5); // Remaining should still be 5","}"],[1152,1153,1154,1159,1160,1161,1162,1163,1164]],[["{","    let mut bytes_mut = BytesMut::with_capacity(10);","    bytes_mut.resize(10, 0); // Set len to 10; cap is 10","","    // Advancing by the full capacity","    let cnt = bytes_mut.remaining(); // Should be 10","    bytes_mut.advance(cnt);","    assert_eq!(bytes_mut.len(), 0); // Length after advancing should be 0","    assert_eq!(bytes_mut.remaining(), 0); // Remaining should also be 0","}"],[1152,1153,1154,1159,1160,1161,1162,1163,1164]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut bytes_mut = BytesMut::with_capacity(10);","    bytes_mut.resize(5, 0); // Set len to 5; cap is 10","","    // Check remaining is 5 and advancing by 5 should not panic","    let cnt = bytes_mut.remaining(); // Should be 5","    bytes_mut.advance(cnt);","    assert_eq!(bytes_mut.len(), 0); // length after advancing should be 0","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(10);","    bytes_mut.resize(5, 0); // Set len to 5; cap is 10","","    // Attempt to advance beyond the remaining length","    let cnt = bytes_mut.remaining() + 1; // Should be 6","    bytes_mut.advance(cnt);","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(10);","    bytes_mut.resize(5, 0); // Set len to 5; cap is 10","","    // Advancing by 0 should be a no-op","    bytes_mut.advance(0);","    assert_eq!(bytes_mut.len(), 5); // Length should remain unchanged","    assert_eq!(bytes_mut.remaining(), 5); // Remaining should still be 5","}"],[]],[["{","    let mut bytes_mut = BytesMut::with_capacity(10);","    bytes_mut.resize(10, 0); // Set len to 10; cap is 10","","    // Advancing by the full capacity","    let cnt = bytes_mut.remaining(); // Should be 10","    bytes_mut.advance(cnt);","    assert_eq!(bytes_mut.len(), 0); // Length after advancing should be 0","    assert_eq!(bytes_mut.remaining(), 0); // Remaining should also be 0","}"],[]]]}