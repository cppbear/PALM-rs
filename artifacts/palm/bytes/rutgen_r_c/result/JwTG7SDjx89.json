{"function_name":"bytes::buf::take::<buf::take::Take<T> as buf::buf_impl::Buf>::chunk","tests":4,"tests_lines":[29,29,29,28],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[140,141,142,143],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","        ","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { data: vec![1, 2, 3], position: 0 };","    let take = Take { inner: buf, limit: 10 };","    let result = take.chunk();","    assert_eq!(result, &[1, 2, 3]);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","        ","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { data: vec![1, 2, 3], position: 0 };","    let take = Take { inner: buf, limit: 3 };","    let result = take.chunk();","    assert_eq!(result, &[1, 2, 3]);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","        ","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { data: vec![1, 2, 3, 4, 5], position: 0 };","    let take = Take { inner: buf, limit: 2 };","    let result = take.chunk();","    assert_eq!(result, &[1, 2]);","}"],[140,141,142,143]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","        ","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { data: vec![], position: 0 };","    let take = Take { inner: buf, limit: 1 };","    let _ = take.chunk(); // This should panic","}"],[140,141,142,143]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","        ","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { data: vec![1, 2, 3], position: 0 };","    let take = Take { inner: buf, limit: 10 };","    let result = take.chunk();","    assert_eq!(result, &[1, 2, 3]);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","        ","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { data: vec![1, 2, 3], position: 0 };","    let take = Take { inner: buf, limit: 3 };","    let result = take.chunk();","    assert_eq!(result, &[1, 2, 3]);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","        ","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { data: vec![1, 2, 3, 4, 5], position: 0 };","    let take = Take { inner: buf, limit: 2 };","    let result = take.chunk();","    assert_eq!(result, &[1, 2]);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","        ","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","        ","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf = TestBuf { data: vec![], position: 0 };","    let take = Take { inner: buf, limit: 1 };","    let _ = take.chunk(); // This should panic","}"],[]]]}