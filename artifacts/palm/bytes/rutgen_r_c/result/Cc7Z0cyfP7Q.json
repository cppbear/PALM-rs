{"function_name":"bytes::buf::chain::<buf::chain::Chain<T, U> as buf::buf_mut::BufMut>::remaining_mut","tests":4,"tests_lines":[23,23,23,23],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[196,197,198,199,200],"codes_lines_covered":[[["{","    struct TestBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","        unsafe fn advance_mut(&mut self, _cnt: usize) {","            unimplemented!()","        }","    }","","    let buf_a = TestBufMut { remaining: 10 };","    let buf_b = TestBufMut { remaining: 5 };","    let chain = Chain { a: buf_a, b: buf_b };","","    assert_eq!(chain.remaining_mut(), 15);","}"],[196,197,198,199,200]],[["{","    struct TestBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","        unsafe fn advance_mut(&mut self, _cnt: usize) {","            unimplemented!()","        }","    }","","    let buf_a = TestBufMut { remaining: 0 };","    let buf_b = TestBufMut { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","","    assert_eq!(chain.remaining_mut(), 0);","}"],[196,197,198,199,200]],[["{","    struct TestBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","        unsafe fn advance_mut(&mut self, _cnt: usize) {","            unimplemented!()","        }","    }","","    let buf_a = TestBufMut { remaining: 10 };","    let buf_b = TestBufMut { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","","    assert_eq!(chain.remaining_mut(), 10);","}"],[196,197,198,199,200]],[["{","    struct TestBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","        unsafe fn advance_mut(&mut self, _cnt: usize) {","            unimplemented!()","        }","    }","","    let buf_a = TestBufMut { remaining: 20 };","    let buf_b = TestBufMut { remaining: 30 };","    let chain = Chain { a: buf_a, b: buf_b };","","    assert_eq!(chain.remaining_mut(), 50);","}"],[196,197,198,199,200]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","        unsafe fn advance_mut(&mut self, _cnt: usize) {","            unimplemented!()","        }","    }","","    let buf_a = TestBufMut { remaining: 10 };","    let buf_b = TestBufMut { remaining: 5 };","    let chain = Chain { a: buf_a, b: buf_b };","","    assert_eq!(chain.remaining_mut(), 15);","}"],[]],[["{","    struct TestBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","        unsafe fn advance_mut(&mut self, _cnt: usize) {","            unimplemented!()","        }","    }","","    let buf_a = TestBufMut { remaining: 0 };","    let buf_b = TestBufMut { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","","    assert_eq!(chain.remaining_mut(), 0);","}"],[]],[["{","    struct TestBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","        unsafe fn advance_mut(&mut self, _cnt: usize) {","            unimplemented!()","        }","    }","","    let buf_a = TestBufMut { remaining: 10 };","    let buf_b = TestBufMut { remaining: 0 };","    let chain = Chain { a: buf_a, b: buf_b };","","    assert_eq!(chain.remaining_mut(), 10);","}"],[]],[["{","    struct TestBufMut {","        remaining: usize,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.remaining","        }","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","        unsafe fn advance_mut(&mut self, _cnt: usize) {","            unimplemented!()","        }","    }","","    let buf_a = TestBufMut { remaining: 20 };","    let buf_b = TestBufMut { remaining: 30 };","    let chain = Chain { a: buf_a, b: buf_b };","","    assert_eq!(chain.remaining_mut(), 50);","}"],[]]]}