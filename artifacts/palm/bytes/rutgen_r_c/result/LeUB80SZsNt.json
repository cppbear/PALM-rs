{"function_name":"bytes::buf::take::<buf::take::Take<T> as buf::buf_impl::Buf>::chunks_vectored","tests":7,"tests_lines":[46,36,38,42,32,31,32],"oracles":7,"oracles_compiled":6,"oracles_compiled_rate":85.71428571428571,"tests_compiled":6,"tests_compiled_rate":85.71428571428571,"oracles_run":6,"oracles_passed":5,"oracles_passed_rate":83.33333333333334,"tests_run":6,"tests_passed":5,"tests_passed_rate":83.33333333333334,"lines":40,"lines_covered":40,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[160,161,162,163,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,192,193,194,195,196,197,198,199,200,202,203],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _cnt: usize) {}","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn chunks_vectored<'a>(&'a self, _dst: &mut [IoSlice<'a>]) -> usize {","            1","        }","    }","","    let buf = TestBuf { data: vec![1, 2, 3] };","    let take = Take { inner: buf, limit: 0 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&mut [])];","","    let result = take.chunks_vectored(&mut slices);","    assert_eq!(result, 0);","}"],[160,161,162,203]],[["{","    struct PanicBuf {","        data: Vec<u8>,","    }","","    impl Buf for PanicBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _cnt: usize) {}","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {","            if dst.is_empty() {","                panic!(\"dst is empty\");","            }","            1","        }","    }","","    let buf = PanicBuf { data: vec![1, 2, 3] };","    let take = Take { inner: buf, limit: 1 };","    let mut slices: [IoSlice; 0] = [];","","    let _ = take.chunks_vectored(&mut slices);","}"],[160,161,163,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189]],[["{","    struct TestBufWithChunks {","        data: Vec<u8>,","        index: usize,","    }","","    impl Buf for TestBufWithChunks {","        fn remaining(&self) -> usize {","            self.data.len() - self.index","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.index..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.index += cnt;","        }","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {","            if dst.is_empty() {","                return 0;","            }","            1","        }","    }","","    let buf = TestBufWithChunks { data: vec![1, 2, 3, 4, 5], index: 0 };","    let take = Take { inner: buf, limit: 5 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&mut [])];","","    let result = take.chunks_vectored(&mut slices);","    assert_eq!(result, 1);","}"],[160,161,163,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,195,196,197,198,199,200,202,203]],[["{","    struct MockBuf {","        data: Vec<u8>,","    }","    ","    impl Buf for MockBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let mock_buf = MockBuf { data: vec![1, 2, 3, 4] };","    let take = Take { inner: mock_buf, limit: 0 };","    let mut dst: [IoSlice; 2] = [IoSlice::new(&[]); 2];","","    let cnt = take.chunks_vectored(&mut dst);","    assert_eq!(cnt, 0);","}"],[160,161,162,203]],[["{","    struct MockBuf {","        data: Vec<u8>,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let mock_buf = MockBuf { data: vec![1, 2, 3, 4] };","    let take = Take { inner: mock_buf, limit: 2 };","    let mut dst: [IoSlice; 17] = [IoSlice::new(&[]); 17]; // Exceeds the capacity limit","","    let _cnt = take.chunks_vectored(&mut dst);","}"],[160,161,163,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,192,193,194,203]],[["{","    struct MockBuf {","        data: Vec<u8>,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize {","            0","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            false","        }","","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let mock_buf = MockBuf { data: vec![] };","    let take = Take { inner: mock_buf, limit: 3 };","    let mut dst: [IoSlice; 2] = [IoSlice::new(&[]); 2];","","    let cnt = take.chunks_vectored(&mut dst);","    assert_eq!(cnt, 0);","}"],[160,161,163,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,202,203]]],"codes_branches":[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":true,"negative":true},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _cnt: usize) {}","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn chunks_vectored<'a>(&'a self, _dst: &mut [IoSlice<'a>]) -> usize {","            1","        }","    }","","    let buf = TestBuf { data: vec![1, 2, 3] };","    let take = Take { inner: buf, limit: 0 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&mut [])];","","    let result = take.chunks_vectored(&mut slices);","    assert_eq!(result, 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":true,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct PanicBuf {","        data: Vec<u8>,","    }","","    impl Buf for PanicBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _cnt: usize) {}","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {","            if dst.is_empty() {","                panic!(\"dst is empty\");","            }","            1","        }","    }","","    let buf = PanicBuf { data: vec![1, 2, 3] };","    let take = Take { inner: buf, limit: 1 };","    let mut slices: [IoSlice; 0] = [];","","    let _ = take.chunks_vectored(&mut slices);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":true},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct TestBufWithChunks {","        data: Vec<u8>,","        index: usize,","    }","","    impl Buf for TestBufWithChunks {","        fn remaining(&self) -> usize {","            self.data.len() - self.index","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.index..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.index += cnt;","        }","","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes {","            unimplemented!()","        }","","        fn has_remaining(&self) -> bool {","            self.remaining() > 0","        }","","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {","            if dst.is_empty() {","                return 0;","            }","            1","        }","    }","","    let buf = TestBufWithChunks { data: vec![1, 2, 3, 4, 5], index: 0 };","    let take = Take { inner: buf, limit: 5 };","    let mut slices: [IoSlice; 1] = [IoSlice::new(&mut [])];","","    let result = take.chunks_vectored(&mut slices);","    assert_eq!(result, 1);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":true},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":true}]],[["{","    struct MockBuf {","        data: Vec<u8>,","    }","    ","    impl Buf for MockBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let mock_buf = MockBuf { data: vec![1, 2, 3, 4] };","    let take = Take { inner: mock_buf, limit: 0 };","    let mut dst: [IoSlice; 2] = [IoSlice::new(&[]); 2];","","    let cnt = take.chunks_vectored(&mut dst);","    assert_eq!(cnt, 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":true,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct MockBuf {","        data: Vec<u8>,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let mock_buf = MockBuf { data: vec![1, 2, 3, 4] };","    let take = Take { inner: mock_buf, limit: 2 };","    let mut dst: [IoSlice; 17] = [IoSlice::new(&[]); 17]; // Exceeds the capacity limit","","    let _cnt = take.chunks_vectored(&mut dst);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":true},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":true,"negative":false}]],[["{","    struct MockBuf {","        data: Vec<u8>,","    }","","    impl Buf for MockBuf {","        fn remaining(&self) -> usize {","            0","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, _: usize) {}","","        fn has_remaining(&self) -> bool {","            false","        }","","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let mock_buf = MockBuf { data: vec![] };","    let take = Take { inner: mock_buf, limit: 3 };","    let mut dst: [IoSlice; 2] = [IoSlice::new(&[]); 2];","","    let cnt = take.chunks_vectored(&mut dst);","    assert_eq!(cnt, 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":true},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]]]}