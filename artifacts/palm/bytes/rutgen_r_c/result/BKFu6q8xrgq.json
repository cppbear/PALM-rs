{"function_name":"bytes::bytes_mut::invalid_ptr","tests":9,"tests_lines":[5,5,5,4,5,5,5,5,7],"oracles":9,"oracles_compiled":9,"oracles_compiled_rate":100.0,"tests_compiled":9,"tests_compiled_rate":100.0,"oracles_run":9,"oracles_passed":7,"oracles_passed_rate":77.77777777777779,"tests_run":9,"tests_passed":7,"tests_passed_rate":77.77777777777779,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1761,1762,1763,1764,1765],"codes_lines_covered":[[["{","    let addr: usize = 0;","    let result: *mut u8 = invalid_ptr::<u8>(addr);","    assert_eq!(result as usize, addr);","}"],[1761,1762,1763,1764,1765]],[["{","    let addr: usize = 1234;","    let result: *mut u8 = invalid_ptr::<u8>(addr);","    assert_eq!(result as usize, addr);","}"],[1761,1762,1763,1764,1765]],[["{","    let addr: usize = usize::MAX;","    let result: *mut u8 = invalid_ptr::<u8>(addr);","    assert_eq!(result as usize, addr);","}"],[1761,1762,1763,1764,1765]],[["{","    let addr: usize = isize::MAX as usize + 1; // simulate a negative address","    invalid_ptr::<u8>(addr); // This should panic due to invalid pointer","}"],[1761,1762,1763,1764,1765]],[["{","    let addr: usize = 1; // a non-zero address","    let ptr: *mut u32 = invalid_ptr(addr);","    assert_eq!(ptr as usize, addr);","}"],[1761,1762,1763,1764,1765]],[["{","    let addr: usize = usize::MAX; // maximum valid pointer address","    let ptr: *mut u32 = invalid_ptr(addr);","    assert_eq!(ptr as usize, addr);","}"],[1761,1762,1763,1764,1765]],[["{","    let addr: usize = 12345; // a random address","    let ptr: *mut u32 = invalid_ptr(addr);","    assert_eq!(ptr as usize, addr);","}"],[1761,1762,1763,1764,1765]],[["{","    let addr: usize = 0; // zero address, should not lead to panic but checking behavior","    let ptr: *mut u32 = invalid_ptr(addr);","    assert_eq!(ptr as usize, addr);","}"],[1761,1762,1763,1764,1765]],[["{","    let addr: usize = 42; // address to test against","    let ptr: *mut u32 = invalid_ptr(addr);","    let different_addr: usize = 43; // ensure this address is different","    let different_ptr: *mut u32 = invalid_ptr(different_addr);","    assert!(!ptr.eq(&different_ptr)); // ensure the pointers are not equal","}"],[1761,1762,1763,1764,1765]]],"codes_branches":[],"codes_branches_covered":[[["{","    let addr: usize = 0;","    let result: *mut u8 = invalid_ptr::<u8>(addr);","    assert_eq!(result as usize, addr);","}"],[]],[["{","    let addr: usize = 1234;","    let result: *mut u8 = invalid_ptr::<u8>(addr);","    assert_eq!(result as usize, addr);","}"],[]],[["{","    let addr: usize = usize::MAX;","    let result: *mut u8 = invalid_ptr::<u8>(addr);","    assert_eq!(result as usize, addr);","}"],[]],[["{","    let addr: usize = isize::MAX as usize + 1; // simulate a negative address","    invalid_ptr::<u8>(addr); // This should panic due to invalid pointer","}"],[]],[["{","    let addr: usize = 1; // a non-zero address","    let ptr: *mut u32 = invalid_ptr(addr);","    assert_eq!(ptr as usize, addr);","}"],[]],[["{","    let addr: usize = usize::MAX; // maximum valid pointer address","    let ptr: *mut u32 = invalid_ptr(addr);","    assert_eq!(ptr as usize, addr);","}"],[]],[["{","    let addr: usize = 12345; // a random address","    let ptr: *mut u32 = invalid_ptr(addr);","    assert_eq!(ptr as usize, addr);","}"],[]],[["{","    let addr: usize = 0; // zero address, should not lead to panic but checking behavior","    let ptr: *mut u32 = invalid_ptr(addr);","    assert_eq!(ptr as usize, addr);","}"],[]],[["{","    let addr: usize = 42; // address to test against","    let ptr: *mut u32 = invalid_ptr(addr);","    let different_addr: usize = 43; // ensure this address is different","    let different_ptr: *mut u32 = invalid_ptr(different_addr);","    assert!(!ptr.eq(&different_ptr)); // ensure the pointers are not equal","}"],[]]]}