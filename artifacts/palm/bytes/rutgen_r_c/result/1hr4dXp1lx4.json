{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::shallow_clone","tests":4,"tests_lines":[48,42,33,26],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":1,"oracles_passed_rate":25.0,"tests_run":4,"tests_passed":1,"tests_passed_rate":25.0,"lines":7,"lines_covered":5,"lines_coveraged_rate":71.42857142857143,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[1058,1059,1060,1061,1063,1064,1066],"codes_lines_covered":[[["{","    struct TestBytesMut {","        data: *mut Shared,","        kind: usize,","    }","","    impl TestBytesMut {","        unsafe fn shallow_clone(&mut self) -> TestBytesMut {","            if self.kind == KIND_ARC {","                increment_shared(self.data);","                ptr::read(self)","            } else {","                self.promote_to_shared(2);","                ptr::read(self)","            }","        }","        ","        fn kind(&self) -> usize {","            self.kind","        }","","        unsafe fn promote_to_shared(&mut self, ref_cnt: usize) {","            // Dummy implementation for testing, in real it will build proper shared","            self.kind = KIND_ARC; // Promoting to ARC for consistency with test","        }","    }","","    let shared = Box::new(Shared {","        vec: vec![1, 2, 3],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let shared_ptr = Box::into_raw(shared);","    ","    let mut bytes_mut = TestBytesMut {","        data: shared_ptr,","        kind: KIND_ARC,","    };","","    let cloned_bytes_mut: TestBytesMut;","","    unsafe {","        cloned_bytes_mut = bytes_mut.shallow_clone();","    }","","    assert_eq!(bytes_mut.kind(), KIND_ARC);","    assert_eq!(unsafe { (*cloned_bytes_mut.data).ref_count.load(Ordering::Relaxed) }, 2);","}"],[]],[["{","    struct TestBytesMut {","        data: *mut Shared,","        kind: usize,","    }","","    impl TestBytesMut {","        unsafe fn shallow_clone(&mut self) -> TestBytesMut {","            if self.kind == KIND_ARC {","                increment_shared(self.data);","                ptr::read(self)","            } else {","                self.promote_to_shared(2);","                ptr::read(self)","            }","        }","        ","        fn kind(&self) -> usize {","            self.kind","        }","","        unsafe fn promote_to_shared(&mut self, _ref_cnt: usize) {","            // Dummy implementation, no state modification to trigger panic","        }","    }","","    let shared = Box::new(Shared {","        vec: vec![1, 2, 3],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let shared_ptr = Box::into_raw(shared);","","    let mut bytes_mut = TestBytesMut {","        data: shared_ptr,","        kind: 0, // invalid kind","    };","","    unsafe {","        bytes_mut.shallow_clone(); // This should trigger a panic due to invalid kind","    }","}"],[]],[["{","    // Defining a simple struct to initialize BytesMut","    struct TestBytesMut {","        bytes: BytesMut,","    }","","    // Initialize with a specific capacity","    let mut test_bytes = TestBytesMut {","        bytes: BytesMut::with_capacity(16),","    };","","    // Set the data field to indicate that it's a kind that's not ARC","    // Manually setting it to KIND_VEC for the purpose of the test","    unsafe {","        let shared_ptr = Box::new(Shared {","            vec: Vec::new(),","            original_capacity_repr: 0,","            ref_count: AtomicUsize::new(1),","        });","","        test_bytes.bytes.data = Box::into_raw(shared_ptr);","    }","","    // Perform the unsafe operation","    unsafe {","        let clone = test_bytes.bytes.shallow_clone();","        // Validate the operation did not panic","        assert!(clone.kind() != KIND_ARC);","        // Check if the original and clone are distinct pointers and are in the right state","        assert_ne!(test_bytes.bytes.data, clone.data);","        assert_eq!(test_bytes.bytes.len(), clone.len());","    }","}"],[1058,1059,1060,1061,1066]],[["{","    // Defining a struct to check panic conditions","    struct TestBytesMut {","        bytes: BytesMut,","    }","","    let mut test_bytes = TestBytesMut {","        bytes: BytesMut::with_capacity(16),","    };","","    // Set the data field to indicate it's an ARC kind","    unsafe {","        let shared_ptr = Box::new(Shared {","            vec: Vec::new(),","            original_capacity_repr: 0,","            ref_count: AtomicUsize::new(usize::MAX), // Set to max to force a panic","        });","","        test_bytes.bytes.data = Box::into_raw(shared_ptr);","    }","","    // This will panic due to incrementing over the maximum value","    unsafe {","        test_bytes.bytes.shallow_clone();","    }","}"],[]]],"codes_branches":[{"start_line":1059,"start_column":12,"end_line":1059,"end_column":35,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    struct TestBytesMut {","        data: *mut Shared,","        kind: usize,","    }","","    impl TestBytesMut {","        unsafe fn shallow_clone(&mut self) -> TestBytesMut {","            if self.kind == KIND_ARC {","                increment_shared(self.data);","                ptr::read(self)","            } else {","                self.promote_to_shared(2);","                ptr::read(self)","            }","        }","        ","        fn kind(&self) -> usize {","            self.kind","        }","","        unsafe fn promote_to_shared(&mut self, ref_cnt: usize) {","            // Dummy implementation for testing, in real it will build proper shared","            self.kind = KIND_ARC; // Promoting to ARC for consistency with test","        }","    }","","    let shared = Box::new(Shared {","        vec: vec![1, 2, 3],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let shared_ptr = Box::into_raw(shared);","    ","    let mut bytes_mut = TestBytesMut {","        data: shared_ptr,","        kind: KIND_ARC,","    };","","    let cloned_bytes_mut: TestBytesMut;","","    unsafe {","        cloned_bytes_mut = bytes_mut.shallow_clone();","    }","","    assert_eq!(bytes_mut.kind(), KIND_ARC);","    assert_eq!(unsafe { (*cloned_bytes_mut.data).ref_count.load(Ordering::Relaxed) }, 2);","}"],[{"start_line":1059,"start_column":12,"end_line":1059,"end_column":35,"positive":false,"negative":false}]],[["{","    struct TestBytesMut {","        data: *mut Shared,","        kind: usize,","    }","","    impl TestBytesMut {","        unsafe fn shallow_clone(&mut self) -> TestBytesMut {","            if self.kind == KIND_ARC {","                increment_shared(self.data);","                ptr::read(self)","            } else {","                self.promote_to_shared(2);","                ptr::read(self)","            }","        }","        ","        fn kind(&self) -> usize {","            self.kind","        }","","        unsafe fn promote_to_shared(&mut self, _ref_cnt: usize) {","            // Dummy implementation, no state modification to trigger panic","        }","    }","","    let shared = Box::new(Shared {","        vec: vec![1, 2, 3],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    });","    let shared_ptr = Box::into_raw(shared);","","    let mut bytes_mut = TestBytesMut {","        data: shared_ptr,","        kind: 0, // invalid kind","    };","","    unsafe {","        bytes_mut.shallow_clone(); // This should trigger a panic due to invalid kind","    }","}"],[{"start_line":1059,"start_column":12,"end_line":1059,"end_column":35,"positive":false,"negative":false}]],[["{","    // Defining a simple struct to initialize BytesMut","    struct TestBytesMut {","        bytes: BytesMut,","    }","","    // Initialize with a specific capacity","    let mut test_bytes = TestBytesMut {","        bytes: BytesMut::with_capacity(16),","    };","","    // Set the data field to indicate that it's a kind that's not ARC","    // Manually setting it to KIND_VEC for the purpose of the test","    unsafe {","        let shared_ptr = Box::new(Shared {","            vec: Vec::new(),","            original_capacity_repr: 0,","            ref_count: AtomicUsize::new(1),","        });","","        test_bytes.bytes.data = Box::into_raw(shared_ptr);","    }","","    // Perform the unsafe operation","    unsafe {","        let clone = test_bytes.bytes.shallow_clone();","        // Validate the operation did not panic","        assert!(clone.kind() != KIND_ARC);","        // Check if the original and clone are distinct pointers and are in the right state","        assert_ne!(test_bytes.bytes.data, clone.data);","        assert_eq!(test_bytes.bytes.len(), clone.len());","    }","}"],[{"start_line":1059,"start_column":12,"end_line":1059,"end_column":35,"positive":true,"negative":false}]],[["{","    // Defining a struct to check panic conditions","    struct TestBytesMut {","        bytes: BytesMut,","    }","","    let mut test_bytes = TestBytesMut {","        bytes: BytesMut::with_capacity(16),","    };","","    // Set the data field to indicate it's an ARC kind","    unsafe {","        let shared_ptr = Box::new(Shared {","            vec: Vec::new(),","            original_capacity_repr: 0,","            ref_count: AtomicUsize::new(usize::MAX), // Set to max to force a panic","        });","","        test_bytes.bytes.data = Box::into_raw(shared_ptr);","    }","","    // This will panic due to incrementing over the maximum value","    unsafe {","        test_bytes.bytes.shallow_clone();","    }","}"],[{"start_line":1059,"start_column":12,"end_line":1059,"end_column":35,"positive":false,"negative":false}]]]}