{"function_name":"bytes::buf::uninit_slice::buf::uninit_slice::UninitSlice::write_byte","tests":5,"tests_lines":[13,6,13,19,6],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":5,"tests_passed":4,"tests_passed_rate":80.0,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[107,108,110,111],"codes_lines_covered":[[["{","    let mut data = [0u8; 3];","    let slice = unsafe { UninitSlice::from_raw_parts_mut(data.as_mut_ptr(), 3) };","","    slice.write_byte(0, b'a');","    assert_eq!(data[0], b'a'); // Test first element","","    slice.write_byte(1, b'b');","    assert_eq!(data[1], b'b'); // Test second element","","    slice.write_byte(2, b'c');","    assert_eq!(data[2], b'c'); // Test third element","}"],[107,108,110,111]],[["{","    let mut data = [0u8; 3];","    let slice = unsafe { UninitSlice::from_raw_parts_mut(data.as_mut_ptr(), 3) };","","    slice.write_byte(3, b'd'); // This should panic","}"],[107,108]],[["{","    let mut data: [MaybeUninit<u8>; 0] = [];","    let slice = UninitSlice::uninit(&mut data);","","    assert_eq!(slice.len(), 0);","    ","    // The len is 0, writing should panic","    // It will not panic on assertion caused by the index check","    #[should_panic(expected = \"assertion failed\")]","    {","        slice.write_byte(0, b'e'); // This should panic","    }","}"],[107,108]],[["{","    let mut data = [0u8; 5];","    let slice = unsafe { UninitSlice::from_raw_parts_mut(data.as_mut_ptr(), 5) };","","    slice.write_byte(0, b'a');","    assert_eq!(data[0], b'a');","    ","    slice.write_byte(1, b'b');","    assert_eq!(data[1], b'b');","","    slice.write_byte(2, b'c');","    assert_eq!(data[2], b'c');","","    slice.write_byte(3, b'd');","    assert_eq!(data[3], b'd');","","    slice.write_byte(4, b'e');","    assert_eq!(data[4], b'e');","}"],[107,108,110,111]],[["{","    let mut data = [0u8; 5];","    let slice = unsafe { UninitSlice::from_raw_parts_mut(data.as_mut_ptr(), 5) };","","    slice.write_byte(5, b'f'); // This should panic as index == len","}"],[107,108]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut data = [0u8; 3];","    let slice = unsafe { UninitSlice::from_raw_parts_mut(data.as_mut_ptr(), 3) };","","    slice.write_byte(0, b'a');","    assert_eq!(data[0], b'a'); // Test first element","","    slice.write_byte(1, b'b');","    assert_eq!(data[1], b'b'); // Test second element","","    slice.write_byte(2, b'c');","    assert_eq!(data[2], b'c'); // Test third element","}"],[]],[["{","    let mut data = [0u8; 3];","    let slice = unsafe { UninitSlice::from_raw_parts_mut(data.as_mut_ptr(), 3) };","","    slice.write_byte(3, b'd'); // This should panic","}"],[]],[["{","    let mut data: [MaybeUninit<u8>; 0] = [];","    let slice = UninitSlice::uninit(&mut data);","","    assert_eq!(slice.len(), 0);","    ","    // The len is 0, writing should panic","    // It will not panic on assertion caused by the index check","    #[should_panic(expected = \"assertion failed\")]","    {","        slice.write_byte(0, b'e'); // This should panic","    }","}"],[]],[["{","    let mut data = [0u8; 5];","    let slice = unsafe { UninitSlice::from_raw_parts_mut(data.as_mut_ptr(), 5) };","","    slice.write_byte(0, b'a');","    assert_eq!(data[0], b'a');","    ","    slice.write_byte(1, b'b');","    assert_eq!(data[1], b'b');","","    slice.write_byte(2, b'c');","    assert_eq!(data[2], b'c');","","    slice.write_byte(3, b'd');","    assert_eq!(data[3], b'd');","","    slice.write_byte(4, b'e');","    assert_eq!(data[4], b'e');","}"],[]],[["{","    let mut data = [0u8; 5];","    let slice = unsafe { UninitSlice::from_raw_parts_mut(data.as_mut_ptr(), 5) };","","    slice.write_byte(5, b'f'); // This should panic as index == len","}"],[]]]}