{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::reserve","tests":8,"tests_lines":[11,7,9,6,6,15,15,8],"oracles":8,"oracles_compiled":8,"oracles_compiled_rate":100.0,"tests_compiled":8,"tests_compiled_rate":100.0,"oracles_run":8,"oracles_passed":8,"oracles_passed_rate":100.0,"tests_run":8,"tests_passed":8,"tests_passed_rate":100.0,"lines":11,"lines_covered":11,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[592,593,594,595,596,599,600,601,602,603,604],"codes_lines_covered":[[["{","    let mut buf = BytesMut::with_capacity(64);","    buf.extend_from_slice(&[0; 64][..]);","    ","    let initial_capacity = buf.capacity();","    let additional = initial_capacity - buf.len(); // additional == rem","","    buf.reserve(additional);","","    assert_eq!(buf.capacity(), initial_capacity);","}"],[592,593,594,595,596,599,604]],[["{","    let mut buf = BytesMut::new();","    ","    buf.reserve(0);","","    assert_eq!(buf.capacity(), 0);","}"],[592,593,594,595,596,599,604]],[["{","    let mut buf = BytesMut::with_capacity(128);","    buf.extend_from_slice(&[0; 64][..]);","    ","    let rem = buf.capacity() - buf.len(); // rem","    buf.reserve(rem);","","    assert_eq!(buf.capacity(), 128); // should not resize","}"],[592,593,594,595,596,599,604]],[["{","    let mut buf = BytesMut::with_capacity(usize::MAX);","    ","    // This should trigger a panic due to capacity overflow.","    buf.reserve(1);","}"],[]],[["{","    let mut buf = BytesMut::new();","","    buf.reserve(64); // should allocate new space, since it's empty","    assert!(buf.capacity() >= 64);","}"],[592,593,594,595,596,600,601,602,603,604]],[["{","    // Initialize BytesMut with a lower capacity than needed","    let mut buf = BytesMut::with_capacity(10);","    buf.resize(5, 0); // Set length to 5, capacity is 10","","    // Verify initial length and capacity","    assert_eq!(buf.len(), 5);","    assert_eq!(buf.capacity(), 10);","","    // Try to reserve more capacity than the remaining capacity","    buf.reserve(10); // additional (10) > rem (10 - 5 = 5)","","    // Check if the new capacity is at least 10","    assert!(buf.capacity() >= 20); // Expecting capacity to be increased due to reallocation","}"],[592,593,594,595,596,599,600,601,602,603,604]],[["{","    // Initialize BytesMut with a given capacity","    let mut buf = BytesMut::with_capacity(16);","    buf.resize(8, 0); // Set length to 8, capacity is 16","","    // Verify initial length and capacity","    assert_eq!(buf.len(), 8);","    assert_eq!(buf.capacity(), 16);","","    // Requesting more than the remaining capacity","    buf.reserve(20); // additional (20) > rem (16 - 8 = 8)","","    // Check if the capacity has increased significantly","    assert!(buf.capacity() >= 20); // Expecting capacity to increase","}"],[592,593,594,595,596,599,600,601,602,603,604]],[["{","    // Initialize BytesMut with a small capacity","    let mut buf = BytesMut::with_capacity(1);","    buf.resize(1, 0); // Set length to 1, capacity is 1","","    // Requesting too much additional capacity which will cause an overflow","    buf.reserve(usize::MAX); // This will panic due to overflow in the function","}"],[592,593,594,595,596,599,600,601,602,603,604]]],"codes_branches":[{"start_line":596,"start_column":12,"end_line":596,"end_column":29,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut buf = BytesMut::with_capacity(64);","    buf.extend_from_slice(&[0; 64][..]);","    ","    let initial_capacity = buf.capacity();","    let additional = initial_capacity - buf.len(); // additional == rem","","    buf.reserve(additional);","","    assert_eq!(buf.capacity(), initial_capacity);","}"],[{"start_line":596,"start_column":12,"end_line":596,"end_column":29,"positive":true,"negative":false}]],[["{","    let mut buf = BytesMut::new();","    ","    buf.reserve(0);","","    assert_eq!(buf.capacity(), 0);","}"],[{"start_line":596,"start_column":12,"end_line":596,"end_column":29,"positive":true,"negative":false}]],[["{","    let mut buf = BytesMut::with_capacity(128);","    buf.extend_from_slice(&[0; 64][..]);","    ","    let rem = buf.capacity() - buf.len(); // rem","    buf.reserve(rem);","","    assert_eq!(buf.capacity(), 128); // should not resize","}"],[{"start_line":596,"start_column":12,"end_line":596,"end_column":29,"positive":true,"negative":false}]],[["{","    let mut buf = BytesMut::with_capacity(usize::MAX);","    ","    // This should trigger a panic due to capacity overflow.","    buf.reserve(1);","}"],[{"start_line":596,"start_column":12,"end_line":596,"end_column":29,"positive":false,"negative":false}]],[["{","    let mut buf = BytesMut::new();","","    buf.reserve(64); // should allocate new space, since it's empty","    assert!(buf.capacity() >= 64);","}"],[{"start_line":596,"start_column":12,"end_line":596,"end_column":29,"positive":false,"negative":true}]],[["{","    // Initialize BytesMut with a lower capacity than needed","    let mut buf = BytesMut::with_capacity(10);","    buf.resize(5, 0); // Set length to 5, capacity is 10","","    // Verify initial length and capacity","    assert_eq!(buf.len(), 5);","    assert_eq!(buf.capacity(), 10);","","    // Try to reserve more capacity than the remaining capacity","    buf.reserve(10); // additional (10) > rem (10 - 5 = 5)","","    // Check if the new capacity is at least 10","    assert!(buf.capacity() >= 20); // Expecting capacity to be increased due to reallocation","}"],[{"start_line":596,"start_column":12,"end_line":596,"end_column":29,"positive":true,"negative":true}]],[["{","    // Initialize BytesMut with a given capacity","    let mut buf = BytesMut::with_capacity(16);","    buf.resize(8, 0); // Set length to 8, capacity is 16","","    // Verify initial length and capacity","    assert_eq!(buf.len(), 8);","    assert_eq!(buf.capacity(), 16);","","    // Requesting more than the remaining capacity","    buf.reserve(20); // additional (20) > rem (16 - 8 = 8)","","    // Check if the capacity has increased significantly","    assert!(buf.capacity() >= 20); // Expecting capacity to increase","}"],[{"start_line":596,"start_column":12,"end_line":596,"end_column":29,"positive":true,"negative":true}]],[["{","    // Initialize BytesMut with a small capacity","    let mut buf = BytesMut::with_capacity(1);","    buf.resize(1, 0); // Set length to 1, capacity is 1","","    // Requesting too much additional capacity which will cause an overflow","    buf.reserve(usize::MAX); // This will panic due to overflow in the function","}"],[{"start_line":596,"start_column":12,"end_line":596,"end_column":29,"positive":true,"negative":true}]]]}