{"function_name":"bytes::bytes::bytes::Bytes::from_owner","tests":4,"tests_lines":[15,19,12,26],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":40,"lines_covered":40,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290],"codes_lines_covered":[[["{","    struct EmptyOwner;","","    impl AsRef<[u8]> for EmptyOwner {","        fn as_ref(&self) -> &[u8] {","            &[]","        }","    }","","    let owner = EmptyOwner;","    let bytes = Bytes::from_owner(owner);","","    assert_eq!(bytes.len(), 0);","    assert!(bytes.is_empty());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct NonEmptyOwner {","        data: Vec<u8>,","    }","","    impl AsRef<[u8]> for NonEmptyOwner {","        fn as_ref(&self) -> &[u8] {","            &self.data","        }","    }","","    let owner = NonEmptyOwner {","        data: vec![1, 2, 3, 4],","    };","    let bytes = Bytes::from_owner(owner);","","    assert_eq!(bytes.len(), 4);","    assert!(!bytes.is_empty());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct OwnerThatPanics;","","    impl AsRef<[u8]> for OwnerThatPanics {","        fn as_ref(&self) -> &[u8] {","            panic!();","        }","    }","","    let owner = OwnerThatPanics;","    let _ = Bytes::from_owner(owner); // This should panic when trying to reference the slice","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]],[["{","    struct MultiOwner {","        data: Vec<u8>,","    }","","    impl AsRef<[u8]> for MultiOwner {","        fn as_ref(&self) -> &[u8] {","            &self.data","        }","    }","","    let owner1 = MultiOwner {","        data: vec![5, 6, 7],","    };","    let bytes1 = Bytes::from_owner(owner1);","","    let owner2 = MultiOwner {","        data: vec![8, 9, 10],","    };","    let bytes2 = Bytes::from_owner(owner2);","","    assert_eq!(bytes1.len(), 3);","    assert_eq!(bytes2.len(), 3);","    assert!(!bytes1.is_empty());","    assert!(!bytes2.is_empty());","}"],[251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct EmptyOwner;","","    impl AsRef<[u8]> for EmptyOwner {","        fn as_ref(&self) -> &[u8] {","            &[]","        }","    }","","    let owner = EmptyOwner;","    let bytes = Bytes::from_owner(owner);","","    assert_eq!(bytes.len(), 0);","    assert!(bytes.is_empty());","}"],[]],[["{","    struct NonEmptyOwner {","        data: Vec<u8>,","    }","","    impl AsRef<[u8]> for NonEmptyOwner {","        fn as_ref(&self) -> &[u8] {","            &self.data","        }","    }","","    let owner = NonEmptyOwner {","        data: vec![1, 2, 3, 4],","    };","    let bytes = Bytes::from_owner(owner);","","    assert_eq!(bytes.len(), 4);","    assert!(!bytes.is_empty());","}"],[]],[["{","    struct OwnerThatPanics;","","    impl AsRef<[u8]> for OwnerThatPanics {","        fn as_ref(&self) -> &[u8] {","            panic!();","        }","    }","","    let owner = OwnerThatPanics;","    let _ = Bytes::from_owner(owner); // This should panic when trying to reference the slice","}"],[]],[["{","    struct MultiOwner {","        data: Vec<u8>,","    }","","    impl AsRef<[u8]> for MultiOwner {","        fn as_ref(&self) -> &[u8] {","            &self.data","        }","    }","","    let owner1 = MultiOwner {","        data: vec![5, 6, 7],","    };","    let bytes1 = Bytes::from_owner(owner1);","","    let owner2 = MultiOwner {","        data: vec![8, 9, 10],","    };","    let bytes2 = Bytes::from_owner(owner2);","","    assert_eq!(bytes1.len(), 3);","    assert_eq!(bytes2.len(), 3);","    assert!(!bytes1.is_empty());","    assert!(!bytes2.is_empty());","}"],[]]]}