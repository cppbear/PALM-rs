{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::set_vec_pos","tests":6,"tests_lines":[40,7,7,18,12,17],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":6,"tests_compiled_rate":100.0,"oracles_run":6,"oracles_passed":3,"oracles_passed_rate":50.0,"tests_run":6,"tests_passed":3,"tests_passed_rate":50.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1076,1077,1078,1080,1081],"codes_lines_covered":[[["{","    use core::mem::MaybeUninit;","","    struct TestBytesMut {","        data: *mut Shared,","        kind_value: usize,","    }","","    impl TestBytesMut {","        unsafe fn kind(&self) -> usize {","            self.kind_value","        }","","        unsafe fn set_vec_pos(&mut self, pos: usize) {","            debug_assert_eq!(self.kind(), KIND_VEC);","            debug_assert!(pos <= MAX_VEC_POS);","","            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));","        }","    }","","    const MAX_VEC_POS: usize = usize::MAX >> VEC_POS_OFFSET;","","    let mut test_bytes_mut = TestBytesMut {","        data: core::ptr::null_mut(),","        kind_value: KIND_VEC,","    };","","    unsafe {","        test_bytes_mut.set_vec_pos(MAX_VEC_POS);","    }","","    // Assuming we cannot take a reference to a potentially invalid pointer,","    // we verify the internal representation. This step may vary depending on full context.","    // Since direct testing is limited, we can inspect this indirectly through test_results:","","    let expected_data_value = (MAX_VEC_POS << VEC_POS_OFFSET) & NOT_VEC_POS_MASK;","","    assert_eq!(test_bytes_mut.data as usize & NOT_VEC_POS_MASK, expected_data_value);","}"],[]],[["{","    let mut bytes_mut = BytesMut::new(); // or use with_capacity if needed","    unsafe {","        bytes_mut.set_vec_pos(0); // testing with a valid position","        assert_eq!(bytes_mut.get_vec_pos(), 0); // assuming get_vec_pos returns the correct value for verification","    }","}"],[1076,1077,1078,1080,1081]],[["{","    let mut bytes_mut = BytesMut::new(); // or use with_capacity if needed","    let invalid_pos = MAX_VEC_POS + 1;","    unsafe {","        bytes_mut.set_vec_pos(invalid_pos); // should panic as pos exceeds MAX_VEC_POS","    }","}"],[1076,1077,1078]],[["{","    let mut shared = Shared {","        vec: vec![1, 2, 3],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    };","    let mut bytes_mut = BytesMut {","        ptr: NonNull::new(shared.vec.as_mut_ptr()).unwrap(),","        len: 3,","        cap: 3,","        data: &mut shared as *mut _,","    };","","    unsafe {","        bytes_mut.set_vec_pos(0); // This should not panic","        assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_VEC);","    }","}"],[]],[["{","    let mut bytes_mut = BytesMut {","        ptr: NonNull::dangling(),","        len: 0,","        cap: 0,","        data: ptr::null_mut(),","    };","","    unsafe {","        bytes_mut.set_vec_pos(0); // This should panic since kind is not KIND_VEC","    }","}"],[]],[["{","    let mut shared = Shared {","        vec: vec![1, 2, 3],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    };","    let mut bytes_mut = BytesMut {","        ptr: NonNull::new(shared.vec.as_mut_ptr()).unwrap(),","        len: 3,","        cap: 3,","        data: &mut shared as *mut _,","    };","","    unsafe {","        bytes_mut.set_vec_pos(usize::MAX); // This should panic as it exceeds MAX_VEC_POS","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use core::mem::MaybeUninit;","","    struct TestBytesMut {","        data: *mut Shared,","        kind_value: usize,","    }","","    impl TestBytesMut {","        unsafe fn kind(&self) -> usize {","            self.kind_value","        }","","        unsafe fn set_vec_pos(&mut self, pos: usize) {","            debug_assert_eq!(self.kind(), KIND_VEC);","            debug_assert!(pos <= MAX_VEC_POS);","","            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));","        }","    }","","    const MAX_VEC_POS: usize = usize::MAX >> VEC_POS_OFFSET;","","    let mut test_bytes_mut = TestBytesMut {","        data: core::ptr::null_mut(),","        kind_value: KIND_VEC,","    };","","    unsafe {","        test_bytes_mut.set_vec_pos(MAX_VEC_POS);","    }","","    // Assuming we cannot take a reference to a potentially invalid pointer,","    // we verify the internal representation. This step may vary depending on full context.","    // Since direct testing is limited, we can inspect this indirectly through test_results:","","    let expected_data_value = (MAX_VEC_POS << VEC_POS_OFFSET) & NOT_VEC_POS_MASK;","","    assert_eq!(test_bytes_mut.data as usize & NOT_VEC_POS_MASK, expected_data_value);","}"],[]],[["{","    let mut bytes_mut = BytesMut::new(); // or use with_capacity if needed","    unsafe {","        bytes_mut.set_vec_pos(0); // testing with a valid position","        assert_eq!(bytes_mut.get_vec_pos(), 0); // assuming get_vec_pos returns the correct value for verification","    }","}"],[]],[["{","    let mut bytes_mut = BytesMut::new(); // or use with_capacity if needed","    let invalid_pos = MAX_VEC_POS + 1;","    unsafe {","        bytes_mut.set_vec_pos(invalid_pos); // should panic as pos exceeds MAX_VEC_POS","    }","}"],[]],[["{","    let mut shared = Shared {","        vec: vec![1, 2, 3],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    };","    let mut bytes_mut = BytesMut {","        ptr: NonNull::new(shared.vec.as_mut_ptr()).unwrap(),","        len: 3,","        cap: 3,","        data: &mut shared as *mut _,","    };","","    unsafe {","        bytes_mut.set_vec_pos(0); // This should not panic","        assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_VEC);","    }","}"],[]],[["{","    let mut bytes_mut = BytesMut {","        ptr: NonNull::dangling(),","        len: 0,","        cap: 0,","        data: ptr::null_mut(),","    };","","    unsafe {","        bytes_mut.set_vec_pos(0); // This should panic since kind is not KIND_VEC","    }","}"],[]],[["{","    let mut shared = Shared {","        vec: vec![1, 2, 3],","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    };","    let mut bytes_mut = BytesMut {","        ptr: NonNull::new(shared.vec.as_mut_ptr()).unwrap(),","        len: 3,","        cap: 3,","        data: &mut shared as *mut _,","    };","","    unsafe {","        bytes_mut.set_vec_pos(usize::MAX); // This should panic as it exceeds MAX_VEC_POS","    }","}"],[]]]}