{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::unsplit","tests":6,"tests_lines":[9,9,12,11,11,26],"oracles":6,"oracles_compiled":5,"oracles_compiled_rate":83.33333333333334,"tests_compiled":5,"tests_compiled_rate":83.33333333333334,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":9,"lines_covered":9,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[904,905,906,907,908,910,911,912,913],"codes_lines_covered":[[["{","    let mut buf = BytesMut::new();","    let other = BytesMut::from_vec(vec![1, 2, 3, 4, 5]);","","    buf.unsplit(other);","","    assert_eq!(buf.len(), 5);","    assert_eq!(buf.as_slice(), &[1, 2, 3, 4, 5]);","}"],[904,905,906,907,913]],[["{","    let mut buf = BytesMut::new();","    let other = BytesMut::new();","","    buf.unsplit(other);","","    assert_eq!(buf.len(), 0);","    assert!(buf.is_empty());","}"],[904,905,906,907,913]],[["{","    let mut buf = BytesMut::with_capacity(64);","    buf.extend_from_slice(b\"abcdef\");","","    let split = buf.split_off(3);","    assert_eq!(b\"abc\", &buf[..]);","    assert_eq!(b\"def\", &split[..]);","","    buf.unsplit(split);","    assert_eq!(b\"abcdef\", &buf[..]);","    assert_eq!(buf.len(), 6);","}"],[904,905,908,910,912,913]],[["{","    let mut buf = BytesMut::with_capacity(10);","    buf.extend_from_slice(b\"abc\");","","    let other = BytesMut::new();","","    buf.unsplit(other);","","    assert_eq!(buf.len(), 3);","    assert_eq!(buf.as_slice(), b\"abc\");","}"],[904,905,908,910,912,913]],[["{","    // Create a BytesMut instance with initial data","    let mut buf = BytesMut::with_capacity(32);","    buf.extend_from_slice(b\"hello world\");","","    // Split the buffer into two parts","    let split = buf.split_off(5); // Resulting split: \"hello\" and \" world\"","","    // Ensure that the original buffer and split parts are correct","    assert_eq!(b\"hello\", &buf[..]);","    assert_eq!(b\" world\", &split[..]);","","    // Create another BytesMut that is not contiguous with the original ","    let mut additional_buf = BytesMut::with_capacity(8);","    additional_buf.extend_from_slice(b\"foo\");","","    // Perform the unsplit operation which should extend from additional_buf","    buf.unsplit(additional_buf);","","    // The buf should now contain \"hellofoo\" since it was not able to perform ","    // the O(1) unsplit due to non-contiguous memory","    assert_eq!(b\"hellofoo\", &buf[..]);","","    // Check that the original split buffer still remains unchanged","    assert_eq!(b\" world\", &split[..]);","}"],[904,905,908,910,911,912,913]]],"codes_branches":[{"start_line":905,"start_column":12,"end_line":905,"end_column":27,"positive":true,"negative":true},{"start_line":910,"start_column":16,"end_line":910,"end_column":26,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut buf = BytesMut::new();","    let other = BytesMut::from_vec(vec![1, 2, 3, 4, 5]);","","    buf.unsplit(other);","","    assert_eq!(buf.len(), 5);","    assert_eq!(buf.as_slice(), &[1, 2, 3, 4, 5]);","}"],[{"start_line":905,"start_column":12,"end_line":905,"end_column":27,"positive":true,"negative":false},{"start_line":910,"start_column":16,"end_line":910,"end_column":26,"positive":false,"negative":false}]],[["{","    let mut buf = BytesMut::new();","    let other = BytesMut::new();","","    buf.unsplit(other);","","    assert_eq!(buf.len(), 0);","    assert!(buf.is_empty());","}"],[{"start_line":905,"start_column":12,"end_line":905,"end_column":27,"positive":true,"negative":false},{"start_line":910,"start_column":16,"end_line":910,"end_column":26,"positive":false,"negative":false}]],[["{","    let mut buf = BytesMut::with_capacity(64);","    buf.extend_from_slice(b\"abcdef\");","","    let split = buf.split_off(3);","    assert_eq!(b\"abc\", &buf[..]);","    assert_eq!(b\"def\", &split[..]);","","    buf.unsplit(split);","    assert_eq!(b\"abcdef\", &buf[..]);","    assert_eq!(buf.len(), 6);","}"],[{"start_line":905,"start_column":12,"end_line":905,"end_column":27,"positive":false,"negative":true},{"start_line":910,"start_column":16,"end_line":910,"end_column":26,"positive":false,"negative":true}]],[["{","    let mut buf = BytesMut::with_capacity(10);","    buf.extend_from_slice(b\"abc\");","","    let other = BytesMut::new();","","    buf.unsplit(other);","","    assert_eq!(buf.len(), 3);","    assert_eq!(buf.as_slice(), b\"abc\");","}"],[{"start_line":905,"start_column":12,"end_line":905,"end_column":27,"positive":false,"negative":true},{"start_line":910,"start_column":16,"end_line":910,"end_column":26,"positive":false,"negative":true}]],[["{","    // Create a BytesMut instance with initial data","    let mut buf = BytesMut::with_capacity(32);","    buf.extend_from_slice(b\"hello world\");","","    // Split the buffer into two parts","    let split = buf.split_off(5); // Resulting split: \"hello\" and \" world\"","","    // Ensure that the original buffer and split parts are correct","    assert_eq!(b\"hello\", &buf[..]);","    assert_eq!(b\" world\", &split[..]);","","    // Create another BytesMut that is not contiguous with the original ","    let mut additional_buf = BytesMut::with_capacity(8);","    additional_buf.extend_from_slice(b\"foo\");","","    // Perform the unsplit operation which should extend from additional_buf","    buf.unsplit(additional_buf);","","    // The buf should now contain \"hellofoo\" since it was not able to perform ","    // the O(1) unsplit due to non-contiguous memory","    assert_eq!(b\"hellofoo\", &buf[..]);","","    // Check that the original split buffer still remains unchanged","    assert_eq!(b\" world\", &split[..]);","}"],[{"start_line":905,"start_column":12,"end_line":905,"end_column":27,"positive":false,"negative":true},{"start_line":910,"start_column":16,"end_line":910,"end_column":26,"positive":true,"negative":false}]]]}