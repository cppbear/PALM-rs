{"function_name":"bytes::buf::chain::<buf::chain::Chain<T, U> as buf::buf_impl::Buf>::remaining","tests":4,"tests_lines":[22,22,22,22],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[135,136,137],"codes_lines_covered":[[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let buf1 = TestBuf { remaining: 5 };","    let buf2 = TestBuf { remaining: 10 };","    let chained_buf = Chain { a: buf1, b: buf2 };","","    assert_eq!(chained_buf.remaining(), 15);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let buf1 = TestBuf { remaining: 0 };","    let buf2 = TestBuf { remaining: 0 };","    let chained_buf = Chain { a: buf1, b: buf2 };","","    assert_eq!(chained_buf.remaining(), 0);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let buf1 = TestBuf { remaining: 5 };","    let buf2 = TestBuf { remaining: 0 };","    let chained_buf = Chain { a: buf1, b: buf2 };","","    assert_eq!(chained_buf.remaining(), 5);","}"],[135,136,137]],[["{","    struct TestBuf {","        remaining: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let buf1 = TestBuf { remaining: usize::MAX - 1 };","    let buf2 = TestBuf { remaining: 1 };","    let chained_buf = Chain { a: buf1, b: buf2 };","","    assert_eq!(chained_buf.remaining(), usize::MAX);","}"],[135,136,137]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        remaining: usize,","    }","    ","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let buf1 = TestBuf { remaining: 5 };","    let buf2 = TestBuf { remaining: 10 };","    let chained_buf = Chain { a: buf1, b: buf2 };","","    assert_eq!(chained_buf.remaining(), 15);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let buf1 = TestBuf { remaining: 0 };","    let buf2 = TestBuf { remaining: 0 };","    let chained_buf = Chain { a: buf1, b: buf2 };","","    assert_eq!(chained_buf.remaining(), 0);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let buf1 = TestBuf { remaining: 5 };","    let buf2 = TestBuf { remaining: 0 };","    let chained_buf = Chain { a: buf1, b: buf2 };","","    assert_eq!(chained_buf.remaining(), 5);","}"],[]],[["{","    struct TestBuf {","        remaining: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.remaining","        }","        fn chunk(&self) -> &[u8] { &[] }","        fn advance(&mut self, _: usize) {}","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, _: &mut [IoSlice<'a>]) -> usize { 0 }","        fn copy_to_bytes(&mut self, _: usize) -> crate::Bytes { crate::Bytes::new() }","    }","","    let buf1 = TestBuf { remaining: usize::MAX - 1 };","    let buf2 = TestBuf { remaining: 1 };","    let chained_buf = Chain { a: buf1, b: buf2 };","","    assert_eq!(chained_buf.remaining(), usize::MAX);","}"],[]]]}