{"function_name":"bytes::buf::buf_impl::<std::io::Cursor<T> as buf::buf_impl::Buf>::remaining","tests":4,"tests_lines":[27,27,27,27],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[2929,2930,2931],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, position: usize) -> Self {","            Self { data, position }","        }","","        fn remaining(&self) -> usize {","            saturating_sub_usize_u64(self.data.len(), self.position as u64)","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> usize {","            self.position","        }","    }","","    let buf = TestBuf::new(vec![1, 2, 3, 4, 5], 0);","    assert_eq!(buf.remaining(), 5);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, position: usize) -> Self {","            Self { data, position }","        }","","        fn remaining(&self) -> usize {","            saturating_sub_usize_u64(self.data.len(), self.position as u64)","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> usize {","            self.position","        }","    }","","    let buf = TestBuf::new(vec![1, 2, 3, 4, 5], 3);","    assert_eq!(buf.remaining(), 2);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, position: usize) -> Self {","            Self { data, position }","        }","","        fn remaining(&self) -> usize {","            saturating_sub_usize_u64(self.data.len(), self.position as u64)","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> usize {","            self.position","        }","    }","","    let buf = TestBuf::new(vec![1, 2, 3, 4, 5], 5);","    assert_eq!(buf.remaining(), 0);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, position: usize) -> Self {","            Self { data, position }","        }","","        fn remaining(&self) -> usize {","            saturating_sub_usize_u64(self.data.len(), self.position as u64)","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> usize {","            self.position","        }","    }","","    let buf = TestBuf::new(vec![1, 2, 3, 4, 5], 10);","    assert_eq!(buf.remaining(), 0);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, position: usize) -> Self {","            Self { data, position }","        }","","        fn remaining(&self) -> usize {","            saturating_sub_usize_u64(self.data.len(), self.position as u64)","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> usize {","            self.position","        }","    }","","    let buf = TestBuf::new(vec![1, 2, 3, 4, 5], 0);","    assert_eq!(buf.remaining(), 5);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, position: usize) -> Self {","            Self { data, position }","        }","","        fn remaining(&self) -> usize {","            saturating_sub_usize_u64(self.data.len(), self.position as u64)","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> usize {","            self.position","        }","    }","","    let buf = TestBuf::new(vec![1, 2, 3, 4, 5], 3);","    assert_eq!(buf.remaining(), 2);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, position: usize) -> Self {","            Self { data, position }","        }","","        fn remaining(&self) -> usize {","            saturating_sub_usize_u64(self.data.len(), self.position as u64)","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> usize {","            self.position","        }","    }","","    let buf = TestBuf::new(vec![1, 2, 3, 4, 5], 5);","    assert_eq!(buf.remaining(), 0);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl TestBuf {","        fn new(data: Vec<u8>, position: usize) -> Self {","            Self { data, position }","        }","","        fn remaining(&self) -> usize {","            saturating_sub_usize_u64(self.data.len(), self.position as u64)","        }","","        fn get_ref(&self) -> &Vec<u8> {","            &self.data","        }","","        fn position(&self) -> usize {","            self.position","        }","    }","","    let buf = TestBuf::new(vec![1, 2, 3, 4, 5], 10);","    assert_eq!(buf.remaining(), 0);","}"],[]]]}