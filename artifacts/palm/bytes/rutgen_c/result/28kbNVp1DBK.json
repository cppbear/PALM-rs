{"function_name":"bytes::buf::buf_mut::<&mut T as buf::buf_mut::BufMut>::remaining_mut","tests":2,"tests_lines":[32,36],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1356,1357,1358],"codes_lines_covered":[[["{","    struct TestBufMut {","        data: Vec<core::mem::MaybeUninit<u8>>,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.data.len()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.data.truncate(self.data.len().saturating_sub(cnt));","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","","        fn put_slice(&mut self, src: &[u8]) {","            let cnt = src.len().min(self.remaining_mut());","            self.data.splice(..cnt, src.iter().map(|&x| core::mem::MaybeUninit::new(x)));","        }","","        fn put_bytes(&mut self, _: u8, _: usize) {}","    }","","    let buf = TestBufMut {","        data: vec![core::mem::MaybeUninit::uninit(); 10],","    };","","    assert_eq!(buf.remaining_mut(), 10);","}"],[]],[["{","    struct TestBufMut {","        data: Vec<core::mem::MaybeUninit<u8>>,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.data.len()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.data.truncate(self.data.len().saturating_sub(cnt));","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","","        fn put_slice(&mut self, src: &[u8]) {","            let cnt = src.len().min(self.remaining_mut());","            self.data.splice(..cnt, src.iter().map(|&x| core::mem::MaybeUninit::new(x)));","        }","","        fn put_bytes(&mut self, _: u8, _: usize) {}","    }","","    let mut buf = TestBufMut {","        data: vec![core::mem::MaybeUninit::uninit(); 10],","    };","","    unsafe {","        buf.advance_mut(5);","    }","    ","    assert_eq!(buf.remaining_mut(), 5);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBufMut {","        data: Vec<core::mem::MaybeUninit<u8>>,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.data.len()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.data.truncate(self.data.len().saturating_sub(cnt));","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","","        fn put_slice(&mut self, src: &[u8]) {","            let cnt = src.len().min(self.remaining_mut());","            self.data.splice(..cnt, src.iter().map(|&x| core::mem::MaybeUninit::new(x)));","        }","","        fn put_bytes(&mut self, _: u8, _: usize) {}","    }","","    let buf = TestBufMut {","        data: vec![core::mem::MaybeUninit::uninit(); 10],","    };","","    assert_eq!(buf.remaining_mut(), 10);","}"],[]],[["{","    struct TestBufMut {","        data: Vec<core::mem::MaybeUninit<u8>>,","    }","","    unsafe impl BufMut for TestBufMut {","        fn remaining_mut(&self) -> usize {","            self.data.len()","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.data.truncate(self.data.len().saturating_sub(cnt));","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            unimplemented!()","        }","","        fn put_slice(&mut self, src: &[u8]) {","            let cnt = src.len().min(self.remaining_mut());","            self.data.splice(..cnt, src.iter().map(|&x| core::mem::MaybeUninit::new(x)));","        }","","        fn put_bytes(&mut self, _: u8, _: usize) {}","    }","","    let mut buf = TestBufMut {","        data: vec![core::mem::MaybeUninit::uninit(); 10],","    };","","    unsafe {","        buf.advance_mut(5);","    }","    ","    assert_eq!(buf.remaining_mut(), 5);","}"],[]]]}