{"function_name":"bytes::buf::limit::<buf::limit::Limit<T> as buf::buf_mut::BufMut>::chunk_mut","tests":3,"tests_lines":[32,32,32],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[64,65,66,67,68],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        cursor: usize,","    }","","    unsafe impl BufMut for TestBuf {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.cursor","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            let slice = &mut self.data[self.cursor..];","            UninitSlice::new(slice)","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.cursor += cnt;","        }","    }","","    let mut buf = TestBuf {","        data: vec![0; 10],","        cursor: 0,","    };","    ","    let limit = 5;","    let mut limited_buf = buf.limit(limit);","    ","    let chunk = limited_buf.chunk_mut();","    assert_eq!(chunk.len(), 5);","}"],[64,65,66,67,68]],[["{","    struct TestBuf {","        data: Vec<u8>,","        cursor: usize,","    }","","    unsafe impl BufMut for TestBuf {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.cursor","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            let slice = &mut self.data[self.cursor..];","            UninitSlice::new(slice)","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.cursor += cnt;","        }","    }","","    let mut buf = TestBuf {","        data: vec![0; 5],","        cursor: 0,","    };","    ","    let limit = 5;","    let mut limited_buf = buf.limit(limit);","    ","    let chunk = limited_buf.chunk_mut();","    assert_eq!(chunk.len(), 5);","}"],[64,65,66,67,68]],[["{","    struct TestBuf {","        data: Vec<u8>,","        cursor: usize,","    }","","    unsafe impl BufMut for TestBuf {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.cursor","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            let slice = &mut self.data[self.cursor..];","            UninitSlice::new(slice)","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.cursor += cnt;","        }","    }","","    let mut buf = TestBuf {","        data: vec![0; 8],","        cursor: 0,","    };","    ","    let limit = 10;","    let mut limited_buf = buf.limit(limit);","    ","    let chunk = limited_buf.chunk_mut();","    assert_eq!(chunk.len(), 8);","}"],[64,65,66,67,68]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        cursor: usize,","    }","","    unsafe impl BufMut for TestBuf {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.cursor","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            let slice = &mut self.data[self.cursor..];","            UninitSlice::new(slice)","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.cursor += cnt;","        }","    }","","    let mut buf = TestBuf {","        data: vec![0; 10],","        cursor: 0,","    };","    ","    let limit = 5;","    let mut limited_buf = buf.limit(limit);","    ","    let chunk = limited_buf.chunk_mut();","    assert_eq!(chunk.len(), 5);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        cursor: usize,","    }","","    unsafe impl BufMut for TestBuf {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.cursor","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            let slice = &mut self.data[self.cursor..];","            UninitSlice::new(slice)","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.cursor += cnt;","        }","    }","","    let mut buf = TestBuf {","        data: vec![0; 5],","        cursor: 0,","    };","    ","    let limit = 5;","    let mut limited_buf = buf.limit(limit);","    ","    let chunk = limited_buf.chunk_mut();","    assert_eq!(chunk.len(), 5);","}"],[]],[["{","    struct TestBuf {","        data: Vec<u8>,","        cursor: usize,","    }","","    unsafe impl BufMut for TestBuf {","        fn remaining_mut(&self) -> usize {","            self.data.len() - self.cursor","        }","","        fn chunk_mut(&mut self) -> &mut UninitSlice {","            let slice = &mut self.data[self.cursor..];","            UninitSlice::new(slice)","        }","","        unsafe fn advance_mut(&mut self, cnt: usize) {","            self.cursor += cnt;","        }","    }","","    let mut buf = TestBuf {","        data: vec![0; 8],","        cursor: 0,","    };","    ","    let limit = 10;","    let mut limited_buf = buf.limit(limit);","    ","    let chunk = limited_buf.chunk_mut();","    assert_eq!(chunk.len(), 8);","}"],[]]]}