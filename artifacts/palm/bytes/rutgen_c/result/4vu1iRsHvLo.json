{"function_name":"bytes::buf::chain::<buf::chain::Chain<T, U> as buf::buf_impl::Buf>::chunks_vectored","tests":3,"tests_lines":[34,35,36],"oracles":3,"oracles_compiled":1,"oracles_compiled_rate":33.33333333333333,"tests_compiled":1,"tests_compiled_rate":33.33333333333333,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[166,167,168,169,170],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, cnt: usize) {","            self.data.drain(0..cnt);","        }","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf_a = TestBuf { data: vec![1, 2, 3] };","    let buf_b = TestBuf { data: vec![4, 5] };","    let chain_buf = Chain { a: buf_a, b: buf_b };","","    let mut dst: [IoSlice; 0] = [];","    assert_eq!(chain_buf.chunks_vectored(&mut dst), 0);","}"],[166,167,168,169,170]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len()","        }","","        fn chunk(&self) -> &[u8] {","            &self.data","        }","","        fn advance(&mut self, cnt: usize) {","            self.data.drain(0..cnt);","        }","","        fn has_remaining(&self) -> bool {","            !self.data.is_empty()","        }","","        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {","            unimplemented!()","        }","    }","","    let buf_a = TestBuf { data: vec![1, 2, 3] };","    let buf_b = TestBuf { data: vec![4, 5] };","    let chain_buf = Chain { a: buf_a, b: buf_b };","","    let mut dst: [IoSlice; 0] = [];","    assert_eq!(chain_buf.chunks_vectored(&mut dst), 0);","}"],[]]]}