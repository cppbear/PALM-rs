{"function_name":"bytes::bytes_mut::bytes_mut::BytesMut::set_vec_pos","tests":3,"tests_lines":[29,28,28],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1076,1077,1078,1080,1081],"codes_lines_covered":[[["{","    struct TestBytesMut {","        data: *mut Shared,","        kind: usize,","    }","","    impl TestBytesMut {","        unsafe fn set_vec_pos(&mut self, pos: usize) {","            debug_assert_eq!(self.kind, KIND_VEC);","            debug_assert!(pos <= MAX_VEC_POS);","","            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));","        }","","        fn kind(&self) -> usize {","            self.kind","        }","    }","","    unsafe {","        let mut test_bytes_mut = TestBytesMut {","            data: core::ptr::null_mut(),","            kind: KIND_VEC,","        };","","        test_bytes_mut.set_vec_pos(10);","        // Check if data was set correctly. In a real scenario, we would need a way to verify this.","    }","}"],[]],[["{","    struct TestBytesMut {","        data: *mut Shared,","        kind: usize,","    }","","    impl TestBytesMut {","        unsafe fn set_vec_pos(&mut self, pos: usize) {","            debug_assert_eq!(self.kind, KIND_VEC);","            debug_assert!(pos <= MAX_VEC_POS);","","            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));","        }","","        fn kind(&self) -> usize {","            self.kind","        }","    }","","    unsafe {","        let mut test_bytes_mut = TestBytesMut {","            data: core::ptr::null_mut(),","            kind: KIND_ARC, // Invalid kind","        };","","        test_bytes_mut.set_vec_pos(10); // This should panic due to invalid kind.","    }","}"],[]],[["{","    struct TestBytesMut {","        data: *mut Shared,","        kind: usize,","    }","","    impl TestBytesMut {","        unsafe fn set_vec_pos(&mut self, pos: usize) {","            debug_assert_eq!(self.kind, KIND_VEC);","            debug_assert!(pos <= MAX_VEC_POS);","","            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));","        }","","        fn kind(&self) -> usize {","            self.kind","        }","    }","","    unsafe {","        let mut test_bytes_mut = TestBytesMut {","            data: core::ptr::null_mut(),","            kind: KIND_VEC,","        };","","        test_bytes_mut.set_vec_pos(MAX_VEC_POS + 1); // This should panic due to out of bounds.","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBytesMut {","        data: *mut Shared,","        kind: usize,","    }","","    impl TestBytesMut {","        unsafe fn set_vec_pos(&mut self, pos: usize) {","            debug_assert_eq!(self.kind, KIND_VEC);","            debug_assert!(pos <= MAX_VEC_POS);","","            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));","        }","","        fn kind(&self) -> usize {","            self.kind","        }","    }","","    unsafe {","        let mut test_bytes_mut = TestBytesMut {","            data: core::ptr::null_mut(),","            kind: KIND_VEC,","        };","","        test_bytes_mut.set_vec_pos(10);","        // Check if data was set correctly. In a real scenario, we would need a way to verify this.","    }","}"],[]],[["{","    struct TestBytesMut {","        data: *mut Shared,","        kind: usize,","    }","","    impl TestBytesMut {","        unsafe fn set_vec_pos(&mut self, pos: usize) {","            debug_assert_eq!(self.kind, KIND_VEC);","            debug_assert!(pos <= MAX_VEC_POS);","","            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));","        }","","        fn kind(&self) -> usize {","            self.kind","        }","    }","","    unsafe {","        let mut test_bytes_mut = TestBytesMut {","            data: core::ptr::null_mut(),","            kind: KIND_ARC, // Invalid kind","        };","","        test_bytes_mut.set_vec_pos(10); // This should panic due to invalid kind.","    }","}"],[]],[["{","    struct TestBytesMut {","        data: *mut Shared,","        kind: usize,","    }","","    impl TestBytesMut {","        unsafe fn set_vec_pos(&mut self, pos: usize) {","            debug_assert_eq!(self.kind, KIND_VEC);","            debug_assert!(pos <= MAX_VEC_POS);","","            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));","        }","","        fn kind(&self) -> usize {","            self.kind","        }","    }","","    unsafe {","        let mut test_bytes_mut = TestBytesMut {","            data: core::ptr::null_mut(),","            kind: KIND_VEC,","        };","","        test_bytes_mut.set_vec_pos(MAX_VEC_POS + 1); // This should panic due to out of bounds.","    }","}"],[]]]}