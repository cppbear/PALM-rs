{"function_name":"bytes::buf::take::<buf::take::Take<T> as buf::buf_impl::Buf>::chunks_vectored","tests":3,"tests_lines":[57,56,47],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":40,"lines_covered":34,"lines_coveraged_rate":85.0,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[160,161,162,163,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,192,193,194,195,196,197,198,199,200,202,203],"codes_lines_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn has_remaining(&self) -> bool {","            self.position < self.data.len()","        }","","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {","            let mut count = 0;","            for slice in dst.iter_mut() {","                if self.has_remaining() {","                    let chunk = self.chunk();","                    *slice = IoSlice::new(chunk);","                    count += 1;","                    break; // For this test we only fill one slice","                }","            }","            count","        }","        ","        // Provide a minimal implementation for additional methods","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes { unimplemented!() }","        fn get_u8(&mut self) -> u8 { unimplemented!() }","        fn get_i8(&mut self) -> i8 { unimplemented!() }","        fn get_u16(&mut self) -> u16 { unimplemented!() }","        // ... Other methods are omitted for brevity","    }","","    let buf = TestBuf {","        data: vec![1, 2, 3, 4, 5],","        position: 0,","    };","    let mut take_buf = Take { inner: buf, limit: 5 };","","    let mut dst: [IoSlice; 1] = [IoSlice::new(&[])];","    let count = take_buf.chunks_vectored(&mut dst);","","    assert_eq!(count, 1);","    assert_eq!(dst[0]. len(), 5);","}"],[160,161,163,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,192,193,194,203]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn has_remaining(&self) -> bool {","            self.position < self.data.len()","        }","        ","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {","            let mut count = 0;","            for slice in dst.iter_mut() {","                if self.has_remaining() {","                    let chunk = self.chunk();","                    *slice = IoSlice::new(chunk);","                    count += 1;","                    break; // For this test we only fill one slice","                }","            }","            count","        }","","        // Provide a minimal implementation for additional methods","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes { unimplemented!() }","        fn get_u8(&mut self) -> u8 { unimplemented!() }","        fn get_i8(&mut self) -> i8 { unimplemented!() }","        fn get_u16(&mut self) -> u16 { unimplemented!() }","        // ... Other methods are omitted for brevity","    }","","    let buf = TestBuf {","        data: vec![1, 2, 3, 4, 5],","        position: 0,","    };","    let mut take_buf = Take { inner: buf, limit: 5 };","","    let mut dst: [IoSlice; 0] = [];","    let count = take_buf.chunks_vectored(&mut dst);","","    assert_eq!(count, 0);","}"],[160,161,163,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,202,203]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn has_remaining(&self) -> bool {","            self.position < self.data.len()","        }","        ","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {","            0 // Simulating that it will return 0 slices","        }","","        // Provide a minimal implementation for additional methods","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes { unimplemented!() }","        fn get_u8(&mut self) -> u8 { unimplemented!() }","        fn get_i8(&mut self) -> i8 { unimplemented!() }","        fn get_u16(&mut self) -> u16 { unimplemented!() }","        // ... Other methods are omitted for brevity","    }","","    let buf = TestBuf {","        data: vec![1, 2, 3, 4, 5],","        position: 0,","    };","    let mut take_buf = Take { inner: buf, limit: 0 };","","    let mut dst: [IoSlice; 1] = [IoSlice::new(&[])];","    let count = take_buf.chunks_vectored(&mut dst);","","    assert_eq!(count, 0);","}"],[160,161,162,203]]],"codes_branches":[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":true,"negative":true},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn has_remaining(&self) -> bool {","            self.position < self.data.len()","        }","","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {","            let mut count = 0;","            for slice in dst.iter_mut() {","                if self.has_remaining() {","                    let chunk = self.chunk();","                    *slice = IoSlice::new(chunk);","                    count += 1;","                    break; // For this test we only fill one slice","                }","            }","            count","        }","        ","        // Provide a minimal implementation for additional methods","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes { unimplemented!() }","        fn get_u8(&mut self) -> u8 { unimplemented!() }","        fn get_i8(&mut self) -> i8 { unimplemented!() }","        fn get_u16(&mut self) -> u16 { unimplemented!() }","        // ... Other methods are omitted for brevity","    }","","    let buf = TestBuf {","        data: vec![1, 2, 3, 4, 5],","        position: 0,","    };","    let mut take_buf = Take { inner: buf, limit: 5 };","","    let mut dst: [IoSlice; 1] = [IoSlice::new(&[])];","    let count = take_buf.chunks_vectored(&mut dst);","","    assert_eq!(count, 1);","    assert_eq!(dst[0]. len(), 5);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":true},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":true,"negative":false}]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn has_remaining(&self) -> bool {","            self.position < self.data.len()","        }","        ","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {","            let mut count = 0;","            for slice in dst.iter_mut() {","                if self.has_remaining() {","                    let chunk = self.chunk();","                    *slice = IoSlice::new(chunk);","                    count += 1;","                    break; // For this test we only fill one slice","                }","            }","            count","        }","","        // Provide a minimal implementation for additional methods","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes { unimplemented!() }","        fn get_u8(&mut self) -> u8 { unimplemented!() }","        fn get_i8(&mut self) -> i8 { unimplemented!() }","        fn get_u16(&mut self) -> u16 { unimplemented!() }","        // ... Other methods are omitted for brevity","    }","","    let buf = TestBuf {","        data: vec![1, 2, 3, 4, 5],","        position: 0,","    };","    let mut take_buf = Take { inner: buf, limit: 5 };","","    let mut dst: [IoSlice; 0] = [];","    let count = take_buf.chunks_vectored(&mut dst);","","    assert_eq!(count, 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":false,"negative":true},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]],[["{","    struct TestBuf {","        data: Vec<u8>,","        position: usize,","    }","","    impl Buf for TestBuf {","        fn remaining(&self) -> usize {","            self.data.len() - self.position","        }","","        fn chunk(&self) -> &[u8] {","            &self.data[self.position..]","        }","","        fn advance(&mut self, cnt: usize) {","            self.position += cnt;","        }","","        fn has_remaining(&self) -> bool {","            self.position < self.data.len()","        }","        ","        #[cfg(feature = \"std\")]","        fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {","            0 // Simulating that it will return 0 slices","        }","","        // Provide a minimal implementation for additional methods","        fn copy_to_bytes(&mut self, _len: usize) -> crate::Bytes { unimplemented!() }","        fn get_u8(&mut self) -> u8 { unimplemented!() }","        fn get_i8(&mut self) -> i8 { unimplemented!() }","        fn get_u16(&mut self) -> u16 { unimplemented!() }","        // ... Other methods are omitted for brevity","    }","","    let buf = TestBuf {","        data: vec![1, 2, 3, 4, 5],","        position: 0,","    };","    let mut take_buf = Take { inner: buf, limit: 0 };","","    let mut dst: [IoSlice; 1] = [IoSlice::new(&[])];","    let count = take_buf.chunks_vectored(&mut dst);","","    assert_eq!(count, 0);","}"],[{"start_line":161,"start_column":12,"end_line":161,"end_column":27,"positive":true,"negative":false},{"start_line":190,"start_column":20,"end_line":190,"end_column":29,"positive":false,"negative":false}]]]}