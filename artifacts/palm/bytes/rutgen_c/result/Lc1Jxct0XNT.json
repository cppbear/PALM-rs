{"function_name":"bytes::bytes_mut::shared_v_to_mut","tests":2,"tests_lines":[19,19],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":26,"lines_covered":26,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1838,1839,1840,1842],"codes_lines_covered":[[["{","    use core::sync::atomic::AtomicPtr;","    use alloc::vec;","","    let vec_data = vec![1, 2, 3, 4];","    let mut shared = Shared {","        vec: vec_data.clone(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    };","    ","    let data = AtomicPtr::new(&mut shared as *mut Shared as *mut ());","","    unsafe {","        let result = shared_v_to_mut(&data, vec_data.as_ptr(), vec_data.len());","        assert_eq!(result.len(), vec_data.len());","        assert_eq!(result.capacity(), vec_data.len());","    }","}"],[1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1842]],[["{","    use core::sync::atomic::AtomicPtr;","    use alloc::vec;","","    let vec_data = vec![1, 2, 3, 4];","    let mut shared = Shared {","        vec: vec_data.clone(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    ","    let data = AtomicPtr::new(&mut shared as *mut Shared as *mut ());","","    unsafe {","        let result = shared_v_to_mut(&data, vec_data.as_ptr(), vec_data.len());","        assert_eq!(result.len(), vec_data.len());","        assert_eq!(result.capacity(), vec_data.len());","    }","}"],[1815,1816,1817,1818,1838,1839,1840,1842]]],"codes_branches":[{"start_line":1818,"start_column":8,"end_line":1818,"end_column":29,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    use core::sync::atomic::AtomicPtr;","    use alloc::vec;","","    let vec_data = vec![1, 2, 3, 4];","    let mut shared = Shared {","        vec: vec_data.clone(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(1),","    };","    ","    let data = AtomicPtr::new(&mut shared as *mut Shared as *mut ());","","    unsafe {","        let result = shared_v_to_mut(&data, vec_data.as_ptr(), vec_data.len());","        assert_eq!(result.len(), vec_data.len());","        assert_eq!(result.capacity(), vec_data.len());","    }","}"],[{"start_line":1818,"start_column":8,"end_line":1818,"end_column":29,"positive":true,"negative":false}]],[["{","    use core::sync::atomic::AtomicPtr;","    use alloc::vec;","","    let vec_data = vec![1, 2, 3, 4];","    let mut shared = Shared {","        vec: vec_data.clone(),","        original_capacity_repr: 0,","        ref_count: AtomicUsize::new(2),","    };","    ","    let data = AtomicPtr::new(&mut shared as *mut Shared as *mut ());","","    unsafe {","        let result = shared_v_to_mut(&data, vec_data.as_ptr(), vec_data.len());","        assert_eq!(result.len(), vec_data.len());","        assert_eq!(result.capacity(), vec_data.len());","    }","}"],[{"start_line":1818,"start_column":8,"end_line":1818,"end_column":29,"positive":false,"negative":true}]]]}