{"function_name":"bytes::buf::vec_deque::buf::vec_deque::<impl buf::buf_impl::Buf for alloc::collections::VecDeque<u8>>::chunks_vectored","tests":4,"tests_lines":[9,11,13,12],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":4,"tests_passed":2,"tests_passed_rate":50.0,"lines":14,"lines_covered":10,"lines_coveraged_rate":71.42857142857143,"branches":8,"branches_covered":4,"branches_coverage_rate":50.0,"codes_lines":[22,23,24,25,26,27,28,29,30,31,32,33,34,35],"codes_lines_covered":[[["{","    use alloc::collections::VecDeque;","    use std::io;","","    let vec_deque: VecDeque<u8> = VecDeque::new();","    let mut slices = [io::IoSlice::new(&[])];","    let result = vec_deque.chunks_vectored(&mut slices);","    assert_eq!(result, 0);","}"],[22,23,24,35]],[["{","    use alloc::collections::VecDeque;","    use std::io;","","    let mut vec_deque: VecDeque<u8> = VecDeque::new();","    vec_deque.push_back(1);","    let mut slices = [io::IoSlice::new(&[])];","    let result = vec_deque.chunks_vectored(&mut slices);","    assert_eq!(result, 1);","    assert_eq!(slices[0].as_ref(), [1]);","}"],[22,23,25,26,27,28,29,30,35]],[["{","    use alloc::collections::VecDeque;","    use std::io;","","    let mut vec_deque: VecDeque<u8> = VecDeque::new();","    vec_deque.push_back(1);","    vec_deque.push_back(2);","    let mut slices = [io::IoSlice::new(&[]), io::IoSlice::new(&[])];","    let result = vec_deque.chunks_vectored(&mut slices);","    assert_eq!(result, 2);","    assert_eq!(slices[0].as_ref(), [1]);","    assert_eq!(slices[1].as_ref(), [2]);","}"],[22,23,25,26,27,28,29,30,35]],[["{","    use alloc::collections::VecDeque;","    use std::io;","","    let mut vec_deque: VecDeque<u8> = VecDeque::new();","    vec_deque.push_back(1);","    vec_deque.push_back(2);","    let mut slices = [io::IoSlice::new(&[])];","    let result = vec_deque.chunks_vectored(&mut slices);","    assert_eq!(result, 1);","    assert_eq!(slices[0].as_ref(), [1]);","}"],[22,23,25,26,27,28,29,30,35]]],"codes_branches":[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":true,"negative":true},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":true},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":true,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    use alloc::collections::VecDeque;","    use std::io;","","    let vec_deque: VecDeque<u8> = VecDeque::new();","    let mut slices = [io::IoSlice::new(&[])];","    let result = vec_deque.chunks_vectored(&mut slices);","    assert_eq!(result, 0);","}"],[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":true,"negative":false},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":false},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":false,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}]],[["{","    use alloc::collections::VecDeque;","    use std::io;","","    let mut vec_deque: VecDeque<u8> = VecDeque::new();","    vec_deque.push_back(1);","    let mut slices = [io::IoSlice::new(&[])];","    let result = vec_deque.chunks_vectored(&mut slices);","    assert_eq!(result, 1);","    assert_eq!(slices[0].as_ref(), [1]);","}"],[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":true},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":true},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":true,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}]],[["{","    use alloc::collections::VecDeque;","    use std::io;","","    let mut vec_deque: VecDeque<u8> = VecDeque::new();","    vec_deque.push_back(1);","    vec_deque.push_back(2);","    let mut slices = [io::IoSlice::new(&[]), io::IoSlice::new(&[])];","    let result = vec_deque.chunks_vectored(&mut slices);","    assert_eq!(result, 2);","    assert_eq!(slices[0].as_ref(), [1]);","    assert_eq!(slices[1].as_ref(), [2]);","}"],[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":true},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":true},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":true,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}]],[["{","    use alloc::collections::VecDeque;","    use std::io;","","    let mut vec_deque: VecDeque<u8> = VecDeque::new();","    vec_deque.push_back(1);","    vec_deque.push_back(2);","    let mut slices = [io::IoSlice::new(&[])];","    let result = vec_deque.chunks_vectored(&mut slices);","    assert_eq!(result, 1);","    assert_eq!(slices[0].as_ref(), [1]);","}"],[{"start_line":23,"start_column":12,"end_line":23,"end_column":27,"positive":false,"negative":true},{"start_line":23,"start_column":31,"end_line":23,"end_column":45,"positive":false,"negative":true},{"start_line":29,"start_column":12,"end_line":29,"end_column":25,"positive":true,"negative":false},{"start_line":29,"start_column":29,"end_line":29,"end_column":43,"positive":false,"negative":false}]]]}