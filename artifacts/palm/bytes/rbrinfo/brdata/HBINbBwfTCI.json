{
  "name": "bytes::buf::buf_impl::Buf::chunks_vectored",
  "name_with_impl": "bytes::buf::buf_impl::Buf::chunks_vectored",
  "mod_info": {
    "name": "buf::buf_impl",
    "loc": "src/buf/mod.rs:17:1:17:14"
  },
  "visible": true,
  "loc": "src/buf/buf_impl.rs:207:5:218:6",
  "doc": "/// Fills `dst` with potentially multiple slices starting at `self`'s\n/// current position.\n///\n/// If the `Buf` is backed by disjoint slices of bytes, `chunk_vectored` enables\n/// fetching more than one slice at once. `dst` is a slice of `IoSlice`\n/// references, enabling the slice to be directly used with [`writev`]\n/// without any further conversion. The sum of the lengths of all the\n/// buffers written to `dst` will be less than or equal to `Buf::remaining()`.\n///\n/// The entries in `dst` will be overwritten, but the data **contained** by\n/// the slices **will not** be modified. The return value is the number of\n/// slices written to `dst`. If `Buf::remaining()` is non-zero, then this\n/// writes at least one non-empty slice to `dst`.\n///\n/// This is a lower level function. Most operations are done with other\n/// functions.\n///\n/// # Implementer notes\n///\n/// This function should never panic. Once the end of the buffer is reached,\n/// i.e., `Buf::remaining` returns 0, calls to `chunk_vectored` must return 0\n/// without mutating `dst`.\n///\n/// Implementations should also take care to properly handle being called\n/// with `dst` being a zero length slice.\n///\n/// [`writev`]: http://man7.org/linux/man-pages/man2/readv.2.html\n",
  "code": [
    "fn chunks_vectored<'a>(&'a self, dst: &mut [IoSlice<'a>]) -> usize {",
    "    if dst.is_empty() {",
    "        return 0;",
    "    }",
    "",
    "    if self.has_remaining() {",
    "        dst[0] = IoSlice::new(self.chunk());",
    "        1",
    "    } else {",
    "        0",
    "    }",
    "}"
  ],
  "size": {
    "chain": 3,
    "contra": 0,
    "min_set": 3
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "dst.is_empty()",
          "norm": null,
          "value": "true",
          "line": 208,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "0",
      "path": [
        0,
        1,
        2,
        11
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "dst.is_empty()",
          "norm": null,
          "value": "false",
          "line": 208,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.has_remaining()",
          "norm": null,
          "value": "true",
          "line": 212,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "1",
      "path": [
        0,
        1,
        3,
        4,
        5,
        6,
        7,
        8,
        10,
        11
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "dst.is_empty()",
          "norm": null,
          "value": "false",
          "line": 208,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.has_remaining()",
          "norm": null,
          "value": "false",
          "line": 212,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "0",
      "path": [
        0,
        1,
        3,
        4,
        9,
        10,
        11
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}