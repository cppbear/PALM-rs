{
  "name": "bytes::bytes_mut::bytes_mut::BytesMut::try_reclaim",
  "name_with_impl": "bytes::bytes_mut::{impl#0}::try_reclaim",
  "mod_info": {
    "name": "bytes_mut",
    "loc": "src/lib.rs:83:1:83:15"
  },
  "visible": true,
  "loc": "src/bytes_mut.rs:833:5:844:6",
  "doc": "/// Attempts to cheaply reclaim already allocated capacity for at least `additional` more\n/// bytes to be inserted into the given `BytesMut` and returns `true` if it succeeded.\n///\n/// `try_reclaim` behaves exactly like `reserve`, except that it never allocates new storage\n/// and returns a `bool` indicating whether it was successful in doing so:\n///\n/// `try_reclaim` returns false under these conditions:\n///  - The spare capacity left is less than `additional` bytes AND\n///  - The existing allocation cannot be reclaimed cheaply or it was less than\n///    `additional` bytes in size\n///\n/// Reclaiming the allocation cheaply is possible if the `BytesMut` has no outstanding\n/// references through other `BytesMut`s or `Bytes` which point to the same underlying\n/// storage.\n///\n/// # Examples\n///\n/// ```\n/// use bytes::BytesMut;\n///\n/// let mut buf = BytesMut::with_capacity(64);\n/// assert_eq!(true, buf.try_reclaim(64));\n/// assert_eq!(64, buf.capacity());\n///\n/// buf.extend_from_slice(b\"abcd\");\n/// let mut split = buf.split();\n/// assert_eq!(60, buf.capacity());\n/// assert_eq!(4, split.capacity());\n/// assert_eq!(false, split.try_reclaim(64));\n/// assert_eq!(false, buf.try_reclaim(64));\n/// // The split buffer is filled with \"abcd\"\n/// assert_eq!(false, split.try_reclaim(4));\n/// // buf is empty and has capacity for 60 bytes\n/// assert_eq!(true, buf.try_reclaim(60));\n///\n/// drop(buf);\n/// assert_eq!(false, split.try_reclaim(64));\n///\n/// split.clear();\n/// assert_eq!(4, split.capacity());\n/// assert_eq!(true, split.try_reclaim(64));\n/// assert_eq!(64, split.capacity());\n/// ```\n",
  "code": [
    "pub fn try_reclaim(&mut self, additional: usize) -> bool {",
    "    let len = self.len();",
    "    let rem = self.capacity() - len;",
    "",
    "    if additional <= rem {",
    "        // The handle can already store at least `additional` more bytes, so",
    "        // there is no further work needed to be done.",
    "        return true;",
    "    }",
    "",
    "    self.reserve_inner(additional, false)",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "additional <= rem",
          "norm": null,
          "value": "true",
          "line": 837,
          "bound": "additional == rem",
          "may_panic": false
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        4,
        7
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "additional <= rem",
          "norm": null,
          "value": "false",
          "line": 837,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        5,
        6,
        7
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}