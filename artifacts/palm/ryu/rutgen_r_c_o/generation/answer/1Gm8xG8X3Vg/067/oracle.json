[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let f: f64 = 1.0e-324; // Valid input that maximizes runtime satisfaction based on constraints",
          "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
          "    unsafe {",
          "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let f: f64 = 1.0e-324;",
            "    let expected_length = 9;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    assert_eq!(len, expected_length);"
          ],
          [
            "    let f: f64 = 1.0e-324;",
            "    let expected_length = 9;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    let slice = std::slice::from_raw_parts(buffer.as_ptr() as *const u8, len);",
            "    let print = std::str::from_utf8_unchecked(slice);",
            "    assert_eq!(print, \"0.000000000\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let f: f64 = 1.0e-324; // Valid input that maximizes runtime satisfaction based on constraints",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let f: f64 = 1.0e-324;",
            "    let expected_length = 9;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    assert_eq!(len, expected_length);",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-324; // Valid input that maximizes runtime satisfaction based on constraints",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let f: f64 = 1.0e-324;",
            "    let expected_length = 9;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    let slice = std::slice::from_raw_parts(buffer.as_ptr() as *const u8, len);",
            "    let print = std::str::from_utf8_unchecked(slice);",
            "    assert_eq!(print, \"0.000000000\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let f: f64 = 1.0e-320; // Valid input to cover another edge case",
          "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
          "    unsafe {",
          "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let f: f64 = 1.0e-320;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    assert_eq!(len, expected_length); // Replace expected_length with the expected output length"
          ],
          [
            "    let f: f64 = 1.0e-320;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    let slice = std::slice::from_raw_parts(buffer.as_ptr() as *const u8, len);",
            "    let print = std::str::from_utf8_unchecked(slice);",
            "    assert_eq!(print, \"0.00000000000000000000\"); // Expected output for 1.0e-320"
          ]
        ],
        "codes": [
          [
            "{",
            "    let f: f64 = 1.0e-320; // Valid input to cover another edge case",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let f: f64 = 1.0e-320;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    assert_eq!(len, expected_length); // Replace expected_length with the expected output length",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-320; // Valid input to cover another edge case",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let f: f64 = 1.0e-320;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    let slice = std::slice::from_raw_parts(buffer.as_ptr() as *const u8, len);",
            "    let print = std::str::from_utf8_unchecked(slice);",
            "    assert_eq!(print, \"0.00000000000000000000\"); // Expected output for 1.0e-320",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let f: f64 = 1.0e-310; // Confirming behavior with a different input within valid range",
          "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
          "    unsafe {",
          "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let f: f64 = 1.0e-310;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    let slice = std::slice::from_raw_parts(buffer.as_ptr() as *const u8, len);",
            "    let print = std::str::from_utf8_unchecked(slice);",
            "    assert_eq!(print, \"0.000000000000000000001\");"
          ],
          [
            "    let f: f64 = 1.0e-310;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    let slice = std::slice::from_raw_parts(buffer.as_ptr() as *const u8, len);",
            "    let print = std::str::from_utf8_unchecked(slice);",
            "    }",
            "    assert!(len <= 24);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let f: f64 = 1.0e-310; // Confirming behavior with a different input within valid range",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let f: f64 = 1.0e-310;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    let slice = std::slice::from_raw_parts(buffer.as_ptr() as *const u8, len);",
            "    let print = std::str::from_utf8_unchecked(slice);",
            "    assert_eq!(print, \"0.000000000000000000001\");",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-310; // Confirming behavior with a different input within valid range",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let f: f64 = 1.0e-310;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    let slice = std::slice::from_raw_parts(buffer.as_ptr() as *const u8, len);",
            "    let print = std::str::from_utf8_unchecked(slice);",
            "    }",
            "    assert!(len <= 24);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let f: f64 = 1.0e-305; // Adjusting input value",
          "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
          "    unsafe {",
          "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let f: f64 = 1.0e-305;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    assert_eq!(len, 11);"
          ],
          [
            "    let f: f64 = 1.0e-305;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    let slice = std::slice::from_raw_parts(buffer.as_ptr() as *const u8, len);",
            "    let print = std::str::from_utf8_unchecked(slice);",
            "    assert_eq!(print, \"0.00000000001\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let f: f64 = 1.0e-305; // Adjusting input value",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let f: f64 = 1.0e-305;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    assert_eq!(len, 11);",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-305; // Adjusting input value",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let f: f64 = 1.0e-305;",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "    let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    let slice = std::slice::from_raw_parts(buffer.as_ptr() as *const u8, len);",
            "    let print = std::str::from_utf8_unchecked(slice);",
            "    assert_eq!(print, \"0.00000000001\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let f: f64 = 1.0e-301; // Testing at upper limit ",
          "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
          "    unsafe {",
          "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let bits = f.to_bits();",
            "    assert_eq!(bits, 0x1e00000000000000);"
          ],
          [
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    assert_eq!(sign, false);"
          ],
          [
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    assert_eq!(ieee_mantissa, 0x0000000000000000);"
          ],
          [
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    assert_ne!(ieee_exponent, 0);"
          ],
          [
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    assert_eq!(length, 1);"
          ],
          [
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    assert!(k >= -324);"
          ],
          [
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    assert!(0 <= k);"
          ],
          [
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    assert!(kk > 0);"
          ],
          [
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    unsafe {",
            "    assert!(buffer.as_mut_ptr() as *mut u8 != std::ptr::null_mut());"
          ],
          [
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    unsafe {",
            "    }",
            "    assert!(len <= 24);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let f: f64 = 1.0e-301; // Testing at upper limit ",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let bits = f.to_bits();",
            "    assert_eq!(bits, 0x1e00000000000000);",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-301; // Testing at upper limit ",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    assert_eq!(sign, false);",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-301; // Testing at upper limit ",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    assert_eq!(ieee_mantissa, 0x0000000000000000);",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-301; // Testing at upper limit ",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    assert_ne!(ieee_exponent, 0);",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-301; // Testing at upper limit ",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    assert_eq!(length, 1);",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-301; // Testing at upper limit ",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    assert!(k >= -324);",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-301; // Testing at upper limit ",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    assert!(0 <= k);",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-301; // Testing at upper limit ",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    assert!(kk > 0);",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-301; // Testing at upper limit ",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    unsafe {",
            "    assert!(buffer.as_mut_ptr() as *mut u8 != std::ptr::null_mut());",
            "}"
          ],
          [
            "{",
            "    let f: f64 = 1.0e-301; // Testing at upper limit ",
            "    let mut buffer = [std::mem::MaybeUninit::<u8>::uninit(); 24];",
            "    unsafe {",
            "        let len = format64(f, buffer.as_mut_ptr() as *mut u8);",
            "    }",
            "    let bits = f.to_bits();",
            "    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;",
            "    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);",
            "    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);",
            "    let length = d2s::decimal_length17(v.mantissa) as isize;",
            "    unsafe {",
            "    }",
            "    assert!(len <= 24);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]