{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/pretty/mod.rs\n// crate name is ryu\nuse self::exponent::{write_exponent2, write_exponent3};\nuse self::mantissa::{write_mantissa, write_mantissa_long};\nuse crate::common;\nuse crate::d2s::{self, d2d, DOUBLE_EXPONENT_BITS, DOUBLE_MANTISSA_BITS};\nuse crate::f2s::{f2d, FLOAT_EXPONENT_BITS, FLOAT_MANTISSA_BITS};\nuse core::ptr;\n#[cfg(feature = \"no-panic\")]\nuse no_panic::no_panic;\npub struct FloatingDecimal32 {\n    pub mantissa: u32,\n    pub exponent: i32,\n}\n#[must_use]\n#[cfg_attr(feature = \"no-panic\", no_panic)]\npub unsafe fn format32(f: f32, result: *mut u8) -> usize {\n    let bits = f.to_bits();\n    let sign = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS)) & 1) != 0;\n    let ieee_mantissa = bits & ((1u32 << FLOAT_MANTISSA_BITS) - 1);\n    let ieee_exponent = (bits >> FLOAT_MANTISSA_BITS)\n        & ((1u32 << FLOAT_EXPONENT_BITS) - 1);\n    let mut index = 0isize;\n    if sign {\n        *result = b'-';\n        index += 1;\n    }\n    if ieee_exponent == 0 && ieee_mantissa == 0 {\n        ptr::copy_nonoverlapping(b\"0.0\".as_ptr(), result.offset(index), 3);\n        return sign as usize + 3;\n    }\n    let v = f2d(ieee_mantissa, ieee_exponent);\n    let length = common::decimal_length9(v.mantissa) as isize;\n    let k = v.exponent as isize;\n    let kk = length + k;\n    debug_assert!(k >= - 45);\n    if 0 <= k && kk <= 13 {\n        write_mantissa(v.mantissa, result.offset(index + length));\n        for i in length..kk {\n            *result.offset(index + i) = b'0';\n        }\n        *result.offset(index + kk) = b'.';\n        *result.offset(index + kk + 1) = b'0';\n        index as usize + kk as usize + 2\n    } else if 0 < kk && kk <= 13 {\n        write_mantissa(v.mantissa, result.offset(index + length + 1));\n        ptr::copy(result.offset(index + 1), result.offset(index), kk as usize);\n        *result.offset(index + kk) = b'.';\n        index as usize + length as usize + 1\n    } else if -6 < kk && kk <= 0 {\n        *result.offset(index) = b'0';\n        *result.offset(index + 1) = b'.';\n        let offset = 2 - kk;\n        for i in 2..offset {\n            *result.offset(index + i) = b'0';\n        }\n        write_mantissa(v.mantissa, result.offset(index + length + offset));\n        index as usize + length as usize + offset as usize\n    } else if length == 1 {\n        *result.offset(index) = b'0' + v.mantissa as u8;\n        *result.offset(index + 1) = b'e';\n        index as usize + 2 + write_exponent2(kk - 1, result.offset(index + 2))\n    } else {\n        write_mantissa(v.mantissa, result.offset(index + length + 1));\n        *result.offset(index) = *result.offset(index + 1);\n        *result.offset(index + 1) = b'.';\n        *result.offset(index + length + 1) = b'e';\n        index as usize + length as usize + 2\n            + write_exponent2(kk - 1, result.offset(index + length + 2))\n    }\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub unsafe fn write_exponent2(mut k: isize, mut result: *mut u8) -> usize {\n    let sign = k < 0;\n    if sign {\n        *result = b'-';\n        result = result.offset(1);\n        k = -k;\n    }\n    debug_assert!(k < 100);\n    if k >= 10 {\n        let d = DIGIT_TABLE.as_ptr().offset(k * 2);\n        ptr::copy_nonoverlapping(d, result, 2);\n        sign as usize + 2\n    } else {\n        *result = b'0' + k as u8;\n        sign as usize + 1\n    }\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn f2d(ieee_mantissa: u32, ieee_exponent: u32) -> FloatingDecimal32 {\n    let (e2, m2) = if ieee_exponent == 0 {\n        (1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS as i32 - 2, ieee_mantissa)\n    } else {\n        (\n            ieee_exponent as i32 - FLOAT_BIAS - FLOAT_MANTISSA_BITS as i32 - 2,\n            (1u32 << FLOAT_MANTISSA_BITS) | ieee_mantissa,\n        )\n    };\n    let even = (m2 & 1) == 0;\n    let accept_bounds = even;\n    let mv = 4 * m2;\n    let mp = 4 * m2 + 2;\n    let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n    let mm = 4 * m2 - 1 - mm_shift;\n    let mut vr: u32;\n    let mut vp: u32;\n    let mut vm: u32;\n    let e10: i32;\n    let mut vm_is_trailing_zeros = false;\n    let mut vr_is_trailing_zeros = false;\n    let mut last_removed_digit = 0u8;\n    if e2 >= 0 {\n        let q = log10_pow2(e2);\n        e10 = q as i32;\n        let k = FLOAT_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n        let i = -e2 + q as i32 + k;\n        vr = mul_pow5_inv_div_pow2(mv, q, i);\n        vp = mul_pow5_inv_div_pow2(mp, q, i);\n        vm = mul_pow5_inv_div_pow2(mm, q, i);\n        if q != 0 && (vp - 1) / 10 <= vm / 10 {\n            let l = FLOAT_POW5_INV_BITCOUNT + pow5bits(q as i32 - 1) - 1;\n            last_removed_digit = (mul_pow5_inv_div_pow2(\n                mv,\n                q - 1,\n                -e2 + q as i32 - 1 + l,\n            ) % 10) as u8;\n        }\n        if q <= 9 {\n            if mv % 5 == 0 {\n                vr_is_trailing_zeros = multiple_of_power_of_5_32(mv, q);\n            } else if accept_bounds {\n                vm_is_trailing_zeros = multiple_of_power_of_5_32(mm, q);\n            } else {\n                vp -= multiple_of_power_of_5_32(mp, q) as u32;\n            }\n        }\n    } else {\n        let q = log10_pow5(-e2);\n        e10 = q as i32 + e2;\n        let i = -e2 - q as i32;\n        let k = pow5bits(i) - FLOAT_POW5_BITCOUNT;\n        let mut j = q as i32 - k;\n        vr = mul_pow5_div_pow2(mv, i as u32, j);\n        vp = mul_pow5_div_pow2(mp, i as u32, j);\n        vm = mul_pow5_div_pow2(mm, i as u32, j);\n        if q != 0 && (vp - 1) / 10 <= vm / 10 {\n            j = q as i32 - 1 - (pow5bits(i + 1) - FLOAT_POW5_BITCOUNT);\n            last_removed_digit = (mul_pow5_div_pow2(mv, (i + 1) as u32, j) % 10) as u8;\n        }\n        if q <= 1 {\n            vr_is_trailing_zeros = true;\n            if accept_bounds {\n                vm_is_trailing_zeros = mm_shift == 1;\n            } else {\n                vp -= 1;\n            }\n        } else if q < 31 {\n            vr_is_trailing_zeros = multiple_of_power_of_2_32(mv, q - 1);\n        }\n    }\n    let mut removed = 0i32;\n    let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n        while vp / 10 > vm / 10 {\n            vm_is_trailing_zeros &= vm - (vm / 10) * 10 == 0;\n            vr_is_trailing_zeros &= last_removed_digit == 0;\n            last_removed_digit = (vr % 10) as u8;\n            vr /= 10;\n            vp /= 10;\n            vm /= 10;\n            removed += 1;\n        }\n        if vm_is_trailing_zeros {\n            while vm % 10 == 0 {\n                vr_is_trailing_zeros &= last_removed_digit == 0;\n                last_removed_digit = (vr % 10) as u8;\n                vr /= 10;\n                vp /= 10;\n                vm /= 10;\n                removed += 1;\n            }\n        }\n        if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n            last_removed_digit = 4;\n        }\n        vr\n            + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros))\n                || last_removed_digit >= 5) as u32\n    } else {\n        while vp / 10 > vm / 10 {\n            last_removed_digit = (vr % 10) as u8;\n            vr /= 10;\n            vp /= 10;\n            vm /= 10;\n            removed += 1;\n        }\n        vr + (vr == vm || last_removed_digit >= 5) as u32\n    };\n    let exp = e10 + removed;\n    FloatingDecimal32 {\n        exponent: exp,\n        mantissa: output,\n    }\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn decimal_length9(v: u32) -> u32 {\n    debug_assert!(v < 1000000000);\n    if v >= 100000000 {\n        9\n    } else if v >= 10000000 {\n        8\n    } else if v >= 1000000 {\n        7\n    } else if v >= 100000 {\n        6\n    } else if v >= 10000 {\n        5\n    } else if v >= 1000 {\n        4\n    } else if v >= 100 {\n        3\n    } else if v >= 10 {\n        2\n    } else {\n        1\n    }\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub unsafe fn write_mantissa(mut output: u32, mut result: *mut u8) {\n    while output >= 10_000 {\n        let c = output - 10_000 * (output / 10_000);\n        output /= 10_000;\n        let c0 = (c % 100) << 1;\n        let c1 = (c / 100) << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c0 as isize),\n            result.offset(-2),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c1 as isize),\n            result.offset(-4),\n            2,\n        );\n        result = result.offset(-4);\n    }\n    if output >= 100 {\n        let c = (output % 100) << 1;\n        output /= 100;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c as isize),\n            result.offset(-2),\n            2,\n        );\n        result = result.offset(-2);\n    }\n    if output >= 10 {\n        let c = output << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c as isize),\n            result.offset(-2),\n            2,\n        );\n    } else {\n        *result.offset(-1) = b'0' + output as u8;\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Print f32 to the given buffer and return number of bytes written.\n///\n/// At most 16 bytes will be written.\n///\n/// ## Special cases\n///\n/// This function **does not** check for NaN or infinity. If the input\n/// number is not a finite float, the printed representation will be some\n/// correctly formatted but unspecified numerical value.\n///\n/// Please check [`is_finite`] yourself before calling this function, or\n/// check [`is_nan`] and [`is_infinite`] and handle those cases yourself.\n///\n/// [`is_finite`]: f32::is_finite\n/// [`is_nan`]: f32::is_nan\n/// [`is_infinite`]: f32::is_infinite\n///\n/// ## Safety\n///\n/// The `result` pointer argument must point to sufficiently many writable bytes\n/// to hold RyÅ«'s representation of `f`.\n///\n/// ## Example\n///\n/// ```\n/// use std::{mem::MaybeUninit, slice, str};\n///\n/// let f = 1.234f32;\n///\n/// unsafe {\n///     let mut buffer = [MaybeUninit::<u8>::uninit(); 16];\n///     let len = ryu::raw::format32(f, buffer.as_mut_ptr() as *mut u8);\n///     let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n///     let print = str::from_utf8_unchecked(slice);\n///     assert_eq!(print, \"1.234\");\n/// }\n/// ```\npub unsafe fn format32(f: f32, result: *mut u8) -> usize {\n    let bits = f.to_bits();\n    let sign = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS)) & 1) != 0;\n    let ieee_mantissa = bits & ((1u32 << FLOAT_MANTISSA_BITS) - 1);\n    let ieee_exponent = (bits >> FLOAT_MANTISSA_BITS) & ((1u32 << FLOAT_EXPONENT_BITS) - 1);\n\n    let mut index = 0isize;\n    if sign {\n        *result = b'-';\n        index += 1;\n    }\n\n    if ieee_exponent == 0 && ieee_mantissa == 0 {\n        ptr::copy_nonoverlapping(b\"0.0\".as_ptr(), result.offset(index), 3);\n        return sign as usize + 3;\n    }\n\n    let v = f2d(ieee_mantissa, ieee_exponent);\n\n    let length = common::decimal_length9(v.mantissa) as isize;\n    let k = v.exponent as isize;\n    let kk = length + k; // 10^(kk-1) <= v < 10^kk\n    debug_assert!(k >= -45);\n\n    if 0 <= k && kk <= 13 {\n        // 1234e7 -> 12340000000.0\n        write_mantissa(v.mantissa, result.offset(index + length));\n        for i in length..kk {\n            *result.offset(index + i) = b'0';\n        }\n        *result.offset(index + kk) = b'.';\n        *result.offset(index + kk + 1) = b'0';\n        index as usize + kk as usize + 2\n    } else if 0 < kk && kk <= 13 {\n        // 1234e-2 -> 12.34\n        write_mantissa(v.mantissa, result.offset(index + length + 1));\n        ptr::copy(result.offset(index + 1), result.offset(index), kk as usize);\n        *result.offset(index + kk) = b'.';\n        index as usize + length as usize + 1\n    } else if -6 < kk && kk <= 0 {\n        // 1234e-6 -> 0.001234\n        *result.offset(index) = b'0';\n        *result.offset(index + 1) = b'.';\n        let offset = 2 - kk;\n        for i in 2..offset {\n            *result.offset(index + i) = b'0';\n        }\n        write_mantissa(v.mantissa, result.offset(index + length + offset));\n        index as usize + length as usize + offset as usize\n    } else if length == 1 {\n        // 1e30\n        *result.offset(index) = b'0' + v.mantissa as u8;\n        *result.offset(index + 1) = b'e';\n        index as usize + 2 + write_exponent2(kk - 1, result.offset(index + 2))\n    } else {\n        // 1234e30 -> 1.234e33\n        write_mantissa(v.mantissa, result.offset(index + length + 1));\n        *result.offset(index) = *result.offset(index + 1);\n        *result.offset(index + 1) = b'.';\n        *result.offset(index + length + 1) = b'e';\n        index as usize\n            + length as usize\n            + 2\n            + write_exponent2(kk - 1, result.offset(index + length + 2))\n    }\n}\n",
  "depend_pt": ""
}