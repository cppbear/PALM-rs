{"function_name":"ryu::f2s_intrinsics::mul_shift_32","tests":10,"tests_lines":[8,10,7,7,8,8,8,6,6,6],"oracles":10,"oracles_compiled":10,"oracles_compiled_rate":100.0,"tests_compiled":10,"tests_compiled_rate":100.0,"oracles_run":10,"oracles_passed":6,"oracles_passed_rate":60.0,"tests_run":10,"tests_passed":6,"tests_passed_rate":60.0,"lines":12,"lines_covered":12,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[58,59,63,64,65,66,67,68,69,70,71,72],"codes_lines_covered":[[["{","    let m: u32 = u32::MAX; // Maximum value for m","    let factor: u64 = 0xFFFFFFFF; // Maximum value for factor","    let shift: i32 = 33; // Valid shift greater than 32","","    let result = mul_shift_32(m, factor, shift);","    assert_eq!(result, u32::MAX); // Expected shifted_sum as u32","}"],[58,59,63,64,65,66,67,68,69,70,71,72]],[["{","    let m: u32 = 1; // Small value for m to check behavior with large factor","    let factor: u64 = u64::MAX; // Maximum value for factor","    let shift: i32 = 34; // Valid shift greater than 32","","    let result = mul_shift_32(m, factor, shift);","    // Calculate expected shifted_sum (1 * max_factor) >> (shift - 32)","    let expected_shifted_sum = (u64::MAX >> (34 - 32)) as u32; // Should fit in u32","    assert_eq!(result, expected_shifted_sum);","}"],[58,59,63,64,65,66,67,68,69,70,71,72]],[["{","    let m: u32 = 1; // Valid m","    let factor: u64 = 1; // Valid factor","    let shift: i32 = 32; // Invalid shift, should panic","","    let _result = mul_shift_32(m, factor, shift);","}"],[58,59]],[["{","    let m: u32 = 1; // minimal valid input","    let factor: u64 = (u64::MAX >> 1) + 1; // making factor large enough to trigger the panic condition","    let shift: i32 = 33; // satisfies the constraint shift > 32","","    let _result = mul_shift_32(m, factor, shift); // calling the function, should panic","}"],[58,59,63,64,65,66,67,68,69,70,71,72]],[["{","    let m: u32 = u32::MAX; // maximal valid input","    let factor: u64 = 1; // small factor to validate behavior under standard conditions","    let shift: i32 = 33; // satisfies the constraint shift > 32","","    let result = mul_shift_32(m, factor, shift);","    assert_eq!(result, 0); // the expected return value should be 0","}"],[58,59,63,64,65,66,67,68,69,70,71,72]],[["{","    let m: u32 = 1; // minimal valid input","    let factor: u64 = u64::MAX; // using maximum allowed factor","    let shift: i32 = 34; // satisfies the constraint shift > 32","","    let result = mul_shift_32(m, factor, shift);","    assert!(result <= u32::max_value()); // check result is within bounds","}"],[58,59,63,64,65,66,67,68,69,70,71,72]],[["{","    let m: u32 = 2; // medium valid input","    let factor: u64 = 2; // moderate factor","    let shift: i32 = 33; // satisfies the constraint shift > 32","","    let result = mul_shift_32(m, factor, shift);","    assert_eq!(result, 1); // expected output check","}"],[58,59,63,64,65,66,67,68,69,70,71,72]],[["{","    let m: u32 = 1;","    let factor: u64 = 1;","    let shift: i32 = 32;","    mul_shift_32(m, factor, shift);","}"],[58,59]],[["{","    let m: u32 = 1;","    let factor: u64 = u64::MAX; // Maximum value for factor","    let shift: i32 = 32;","    mul_shift_32(m, factor, shift);","}"],[58,59]],[["{","    let m: u32 = 0; // Check behavior with zero multiplicand","    let factor: u64 = 1;","    let shift: i32 = 32;","    mul_shift_32(m, factor, shift);","}"],[58,59]]],"codes_branches":[],"codes_branches_covered":[[["{","    let m: u32 = u32::MAX; // Maximum value for m","    let factor: u64 = 0xFFFFFFFF; // Maximum value for factor","    let shift: i32 = 33; // Valid shift greater than 32","","    let result = mul_shift_32(m, factor, shift);","    assert_eq!(result, u32::MAX); // Expected shifted_sum as u32","}"],[]],[["{","    let m: u32 = 1; // Small value for m to check behavior with large factor","    let factor: u64 = u64::MAX; // Maximum value for factor","    let shift: i32 = 34; // Valid shift greater than 32","","    let result = mul_shift_32(m, factor, shift);","    // Calculate expected shifted_sum (1 * max_factor) >> (shift - 32)","    let expected_shifted_sum = (u64::MAX >> (34 - 32)) as u32; // Should fit in u32","    assert_eq!(result, expected_shifted_sum);","}"],[]],[["{","    let m: u32 = 1; // Valid m","    let factor: u64 = 1; // Valid factor","    let shift: i32 = 32; // Invalid shift, should panic","","    let _result = mul_shift_32(m, factor, shift);","}"],[]],[["{","    let m: u32 = 1; // minimal valid input","    let factor: u64 = (u64::MAX >> 1) + 1; // making factor large enough to trigger the panic condition","    let shift: i32 = 33; // satisfies the constraint shift > 32","","    let _result = mul_shift_32(m, factor, shift); // calling the function, should panic","}"],[]],[["{","    let m: u32 = u32::MAX; // maximal valid input","    let factor: u64 = 1; // small factor to validate behavior under standard conditions","    let shift: i32 = 33; // satisfies the constraint shift > 32","","    let result = mul_shift_32(m, factor, shift);","    assert_eq!(result, 0); // the expected return value should be 0","}"],[]],[["{","    let m: u32 = 1; // minimal valid input","    let factor: u64 = u64::MAX; // using maximum allowed factor","    let shift: i32 = 34; // satisfies the constraint shift > 32","","    let result = mul_shift_32(m, factor, shift);","    assert!(result <= u32::max_value()); // check result is within bounds","}"],[]],[["{","    let m: u32 = 2; // medium valid input","    let factor: u64 = 2; // moderate factor","    let shift: i32 = 33; // satisfies the constraint shift > 32","","    let result = mul_shift_32(m, factor, shift);","    assert_eq!(result, 1); // expected output check","}"],[]],[["{","    let m: u32 = 1;","    let factor: u64 = 1;","    let shift: i32 = 32;","    mul_shift_32(m, factor, shift);","}"],[]],[["{","    let m: u32 = 1;","    let factor: u64 = u64::MAX; // Maximum value for factor","    let shift: i32 = 32;","    mul_shift_32(m, factor, shift);","}"],[]],[["{","    let m: u32 = 0; // Check behavior with zero multiplicand","    let factor: u64 = 1;","    let shift: i32 = 32;","    mul_shift_32(m, factor, shift);","}"],[]]]}