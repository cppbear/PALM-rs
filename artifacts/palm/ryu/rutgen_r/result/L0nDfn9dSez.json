{"function_name":"ryu::d2s_intrinsics::multiple_of_power_of_2","tests":18,"tests_lines":[5,4,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5],"oracles":18,"oracles_compiled":18,"oracles_compiled_rate":100.0,"tests_compiled":18,"tests_compiled_rate":100.0,"oracles_run":18,"oracles_passed":17,"oracles_passed_rate":94.44444444444444,"tests_run":18,"tests_passed":17,"tests_passed_rate":94.44444444444444,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[63,64,65,67,68],"codes_lines_covered":[[["{","    assert!(multiple_of_power_of_2(8, 3)); // 8 is multiple of 2^3 (8)","    assert!(multiple_of_power_of_2(16, 4)); // 16 is multiple of 2^4 (16)","    assert!(multiple_of_power_of_2(0b111000, 3)); // 56 is multiple of 2^3 (8)","}"],[63,64,65,67,68]],[["{","    assert!(!multiple_of_power_of_2(10, 3)); // 10 is not a multiple of 2^3 (8)","    assert!(!multiple_of_power_of_2(20, 4)); // 20 is not a multiple of 2^4 (16)","}"],[63,64,65,67,68]],[["{","    multiple_of_power_of_2(0, 0); // should panic because value is 0","}"],[63,64]],[["{","    multiple_of_power_of_2(1, 64); // should panic because p is not less than 64","}"],[63,64,65]],[["{","    let value: u64 = 0;","    let p: u32 = 5;","    multiple_of_power_of_2(value, p);","}"],[63,64]],[["{","    let value: u64 = 8;","    let p: u32 = 64; // p must be less than 64","    multiple_of_power_of_2(value, p);","}"],[63,64,65]],[["{","    let value: u64 = 1; // minimum non-zero value","    let p: u32 = 1;","    assert!(multiple_of_power_of_2(value, p));","}"],[63,64,65,67,68]],[["{","    let value: u64 = 4; // 2^2","    let p: u32 = 2;    ","    assert!(multiple_of_power_of_2(value, p));","}"],[63,64,65,67,68]],[["{","    let value: u64 = 6; // not a multiple of 2^2","    let p: u32 = 2;    ","    assert!(!multiple_of_power_of_2(value, p));","}"],[63,64,65,67,68]],[["{","    let value: u64 = 16; // 2^4","    let p: u32 = 4;    ","    assert!(multiple_of_power_of_2(value, p));","}"],[63,64,65,67,68]],[["{","    let value: u64 = 32; // 2^5","    let p: u32 = 5;    ","    assert!(multiple_of_power_of_2(value, p));","}"],[63,64,65,67,68]],[["{","    let value = 0u64; // This should trigger the panic for value != 0","    let p = 3u32; // Arbitrary value for p","    multiple_of_power_of_2(value, p);","}"],[63,64]],[["{","    let value = 8u64; // 8 is 1000 in binary, multiple of 2^3","    let p = 3u32; // Testing with p = 3","    assert_eq!(multiple_of_power_of_2(value, p), true);","}"],[63,64,65,67,68]],[["{","    let value = 10u64; // 10 is not a multiple of 2^3","    let p = 3u32; // Testing with p = 3","    assert_eq!(multiple_of_power_of_2(value, p), false);","}"],[63,64,65,67,68]],[["{","    let value = 0b1111u64; // 15 is not a multiple of 2^3","    let p = 3u32; // Testing with p = 3","    assert_eq!(multiple_of_power_of_2(value, p), false);","}"],[63,64,65,67,68]],[["{","    let value = 1u64; // 1 is a multiple of any power of 2 that is less than its bit length","    let p = 0u32; // Testing with p = 0","    assert_eq!(multiple_of_power_of_2(value, p), true);","}"],[63,64,65,67,68]],[["{","    let value = 18446744073709551615u64; // maximum u64 value","    let p = 63u32; // Testing with maximum valid p","    assert_eq!(multiple_of_power_of_2(value, p), false); // should not be a multiple of 2^63","}"],[63,64,65,67,68]],[["{","    let value = 2u64; // Arbitrary non-zero value","    let p = 64u32; // This should trigger the panic for p < 64","    multiple_of_power_of_2(value, p);","}"],[63,64,65]]],"codes_branches":[],"codes_branches_covered":[[["{","    assert!(multiple_of_power_of_2(8, 3)); // 8 is multiple of 2^3 (8)","    assert!(multiple_of_power_of_2(16, 4)); // 16 is multiple of 2^4 (16)","    assert!(multiple_of_power_of_2(0b111000, 3)); // 56 is multiple of 2^3 (8)","}"],[]],[["{","    assert!(!multiple_of_power_of_2(10, 3)); // 10 is not a multiple of 2^3 (8)","    assert!(!multiple_of_power_of_2(20, 4)); // 20 is not a multiple of 2^4 (16)","}"],[]],[["{","    multiple_of_power_of_2(0, 0); // should panic because value is 0","}"],[]],[["{","    multiple_of_power_of_2(1, 64); // should panic because p is not less than 64","}"],[]],[["{","    let value: u64 = 0;","    let p: u32 = 5;","    multiple_of_power_of_2(value, p);","}"],[]],[["{","    let value: u64 = 8;","    let p: u32 = 64; // p must be less than 64","    multiple_of_power_of_2(value, p);","}"],[]],[["{","    let value: u64 = 1; // minimum non-zero value","    let p: u32 = 1;","    assert!(multiple_of_power_of_2(value, p));","}"],[]],[["{","    let value: u64 = 4; // 2^2","    let p: u32 = 2;    ","    assert!(multiple_of_power_of_2(value, p));","}"],[]],[["{","    let value: u64 = 6; // not a multiple of 2^2","    let p: u32 = 2;    ","    assert!(!multiple_of_power_of_2(value, p));","}"],[]],[["{","    let value: u64 = 16; // 2^4","    let p: u32 = 4;    ","    assert!(multiple_of_power_of_2(value, p));","}"],[]],[["{","    let value: u64 = 32; // 2^5","    let p: u32 = 5;    ","    assert!(multiple_of_power_of_2(value, p));","}"],[]],[["{","    let value = 0u64; // This should trigger the panic for value != 0","    let p = 3u32; // Arbitrary value for p","    multiple_of_power_of_2(value, p);","}"],[]],[["{","    let value = 8u64; // 8 is 1000 in binary, multiple of 2^3","    let p = 3u32; // Testing with p = 3","    assert_eq!(multiple_of_power_of_2(value, p), true);","}"],[]],[["{","    let value = 10u64; // 10 is not a multiple of 2^3","    let p = 3u32; // Testing with p = 3","    assert_eq!(multiple_of_power_of_2(value, p), false);","}"],[]],[["{","    let value = 0b1111u64; // 15 is not a multiple of 2^3","    let p = 3u32; // Testing with p = 3","    assert_eq!(multiple_of_power_of_2(value, p), false);","}"],[]],[["{","    let value = 1u64; // 1 is a multiple of any power of 2 that is less than its bit length","    let p = 0u32; // Testing with p = 0","    assert_eq!(multiple_of_power_of_2(value, p), true);","}"],[]],[["{","    let value = 18446744073709551615u64; // maximum u64 value","    let p = 63u32; // Testing with maximum valid p","    assert_eq!(multiple_of_power_of_2(value, p), false); // should not be a multiple of 2^63","}"],[]],[["{","    let value = 2u64; // Arbitrary non-zero value","    let p = 64u32; // This should trigger the panic for p < 64","    multiple_of_power_of_2(value, p);","}"],[]]]}