{"function_name":"ryu::buffer::<f32 as buffer::Sealed>::format_nonfinite","tests":5,"tests_lines":[27,27,27,27,27],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[125,128,129,130,131,132,134,136],"codes_lines_covered":[[["{","    struct TestFloat {","        bits: u32,","    }","","    impl TestFloat {","        fn to_bits(self) -> u32 {","            self.bits","        }","","        fn format_nonfinite(self) -> &'static str {","            const MANTISSA_MASK: u32 = 0x007fffff;","            const SIGN_MASK: u32 = 0x80000000;","            let bits = self.to_bits();","            if bits & MANTISSA_MASK != 0 {","                \"NAN\"","            } else if bits & SIGN_MASK != 0 {","                \"NEG_INFINITY\"","            } else {","                \"INFINITY\"","            }","        }","    }","","    let test_value = TestFloat { bits: 0x7fffffff }; // Example representation of NaN","    assert_eq!(test_value.format_nonfinite(), \"NAN\");","}"],[]],[["{","    struct FloatWrapper {","        bits: u32,","    }","","    impl FloatWrapper {","        fn to_bits(self) -> u32 {","            self.bits","        }","","        fn format_nonfinite(self) -> &'static str {","            const MANTISSA_MASK: u32 = 0x007fffff;","            const SIGN_MASK: u32 = 0x80000000;","            let bits = self.to_bits();","            if bits & MANTISSA_MASK != 0 {","                \"NAN\"","            } else if bits & SIGN_MASK != 0 {","                \"NEG_INFINITY\"","            } else {","                \"INFINITY\"","            }","        }","    }","","    let negative_infinity = FloatWrapper { bits: 0x80000000 };","    assert_eq!(negative_infinity.format_nonfinite(), \"NEG_INFINITY\");","}"],[]],[["{","    struct FloatWrapper {","        value: f32,","    }","","    impl FloatWrapper {","        fn to_bits(self) -> u32 {","            self.value.to_bits()","        }","","        fn format_nonfinite(self) -> &'static str {","            const MANTISSA_MASK: u32 = 0x007fffff;","            const SIGN_MASK: u32 = 0x80000000;","            let bits = self.to_bits();","            if bits & MANTISSA_MASK != 0 {","                \"NaN\"","            } else if bits & SIGN_MASK != 0 {","                \"-Infinity\"","            } else {","                \"Infinity\"","            }","        }","    }","","    let positive_infinity = FloatWrapper { value: f32::INFINITY };","    assert_eq!(positive_infinity.format_nonfinite(), \"Infinity\");","}"],[]],[["{","    struct FloatWrapper {","        value: f32,","    }","","    impl FloatWrapper {","        fn to_bits(self) -> u32 {","            self.value.to_bits()","        }","","        fn format_nonfinite(self) -> &'static str {","            const MANTISSA_MASK: u32 = 0x007fffff;","            const SIGN_MASK: u32 = 0x80000000;","            let bits = self.to_bits();","            if bits & MANTISSA_MASK != 0 {","                \"NaN\"","            } else if bits & SIGN_MASK != 0 {","                \"-Infinity\"","            } else {","                \"Infinity\"","            }","        }","    }","","    let negative_infinity = FloatWrapper { value: f32::NEG_INFINITY };","    assert_eq!(negative_infinity.format_nonfinite(), \"-Infinity\");","}"],[]],[["{","    struct FloatWrapper {","        value: f32,","    }","","    impl FloatWrapper {","        fn to_bits(self) -> u32 {","            self.value.to_bits()","        }","","        fn format_nonfinite(self) -> &'static str {","            const MANTISSA_MASK: u32 = 0x007fffff;","            const SIGN_MASK: u32 = 0x80000000;","            let bits = self.to_bits();","            if bits & MANTISSA_MASK != 0 {","                \"NaN\"","            } else if bits & SIGN_MASK != 0 {","                \"-Infinity\"","            } else {","                \"Infinity\"","            }","        }","    }","","    let nan_value = FloatWrapper { value: f32::NAN };","    assert_eq!(nan_value.format_nonfinite(), \"NaN\");","}"],[]]],"codes_branches":[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestFloat {","        bits: u32,","    }","","    impl TestFloat {","        fn to_bits(self) -> u32 {","            self.bits","        }","","        fn format_nonfinite(self) -> &'static str {","            const MANTISSA_MASK: u32 = 0x007fffff;","            const SIGN_MASK: u32 = 0x80000000;","            let bits = self.to_bits();","            if bits & MANTISSA_MASK != 0 {","                \"NAN\"","            } else if bits & SIGN_MASK != 0 {","                \"NEG_INFINITY\"","            } else {","                \"INFINITY\"","            }","        }","    }","","    let test_value = TestFloat { bits: 0x7fffffff }; // Example representation of NaN","    assert_eq!(test_value.format_nonfinite(), \"NAN\");","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]],[["{","    struct FloatWrapper {","        bits: u32,","    }","","    impl FloatWrapper {","        fn to_bits(self) -> u32 {","            self.bits","        }","","        fn format_nonfinite(self) -> &'static str {","            const MANTISSA_MASK: u32 = 0x007fffff;","            const SIGN_MASK: u32 = 0x80000000;","            let bits = self.to_bits();","            if bits & MANTISSA_MASK != 0 {","                \"NAN\"","            } else if bits & SIGN_MASK != 0 {","                \"NEG_INFINITY\"","            } else {","                \"INFINITY\"","            }","        }","    }","","    let negative_infinity = FloatWrapper { bits: 0x80000000 };","    assert_eq!(negative_infinity.format_nonfinite(), \"NEG_INFINITY\");","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]],[["{","    struct FloatWrapper {","        value: f32,","    }","","    impl FloatWrapper {","        fn to_bits(self) -> u32 {","            self.value.to_bits()","        }","","        fn format_nonfinite(self) -> &'static str {","            const MANTISSA_MASK: u32 = 0x007fffff;","            const SIGN_MASK: u32 = 0x80000000;","            let bits = self.to_bits();","            if bits & MANTISSA_MASK != 0 {","                \"NaN\"","            } else if bits & SIGN_MASK != 0 {","                \"-Infinity\"","            } else {","                \"Infinity\"","            }","        }","    }","","    let positive_infinity = FloatWrapper { value: f32::INFINITY };","    assert_eq!(positive_infinity.format_nonfinite(), \"Infinity\");","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]],[["{","    struct FloatWrapper {","        value: f32,","    }","","    impl FloatWrapper {","        fn to_bits(self) -> u32 {","            self.value.to_bits()","        }","","        fn format_nonfinite(self) -> &'static str {","            const MANTISSA_MASK: u32 = 0x007fffff;","            const SIGN_MASK: u32 = 0x80000000;","            let bits = self.to_bits();","            if bits & MANTISSA_MASK != 0 {","                \"NaN\"","            } else if bits & SIGN_MASK != 0 {","                \"-Infinity\"","            } else {","                \"Infinity\"","            }","        }","    }","","    let negative_infinity = FloatWrapper { value: f32::NEG_INFINITY };","    assert_eq!(negative_infinity.format_nonfinite(), \"-Infinity\");","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]],[["{","    struct FloatWrapper {","        value: f32,","    }","","    impl FloatWrapper {","        fn to_bits(self) -> u32 {","            self.value.to_bits()","        }","","        fn format_nonfinite(self) -> &'static str {","            const MANTISSA_MASK: u32 = 0x007fffff;","            const SIGN_MASK: u32 = 0x80000000;","            let bits = self.to_bits();","            if bits & MANTISSA_MASK != 0 {","                \"NaN\"","            } else if bits & SIGN_MASK != 0 {","                \"-Infinity\"","            } else {","                \"Infinity\"","            }","        }","    }","","    let nan_value = FloatWrapper { value: f32::NAN };","    assert_eq!(nan_value.format_nonfinite(), \"NaN\");","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]]]}