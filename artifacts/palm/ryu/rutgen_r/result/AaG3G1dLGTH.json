{"function_name":"ryu::f2s_intrinsics::mul_pow5_inv_div_pow2","tests":5,"tests_lines":[10,9,9,13,16],"oracles":5,"oracles_compiled":2,"oracles_compiled_rate":40.0,"tests_compiled":2,"tests_compiled_rate":40.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":23,"lines_covered":23,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,91,92,93,94,95,96,97,98],"codes_lines_covered":[[["{","    struct d2s;","    impl d2s {","        const DOUBLE_POW5_INV_SPLIT: [(u32, u32); 1] = [(0, 0)]; // Dummy initialization for test context","        // No need for actual compute_inv_pow5 as it won't be called in this test","    }","    ","    let m: u32 = 10; // Arbitrary valid value for m","    let j: i32 = 5;  // Arbitrary valid value for j","    let q: u32 = d2s::DOUBLE_POW5_INV_SPLIT.len() as u32; // This should trigger the panic condition","    ","    let _result = mul_pow5_inv_div_pow2(m, q, j);","}"],[75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,91,92,93,94,95,96,97,98]],[["{","    struct d2s;","    impl d2s {","        const DOUBLE_POW5_INV_SPLIT: [(u32, u32); 2] = [(1, 2), (3, 4)]; // Example initialization","    ","        unsafe fn compute_inv_pow5(q: u32) -> (u32, u32) {","            (0, 0) // Dummy implementation for test context","        }","    }","","    let m: u32 = 8; // Arbitrary valid value for m","    let j: i32 = 2; // Arbitrary valid value for j","    let q: u32 = 0; // Valid index in DOUBLE_POW5_INV_SPLIT","    let result = mul_pow5_inv_div_pow2(m, q, j);","    assert_eq!(result, 0); // Adjust this expected value based on actual logic","}"],[75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,91,92,93,94,95,96,97,98]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct d2s;","    impl d2s {","        const DOUBLE_POW5_INV_SPLIT: [(u32, u32); 1] = [(0, 0)]; // Dummy initialization for test context","        // No need for actual compute_inv_pow5 as it won't be called in this test","    }","    ","    let m: u32 = 10; // Arbitrary valid value for m","    let j: i32 = 5;  // Arbitrary valid value for j","    let q: u32 = d2s::DOUBLE_POW5_INV_SPLIT.len() as u32; // This should trigger the panic condition","    ","    let _result = mul_pow5_inv_div_pow2(m, q, j);","}"],[]],[["{","    struct d2s;","    impl d2s {","        const DOUBLE_POW5_INV_SPLIT: [(u32, u32); 2] = [(1, 2), (3, 4)]; // Example initialization","    ","        unsafe fn compute_inv_pow5(q: u32) -> (u32, u32) {","            (0, 0) // Dummy implementation for test context","        }","    }","","    let m: u32 = 8; // Arbitrary valid value for m","    let j: i32 = 2; // Arbitrary valid value for j","    let q: u32 = 0; // Valid index in DOUBLE_POW5_INV_SPLIT","    let result = mul_pow5_inv_div_pow2(m, q, j);","    assert_eq!(result, 0); // Adjust this expected value based on actual logic","}"],[]]]}