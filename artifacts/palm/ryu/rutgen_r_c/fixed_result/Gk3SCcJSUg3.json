{"function_name":"ryu::d2s_intrinsics::mul_shift_64","tests":5,"tests_lines":[7,7,7,7,7],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":5,"tests_passed":4,"tests_passed_rate":80.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[71,72,73,74,75],"codes_lines_covered":[[["{","    let m: u64 = 1;","    let mul: (u64, u64) = (2, 3);","    let j: u32 = 64;","    let result = mul_shift_64(m, &mul, j);","    assert_eq!(result, 0); // (((1 * 2) >> 64) + (1 * 3)) >> (64 - 64) == 0","}"],[71,72,73,74,75]],[["{","    let m: u64 = 2;","    let mul: (u64, u64) = (1, 1);","    let j: u32 = 65;","    let result = mul_shift_64(m, &mul, j);","    assert_eq!(result, 1); // (((2 * 1) >> 64) + (2 * 1)) >> (65 - 64) == 1","}"],[71,72,73,74,75]],[["{","    let m: u64 = 1 << 63; // Test with the maximum value for 'm'","    let mul: (u64, u64) = (1, 1);","    let j: u32 = 128;","    let result = mul_shift_64(m, &mul, j);","    assert_eq!(result, 0); // (((1 << 63 * 1) >> 64) + (1 << 63 * 1)) >> (128 - 64) == 0","}"],[71,72,73,74,75]],[["{","    let m: u64 = 0;","    let mul: (u64, u64) = (5, 10);","    let j: u32 = 64;","    let result = mul_shift_64(m, &mul, j);","    assert_eq!(result, 0); // (((0 * 5) >> 64) + (0 * 10)) >> (64 - 64) == 0","}"],[71,72,73,74,75]],[["{","    let m: u64 = u64::MAX;","    let mul: (u64, u64) = (u64::MAX, u64::MAX);","    let j: u32 = 64;","    let result = mul_shift_64(m, &mul, j);","    assert_eq!(result, 18446744073709551615); // Check the expected outcome with large max values.","}"],[71,72,73,74,75]]],"codes_branches":[],"codes_branches_covered":[[["{","    let m: u64 = 1;","    let mul: (u64, u64) = (2, 3);","    let j: u32 = 64;","    let result = mul_shift_64(m, &mul, j);","    assert_eq!(result, 0); // (((1 * 2) >> 64) + (1 * 3)) >> (64 - 64) == 0","}"],[]],[["{","    let m: u64 = 2;","    let mul: (u64, u64) = (1, 1);","    let j: u32 = 65;","    let result = mul_shift_64(m, &mul, j);","    assert_eq!(result, 1); // (((2 * 1) >> 64) + (2 * 1)) >> (65 - 64) == 1","}"],[]],[["{","    let m: u64 = 1 << 63; // Test with the maximum value for 'm'","    let mul: (u64, u64) = (1, 1);","    let j: u32 = 128;","    let result = mul_shift_64(m, &mul, j);","    assert_eq!(result, 0); // (((1 << 63 * 1) >> 64) + (1 << 63 * 1)) >> (128 - 64) == 0","}"],[]],[["{","    let m: u64 = 0;","    let mul: (u64, u64) = (5, 10);","    let j: u32 = 64;","    let result = mul_shift_64(m, &mul, j);","    assert_eq!(result, 0); // (((0 * 5) >> 64) + (0 * 10)) >> (64 - 64) == 0","}"],[]],[["{","    let m: u64 = u64::MAX;","    let mul: (u64, u64) = (u64::MAX, u64::MAX);","    let j: u32 = 64;","    let result = mul_shift_64(m, &mul, j);","    assert_eq!(result, 18446744073709551615); // Check the expected outcome with large max values.","}"],[]]]}