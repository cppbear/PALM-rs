{"function_name":"ryu::pretty::mantissa::write_mantissa_long","tests":10,"tests_lines":[13,13,13,13,11,11,11,11,11,11],"oracles":10,"oracles_compiled":10,"oracles_compiled_rate":100.0,"tests_compiled":10,"tests_compiled_rate":100.0,"oracles_run":10,"oracles_passed":2,"oracles_passed_rate":20.0,"tests_run":10,"tests_passed":2,"tests_passed_rate":20.0,"lines":37,"lines_covered":37,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41],"codes_lines_covered":[[["{","  // use std::mem::MaybeUninit;  ","","   let output: u64 = 1_000_000_000_000_000; // 1 quadrillion","   let mut buffer: [u8; 20] = [0; 20];","   let result;","   unsafe {","       result = buffer.as_mut_ptr().add(19); // result pointer to the end of the buffer","       write_mantissa_long(output, result);","   }","","   assert_eq!(&buffer[10..20], b\"1000000000000000000\");","}"],[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]],[["{","  // use std::mem::MaybeUninit;  // Removed unused import","   ","   let output: u64 = 123_456_789_012; // Mid-range value","   let mut buffer: [u8; 20] = [0; 20];","   let result;","   ","   unsafe {","       result = buffer.as_mut_ptr().add(19); // result pointer to the end of the buffer","       write_mantissa_long(output, result);","   }","   assert_eq!(&buffer[11..20], b\"123456789012\");","}"],[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]],[["{","   // use std::mem::MaybeUninit;","","    let output: u64 = 4_294_967_296; // 2^32","    let mut buffer: [u8; 20] = [0; 20];","   let result;  ","   unsafe {  ","       result = buffer.as_mut_ptr().add(19); // result pointer to the end of the buffer  ","       write_mantissa_long(output, result);  ","   }  "," ","","}"],[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]],[["{","   // use std::mem::MaybeUninit;","","   let output: u64 = u64::MAX; // Maximum value for u64","   let mut buffer: [u8; 20] = [0; 20];","   let result;","   ","   unsafe {","       result = buffer.as_mut_ptr().add(19); // result pointer to the end of the buffer","       write_mantissa_long(output, result);","   }","   ","}"],[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]],[["{","    let output: u64 = 0; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","    ","    assert_eq!(&result[10..], b\"0\"); // Should write \"0\"","}"],[]],[["{","    let output: u64 = 5; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","","    assert_eq!(&result[19..], b\"5\"); // Should write \"5\"","}"],[]],[["{","    let output: u64 = 10; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","","    assert_eq!(&result[18..], b\"10\"); // Should write \"10\"","}"],[]],[["{","    let output: u64 = 99; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","","    assert_eq!(&result[18..], b\"99\"); // Should write \"99\"","}"],[]],[["{","    let output: u64 = 100; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","","    assert_eq!(&result[18..], b\"100\"); // Should write \"100\"","}"],[]],[["{","    let output: u64 = 1_000_000; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","","    assert_eq!(&result[16..], b\"1000000\"); // Should write \"1000000\"","}"],[]]],"codes_branches":[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":true,"negative":false}],"codes_branches_covered":[[["{","  // use std::mem::MaybeUninit;  ","","   let output: u64 = 1_000_000_000_000_000; // 1 quadrillion","   let mut buffer: [u8; 20] = [0; 20];","   let result;","   unsafe {","       result = buffer.as_mut_ptr().add(19); // result pointer to the end of the buffer","       write_mantissa_long(output, result);","   }","","   assert_eq!(&buffer[10..20], b\"1000000000000000000\");","}"],[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":true,"negative":false}]],[["{","  // use std::mem::MaybeUninit;  // Removed unused import","   ","   let output: u64 = 123_456_789_012; // Mid-range value","   let mut buffer: [u8; 20] = [0; 20];","   let result;","   ","   unsafe {","       result = buffer.as_mut_ptr().add(19); // result pointer to the end of the buffer","       write_mantissa_long(output, result);","   }","   assert_eq!(&buffer[11..20], b\"123456789012\");","}"],[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":true,"negative":false}]],[["{","   // use std::mem::MaybeUninit;","","    let output: u64 = 4_294_967_296; // 2^32","    let mut buffer: [u8; 20] = [0; 20];","   let result;  ","   unsafe {  ","       result = buffer.as_mut_ptr().add(19); // result pointer to the end of the buffer  ","       write_mantissa_long(output, result);  ","   }  "," ","","}"],[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":true,"negative":false}]],[["{","   // use std::mem::MaybeUninit;","","   let output: u64 = u64::MAX; // Maximum value for u64","   let mut buffer: [u8; 20] = [0; 20];","   let result;","   ","   unsafe {","       result = buffer.as_mut_ptr().add(19); // result pointer to the end of the buffer","       write_mantissa_long(output, result);","   }","   ","}"],[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":true,"negative":false}]],[["{","    let output: u64 = 0; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","    ","    assert_eq!(&result[10..], b\"0\"); // Should write \"0\"","}"],[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":false,"negative":false}]],[["{","    let output: u64 = 5; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","","    assert_eq!(&result[19..], b\"5\"); // Should write \"5\"","}"],[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":false,"negative":false}]],[["{","    let output: u64 = 10; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","","    assert_eq!(&result[18..], b\"10\"); // Should write \"10\"","}"],[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":false,"negative":false}]],[["{","    let output: u64 = 99; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","","    assert_eq!(&result[18..], b\"99\"); // Should write \"99\"","}"],[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":false,"negative":false}]],[["{","    let output: u64 = 100; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","","    assert_eq!(&result[18..], b\"100\"); // Should write \"100\"","}"],[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":false,"negative":false}]],[["{","    let output: u64 = 1_000_000; // This will ensure (output >> 32) != 0 is false","    let mut result = vec![0u8; 20]; // Allocate enough space for the result","    let output_ptr = result.as_mut_ptr();","","    unsafe {","        write_mantissa_long(output, output_ptr);","    }","","    assert_eq!(&result[16..], b\"1000000\"); // Should write \"1000000\"","}"],[{"start_line":6,"start_column":8,"end_line":6,"end_column":27,"positive":false,"negative":false}]]]}