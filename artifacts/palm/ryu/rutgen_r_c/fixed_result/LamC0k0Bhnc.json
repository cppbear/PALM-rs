{"function_name":"ryu::buffer::<f32 as buffer::Sealed>::format_nonfinite","tests":7,"tests_lines":[6,23,23,22,12,12,12],"oracles":7,"oracles_compiled":6,"oracles_compiled_rate":85.71428571428571,"tests_compiled":6,"tests_compiled_rate":85.71428571428571,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[125,128,129,130,131,132,134,136],"codes_lines_covered":[[["{","    struct TestStruct(f64);","","    let val: TestStruct = TestStruct(f64::from_bits(0x7ff8000000000000)); // NaN representation","    assert_eq!(val.0.format_nonfinite(), \"NaN\");","}"],[]],[["{","  #[derive(Clone)]","  struct TestStruct(f64);  ","","  impl Copy for TestStruct {}  "," ","   impl Sealed for TestStruct {  ","       fn is_nonfinite(self) -> bool {  ","           false // Non-finite check can be simplified for this test case  ","       }  ","       ","       fn format_nonfinite(self) -> &'static str {  ","           self.0.format_nonfinite()  ","       }  "," ","       unsafe fn write_to_ryu_buffer(self, _result: *mut u8) -> usize {  ","           0 // Not tested in this case  ","       }  ","   }  "," ","   let value = TestStruct(f64::from_bits(0x8000000000000000)); // -Infinity  ","   assert_eq!(value.format_nonfinite(), NEG_INFINITY);  ","}"],[]],[["{","  #[derive(Clone)]","  struct TestStruct(f64);","  ","  impl Copy for TestStruct {}","","   impl Sealed for TestStruct {","       fn is_nonfinite(self) -> bool {","           self.0.is_nan()","       }","       ","       fn format_nonfinite(self) -> &'static str {","           self.0.format_nonfinite()","       }","","       unsafe fn write_to_ryu_buffer(self, _result: *mut u8) -> usize {","           0 // Not tested in this case","       }","   }","","   let value = TestStruct(f64::NAN);","   assert_eq!(value.format_nonfinite(), NAN);","}"],[]],[["{","   #[derive(Clone)]","   struct TestStruct(f64);","   ","   impl Copy for TestStruct {}","    impl Sealed for TestStruct {","        fn is_nonfinite(self) -> bool {","            false // Non-finite check can be simplified for this test case","        }","        ","        fn format_nonfinite(self) -> &'static str {","            self.0.format_nonfinite()","        }","","       unsafe fn write_to_ryu_buffer(self, _result: *mut u8) -> usize {  ","           0 // Not tested in this case  ","       }  ","    }","","    let value = TestStruct(f64::INFINITY);","    assert_eq!(value.format_nonfinite(), INFINITY);","}"],[]],[["{","    struct NonFiniteTest(f64);","","    impl NonFiniteTest {","        fn to_bits(self) -> u64 {","            self.0.to_bits()","        }","    }","","   let test_value = NonFiniteTest(f64::INFINITY);  ","   assert_eq!(test_value.0.format_nonfinite(), \"inf\");  ","}"],[]],[["{","   struct NonFiniteTest(f64);  "," ","   impl NonFiniteTest {  ","       fn to_bits(self) -> u64 {  ","           self.0.to_bits()  ","       }  ","   }  "," ","   let test_value = NonFiniteTest(f64::NEG_INFINITY);  ","   assert_eq!(test_value.0.format_nonfinite(), \"-inf\");  ","}"],[]]],"codes_branches":[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestStruct(f64);","","    let val: TestStruct = TestStruct(f64::from_bits(0x7ff8000000000000)); // NaN representation","    assert_eq!(val.0.format_nonfinite(), \"NaN\");","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]],[["{","  #[derive(Clone)]","  struct TestStruct(f64);  ","","  impl Copy for TestStruct {}  "," ","   impl Sealed for TestStruct {  ","       fn is_nonfinite(self) -> bool {  ","           false // Non-finite check can be simplified for this test case  ","       }  ","       ","       fn format_nonfinite(self) -> &'static str {  ","           self.0.format_nonfinite()  ","       }  "," ","       unsafe fn write_to_ryu_buffer(self, _result: *mut u8) -> usize {  ","           0 // Not tested in this case  ","       }  ","   }  "," ","   let value = TestStruct(f64::from_bits(0x8000000000000000)); // -Infinity  ","   assert_eq!(value.format_nonfinite(), NEG_INFINITY);  ","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]],[["{","  #[derive(Clone)]","  struct TestStruct(f64);","  ","  impl Copy for TestStruct {}","","   impl Sealed for TestStruct {","       fn is_nonfinite(self) -> bool {","           self.0.is_nan()","       }","       ","       fn format_nonfinite(self) -> &'static str {","           self.0.format_nonfinite()","       }","","       unsafe fn write_to_ryu_buffer(self, _result: *mut u8) -> usize {","           0 // Not tested in this case","       }","   }","","   let value = TestStruct(f64::NAN);","   assert_eq!(value.format_nonfinite(), NAN);","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]],[["{","   #[derive(Clone)]","   struct TestStruct(f64);","   ","   impl Copy for TestStruct {}","    impl Sealed for TestStruct {","        fn is_nonfinite(self) -> bool {","            false // Non-finite check can be simplified for this test case","        }","        ","        fn format_nonfinite(self) -> &'static str {","            self.0.format_nonfinite()","        }","","       unsafe fn write_to_ryu_buffer(self, _result: *mut u8) -> usize {  ","           0 // Not tested in this case  ","       }  ","    }","","    let value = TestStruct(f64::INFINITY);","    assert_eq!(value.format_nonfinite(), INFINITY);","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]],[["{","    struct NonFiniteTest(f64);","","    impl NonFiniteTest {","        fn to_bits(self) -> u64 {","            self.0.to_bits()","        }","    }","","   let test_value = NonFiniteTest(f64::INFINITY);  ","   assert_eq!(test_value.0.format_nonfinite(), \"inf\");  ","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]],[["{","   struct NonFiniteTest(f64);  "," ","   impl NonFiniteTest {  ","       fn to_bits(self) -> u64 {  ","           self.0.to_bits()  ","       }  ","   }  "," ","   let test_value = NonFiniteTest(f64::NEG_INFINITY);  ","   assert_eq!(test_value.0.format_nonfinite(), \"-inf\");  ","}"],[{"start_line":129,"start_column":12,"end_line":129,"end_column":37,"positive":false,"negative":false},{"start_line":131,"start_column":19,"end_line":131,"end_column":40,"positive":false,"negative":false}]]]}