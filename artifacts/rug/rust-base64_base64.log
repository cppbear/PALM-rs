ChatCompletion(id='chatcmpl-BcpvXvifinApTiTLTDlyyc2QDXA4f', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::write::encoder_string_writer::StrConsumer;\n\n    struct MockStrConsumer {\n        consumed: String,\n    }\n\n    impl StrConsumer for MockStrConsumer {\n        fn consume(&mut self, buf: &str) {\n            self.consumed.push_str(buf);\n        }\n    }\n\n    #[test]\n    fn test_consume() {\n        let mut mock = MockStrConsumer {\n            consumed: String::new(),\n        };\n\n        let input = "Hello, World!";\n        mock.consume(input);\n        assert_eq!(mock.consumed, "Hello, World!");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595771, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=137, prompt_tokens=159, total_tokens=296, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpvdjiIOnTy95ZsgxHpo6yboY67i', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_input() {\n        let input = "valid_input";\n        let result = Alphabet::try_from(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_input() {\n        let input = "invalid_input";\n        let result = Alphabet::try_from(input);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595777, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=105, prompt_tokens=162, total_tokens=267, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpviqOfNWWPdaFR0t1te1vcsC3bU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::chunked_encoder::{StringSink, Sink};\n\n    #[test]\n    fn test_write_encoded_bytes() {\n        let mut s = String::new();\n        let mut sink = StringSink::new(&mut s);\n        let input = b"Hello, World!";\n        \n        let result = sink.write_encoded_bytes(input);\n        \n        assert!(result.is_ok());\n        assert_eq!(s, "Hello, World!");\n    }\n\n    #[test]\n    fn test_write_encoded_bytes_invalid_utf8() {\n        let mut s = String::new();\n        let mut sink = StringSink::new(&mut s);\n        let input = &[0, 159, 146, 150]; // Invalid UTF-8 sequence\n        \n        let result = sink.write_encoded_bytes(input);\n        \n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595782, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=185, prompt_tokens=428, total_tokens=613, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcpvny6pR0ep1Z1MlUYpygefG8I9J', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::decode::{DecodeError, DecodeSliceError};\n\n    #[test]\n    fn test_from_invalid_byte() {\n        let error = DecodeError::InvalidByte(5, b\'A\');\n        let slice_error: DecodeSliceError = DecodeSliceError::from(error);\n        match slice_error {\n            DecodeSliceError::DecodeError(ref err) => match err {\n                DecodeError::InvalidByte(index, byte) => {\n                    assert_eq!(*index, 5);\n                    assert_eq!(*byte, b\'A\');\n                }\n                _ => panic!("Expected DecodeError::InvalidByte"),\n            },\n            _ => panic!("Expected DecodeSliceError::DecodeError"),\n        }\n    }\n\n    #[test]\n    fn test_from_invalid_length() {\n        let error = DecodeError::InvalidLength(3);\n        let slice_error: DecodeSliceError = DecodeSliceError::from(error);\n        match slice_error {\n            DecodeSliceError::DecodeError(ref err) => match err {\n                DecodeError::InvalidLength(len) => assert_eq!(*len, 3),\n                _ => panic!("Expected DecodeError::InvalidLength"),\n            },\n            _ => panic!("Expected DecodeSliceError::DecodeError"),\n        }\n    }\n\n    #[test]\n    fn test_from_invalid_last_symbol() {\n        let error = DecodeError::InvalidLastSymbol(7, b\'Z\');\n        let slice_error: DecodeSliceError = DecodeSliceError::from(error);\n        match slice_error {\n            DecodeSliceError::DecodeError(ref err) => match err {\n                DecodeError::InvalidLastSymbol(index, byte) => {\n                    assert_eq!(*index, 7);\n                    assert_eq!(*byte, b\'Z\');\n                }\n                _ => panic!("Expected DecodeError::InvalidLastSymbol"),\n            },\n            _ => panic!("Expected DecodeSliceError::DecodeError"),\n        }\n    }\n\n    #[test]\n    fn test_from_invalid_padding() {\n        let error = DecodeError::InvalidPadding;\n        let slice_error: DecodeSliceError = DecodeSliceError::from(error);\n        match slice_error {\n            DecodeSliceError::DecodeError(ref err) => match err {\n                DecodeError::InvalidPadding => {},\n                _ => panic!("Expected DecodeError::InvalidPadding"),\n            },\n            _ => panic!("Expected DecodeSliceError::DecodeError"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595787, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=493, prompt_tokens=963, total_tokens=1456, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpvySaJ4hxot7G2tbxY5QTwHnDBZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::error::Error;\n\n    #[test]\n    fn test_source_decode_error() {\n        let decode_error = DecodeError::InvalidByte(1, b\'A\');\n        let decode_slice_error = DecodeSliceError::from(decode_error);\n\n        if let Some(source) = decode_slice_error.source() {\n            assert_eq!(source.to_string(), "Invalid symbol 65, offset 1.");\n            assert!(source.is::<DecodeError>());\n        } else {\n            panic!("Expected a source for DecodeSliceError::DecodeError.");\n        }\n    }\n\n    #[test]\n    fn test_source_output_slice_too_small() {\n        let decode_slice_error = DecodeSliceError::OutputSliceTooSmall;\n\n        assert!(decode_slice_error.source().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595798, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=172, prompt_tokens=988, total_tokens=1160, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcpw3he0cOD5PgINrmc6EgwsUKYdw', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt::{self, Formatter};\n\n    struct MockFormatter {\n        output: String,\n    }\n\n    impl MockFormatter {\n        fn new() -> Self {\n            MockFormatter { output: String::new() }\n        }\n    }\n\n    impl Formatter<\'_> for MockFormatter {\n        fn write_str(&mut self, s: &str) -> fmt::Result {\n            self.output.push_str(s);\n            Ok(())\n        }\n    }\n\n    #[test]\n    fn test_write_encoded_bytes_valid_utf8() {\n        let mut mock_formatter = MockFormatter::new();\n        let mut sink = FormatterSink { f: &mut mock_formatter };\n\n        let encoded_bytes = b"Valid base64 data";\n        let result = sink.write_encoded_bytes(encoded_bytes);\n\n        assert!(result.is_ok());\n        assert_eq!(mock_formatter.output, "Valid base64 data");\n    }\n\n    #[test]\n    #[should_panic(expected = "base64 data was not utf8")]\n    fn test_write_encoded_bytes_invalid_utf8() {\n        let mut mock_formatter = MockFormatter::new();\n        let mut sink = FormatterSink { f: &mut mock_formatter };\n\n        let encoded_bytes = &[0, 159, 146, 150]; // Invalid UTF-8 sequence\n        let _result = sink.write_encoded_bytes(encoded_bytes);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595803, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=289, prompt_tokens=403, total_tokens=692, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpwBrIo8URlbly4modDPN05x0Pdg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    use crate::engine::DecodePaddingMode;\n\n    #[test]\n    fn test_config() {\n        let config = GeneralPurposeConfig::new();\n        let engine = GeneralPurpose::new(&Alphabet::STANDARD, config.clone());\n\n        assert_eq!(engine.config().encode_padding(), config.encode_padding());\n        assert_eq!(engine.config().decode_allow_trailing_bits, config.decode_allow_trailing_bits);\n        assert_eq!(engine.config().decode_padding_mode, config.decode_padding_mode);\n    }\n\n    #[test]\n    fn test_config_with_custom_padding() {\n        let config = GeneralPurposeConfig::new().with_encode_padding(false);\n        let engine = GeneralPurpose::new(&Alphabet::STANDARD, config.clone());\n\n        assert_eq!(engine.config().encode_padding(), false);\n        assert_eq!(engine.config().decode_allow_trailing_bits, config.decode_allow_trailing_bits);\n        assert_eq!(engine.config().decode_padding_mode, config.decode_padding_mode);\n    }\n\n    #[test]\n    fn test_config_with_custom_padding_mode() {\n        let config = GeneralPurposeConfig::new().with_decode_padding_mode(DecodePaddingMode::Indifferent);\n        let engine = GeneralPurpose::new(&Alphabet::STANDARD, config.clone());\n\n        assert_eq!(engine.config().encode_padding(), config.encode_padding());\n        assert_eq!(engine.config().decode_allow_trailing_bits, config.decode_allow_trailing_bits);\n        assert_eq!(engine.config().decode_padding_mode, DecodePaddingMode::Indifferent);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595811, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=331, prompt_tokens=3570, total_tokens=3901, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpwJbyRHJLoDzaVUgNGSqF1DSJ1o', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    use crate::engine::DecodePaddingMode;\n    use crate::engine::DecodeSliceError;\n    use crate::engine::DecodeMetadata;\n\n    #[test]\n    fn test_internal_decode_valid_input() {\n        let config = GeneralPurposeConfig::new();\n        let engine = GeneralPurpose::new(&crate::Alphabet::STANDARD, config);\n        let input = b"SGVsbG8gV29ybGQ=";\n        let mut output = vec![0; 11]; // "Hello World" is 11 bytes\n        let estimate = engine.internal_decoded_len_estimate(input.len());\n\n        let result: Result<DecodeMetadata, DecodeSliceError> = engine.internal_decode(input, &mut output, estimate);\n        \n        assert!(result.is_ok());\n        assert_eq!(&output[..11], b"Hello World");\n    }\n\n    #[test]\n    fn test_internal_decode_invalid_input() {\n        let config = GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::RequireCanonical);\n        let engine = GeneralPurpose::new(&crate::Alphabet::STANDARD, config);\n        let input = b"SGVsbG8gV29ybGQ"; // Missing padding\n        let mut output = vec![0; 11];\n        let estimate = engine.internal_decoded_len_estimate(input.len());\n\n        let result: Result<DecodeMetadata, DecodeSliceError> = engine.internal_decode(input, &mut output, estimate);\n        \n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_internal_decode_no_padding() {\n        let config = GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::RequireNone);\n        let engine = GeneralPurpose::new(&crate::Alphabet::STANDARD, config);\n        let input = b"SGVsbG8gV29ybGQ"; // No padding is okay\n        let mut output = vec![0; 11];\n        let estimate = engine.internal_decoded_len_estimate(input.len());\n\n        let result: Result<DecodeMetadata, DecodeSliceError> = engine.internal_decode(input, &mut output, estimate);\n        \n        assert!(result.is_ok());\n        assert_eq!(&output[..11], b"Hello World");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595819, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=496, prompt_tokens=3640, total_tokens=4136, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpwThry9BXu9UTeLnnajuysHJMG5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n\n    #[test]\n    fn test_internal_decoded_len_estimate() {\n        let config = GeneralPurposeConfig::default();\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, config);\n        \n        let input_len = 10;\n        let estimate = engine.internal_decoded_len_estimate(input_len);\n        \n        // Assuming the GeneralPurposeEstimate is public and has an appropriate way to get the value\n        // Replace the following line with an appropriate way to retrieve the length from estimate\n        let estimated_len = estimate.length(); // Example, adjust based on actual implementation\n        assert_eq!(estimated_len, 10);  // Adjust the value based on the expected behavior\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595829, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=177, prompt_tokens=3594, total_tokens=3771, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpwZ7YXg0X6erAj2NRjwFQEEVC0A', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    use engine::DecodePaddingMode;\n\n    #[test]\n    fn test_internal_encode() {\n        let alphabet = base64::Alphabet::STANDARD;\n        let config = GeneralPurposeConfig::new();\n        let encoder = GeneralPurpose::new(&alphabet, config);\n        \n        let input = b"Hello, World!";\n        let mut output = vec![0u8; 24]; // Sufficient size for output\n        let encoded_length = encoder.internal_encode(input, &mut output);\n        \n        assert_eq!(encoded_length, 20);\n        assert_eq!(&output[..encoded_length], b"SGVsbG8sIFdvcmxkIQ==");\n    }\n\n    #[test]\n    fn test_internal_encode_with_padding() {\n        let alphabet = base64::Alphabet::STANDARD;\n        let config = GeneralPurposeConfig::new()\n            .with_encode_padding(true);\n        let encoder = GeneralPurpose::new(&alphabet, config);\n        \n        let input = b"Hello";\n        let mut output = vec![0u8; 8]; // Sufficient size for output\n        let encoded_length = encoder.internal_encode(input, &mut output);\n        \n        assert_eq!(encoded_length, 8);\n        assert_eq!(&output[..encoded_length], b"SGVs");\n    }\n\n    #[test]\n    fn test_internal_encode_without_padding() {\n        let alphabet = base64::Alphabet::STANDARD;\n        let config = GeneralPurposeConfig::new()\n            .with_encode_padding(false);\n        let encoder = GeneralPurpose::new(&alphabet, config);\n        \n        let input = b"Hello";\n        let mut output = vec![0u8; 8]; // Sufficient size for output\n        let encoded_length = encoder.internal_encode(input, &mut output);\n        \n        assert_eq!(encoded_length, 7);\n        assert_eq!(&output[..encoded_length], b"SGVsbw");\n    }\n\n    #[test]\n    fn test_internal_encode_empty_input() {\n        let alphabet = base64::Alphabet::STANDARD;\n        let config = GeneralPurposeConfig::new();\n        let encoder = GeneralPurpose::new(&alphabet, config);\n        \n        let input: &[u8] = b"";\n        let mut output = vec![0u8; 4]; // Sufficient size for output\n        let encoded_length = encoder.internal_encode(input, &mut output);\n        \n        assert_eq!(encoded_length, 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595835, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=531, prompt_tokens=5358, total_tokens=5889, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpwiEDT5xi0e2brGdVPtszWD9pQL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::GeneralPurposeConfig;\n\n    #[test]\n    fn test_encode_padding_default_true() {\n        let config = GeneralPurposeConfig::new();\n        assert!(config.encode_padding());\n    }\n\n    #[test]\n    fn test_encode_padding_with_padding_true() {\n        let config = GeneralPurposeConfig::new().with_encode_padding(true);\n        assert!(config.encode_padding());\n    }\n\n    #[test]\n    fn test_encode_padding_with_padding_false() {\n        let config = GeneralPurposeConfig::new().with_encode_padding(false);\n        assert!(!config.encode_padding());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595844, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=139, prompt_tokens=1334, total_tokens=1473, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcpwmss4jpDUZwoFeobWIg1ZE4ZAm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose::GeneralPurposeConfig;\n\n    #[test]\n    fn test_default() {\n        let config = GeneralPurposeConfig::default();\n        assert_eq!(config.encode_padding(), true);\n        assert_eq!(config.decode_allow_trailing_bits, false);\n        assert_eq!(config.decode_padding_mode, DecodePaddingMode::RequireCanonical);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595848, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=92, prompt_tokens=1343, total_tokens=1435, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpwqK8l7F84IcBEgol9wZOoMqqeB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::engine::general_purpose::decode::GeneralPurposeEstimate;\n    use super::engine::DecodeEstimate;\n\n    #[test]\n    fn test_decoded_len_estimate() {\n        let estimate = GeneralPurposeEstimate::new(4);\n        assert_eq!(estimate.decoded_len_estimate(), 3);\n\n        let estimate = GeneralPurposeEstimate::new(8);\n        assert_eq!(estimate.decoded_len_estimate(), 6);\n\n        let estimate = GeneralPurposeEstimate::new(10);\n        assert_eq!(estimate.decoded_len_estimate(), 9);\n\n        let estimate = GeneralPurposeEstimate::new(11);\n        assert_eq!(estimate.decoded_len_estimate(), 9);\n        \n        let estimate = GeneralPurposeEstimate::new(0);\n        assert_eq!(estimate.decoded_len_estimate(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595852, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=184, prompt_tokens=353, total_tokens=537, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpwyshJhBW19er3QDxDU0lET7Rvk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_decoder_reader_read_success() {\n        let input_data = b"YXNkZg=="; // Base64 for "asdf"\n        let mut cursor = Cursor::new(input_data);\n        let engine = &general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(&mut cursor, engine);\n        \n        let mut output_buf = vec![0; 4]; // Buffer for the decoded output\n        let bytes_read = decoder.read(&mut output_buf).unwrap();\n        \n        assert_eq!(bytes_read, 4);\n        assert_eq!(&output_buf[..bytes_read], b"asdf");\n    }\n\n    #[test]\n    fn test_decoder_reader_read_empty() {\n        let input_data = b""; // Empty input\n        let mut cursor = Cursor::new(input_data);\n        let engine = &general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(&mut cursor, engine);\n        \n        let mut output_buf = vec![0; 4]; // Buffer for the decoded output\n        let bytes_read = decoder.read(&mut output_buf).unwrap();\n        \n        assert_eq!(bytes_read, 0); // No bytes should be read\n    }\n\n    #[test]\n    fn test_decoder_reader_read_invalid_data() {\n        let input_data = b"INVALID_BASE64"; // Invalid base64\n        let mut cursor = Cursor::new(input_data);\n        let engine = &general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(&mut cursor, engine);\n        \n        let mut output_buf = vec![0; 4]; // Buffer for the decoded output\n        let result = decoder.read(&mut output_buf);\n        \n        assert!(result.is_err()); // Should return an error\n    }\n\n    #[test]\n    fn test_decoder_reader_read_partial_data() {\n        let input_data = b"YXNk"; // Base64 for "as"\n        let mut cursor = Cursor::new(input_data);\n        let engine = &general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(&mut cursor, engine);\n        \n        let mut output_buf = vec![0; 3]; // Buffer for the decoded output\n        let bytes_read = decoder.read(&mut output_buf).unwrap();\n        \n        assert_eq!(bytes_read, 2); // Should decode "as"\n        assert_eq!(&output_buf[..bytes_read], b"as");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595860, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=537, prompt_tokens=11135, total_tokens=11672, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpxACSVnkLVAuNyvWH4jvFFYZBJr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Make sure to import necessary items from the parent module\n    use std::string::String; // Import the String from the standard library\n\n    #[test]\n    fn test_consume() {\n        let mut s = String::new();\n        let input = "Hello, ";\n        \n        s.consume(input);\n        \n        assert_eq!(s, "Hello, ");\n        \n        let additional_input = "world!";\n        s.consume(additional_input);\n        \n        assert_eq!(s, "Hello, world!");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595872, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=121, prompt_tokens=233, total_tokens=354, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpxFKZuwBqFXeONI5YpZdaP9GVLt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{engine::general_purpose, write::EncoderWriter};\n    use std::io::Cursor;\n\n    #[test]\n    fn test_flush_function() {\n        let data = b"hello world";\n        let mut buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(Cursor::new(&mut buffer), &general_purpose::STANDARD);\n\n        // Write some data to the encoder\n        encoder.write_all(data).expect("Failed to write data");\n\n        // Flush the encoder\n        encoder.flush().expect("Failed to flush the encoder");\n\n        // Retrieve the encoded result\n        let encoded = encoder.finish().expect("Failed to finish encoder");\n\n        // Validate the encoded output\n        assert_eq!(encoded, b"aGVsbG8gd29ybGQ=");\n    }\n\n    #[test]\n    fn test_flush_with_error_handling() {\n        let data = b"test";\n        let mut mock_writer = MockWriter::new();\n        let mut encoder = EncoderWriter::new(mock_writer, &general_purpose::STANDARD);\n\n        // Write data to encoder\n        encoder.write_all(data).expect("Failed to write to encoder");\n\n        // Flush the encoder\n        let result = encoder.flush();\n\n        // Check if flush returned an error\n        assert!(result.is_err());\n    }\n\n    struct MockWriter {\n        flush_called: bool,\n    }\n\n    impl MockWriter {\n        fn new() -> Self {\n            MockWriter { flush_called: false }\n        }\n    }\n\n    impl std::io::Write for MockWriter {\n        fn write(&mut self, _buf: &[u8]) -> std::io::Result<usize> {\n            Ok(4) // simulate successful write\n        }\n\n        fn flush(&mut self) -> std::io::Result<()> {\n            self.flush_called = true;\n            Err(std::io::Error::new(std::io::ErrorKind::Other, "Flush error")) // simulate an error\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595877, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=422, prompt_tokens=10935, total_tokens=11357, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpxUShtx69b7dEQqlGKYnsOgtPeV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn test_write_empty_input() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        let result = writer.write(&[]);\n        assert_eq!(result, Ok(0));\n    }\n\n    #[test]\n    fn test_write_single_byte() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        let result = writer.write(&[0x61]); // \'a\'\n        assert_eq!(result, Ok(1));\n        writer.finish().unwrap();\n        assert_eq!(&vec[..], b"YQ=="); // Base64 encoding of \'a\'\n    }\n\n    #[test]\n    fn test_write_multiple_bytes() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        let result = writer.write(b"abc");\n        assert_eq!(result, Ok(3));\n        writer.finish().unwrap();\n        assert_eq!(&vec[..], b"YWJj"); // Base64 encoding of \'abc\'\n    }\n\n    #[test]\n    fn test_write_partial_chunk() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        let result1 = writer.write(b"ab"); // 2 bytes\n        assert_eq!(result1, Ok(2));\n        let result2 = writer.write(b"c"); // 1 byte\n        assert_eq!(result2, Ok(1));\n        writer.finish().unwrap();\n        assert_eq!(&vec[..], b"YWJj"); // Base64 encoding of \'abc\'\n    }\n\n    #[test]\n    fn test_write_large_input() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        let data = b"Hello, world!"; // 13 bytes\n        let result = writer.write(data);\n        assert_eq!(result, Ok(13));\n        writer.finish().unwrap();\n        assert_eq!(&vec[..], b"SGVsbG8sIHdvcmxkIQ=="); // Base64 encoding of \'Hello, world!\'\n    }\n\n    #[test]\n    fn test_write_after_finish() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        writer.finish().unwrap();\n        let result = writer.write(b"test");\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595892, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=617, prompt_tokens=12225, total_tokens=12842, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpxgJSqnL34W6z5C9F5KX5moMmwz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn test_encoder_writer_drop_when_panicked() {\n        let output: Vec<u8> = Vec::new();\n        let engine = &general_purpose::STANDARD;\n        let mut encoder_writer = EncoderWriter::new(Cursor::new(output), engine);\n\n        encoder_writer.panicked = true; // Simulating panic\n        encoder_writer.drop(); // Call drop directly\n        // No assert; we just want to ensure it does not panic\n    }\n\n    #[test]\n    fn test_encoder_writer_drop_without_panicked() {\n        let output: Vec<u8> = Vec::new();\n        let engine = &general_purpose::STANDARD;\n        let mut encoder_writer = EncoderWriter::new(Cursor::new(output), engine);\n\n        encoder_writer.panicked = false; // Simulating normal operation\n\n        encoder_writer.drop(); // Call drop directly\n        // We can assert that encoder_writer now has a None delegate\n        assert!(encoder_writer.delegate.is_none());\n    }\n\n    #[test]\n    fn test_encoder_writer_drop_with_remaining_input() {\n        let output: Vec<u8> = Vec::new();\n        let engine = &general_purpose::STANDARD;\n        let mut encoder_writer = EncoderWriter::new(Cursor::new(output), engine);\n\n        encoder_writer.extra_input_occupied_len = 1; // Simulating leftover input\n        encoder_writer.panicked = false; // Simulating normal operation\n\n        encoder_writer.drop(); // Call drop directly\n        // We can check if drop handled the leftover input correctly\n        // Here we need to ensure that write_final_leftovers() was called, but this requires\n        // a bit of refactoring of the drop and write_final_leftovers to return some checkable result.\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595904, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=380, prompt_tokens=10881, total_tokens=11261, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcpxr9n888UceeHqdd8FXXTwhXXtf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_flush() {\n        let engine = &general_purpose::STANDARD;\n        let mut buf = String::new();\n        let mut encoder = base64::write::EncoderStringWriter::from_consumer(&mut buf, engine);\n        \n        encoder.write_all(b"test").unwrap();\n        encoder.flush().unwrap(); // Call flush to ensure encoding is complete\n\n        assert_eq!(buf, "dGVzdA=="); // Validate the base64-encoded output\n    }\n\n    #[test]\n    fn test_flush_empty() {\n        let engine = &general_purpose::STANDARD;\n        let mut buf = String::new();\n        let mut encoder = base64::write::EncoderStringWriter::from_consumer(&mut buf, engine);\n        \n        encoder.flush().unwrap(); // Should work even if nothing was written\n\n        assert!(buf.is_empty()); // Validate that buffer is still empty\n    }\n\n    #[test]\n    fn test_flush_with_data() {\n        let engine = &general_purpose::STANDARD;\n        let mut buf = String::new();\n        let mut encoder = base64::write::EncoderStringWriter::from_consumer(&mut buf, engine);\n        \n        encoder.write_all(b"data").unwrap();\n        encoder.flush().unwrap(); // Should flush the written data\n\n        assert_eq!(buf, "ZGF0YQ=="); // Check that the encoded data is correct\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595915, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=321, prompt_tokens=11772, total_tokens=12093, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpxzZjLV5oNvVZM14HseF4VDU9ty', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_write() {\n        let mut encoder = base64::write::EncoderStringWriter::new(&general_purpose::STANDARD);\n        let input = b"hello";\n        \n        let result = encoder.write(input);\n        \n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), input.len());\n        \n        let b64_string = encoder.into_inner();\n        assert_eq!(b64_string, "aGVsbG8=");\n    }\n\n    #[test]\n    fn test_write_empty() {\n        let mut encoder = base64::write::EncoderStringWriter::new(&general_purpose::STANDARD);\n        let input: &[u8] = &[];\n\n        let result = encoder.write(input);\n        \n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), input.len());\n        \n        let b64_string = encoder.into_inner();\n        assert_eq!(b64_string, "");\n    }\n\n    #[test]\n    fn test_write_partial() {\n        let mut encoder = base64::write::EncoderStringWriter::new(&general_purpose::STANDARD);\n        let input = b"hello, world";\n        \n        let _ = encoder.write(&input[0..5]);  // Write "hello"\n        let b64_string = encoder.into_inner();\n        assert_eq!(b64_string, "aGVsbG8=");\n        \n        let _ = encoder.write(&input[5..]); // Write ", world"\n        let b64_string = encoder.into_inner();\n        assert_eq!(b64_string, "aGVsbG8sIHdvcmxk");\n    }\n\n    #[test]\n    fn test_write_multiple() {\n        let mut encoder = base64::write::EncoderStringWriter::new(&general_purpose::STANDARD);\n        \n        let inputs = vec![b"first", b" second", b" third"];\n        for input in inputs {\n            encoder.write_all(input).expect("Writing failed");\n        }\n\n        let b64_string = encoder.into_inner();\n        assert_eq!(b64_string, "Zmlyc3Qgc2Vjb25kIHRoa");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595923, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=460, prompt_tokens=11780, total_tokens=12240, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcpy9RU13QeS8vIUvKytEWFyF1FHr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n\n    #[test]\n    fn test_flush() {\n        let mut string = String::new();\n        let mut writer = Utf8SingleCodeUnitWriter { str_consumer: string };\n\n        // Call flush and check the result\n        let result = writer.flush();\n\n        // Ensure flush returns Ok(())\n        assert!(result.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595933, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=93, prompt_tokens=583, total_tokens=676, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpyDbhHcTkmkhTcmSLDEZ61pzaqa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n\n    #[test]\n    fn test_utf8_single_code_unit_writer() {\n        let mut string_consumer = String::new();\n        let mut writer = Utf8SingleCodeUnitWriter { str_consumer: string_consumer };\n\n        let input = b"Hello, World!";\n        let result = writer.write(input).expect("Failed to write");\n\n        assert_eq!(result, input.len());\n        assert_eq!(writer.str_consumer, "Hello, World!");\n    }\n\n    #[test]\n    fn test_invalid_utf8() {\n        let mut string_consumer = String::new();\n        let mut writer = Utf8SingleCodeUnitWriter { str_consumer: string_consumer };\n\n        let invalid_input = [0, 159, 146, 150]; // invalid UTF-8 bytes\n        let write_result = writer.write(&invalid_input);\n        \n        assert!(write_result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595937, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=208, prompt_tokens=644, total_tokens=852, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpyJA4LbmKd3NEsy9EeXxvItmlWz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::alphabet::Alphabet;\n\n    #[test]\n    fn test_as_str() {\n        let alphabet_str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\n        let alphabet = Alphabet::new(alphabet_str).unwrap();\n        \n        assert_eq!(alphabet.as_str(), alphabet_str);\n    }\n\n    #[test]\n    fn test_as_str_invalid_alphabet() {\n        let alphabet_str = "INVALID_ALPHABET_LENGTH"; // length is not 64\n        let result = Alphabet::new(alphabet_str);\n        \n        assert!(result.is_err());\n        \n        let alphabet_str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; // contains \'=\'\n        let result = Alphabet::new(alphabet_str);\n        \n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_as_str_with_custom_alphabet() {\n        let custom_alphabet_str = "ABCDEFGHIJKLMNOPQRSTUVWXYSZabcdefghijklmnopqrstuvwxyz0123456789+/";\n        let alphabet = Alphabet::new(custom_alphabet_str).unwrap();\n        \n        assert_eq!(alphabet.as_str(), custom_alphabet_str);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595943, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=236, prompt_tokens=1122, total_tokens=1358, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpyQSmQ4MBWoo6j16jDr3i6RCfT1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::Alphabet;\n\n    #[test]\n    fn test_from_str_unchecked_valid() {\n        const ALPHABET_STR: &str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\n        let alphabet = Alphabet::from_str_unchecked(ALPHABET_STR);\n        assert_eq!(alphabet.as_str(), ALPHABET_STR);\n    }\n\n    #[test]\n    fn test_from_str_unchecked_empty() {\n        const ALPHABET_STR: &str = "                                                                  ";\n        let alphabet = Alphabet::from_str_unchecked(ALPHABET_STR);\n        assert_eq!(alphabet.as_str(), ALPHABET_STR);\n    }\n\n    #[test]\n    fn test_from_str_unchecked_repeated_chars() {\n        const ALPHABET_STR: &str = "ABCDEFGHIJKLMNOABCDEFGHIJKLMNOABCDEFGHJKLMNOABCDEFGHIJKLMNO"; // Invalid for base64\n        let alphabet = Alphabet::from_str_unchecked(ALPHABET_STR);\n        assert_eq!(alphabet.as_str(), ALPHABET_STR);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595950, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=215, prompt_tokens=1189, total_tokens=1404, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpyVdHyl2qwLXev5M9P7nbkNvKfX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::alphabet::{Alphabet, ParseAlphabetError};\n\n    #[test]\n    fn test_new_valid_alphabet() {\n        let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\n        let result = Alphabet::new(alphabet);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_new_invalid_length() {\n        let alphabet = "Short";\n        let result = Alphabet::new(alphabet);\n        assert_eq!(result, Err(ParseAlphabetError::InvalidLength));\n    }\n\n    #[test]\n    fn test_new_unprintable_byte() {\n        let alphabet = "ABCDEFGHIJKLMNO\\x00QRSTUVWXYYZabcdefgh";\n        let result = Alphabet::new(alphabet);\n        assert_eq!(result, Err(ParseAlphabetError::UnprintableByte(0)));\n    }\n\n    #[test]\n    fn test_new_reserved_byte() {\n        let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789=";\n        let result = Alphabet::new(alphabet);\n        assert_eq!(result, Err(ParseAlphabetError::ReservedByte(b\'=\')));\n    }\n\n    #[test]\n    fn test_new_duplicated_byte() {\n        let alphabet = "ABCDEFGHIJKLMABCDE0123456789+/";\n        let result = Alphabet::new(alphabet);\n        assert_eq!(result, Err(ParseAlphabetError::DuplicatedByte(b\'A\')));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595955, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=292, prompt_tokens=478, total_tokens=770, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpyeDm8hCJEmgFdACgIA9ymlX8Jo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::chunked_encoder::{ChunkedEncoder, StringSink};\n    use crate::engine::{general_purpose::GeneralPurpose, GeneralPurposeConfig};\n\n    #[test]\n    fn test_encode() {\n        let engine = GeneralPurpose::new(&crate::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let encoder = ChunkedEncoder::new(&engine);\n        \n        let input_data = b"Hello, world!";\n        let mut output_string = String::new();\n        let mut sink = StringSink::new(&mut output_string);\n\n        let result = encoder.encode(input_data, &mut sink);\n        \n        assert!(result.is_ok());\n        assert_eq!(output_string, "SGVsbG8sIHdvcmxkIQ==");\n    }\n\n    #[test]\n    fn test_encode_empty() {\n        let engine = GeneralPurpose::new(&crate::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let encoder = ChunkedEncoder::new(&engine);\n\n        let input_data: &[u8] = &[];\n        let mut output_string = String::new();\n        let mut sink = StringSink::new(&mut output_string);\n\n        let result = encoder.encode(input_data, &mut sink);\n\n        assert!(result.is_ok());\n        assert_eq!(output_string, "");\n    }\n\n    #[test]\n    fn test_encode_with_padding() {\n        let engine = GeneralPurpose::new(&crate::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let encoder = ChunkedEncoder::new(&engine);\n\n        let input_data = b"abc"; // 3 bytes => 4 base64 characters\n        let mut output_string = String::new();\n        let mut sink = StringSink::new(&mut output_string);\n\n        let result = encoder.encode(input_data, &mut sink);\n\n        assert!(result.is_ok());\n        assert_eq!(output_string, "YWJj");\n    }\n\n    #[test]\n    fn test_encode_without_padding() {\n        let config = GeneralPurposeConfig::new().with_encode_padding(false);\n        let engine = GeneralPurpose::new(&crate::alphabet::STANDARD, config);\n        let encoder = ChunkedEncoder::new(&engine);\n\n        let input_data = b"abc"; // 3 bytes => 4 base64 characters\n        let mut output_string = String::new();\n        let mut sink = StringSink::new(&mut output_string);\n\n        let result = encoder.encode(input_data, &mut sink);\n\n        assert!(result.is_ok());\n        assert_eq!(output_string, "YWJj");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595964, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=539, prompt_tokens=7871, total_tokens=8410, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpyxR7hSJ6o5nIc7f1lGEY6Xdtx4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose, GeneralPurpose, GeneralPurposeConfig};\n    \n    #[test]\n    fn test_chunked_encoder_new() {\n        let config = GeneralPurposeConfig::default();\n        let engine = GeneralPurpose::new(&general_purpose::STANDARD, config);\n        \n        let chunked_encoder = ChunkedEncoder::new(&engine);\n        \n        assert_eq!(chunked_encoder.engine.config().encode_padding(), true);\n        assert_eq!(chunked_encoder.engine as *const _, &engine as *const _);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595983, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=129, prompt_tokens=7341, total_tokens=7470, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcpz1BWh4B9CLm7E3ETSvpDWNjTY4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::chunked_encoder::{StringSink, Sink};\n\n    #[test]\n    fn test_string_sink_new() {\n        let mut test_string = String::new();\n        let mut string_sink = StringSink::new(&mut test_string);\n\n        assert_eq!(test_string, "");\n\n        let bytes = b"Hello, ";\n        string_sink.write_encoded_bytes(bytes).unwrap();\n        assert_eq!(test_string, "Hello, ");\n\n        let more_bytes = b"world!";\n        string_sink.write_encoded_bytes(more_bytes).unwrap();\n        assert_eq!(test_string, "Hello, world!");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595987, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=139, prompt_tokens=403, total_tokens=542, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcpz5GZdGxywuRhUBFmAZwA0xWXwO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{decode, DecodeError};\n\n    #[test]\n    fn test_decode_valid_base64() {\n        let input = "SGVsbG8gV29ybGQ=";\n        let expected = b"Hello World";\n        let result = decode(input).unwrap();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_decode_invalid_base64() {\n        let input = "!!invalid!!";\n        let result = decode(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_decode_empty() {\n        let input = "";\n        let result = decode(input).unwrap();\n        assert_eq!(result, b"");\n    }\n\n    #[test]\n    fn test_decode_with_padding() {\n        let input = "U29tZSBkYXRh";\n        let expected = b"Some data";\n        let result = decode(input).unwrap();\n        assert_eq!(result, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595991, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=214, prompt_tokens=207, total_tokens=421, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpzBEDDWSSe3hLLH2JbGSyA3F5u1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n    use base64::engine::Engine;\n    use base64::DecodeError;\n\n    #[test]\n    fn test_decode_engine_valid() {\n        let engine = general_purpose::STANDARD;\n        let input = "SGVsbG8gd29ybGQ="; // "Hello world" in base64\n        let expected_output = b"Hello world";\n\n        let result = decode_engine(input, &engine);\n        assert_eq!(result.is_ok(), true);\n        assert_eq!(result.unwrap(), expected_output.to_vec());\n    }\n\n    #[test]\n    fn test_decode_engine_invalid() {\n        let engine = general_purpose::STANDARD;\n        let input = "SGVsbG8gd29ybGQ"; // Invalid base64 (missing padding)\n\n        let result = decode_engine(input, &engine);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), DecodeError::InvalidLastSymbol);\n    }\n\n    #[test]\n    fn test_decode_engine_with_trailing_bits() {\n        let engine = general_purpose::STANDARD;\n        let input = "SGVsbG8gd29ybGQ="; // "Hello world" in base64\n        let expected_output = b"Hello world";\n\n        // Allow trailing bits\n        let config = general_purpose::GeneralPurposeConfig::new()\n            .with_decode_allow_trailing_bits(true);\n        let engine_with_trailing_bits = general_purpose::GeneralPurpose::new(&general_purpose::STANDARD.encode_table, config);\n        let result = decode_engine(input, &engine_with_trailing_bits);\n        \n        assert_eq!(result.is_ok(), true);\n        assert_eq!(result.unwrap(), expected_output.to_vec());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748595997, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=376, prompt_tokens=7097, total_tokens=7473, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpzM6EtCzJR9Qq1Iny0rOUpesyCv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose};\n\n    #[test]\n    fn test_decode_engine_slice() {\n        let engine = general_purpose::STANDARD;\n        let input = "aGVsbG8gd29ybGR+Cg==";\n        let mut output = vec![0u8; 16]; // Allocate enough space for the output\n        let result = decode_engine_slice(input, &mut output, &engine);\n\n        assert!(result.is_ok());\n        let bytes_written = result.unwrap();\n        assert_eq!(bytes_written, 13);\n        assert_eq!(&output[..bytes_written], b"hello world\\n");\n    }\n\n    #[test]\n    fn test_decode_engine_slice_with_canonical_padding() {\n        let config = engine::GeneralPurposeConfig::new().with_decode_padding_mode(DecodePaddingMode::RequireCanonical);\n        let engine = engine::GeneralPurpose::new(&engine::alphabet::STANDARD, config);\n        let input = "aGVsbG8gd29ybGR+Cg==";\n        let mut output = vec![0u8; 16];\n        \n        let result = decode_engine_slice(input, &mut output, &engine);\n\n        assert!(result.is_ok());\n        let bytes_written = result.unwrap();\n        assert_eq!(bytes_written, 13);\n        assert_eq!(&output[..bytes_written], b"hello world\\n");\n    }\n\n    #[test]\n    fn test_decode_engine_slice_no_padding() {\n        let config = engine::GeneralPurposeConfig::new().with_decode_padding(false);\n        let engine = engine::GeneralPurpose::new(&engine::alphabet::STANDARD, config);\n        let input = "aGVsbG8gd29ybGR";\n        let mut output = vec![0u8; 16];\n        \n        let result = decode_engine_slice(input, &mut output, &engine);\n\n        assert!(result.is_ok());\n        let bytes_written = result.unwrap();\n        assert_eq!(bytes_written, 12);\n        assert_eq!(&output[..bytes_written], b"hello world");\n    }\n\n    #[test]\n    fn test_decode_engine_slice_with_trailing_bits() {\n        let config = engine::GeneralPurposeConfig::new().with_decode_allow_trailing_bits(true);\n        let engine = engine::GeneralPurpose::new(&engine::alphabet::STANDARD, config);\n        let input = "aGVsbG8gd29ybGR+Cg==";\n        let mut output = vec![0u8; 16];\n        \n        let result = decode_engine_slice(input, &mut output, &engine);\n\n        assert!(result.is_ok());\n        let bytes_written = result.unwrap();\n        assert_eq!(bytes_written, 13);\n        assert_eq!(&output[..bytes_written], b"hello world\\n");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596008, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=586, prompt_tokens=7085, total_tokens=7671, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpzfmvwYQhYjGcii2jYRGzSqVlVl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_decode_engine_vec() {\n        let input = "aGVsbG8gd29ybGR+Cg==";\n        let mut buffer = Vec::new();\n        \n        let engine = general_purpose::STANDARD;\n        \n        let result = decode_engine_vec(input, &mut buffer, &engine);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b"hello world\\n");\n    }\n\n    #[test]\n    fn test_decode_engine_vec_invalid() {\n        let input = "Invalid base64";\n        let mut buffer = Vec::new();\n        \n        let engine = general_purpose::STANDARD;\n        \n        let result = decode_engine_vec(input, &mut buffer, &engine);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_decode_engine_vec_with_custom_engine() {\n        let input = "aGVsbG8gaW50ZXJuZXR-Cg";\n        let mut buffer = Vec::new();\n        \n        let engine = general_purpose::GeneralPurpose::new(&base64::alphabet::URL_SAFE, general_purpose::NO_PAD);\n        \n        let result = decode_engine_vec(input, &mut buffer, &engine);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b"hello internet\\n");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596027, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=294, prompt_tokens=7091, total_tokens=7385, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpzorLpQMnztMCK1YoAbMFWI7jb6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::decoded_len_estimate;\n\n    #[test]\n    fn test_decoded_len_estimate() {\n        assert_eq!(3, decoded_len_estimate(1));\n        assert_eq!(3, decoded_len_estimate(2));\n        assert_eq!(3, decoded_len_estimate(3));\n        assert_eq!(3, decoded_len_estimate(4));\n        assert_eq!(6, decoded_len_estimate(5));\n        assert_eq!(6, decoded_len_estimate(6));\n        assert_eq!(9, decoded_len_estimate(9));\n        assert_eq!(12, decoded_len_estimate(12));\n        assert_eq!(15, decoded_len_estimate(15));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596036, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=154, prompt_tokens=331, total_tokens=485, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcpzuiOHyXBZzuQJ0yco4kPNM8PaN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose};\n    \n    #[test]\n    fn test_base64_display_new() {\n        let bytes: &[u8] = b"hello world";\n        let engine = general_purpose::STANDARD;\n        \n        let base64_display = Base64Display::new(bytes, &engine);\n        \n        assert_eq!(base64_display.bytes, bytes);\n        // Additional checks can be added here if necessary\n    }\n    \n    #[test]\n    fn test_base64_display_display() {\n        let bytes: &[u8] = b"hello world";\n        let engine = general_purpose::STANDARD;\n        let base64_display = Base64Display::new(bytes, &engine);\n        \n        let output = format!("{}", base64_display);\n        assert_eq!(output, "aGVsbG8gd29ybGQ="); // Check the expected Base64 output\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596042, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=203, prompt_tokens=7642, total_tokens=7845, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq08CikBVYstYr67V0Qm8XjzxeD6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::encode::add_padding;\n\n    const PAD_BYTE: u8 = b'=';\n\n    #[test]\n    fn test_add_padding_no_padding_needed() {\n        let mut output = [0u8; 2];\n        let padding = add_padding(4, &mut output);\n        assert_eq!(padding, 0);\n        assert_eq!(&output[..padding], &[]);\n    }\n\n    #[test]\n    fn test_add_padding_one_byte_padding() {\n        let mut output = [0u8; 2];\n        let padding = add_padding(3, &mut output);\n        assert_eq!(padding, 1);\n        assert_eq!(output[..padding], [PAD_BYTE]);\n    }\n\n    #[test]\n    fn test_add_padding_two_byte_padding() {\n        let mut output = [0u8; 2];\n        let padding = add_padding(2, &mut output);\n        assert_eq!(padding, 2);\n        assert_eq!(output[..padding], [PAD_BYTE, PAD_BYTE]);\n    }\n\n    #[test]\n    fn test_add_padding_three_byte_padding() {\n        let mut output = [0u8; 2];\n        let padding = add_padding(1, &mut output);\n        assert_eq!(padding, 3);\n        assert_eq!(output[..padding], [PAD_BYTE, PAD_BYTE]);\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596056, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=290, prompt_tokens=292, total_tokens=582, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq0Euz8oCGgTBbLwTLdqlUlY2jPG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::encode;\n\n    #[test]\n    fn test_encode() {\n        assert_eq!(encode("Hello, World!"), "SGVsbG8sIFdvcmxkIQ==");\n        assert_eq!(encode(b"Hello, World!"), "SGVsbG8sIFdvcmxkIQ==");\n        assert_eq!(encode(""), "");\n        assert_eq!(encode(b""), "");\n        assert_eq!(encode("Rust"), "UnVzdA==");\n        assert_eq!(encode("base64"), "YmFzZTY0");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596062, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=137, prompt_tokens=283, total_tokens=420, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq0K9Q21oSB0OjtnHjK2mn9VsE9T', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose};\n\n    #[test]\n    fn test_encode_engine_with_standard_engine() {\n        let engine = general_purpose::STANDARD;\n        let input = b"hello world";\n        let expected_output = "aGVsbG8gd29ybGQ=";\n        let output = encode_engine(input, &engine);\n        assert_eq!(output, expected_output);\n    }\n\n    #[test]\n    fn test_encode_engine_with_custom_engine() {\n        const CUSTOM_ENGINE: engine::GeneralPurpose =\n            engine::GeneralPurpose::new(&base64::alphabet::URL_SAFE, general_purpose::NO_PAD);\n        let input = b"hello world";\n        let expected_output = "aGVsbG8gd29ybGQ";\n        let output = encode_engine(input, &CUSTOM_ENGINE);\n        assert_eq!(output, expected_output);\n    }\n\n    #[test]\n    fn test_encode_engine_empty_string() {\n        let engine = general_purpose::STANDARD;\n        let input: &[u8] = b"";\n        let expected_output = ""; // Empty string should encode to an empty output\n        let output = encode_engine(input, &engine);\n        assert_eq!(output, expected_output);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596068, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=271, prompt_tokens=7157, total_tokens=7428, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq0R3jRm196elVtJO7XU5M9QCoJ5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n\n    #[test]\n    fn test_encode_engine_slice() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b"hello world";\n        let mut output_buf = vec![0; 24]; // Buffer size based on expected encoded length\n\n        let result = encode_engine_slice(input, &mut output_buf, &engine).unwrap();\n        \n        let expected_output = "aGVsbG8gd29ybGQ="; // Base64 encoded result for "hello world"\n        assert_eq!(result, expected_output.len());\n        assert_eq!(String::from_utf8_lossy(&output_buf[..result]), expected_output);\n    }\n\n    #[test]\n    fn test_encode_engine_slice_output_buffer_too_small() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b"hello world";\n        let mut output_buf = vec![0; 10]; // Too small buffer\n\n        let result = encode_engine_slice(input, &mut output_buf, &engine);\n        \n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), EncodeSliceError::OutputSliceTooSmall);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596075, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=289, prompt_tokens=7095, total_tokens=7384, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq0bqHcBMZsaI5uo0gZ4b7LRvAPO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose};\n\n    #[test]\n    fn test_encode_engine_string() {\n        let engine = general_purpose::STANDARD;\n        let input = b"hello world";\n        let mut output = String::new();\n\n        encode_engine_string(input, &mut output, &engine);\n\n        assert_eq!(output, "aGVsbG8gd29ybGQ=");\n    }\n\n    #[test]\n    fn test_encode_engine_string_no_padding() {\n        let engine = general_purpose::GeneralPurpose::new(&base64::alphabet::URL_SAFE, general_purpose::NO_PAD);\n        let input = b"hello";\n        let mut output = String::new();\n\n        encode_engine_string(input, &mut output, &engine);\n\n        assert_eq!(output, "aGVsbG8");\n    }\n\n    #[test]\n    fn test_empty_string() {\n        let engine = general_purpose::STANDARD;\n        let input = b"";\n        let mut output = String::new();\n\n        encode_engine_string(input, &mut output, &engine);\n\n        assert_eq!(output, "");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596085, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=248, prompt_tokens=7169, total_tokens=7417, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq0ixcY3gAzjqAtcRaWFjfYq5tzl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    \n    #[test]\n    fn test_encode_with_padding() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b"hello";\n        let expected_encoded_size = 8; // Base64 encoding for "hello" is "aGVsbG8="\n\n        let mut output = vec![0; expected_encoded_size];\n        \n        encode_with_padding(input, &mut output, &engine, expected_encoded_size);\n\n        // Assert output is correct\n        assert_eq!(output, b"aGVsbG8=");\n    }\n\n    #[test]\n    fn test_encode_with_no_padding() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::new().with_encode_padding(false));\n        let input = b"hello";\n        let expected_encoded_size = 8; // Base64 encoding for "hello" is "aGVsbG8=" but without padding "aGVsbG8"\n\n        let mut output = vec![0; expected_encoded_size];\n        \n        encode_with_padding(input, &mut output, &engine, expected_encoded_size);\n\n        // Assert output is correct without padding\n        assert_eq!(output, b"aGVsbG8");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_encoded_size_mismatch() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b"hello";\n        let expected_encoded_size = 10; // Mismatch expected size\n\n        let mut output = vec![0; 8]; // Correct size is 8\n        \n        encode_with_padding(input, &mut output, &engine, expected_encoded_size);\n    }\n\n    #[test]\n    fn test_empty_input() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b"";\n        let expected_encoded_size = 0; // No output for empty input\n\n        let mut output = vec![0; expected_encoded_size];\n        \n        encode_with_padding(input, &mut output, &engine, expected_encoded_size);\n\n        // Assert output is empty\n        assert_eq!(output, &[]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596092, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=500, prompt_tokens=7221, total_tokens=7721, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq0rWbYVBoxCuQVa8b8rdWWN9nc8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::encode::encoded_len;\n\n    #[test]\n    fn test_encoded_len_no_padding() {\n        assert_eq!(encoded_len(0, false), Some(0));\n        assert_eq!(encoded_len(1, false), Some(2));\n        assert_eq!(encoded_len(2, false), Some(3));\n        assert_eq!(encoded_len(3, false), Some(4));\n        assert_eq!(encoded_len(4, false), Some(6));\n        assert_eq!(encoded_len(6, false), Some(8));\n    }\n\n    #[test]\n    fn test_encoded_len_with_padding() {\n        assert_eq!(encoded_len(0, true), Some(0));\n        assert_eq!(encoded_len(1, true), Some(4));\n        assert_eq!(encoded_len(2, true), Some(4));\n        assert_eq!(encoded_len(3, true), Some(4));\n        assert_eq!(encoded_len(4, true), Some(8));\n        assert_eq!(encoded_len(6, true), Some(8));\n    }\n\n    #[test]\n    fn test_encoded_len_large_input() {\n        assert_eq!(encoded_len(usize::MAX - 1, false), None);\n        assert_eq!(encoded_len(usize::MAX - 2, true), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596101, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=282, prompt_tokens=414, total_tokens=696, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq0wVtzadWcPo20CFcRPG2hv7Kc1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_decode_metadata_new() {\n        // Test case 1: No padding\n        let metadata = DecodeMetadata::new(10, None);\n        assert_eq!(metadata.decoded_len, 10);\n        assert_eq!(metadata.padding_offset, None);\n\n        // Test case 2: With padding\n        let metadata = DecodeMetadata::new(10, Some(2));\n        assert_eq!(metadata.decoded_len, 10);\n        assert_eq!(metadata.padding_offset, Some(2));\n\n        // Test case 3: Zero decoded bytes\n        let metadata = DecodeMetadata::new(0, Some(0));\n        assert_eq!(metadata.decoded_len, 0);\n        assert_eq!(metadata.padding_offset, Some(0));\n\n        // Test case 4: Large decoded bytes\n        let metadata = DecodeMetadata::new(usize::MAX, None);\n        assert_eq!(metadata.decoded_len, usize::MAX);\n        assert_eq!(metadata.padding_offset, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596106, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=223, prompt_tokens=339, total_tokens=562, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq13UMoBVh6MQqdbO8ZWgUeSFfcD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{engine::{self, general_purpose}, alphabet};\n\n    #[test]\n    fn test_standard_decode() {\n        let input = "aGVsbG8gd29ybGR+Cg==";\n        let expected = b"hello world\\n".to_vec();\n        let result = general_purpose::STANDARD.decode(input).unwrap();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_url_safe_decode() {\n        let input = "aGVsbG8gaW50ZXJuZXR-Cg";\n        let expected = b"hello interner\\n".to_vec();\n        let engine = engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);\n        let result = engine.decode(input).unwrap();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_decode_invalid_input() {\n        let input = "!!!invalid base64!!!";\n        let result = general_purpose::STANDARD.decode(input);\n        assert!(result.is_err()); // Expecting an error due to invalid input\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596113, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=240, prompt_tokens=474, total_tokens=714, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq1ALmzSOk847ojGGAY0kcPgReN9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose, DecodePaddingMode};\n\n    #[test]\n    fn test_general_purpose_decode() {\n        let engine = general_purpose::STANDARD;\n        let input = b"aGVsbG8gd29ybGR+Cg=="; // "hello world\\n"\n        let expected_output = b"hello world\\n";\n        \n        let result = engine.decode(input).expect("Decoding failed");\n        assert_eq!(result.as_slice(), expected_output);\n    }\n\n    #[test]\n    fn test_decode_with_no_padding() {\n        let config = engine::GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::RequireNone);\n        let engine = engine::GeneralPurpose::new(&base64::alphabet::STANDARD, config);\n        \n        let input = b"aGVsbG8gaW50ZXJuZXR-Cg"; // "hello internet\\n"\n        let expected_output = b"hello internet\\n";\n        \n        let result = engine.decode(input).expect("Decoding failed");\n        assert_eq!(result.as_slice(), expected_output);\n    }\n\n    #[test]\n    fn test_decode_with_indifferent_padding() {\n        let config = engine::GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::Indifferent);\n        let engine = engine::GeneralPurpose::new(&base64::alphabet::STANDARD, config);\n        \n        let input = b"aGVsbG8gd29ybGR+Cg"; // "hello world\\n"\n        let expected_output = b"hello world\\n";\n        \n        let result = engine.decode(input).expect("Decoding failed");\n        assert_eq!(result.as_slice(), expected_output);\n    }\n\n    #[test]\n    fn test_decode_error_with_invalid_input() {\n        let engine = general_purpose::STANDARD;\n        let input = b"invalid-base64"; // Invalid base64 input\n        \n        let result = engine.decode(input);\n        assert!(result.is_err(), "Decoding should have failed");\n    }\n\n    #[test]\n    fn test_decode_empty_input() {\n        let engine = general_purpose::STANDARD;\n        let input: &[u8] = b""; // Empty input\n        \n        let result = engine.decode(input).expect("Decoding failed");\n        assert!(result.is_empty(), "Decoding empty input should yield empty Vec");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596120, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=502, prompt_tokens=7142, total_tokens=7644, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq1Mo5t9Kq7zdju99n62OCK7D7on', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::Engine;\n    use base64::engine::DecodeSliceError;\n\n    #[test]\n    fn test_decode_slice_success() {\n        let engine = Engine::new(); // Assuming a way to create an Engine, replace with actual constructor\n        let input = b"SGVsbG8sIFdvcmxkIQ=="; // Base64 for "Hello, World!"\n        let mut output = vec![0u8; 13]; // Length of "Hello, World!"\n        \n        let result = engine.decode_slice(input, &mut output);\n        \n        assert_eq!(result, Ok(13));\n        assert_eq!(output, b"Hello, World!");\n    }\n\n    #[test]\n    fn test_decode_slice_error_small_output() {\n        let engine = Engine::new(); // Assuming a way to create an Engine, replace with actual constructor\n        let input = b"SGVsbG8sIFdvcmxkIQ=="; // Base64 for "Hello, World!"\n        let mut output = vec![0u8; 5]; // Insufficient length\n        \n        let result = engine.decode_slice(input, &mut output);\n        \n        assert!(result.is_err());\n        match result {\n            Err(DecodeSliceError::OutputTooSmall) => {},\n            _ => panic!("Expected DecodeSliceError::OutputTooSmall"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596132, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=300, prompt_tokens=383, total_tokens=683, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq1U7rPzTQkH8L1XIHR95Z3GKm6V', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose};\n    use base64::DecodeSliceError;\n\n    #[test]\n    fn test_inner_decode_success() {\n        let engine = general_purpose::STANDARD;\n        let input = b"SGVsbG8gd29ybGQ="; // "Hello world"\n        let mut output = vec![0; 11]; // Sized according to expected output length\n\n        let result = inner(&engine, input, &mut output);\n        assert!(result.is_ok());\n        assert_eq!(&output, b"Hello world");\n    }\n\n    #[test]\n    fn test_inner_decode_invalid_padding() {\n        let engine = general_purpose::STANDARD;\n        let input = b"SGVsbG8gd29ybGQ=="; // Invalid padding\n\n        let mut output = vec![0; 11]; // Sized according to expected output length\n\n        let result = inner(&engine, input, &mut output);\n        assert!(result.is_err());\n        assert_eq!(result.err(), Some(DecodeSliceError::DecodeError(_)));\n    }\n\n    #[test]\n    fn test_inner_decode_output_size_too_small() {\n        let engine = general_purpose::STANDARD;\n        let input = b"SGVsbG8gd29ybGQ="; // "Hello world"\n        let mut output = vec![0; 5]; // Sized too small\n\n        let result = inner(&engine, input, &mut output);\n        assert!(result.is_err());\n        assert_eq!(result.err(), Some(DecodeSliceError::OutputSliceTooSmall));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596140, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=350, prompt_tokens=7081, total_tokens=7431, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq1dyKavWq4ulSXMNQmfhK9vW54R', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{Engine, DecodeError};\n\n    struct MockEngine;\n\n    impl Engine for MockEngine {\n        // Implement necessary methods for the Engine trait\n    }\n\n    #[test]\n    fn test_decode_slice_unchecked_valid() {\n        let engine = MockEngine;\n        let input = b"SGVsbG8sIHdvcmxkIQ=="; // Base64 for "Hello, world!"\n        let mut output = [0u8; 13]; // Expected output size\n        let result = engine.decode_slice_unchecked(input, &mut output);\n        \n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), 13);\n        assert_eq!(&output[..], b"Hello, world!");\n    }\n\n    #[test]\n    #[should_panic(expected = "Output slice is too small")]\n    fn test_decode_slice_unchecked_too_small_output() {\n        let engine = MockEngine;\n        let input = b"SGVsbG8sIHdvcmxkIQ=="; // Base64 for "Hello, world!"\n        let mut output = [0u8; 5]; // Expected output size too small\n        engine.decode_slice_unchecked(input, &mut output).unwrap();\n    }\n\n    #[test]\n    fn test_decode_slice_unchecked_empty_input() {\n        let engine = MockEngine;\n        let input = b""; // Empty input\n        let mut output = [0u8; 0]; // Empty output\n        let result = engine.decode_slice_unchecked(input, &mut output);\n        \n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596149, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=357, prompt_tokens=429, total_tokens=786, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq1nu5bsL3x0yxE5jliwYAxUcoqy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    use base64::engine::DecodePaddingMode;\n\n    #[test]\n    fn test_inner_valid_decoding() {\n        let engine = GeneralPurpose::new(base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b"aGVsbG8gd29ybGQ="; // "hello world" in base64\n        let mut output = vec![0; 11]; // allocate sufficient space for "hello world" (11 bytes)\n\n        let result = inner(&engine, input, &mut output);\n        assert_eq!(result, Ok(11));\n        assert_eq!(output, b"hello world");\n    }\n\n    #[test]\n    fn test_inner_too_small_output() {\n        let engine = GeneralPurpose::new(base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b"aGVsbG8gd29ybGQ="; // "hello world" in base64\n        let mut output = vec![0; 5]; // insufficient space for "hello world"\n\n        let result = inner(&engine, input, &mut output);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_inner_invalid_input() {\n        let engine = GeneralPurpose::new(base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b"invalid_base64"; // Invalid base64\n        let mut output = vec![0; 11]; // allocate sufficient space for decoding\n\n        let result = inner(&engine, input, &mut output);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596159, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=361, prompt_tokens=7123, total_tokens=7484, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq1wmGEbvOoq96vVTdacytMvagzv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{Engine as _, alphabet, engine::{self, general_purpose}};\n\n    #[test]\n    fn test_decode_vec_standard_engine() {\n        let mut buffer = Vec::new();\n        let result = general_purpose::STANDARD.decode_vec("aGVsbG8gd29ybGR+Cg==", &mut buffer);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b"hello world\\n");\n    }\n\n    #[test]\n    fn test_decode_vec_custom_engine() {\n        const CUSTOM_ENGINE: engine::GeneralPurpose =\n            engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::PAD);\n        let mut buffer = Vec::new();\n        let result = CUSTOM_ENGINE.decode_vec("aGVsbG8gaW50ZXJuZXR-Cg==", &mut buffer);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b"hello internet\\n");\n    }\n\n    #[test]\n    fn test_decode_vec_empty_input() {\n        let mut buffer = Vec::new();\n        let result = general_purpose::STANDARD.decode_vec("", &mut buffer);\n        assert!(result.is_ok());\n        assert!(buffer.is_empty());\n    }\n\n    #[test]\n    fn test_decode_vec_invalid_input() {\n        let mut buffer = Vec::new();\n        let result = general_purpose::STANDARD.decode_vec("%%%invalid%%%", &mut buffer);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596168, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=313, prompt_tokens=653, total_tokens=966, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq254J8i17sruWYtzVxq2GlqPsXJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::{self, general_purpose};\n    use crate::engine::DecodePaddingMode;\n\n    #[test]\n    fn test_inner_decoding_success() {\n        let engine = general_purpose::STANDARD;\n        let input = b"aGVsbG8gd29ybGR+Cg==";\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b"hello world\\n");\n    }\n\n    #[test]\n    fn test_inner_decoding_with_padding() {\n        let engine = general_purpose::STANDARD;\n        let input = b"aGVsbG8gd29ybGR+Cg=="; // Base64 for "hello world\\n"\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b"hello world\\n");\n    }\n\n    #[test]\n    fn test_inner_decoding_no_padding() {\n        let config = general_purpose::GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::RequireNone);\n        let engine = general_purpose::GeneralPurpose::new(&general_purpose::STANDARD.decode_table, config);\n        let input = b"aGVsbG8gd29ybGR+Cg=="; // Base64 for "hello world\\n"\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b"hello world\\n");\n    }\n\n    #[test]\n    fn test_inner_decoding_invalid_padding() {\n        let config = general_purpose::GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::RequireCanonical);\n        let engine = general_purpose::GeneralPurpose::new(&general_purpose::STANDARD.decode_table, config);\n        let input = b"aGVsbG8gd29ybGR+Cg"; // Invalid Base64 without proper padding\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_inner_decoding_empty_input() {\n        let engine = general_purpose::STANDARD;\n        let input: &[u8] = b""; // Empty input\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_ok());\n        assert!(buffer.is_empty());\n    }\n\n    #[test]\n    fn test_inner_decoding_invalid_input() {\n        let engine = general_purpose::STANDARD;\n        let input = b"!!invalid$$"; // Invalid Base64\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596177, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=620, prompt_tokens=7207, total_tokens=7827, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq2HDZWKLqAUWM6dcWBpQJzXqMh0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{engine::{self, general_purpose}, alphabet};\n\n    #[test]\n    fn test_encode_standard() {\n        let input = b"hello world~";\n        let expected = "aGVsbG8gd29ybGQ~";\n        let result = general_purpose::STANDARD.encode(input);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_encode_custom_engine() {\n        const CUSTOM_ENGINE: engine::GeneralPurpose =\n            engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);\n        let input = b"hello internet~";\n        let expected = "aGVsbG8gaW50ZXJuZXQ~";\n        let result = CUSTOM_ENGINE.encode(input);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_encode_empty_input() {\n        let input = b"";\n        let expected = "";\n        let result = general_purpose::STANDARD.encode(input);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_encode_special_characters() {\n        let input = b"hello & welcome @ 2023!";\n        let expected = "aGVsbG8gJiB3ZWxjb21lICMgMjAyMw~";\n        let result = general_purpose::STANDARD.encode(input);\n        assert_eq!(result, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596189, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=302, prompt_tokens=468, total_tokens=770, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq2PbZcBLGYgsHhpc97n8EholQWR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_inner_encode() {\n        let engine = general_purpose::STANDARD;\n        let input = b"hello world";\n        let expected_output = "aGVsbG8gd29ybGQ="; // Expected base64 output with padding\n        let encoded = engine.encode(input);\n        assert_eq!(encoded, expected_output);\n    }\n\n    #[test]\n    fn test_inner_encode_empty() {\n        let engine = general_purpose::STANDARD;\n        let input: &[u8] = &[];\n        let expected_output = ""; // Expected output for an empty input\n        let encoded = engine.encode(input);\n        assert_eq!(encoded, expected_output);\n    }\n\n    #[test]\n    fn test_inner_encode_no_padding() {\n        let config = general_purpose::GeneralPurposeConfig::new().with_encode_padding(false);\n        let engine = general_purpose::GeneralPurpose::new(&general_purpose::STANDARD.encode_table, config);\n        let input = b"hello world";\n        let expected_output = "aGVsbG8gd29ybGQ"; // Expected base64 output without padding\n        let encoded = engine.encode(input);\n        assert_eq!(encoded, expected_output);\n    }\n\n    #[test]\n    fn test_inner_encode_invalid_utf8() {\n        let engine = general_purpose::STANDARD;\n        let input = [0xFF, 0xFF, 0xFF]; // Invalid UTF-8 sequence\n        let result = std::panic::catch_unwind(|| {\n            engine.encode(&input)\n        });\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596197, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=356, prompt_tokens=7165, total_tokens=7521, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq2ZUl4wau1CRlMaXt6VsIsyHLVr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{engine::general_purpose, Engine};\n\n    #[test]\n    fn test_encode_slice_success() {\n        let s = b"hello internet!";\n        let mut buf = vec![0u8; s.len() * 4 / 3 + 4]; // Ensure buffer is large enough\n        let bytes_written = general_purpose::STANDARD.encode_slice(s, &mut buf).unwrap();\n        buf.truncate(bytes_written);\n        assert_eq!(s, general_purpose::STANDARD.decode(&buf).unwrap().as_slice());\n    }\n\n    #[test]\n    fn test_encode_slice_too_small_buffer() {\n        let s = b"hello";\n        let mut buf = vec![0u8; 5]; // Insufficient buffer size\n        let result = general_purpose::STANDARD.encode_slice(s, &mut buf);\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap(), EncodeSliceError::OutputSliceTooSmall);\n    }\n\n    #[test]\n    fn test_encode_slice_empty_input() {\n        let s: &[u8] = &[];\n        let mut buf = vec![0u8; 4]; // Minimum buffer size for base64\n        let bytes_written = general_purpose::STANDARD.encode_slice(s, &mut buf).unwrap();\n        buf.truncate(bytes_written);\n        assert_eq!(buf, b"");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596207, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=301, prompt_tokens=521, total_tokens=822, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq2hriISTo0FPzRNQ78OwR3chkG6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose::GeneralPurpose};\n\n    #[test]\n    fn test_inner_encode_success() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = b"hello";\n        let mut output_buf = vec![0; 8]; // Expected output size for base64\n        let result = inner(&engine, input, &mut output_buf);\n        assert!(result.is_ok());\n        let encoded_size = result.unwrap();\n        let expected_output = "aGVsbG8=".as_bytes();\n        assert_eq!(&output_buf[..encoded_size], expected_output);\n    }\n\n    #[test]\n    fn test_inner_encode_output_buffer_too_small() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = b"hello";\n        let mut output_buf = vec![0; 5]; // Too small for base64 encoding of "hello"\n        let result = inner(&engine, input, &mut output_buf);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), EncodeSliceError::OutputSliceTooSmall);\n    }\n\n    #[test]\n    fn test_inner_encode_empty_input() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input: &[u8] = &[];\n        let mut output_buf = vec![0; 4]; // Expected output size for empty input is 0\n        let result = inner(&engine, input, &mut output_buf);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596215, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=374, prompt_tokens=7132, total_tokens=7506, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq2oiKJ2B06rArasWeTVGoopvHnX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{engine::{self, general_purpose}, alphabet};\n\n    #[test]\n    fn test_encode_string_standard() {\n        let mut output_buf = String::new();\n        general_purpose::STANDARD.encode_string(b"hello world~", &mut output_buf);\n        assert_eq!(output_buf, "aGVsbG8gd29ybGQ~"); // Example base64 encoded output\n    }\n\n    #[test]\n    fn test_encode_string_custom() {\n        const CUSTOM_ENGINE: engine::GeneralPurpose =\n            engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);\n        let mut output_buf = String::new();\n        CUSTOM_ENGINE.encode_string(b"hello internet~", &mut output_buf);\n        assert_eq!(output_buf, "aGVsbG8gaW50ZXJuZXQ~"); // Example base64 encoded output\n    }\n\n    #[test]\n    fn test_encode_string_empty() {\n        let mut output_buf = String::new();\n        general_purpose::STANDARD.encode_string(b"", &mut output_buf);\n        assert_eq!(output_buf, ""); // Empty input should produce empty output\n    }\n\n    #[test]\n    fn test_encode_string_non_ascii() {\n        let mut output_buf = String::new();\n        general_purpose::STANDARD.encode_string(b"hello ", &mut output_buf);\n        assert_eq!(output_buf, "aGVsbG8g8J+YgPCf"); // Example base64 encoded output\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596222, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=329, prompt_tokens=503, total_tokens=832, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq2zMCH3ntdTudTaz7PWSq3PEz6i', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose::GeneralPurpose, DecodePaddingMode};\n\n    #[test]\n    fn test_encode_string() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = b"hello, world!";\n        let mut output = String::new();\n        \n        engine.encode_string(input, &mut output);\n        \n        assert_eq!(output, "aGVsbG8sIHdvcmxkIQ==");\n    }\n\n    #[test]\n    fn test_encode_string_with_no_padding() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::new().with_encode_padding(false));\n        let input = b"hello, world!";\n        let mut output = String::new();\n        \n        engine.encode_string(input, &mut output);\n        \n        assert_eq!(output, "aGVsbG8sIHdvcmxkIQ");\n    }\n\n    #[test]\n    fn test_empty_string() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = b"";\n        let mut output = String::new();\n        \n        engine.encode_string(input, &mut output);\n        \n        assert_eq!(output, "");\n    }\n\n    #[test]\n    fn test_unicode_string() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = "".as_bytes();\n        let mut output = String::new();\n        \n        engine.encode_string(input, &mut output);\n        \n        assert_eq!(output, "44GT44KT44Go44K44K544Oz");\n    }\n\n    #[test]\n    fn test_large_input() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = vec![b\'a\'; 1000];\n        let mut output = String::new();\n        \n        engine.encode_string(&input, &mut output);\n        \n        assert_eq!(output.len(), 1334); // 1000 bytes of \'a\'s produce 1334 base64 characters\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596233, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=476, prompt_tokens=7148, total_tokens=7624, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq39DCFaOBx30WtN48hcwcfkjtQT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::alphabet::Alphabet;\n    use base64::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    use base64::engine::DecodePaddingMode;\n\n    #[test]\n    fn test_general_purpose_new() {\n        let alphabet = Alphabet::new("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").unwrap();\n        let config = GeneralPurposeConfig::new()\n            .with_encode_padding(true)\n            .with_decode_padding_mode(DecodePaddingMode::RequireCanonical);\n        \n        let engine = GeneralPurpose::new(&alphabet, config);\n        \n        assert_eq!(engine.config().encode_padding(), true);\n        assert_eq!(engine.config().decode_padding_mode, DecodePaddingMode::RequireCanonical);\n    }\n\n    #[test]\n    fn test_general_purpose_new_invalid_alphabet() {\n        assert!(Alphabet::new("Not a valid alphabet!").is_err());\n    }\n\n    #[test]\n    fn test_general_purpose_new_empty_alphabet() {\n        assert!(Alphabet::new("").is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596243, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=225, prompt_tokens=4581, total_tokens=4806, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq3GRgidqtn1fD41kkwAyOA91Mw7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::{DecodePaddingMode, GeneralPurposeConfig};\n\n    #[test]\n    fn test_general_purpose_config_new() {\n        let config = GeneralPurposeConfig::new();\n        \n        assert_eq!(config.encode_padding(), true);\n        assert_eq!(config.decode_allow_trailing_bits, false);\n        assert_eq!(config.decode_padding_mode, DecodePaddingMode::RequireCanonical);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596250, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=96, prompt_tokens=1441, total_tokens=1537, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq3KLuIPh90VJpWucM9q1iNKoepF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use engine::general_purpose::GeneralPurposeConfig;\n\n    #[test]\n    fn test_with_decode_allow_trailing_bits() {\n        let config = GeneralPurposeConfig::new();\n        \n        // Test allowing trailing bits\n        let updated_config = config.with_decode_allow_trailing_bits(true);\n        assert_eq!(updated_config.decode_allow_trailing_bits, true);\n        \n        // Test not allowing trailing bits\n        let updated_config = config.with_decode_allow_trailing_bits(false);\n        assert_eq!(updated_config.decode_allow_trailing_bits, false);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596254, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=128, prompt_tokens=1486, total_tokens=1614, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq3QuleipJuoz8u8YosJxthctHv8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use engine::general_purpose::GeneralPurposeConfig;\n    use engine::DecodePaddingMode;\n\n    #[test]\n    fn test_with_decode_padding_mode_indifferent() {\n        let config = GeneralPurposeConfig::new();\n        let updated_config = config.with_decode_padding_mode(DecodePaddingMode::Indifferent);\n        assert_eq!(updated_config.decode_padding_mode, DecodePaddingMode::Indifferent);\n    }\n\n    #[test]\n    fn test_with_decode_padding_mode_require_canonical() {\n        let config = GeneralPurposeConfig::new();\n        let updated_config = config.with_decode_padding_mode(DecodePaddingMode::RequireCanonical);\n        assert_eq!(updated_config.decode_padding_mode, DecodePaddingMode::RequireCanonical);\n    }\n\n    #[test]\n    fn test_with_decode_padding_mode_require_none() {\n        let config = GeneralPurposeConfig::new();\n        let updated_config = config.with_decode_padding_mode(DecodePaddingMode::RequireNone);\n        assert_eq!(updated_config.decode_padding_mode, DecodePaddingMode::RequireNone);\n    }\n\n    #[test]\n    fn test_with_decode_padding_mode_chain() {\n        let config = GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::Indifferent)\n            .with_decode_padding_mode(DecodePaddingMode::RequireNone);\n        assert_eq!(config.decode_padding_mode, DecodePaddingMode::RequireNone);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596260, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=293, prompt_tokens=1536, total_tokens=1829, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq3Xp6pUMXdnoliWq7xZbLIdt7k6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::GeneralPurposeConfig;\n\n    #[test]\n    fn test_with_encode_padding() {\n        let config = GeneralPurposeConfig::new();\n\n        // Test with padding enabled\n        let config_with_padding = config.with_encode_padding(true);\n        assert_eq!(config_with_padding.encode_padding, true);\n\n        // Test with padding disabled\n        let config_without_padding = config.with_encode_padding(false);\n        assert_eq!(config_without_padding.encode_padding, false);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596267, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=116, prompt_tokens=1476, total_tokens=1592, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq3fzSCtujYcaHBTeP94fWLfsnem', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::engine::general_purpose::decode::GeneralPurposeEstimate;\n\n    #[test]\n    fn test_new() {\n        let encoded_len = 4;\n        let estimate = GeneralPurposeEstimate::new(encoded_len);\n        assert_eq!(estimate.rem, 0);\n        assert_eq!(estimate.conservative_decoded_len, 3);\n        \n        let encoded_len = 5;\n        let estimate = GeneralPurposeEstimate::new(encoded_len);\n        assert_eq!(estimate.rem, 1);\n        assert_eq!(estimate.conservative_decoded_len, 6);\n        \n        let encoded_len = 6;\n        let estimate = GeneralPurposeEstimate::new(encoded_len);\n        assert_eq!(estimate.rem, 2);\n        assert_eq!(estimate.conservative_decoded_len, 6);\n        \n        let encoded_len = 7;\n        let estimate = GeneralPurposeEstimate::new(encoded_len);\n        assert_eq!(estimate.rem, 3);\n        assert_eq!(estimate.conservative_decoded_len, 9);\n        \n        let encoded_len = 8;\n        let estimate = GeneralPurposeEstimate::new(encoded_len);\n        assert_eq!(estimate.rem, 0);\n        assert_eq!(estimate.conservative_decoded_len, 6);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596275, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=264, prompt_tokens=379, total_tokens=643, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq3tPvHxpUomoJiEIp5J3epoAvFL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::decode::complete_quads_len;\n    use crate::engine::general_purpose::decode::{DecodeSliceError, DecodeError, PAD_BYTE, INVALID_VALUE};\n\n    #[test]\n    fn test_complete_quads_len() {\n        let decode_table: [u8; 256] = [\n            INVALID_VALUE; 256\n        ];\n\n        // Valid case with complete quads\n        let input = b"QUJDRA=="; // Length 8, 6 complete bytes\n        let input_len_rem = 2;\n        let output_len = 5; // 6 bytes input should decode to 5 bytes output\n        assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Ok(6));\n\n        // Valid case with incomplete quads, one valid byte\n        let input = b"QUJDRA="; // Length 7\n        let input_len_rem = 1;\n        let output_len = 5;\n        assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Ok(6));\n\n        // Invalid case: output length too small\n        let input = b"QUJDRA=";\n        let input_len_rem = 1;\n        let output_len = 4; // Not enough space\n        assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Err(DecodeSliceError::OutputSliceTooSmall));\n\n        // Invalid case: trailing invalid byte\n        let decode_table: [u8; 256] = {\n            let mut table = [INVALID_VALUE; 256];\n            table[b\'Q\' as usize] = 16; // Set valid decode values for testing\n            table[b\'U\' as usize] = 20;\n            table[b\'J\' as usize] = 9;\n            table[b\'D\' as usize] = 3;\n            table\n        };\n\n        let input = b"QUJDRA\\xFF"; // Invalid trailing byte\n        let input_len_rem = 1;\n        let output_len = 5;\n        assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Err(DecodeError::InvalidByte(6, 0xFF).into()));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596289, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=497, prompt_tokens=587, total_tokens=1084, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq431INmznDdzehydiUQi9REf3M0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::decode::{decode_chunk_4, DecodeError};\n\n    const DECODE_TABLE: [u8; 256] = [ /* your decode table values here */ ];\n    const INVALID_VALUE: u8 = 255; // Assuming 255 represents an invalid value\n\n    #[test]\n    fn test_decode_chunk_4_valid_input() {\n        let input = b"QUJD"; // Base64 encoding of "ABC"\n        let mut output = [0u8; 3];\n\n        let result = decode_chunk_4(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_ok());\n        assert_eq!(&output, b"ABC");\n    }\n\n    #[test]\n    fn test_decode_chunk_4_invalid_input() {\n        let input = b"QUJ*"; // Invalid Base64 input\n        let mut output = [0u8; 3];\n\n        let result = decode_chunk_4(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_err());\n        if let Err(DecodeError::InvalidByte(index, byte)) = result {\n            assert_eq!(index, 3);\n            assert_eq!(byte, b\'*\');\n        } else {\n            panic!("Expected an InvalidByte error");\n        }\n    }\n\n    #[test]\n    fn test_decode_chunk_4_partial_input() {\n        let input = b"QU"; // Incomplete Base64 input\n        let mut output = [0u8; 3];\n\n        let result = decode_chunk_4(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_err());\n        // Check that the error is due to the input length.\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596299, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=378, prompt_tokens=505, total_tokens=883, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq4C2FgABOvPkRCVDGCe7uhWUNKy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::decode::decode_chunk_8;\n\n    const DECODE_TABLE: [u8; 256] = [\n        // Initialize with example values; actual values should correspond to your base64 alphabet\n        // for example, base64 standard values\n        // 0-25: \'A\'-\'Z\' -> 0-25\n        // 26-51: \'a\'-\'z\' -> 26-51\n        // 52-61: \'0\'-\'9\' -> 52-61\n        // 62: \'+\' -> 62\n        // 63: \'/\' -> 63\n        // Any other byte should be INVALID_VALUE\n        // Add values accordingly...\n    ];\n    \n    const INVALID_VALUE: u8 = 255; // or whatever your INVALID_VALUE is\n\n    #[test]\n    fn test_decode_chunk_8_valid() {\n        let input = b"QmFzZTY0"; // Base64 for "Base64"\n        let mut output = [0u8; 6];\n        let result = decode_chunk_8(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_ok());\n        assert_eq!(&output[..], b"Base64"); // Example output; adjust according to actual expected\n    }\n\n    #[test]\n    fn test_decode_chunk_8_invalid_byte() {\n        let input = b"QmFzZ"&[0u8]; // Invalid character\n        let mut output = [0u8; 6];\n        let result = decode_chunk_8(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_decode_chunk_8_invalid_length() {\n        let input = b"QmFz"; // Insufficient length\n        let mut output = [0u8; 6];\n        let result = decode_chunk_8(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596308, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=448, prompt_tokens=831, total_tokens=1279, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq4KkxNxmmCYc4pbiYlud06e2Zu8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::{decode::decode_helper, DecodePaddingMode, general_purpose::GeneralPurposeEstimate};\n\n    #[test]\n    fn test_decode_helper() {\n        let input: &[u8] = b"SGVsbG8gV29ybGQ="; // "Hello World" in base64\n        let estimate = GeneralPurposeEstimate::new(input.len());\n        let mut output = vec![0u8; estimate.decoded_len_estimate()];\n        let decode_table = base64::engine::general_purpose::TABLE; // Assuming the decode table is accessible in this context\n        let decode_allow_trailing_bits = true; // Assuming this edge case\n        let padding_mode = DecodePaddingMode::RequireCanonical;\n\n        let result = decode_helper(input, &estimate, &mut output, decode_table, decode_allow_trailing_bits, padding_mode);\n\n        assert!(result.is_ok());\n        let metadata = result.unwrap();\n        assert_eq!(metadata.len, 11); // Length of "Hello World"\n        assert_eq!(&output[..11], b"Hello World"); // Check the output\n    }\n    \n    #[test]\n    fn test_decode_helper_with_invalid_input() {\n        let input: &[u8] = b"SGVsbG8gV29ybGQ"; // Invalid base64 input (missing padding)\n        let estimate = GeneralPurposeEstimate::new(input.len());\n        let mut output = vec![0u8; estimate.decoded_len_estimate()];\n        let decode_table = base64::engine::general_purpose::TABLE;\n        let decode_allow_trailing_bits = false;\n        let padding_mode = DecodePaddingMode::RequireCanonical;\n\n        let result = decode_helper(input, &estimate, &mut output, decode_table, decode_allow_trailing_bits, padding_mode);\n\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596316, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=398, prompt_tokens=1229, total_tokens=1627, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq4TCACZi6Wb02U0CTbDfcLNCfBG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::DecodePaddingMode;\n\n    #[test]\n    fn test_decode_suffix_valid() {\n        let input = b"QUJDRA=="; // Base64 for "ABCD"\n        let input_index = 0;\n        let mut output = [0u8; 4];\n        let output_index = 0;\n        let decode_table = [0; 256]; // Populate with actual decode values\n        let decode_allow_trailing_bits = false;\n        let padding_mode = DecodePaddingMode::RequireCanonical;\n\n        let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);\n        assert!(result.is_ok());\n        let metadata = result.unwrap();\n        assert_eq!(metadata.total_bytes, 4);\n        assert_eq!(output, b"ABCD");\n    }\n\n    #[test]\n    fn test_decode_suffix_invalid_padding() {\n        let input = b"QUJDRA==A"; // Invalid padding\n        let input_index = 0;\n        let mut output = [0u8; 4];\n        let output_index = 0;\n        let decode_table = [0; 256]; // Populate with actual decode values\n        let decode_allow_trailing_bits = false;\n        let padding_mode = DecodePaddingMode::RequireCanonical;\n\n        let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_decode_suffix_with_trailing_bits() {\n        let input = b"QUJDRA"; // Valid input, but with trailing bits\n        let input_index = 0;\n        let mut output = [0u8; 4];\n        let output_index = 0;\n        let decode_table = [0; 256]; // Populate with actual decode values\n        let decode_allow_trailing_bits = false;\n        let padding_mode = DecodePaddingMode::RequireNone;\n\n        let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_decode_suffix_indifferent_padding() {\n        let input = b"QUJDRA=="; // Base64 for "ABCD"\n        let input_index = 0;\n        let mut output = [0u8; 4];\n        let output_index = 0;\n        let decode_table = [0; 256]; // Populate with actual decode values\n        let decode_allow_trailing_bits = false;\n        let padding_mode = DecodePaddingMode::Indifferent;\n\n        let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);\n        assert!(result.is_ok());\n        let metadata = result.unwrap();\n        assert_eq!(metadata.total_bytes, 4);\n        assert_eq!(output, b"ABCD");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596325, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=647, prompt_tokens=1964, total_tokens=2611, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq4fGHNeIA5wpnAwfO7ndvmAdkh8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::alphabet::Alphabet;\n\n    #[test]\n    fn test_decode_table_valid_alphabet() {\n        let alphabet = Alphabet::new("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").unwrap();\n        let table = decode_table(&alphabet);\n        \n        // Check if the table has the correct mappings for the alphabet\n        for (index, &symbol) in alphabet.symbols.iter().enumerate() {\n            assert_eq!(table[symbol as usize], index as u8);\n        }\n\n        // Check if invalid symbols return INVALID_VALUE\n        for byte in 0..256 {\n            if byte < 65 || (byte > 90 && byte < 97) || (byte > 122 && byte < 48) || byte > 57 {\n                assert_eq!(table[byte], INVALID_VALUE);\n            }\n        }\n    }\n\n    #[test]\n    fn test_decode_table_custom_alphabet() {\n        let custom_alphabet = "ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba9876543210/=";\n        let alphabet = Alphabet::new(custom_alphabet).unwrap();\n        let table = decode_table(&alphabet);\n        \n        // Check if the table has the correct mappings for the custom alphabet\n        for (index, &symbol) in alphabet.symbols.iter().enumerate() {\n            assert_eq!(table[symbol as usize], index as u8);\n        }\n\n        // Check if invalid symbols return INVALID_VALUE\n        for byte in 0..256 {\n            if !alphabet.symbols.iter().any(|&x| x == byte) {\n                assert_eq!(table[byte], INVALID_VALUE);\n            }\n        }\n    }\n\n    #[test]\n    fn test_decode_table_invalid_alphabet() {\n        // Test with an alphabet with duplicates\n        let invalid_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefgh";\n        assert!(Alphabet::new(invalid_alphabet).is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596337, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=421, prompt_tokens=1278, total_tokens=1699, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq4pOjlwLAc24FR8vd80thLLVG2A', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::alphabet::Alphabet;\n\n    #[test]\n    fn test_encode_table() {\n        let alphabet = Alphabet::new("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").unwrap();\n        let expected_table: [u8; 64] = [\n            b\'A\', b\'B\', b\'C\', b\'D\', b\'E\', b\'F\', b\'G\', b\'H\',\n            b\'I\', b\'J\', b\'K\', b\'L\', b\'M\', b\'N\', b\'O\', b\'P\',\n            b\'Q\', b\'R\', b\'S\', b\'T\', b\'U\', b\'V\', b\'W\', b\'X\',\n            b\'Y\', b\'Z\', b\'a\', b\'b\', b\'c\', b\'d\', b\'e\', b\'f\',\n            b\'g\', b\'h\', b\'i\', b\'j\', b\'k\', b\'l\', b\'m\', b\'n\',\n            b\'o\', b\'p\', b\'q\', b\'r\', b\'s\', b\'t\', b\'u\', b\'v\',\n            b\'w\', b\'x\', b\'y\', b\'z\', b\'0\', b\'1\', b\'2\', b\'3\',\n            b\'4\', b\'5\', b\'6\', b\'7\', b\'8\', b\'9\', b\'+\', b\'/\',\n        ];\n\n        let table = encode_table(&alphabet);\n        assert_eq!(table, expected_table);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596347, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=317, prompt_tokens=1200, total_tokens=1517, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq4w0iUAI2jM5GR9xY0KdkXGc4eN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_read_u64() {\n        let input: &[u8] = &[0, 0, 0, 0, 0, 0, 0, 1]; // represents 1 in big-endian\n        let result = read_u64(input);\n        assert_eq!(result, 1);\n\n        let input: &[u8] = &[0, 0, 0, 0, 0, 0, 0, 255]; // represents 255 in big-endian\n        let result = read_u64(input);\n        assert_eq!(result, 255);\n\n        let input: &[u8] = &[0, 0, 0, 0, 1, 0, 0, 0]; // represents 16777216 in big-endian\n        let result = read_u64(input);\n        assert_eq!(result, 16777216);\n\n        let input: &[u8] = &[255, 255, 255, 255, 255, 255, 255, 255]; // represents maximum u64 value\n        let result = read_u64(input);\n        assert_eq!(result, u64::MAX);\n\n        let input: &[u8] = &[0, 0, 0, 0, 0, 0, 0, 0]; // represents 0 in big-endian\n        let result = read_u64(input);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_read_u64_panic_on_short_slice() {\n        let input: &[u8] = &[0, 0, 0]; // Less than 8 bytes\n        let _result = read_u64(input);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596354, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=394, prompt_tokens=171, total_tokens=565, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq59cUdUizBZvGbpzWrNbdv4y2yC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn test_decode_to_buf_success() {\n        let input_data = b"YW55IGNhbm7igJlzIGNvbW1vbmx5IG5vdCBhIHZhbGlkIHN0YXdlLg=="; // "any cano is commonly not a valid stave."\n        let expected_output = b"any cano is commonly not a valid stave.";\n        let mut cursor = Cursor::new(input_data);\n        let engine = general_purpose::STANDARD;\n\n        let mut decoder = DecoderReader::new(&mut cursor, &engine);\n        let mut output_buf = vec![0; 64]; // Set output buffer size\n        \n        let decoded_len = decoder.decode_to_buf(input_data.len(), &mut output_buf).expect("Decoding failed");\n        assert_eq!(decoded_len, expected_output.len());\n        assert_eq!(&output_buf[..decoded_len], expected_output);\n    }\n\n    #[test]\n    #[should_panic(expected = "panics if `buf` is too small")]\n    fn test_decode_to_buf_panic_on_small_buf() {\n        let input_data = b"YW55IGNhbm7igJlzIGNvbW1vbmx5IG5vdCBhIHZhbGlkIHN0YXdlLg==";\n        let mut cursor = Cursor::new(input_data);\n        let engine = general_purpose::STANDARD;\n\n        let mut decoder = DecoderReader::new(&mut cursor, &engine);\n        let mut output_buf = [0; 1]; // Too small buffer\n        \n        let _ = decoder.decode_to_buf(input_data.len(), &mut output_buf);\n    }\n\n    #[test]\n    fn test_decode_to_buf_padding_error() {\n        let input_data = b"YW55IGNhbm7igJlzIGNvbW1vbmx5IG5vdCBhIHZhbGlkIHN0YXdlLg=="; // Properly padded\n        let mut cursor = Cursor::new(input_data);\n        let engine = general_purpose::STANDARD;\n\n        let mut decoder = DecoderReader::new(&mut cursor, &engine);\n        let mut output_buf = vec![0; 64];\n\n        // Decode the initial valid part\n        let _ = decoder.decode_to_buf(input_data.len() / 4 * 4, &mut output_buf).expect("Decoding failed");\n        \n        // Simulate an error case with invalid padding\n        let invalid_input_data = b"YW55IGNhbm7igJlzIGNvbW1vbmx5IG5vdCBhIHZhbGlk=="; // Invalid padding\n        let invalid_cursor = Cursor::new(invalid_input_data);\n        let mut invalid_decoder = DecoderReader::new(&mut invalid_cursor, &engine);\n        \n        let result = invalid_decoder.decode_to_buf(invalid_input_data.len(), &mut output_buf);\n        assert!(result.is_err(), "Expected error due to invalid padding");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596367, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=634, prompt_tokens=10754, total_tokens=11388, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq5OogjUHU1QVzFuBUI98HaQbMeI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn test_flush_decoded_buf() {\n        let data = b"Hello, World!";\n        let engine = engine::general_purpose::STANDARD;\n        let mut cursor = Cursor::new(data);\n        let mut decoder = read::DecoderReader::new(&mut cursor, &engine);\n        let mut decoded_buffer = [0u8; 32];\n        decoder.decoded_chunk_buffer[..data.len()].copy_from_slice(data);\n        decoder.decoded_len = data.len();\n        decoder.decoded_offset = 0;\n\n        let result = decoder.flush_decoded_buf(&mut decoded_buffer[..]);\n        assert!(result.is_ok());\n        let copied_bytes = result.unwrap();\n        assert_eq!(copied_bytes, data.len());\n        assert_eq!(&decoded_buffer[..copied_bytes], data);\n        assert_eq!(decoder.decoded_len, 0);\n        assert_eq!(decoder.decoded_offset, decoded_buffer.len());\n    }\n\n    #[test]\n    fn test_flush_decoded_buf_partial_copy() {\n        let data = b"Hello, World!";\n        let engine = engine::general_purpose::STANDARD;\n        let mut cursor = Cursor::new(data);\n        let mut decoder = read::DecoderReader::new(&mut cursor, &engine);\n        let mut decoded_buffer = [0u8; 5];\n        decoder.decoded_chunk_buffer[..data.len()].copy_from_slice(data);\n        decoder.decoded_len = data.len();\n        decoder.decoded_offset = 0;\n\n        let result = decoder.flush_decoded_buf(&mut decoded_buffer[..]);\n        assert!(result.is_ok());\n        let copied_bytes = result.unwrap();\n        assert_eq!(copied_bytes, decoded_buffer.len());\n        assert_eq!(&decoded_buffer[..], b"Hello");\n        assert_eq!(decoder.decoded_len, data.len() - copied_bytes);\n        assert_eq!(decoder.decoded_offset, copied_bytes);\n    }\n\n    #[test]\n    fn test_flush_decoded_buf_empty_buffer() {\n        let data = b"Hello, World!";\n        let engine = engine::general_purpose::STANDARD;\n        let mut cursor = Cursor::new(data);\n        let mut decoder = read::DecoderReader::new(&mut cursor, &engine);\n        let mut decoded_buffer = [0u8; 0]; // empty buffer\n        decoder.decoded_chunk_buffer[..data.len()].copy_from_slice(data);\n        decoder.decoded_len = data.len();\n        decoder.decoded_offset = 0;\n\n        let result = decoder.flush_decoded_buf(&mut decoded_buffer[..]);\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap().kind(), io::ErrorKind::InvalidInput);\n    }\n\n    #[test]\n    fn test_flush_decoded_buf_no_data() {\n        let engine = engine::general_purpose::STANDARD;\n        let mut cursor = Cursor::new(b"");\n        let mut decoder = read::DecoderReader::new(&mut cursor, &engine);\n        let mut decoded_buffer = [0u8; 5];\n        decoder.decoded_len = 0; // no data to flush\n        decoder.decoded_offset = 0;\n\n        let result = decoder.flush_decoded_buf(&mut decoded_buffer[..]);\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap().kind(), io::ErrorKind::InvalidInput);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596382, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=709, prompt_tokens=10289, total_tokens=10998, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq5dTHyEcOt7i5EOXRBuFWAILluz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_into_inner() {\n        let data = b"YXNkZg=="; // base64 for "asdf"\n        let cursor = Cursor::new(data);\n        let engine = &general_purpose::STANDARD;\n\n        let decoder = DecoderReader::new(cursor, engine);\n        let inner_reader = decoder.into_inner();\n\n        let mut result = Vec::new();\n        inner_reader.read_to_end(&mut result).unwrap();\n        assert_eq!(data.to_vec(), result);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596397, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=139, prompt_tokens=10172, total_tokens=10311, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq5kvciQnqkRD6lDGwKB3q1Rn2zP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_decoder_reader_new() {\n        let data = b"YXNkZg=="; // "asdf" in base64\n        let cursor = Cursor::new(data);\n        let engine = &general_purpose::STANDARD;\n\n        // Create a new DecoderReader\n        let decoder_reader = DecoderReader::new(cursor, engine);\n\n        // Check that properties are initialized correctly\n        assert_eq!(decoder_reader.b64_offset, 0);\n        assert_eq!(decoder_reader.b64_len, 0);\n        assert_eq!(decoder_reader.decoded_offset, 0);\n        assert_eq!(decoder_reader.decoded_len, 0);\n        assert_eq!(decoder_reader.input_consumed_len, 0);\n        assert!(decoder_reader.padding_offset.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596404, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=195, prompt_tokens=10201, total_tokens=10396, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq5tKu30Tcg9KSu5lBFrjVwyxxCy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_read_from_delegate() {\n        let input = b"YXNkZg=="; // Base64 representation of "asdf"\n        let cursor = Cursor::new(input);\n        let engine = general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(cursor, &engine);\n        let mut buffer = [0u8; 8]; // Buffer to read decoded bytes\n\n        // The read_from_delegate method should read base64 data into b64_buffer\n        let bytes_read = decoder.read_from_delegate().unwrap();\n\n        // Ensure that the number of bytes read is as expected\n        assert!(bytes_read > 0);\n        assert_eq!(bytes_read, input.len());\n\n        // Now decode the data that was read\n        let decoded_bytes = decoder.decode_to_buf(bytes_read, &mut buffer).unwrap();\n        \n        // Check that the decoded bytes match expected result\n        assert_eq!(&buffer[..decoded_bytes], b"asdf");\n    }\n\n    #[test]\n    fn test_read_from_delegate_buffer_overflow() {\n        let input = b"YXNkZg=="; // Base64 representation of "asdf"\n        let cursor = Cursor::new(input);\n        let engine = general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(cursor, &engine);\n\n        // Fill the b64_buffer manually to trigger overflow assertions\n        decoder.b64_offset = BUF_SIZE - 1; // Assuming BUF_SIZE is the expected buffer size\n        decoder.b64_len = 1; // Pretend we have one byte in the buffer\n\n        let result = decoder.read_from_delegate();\n\n        // Check if the overflow condition is handled\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596413, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=388, prompt_tokens=10217, total_tokens=10605, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq643apdC3sPrmyYtDtGywn4IT5v', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use crate::engine::general_purpose;\n\n    #[test]\n    fn test_finish_success() {\n        let input = b"hello";\n        let buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(buffer, &general_purpose::STANDARD);\n\n        encoder.write_all(input).unwrap();\n        let finished_writer = encoder.finish().unwrap();\n\n        let encoded = finished_writer;\n        assert_eq!(encoded, b"aGVsbG8=");\n    }\n\n    #[test]\n    fn test_finish_called_twice() {\n        let input = b"hello";\n        let buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(buffer, &general_purpose::STANDARD);\n\n        encoder.write_all(input).unwrap();\n        let _ = encoder.finish().unwrap();\n\n        let result = std::panic::catch_unwind(|| {\n            encoder.finish().unwrap();\n        });\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_finish_no_write_before_finish() {\n        let buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(buffer, &general_purpose::STANDARD);\n\n        let result = encoder.finish();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_finish_with_extra_input() {\n        let input = b"he";\n        let buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(buffer, &general_purpose::STANDARD);\n\n        encoder.write_all(input).unwrap();\n        let finished_writer = encoder.finish().unwrap();\n\n        let encoded = finished_writer;\n        assert_eq!(encoded, b"aGU=");\n    }\n\n    #[test]\n    fn test_finish_with_unbuffered_writer() {\n        let input = b"test input";\n        let cursor = Cursor::new(Vec::new());\n        let mut encoder = EncoderWriter::new(cursor, &general_purpose::STANDARD);\n\n        encoder.write_all(input).unwrap();\n        let finished_writer = encoder.finish().unwrap();\n\n        let encoded = finished_writer;\n        assert_eq!(encoded, b"dGVzdCBpbnB1dA==");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596424, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=452, prompt_tokens=11066, total_tokens=11518, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq6HgGBmP8XPPhpO1hNx3yiDb5Pw', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // assuming EncoderWriter is in the same module\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_into_inner() {\n        let data = b"test data";\n        let mut buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(Cursor::new(&mut buffer), &general_purpose::STANDARD);\n\n        // Write data to the encoder\n        encoder.write_all(data).unwrap();\n        \n        // Ensure that calling into_inner does not panic after finish\n        let inner_writer = encoder.finish().unwrap();\n        \n        // Obtain the inner buffer\n        let returned = encoder.into_inner(); // Should panic if we call this again after finish\n        \n        // Check that we can still use the inner writer\n        let result = String::from_utf8(returned.into_inner().into_inner().into_inner().into_inner().into_inner().to_vec().unwrap();\n        assert_eq!(result, "dGVzdCBkYXRh"); // Base64 encoded string\n    }\n\n    #[test]\n    #[should_panic(expected = "Encoder has already had finish() called")]\n    fn test_into_inner_panics_after_finish() {\n        let data = b"test data";\n        let buffer = Vec::new();\n        let encoder = EncoderWriter::new(Cursor::new(&mut buffer), &general_purpose::STANDARD);\n\n        // Write data to the encoder\n        encoder.write_all(data).unwrap();\n        \n        // Call finish to complete the write\n        let _ = encoder.finish().unwrap();\n        \n        // This call should panic\n        let _ = encoder.into_inner();\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596437, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=355, prompt_tokens=11007, total_tokens=11362, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq6SszyCgXqWSF2giuYS8KidLZez', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_encoder_writer_new() {\n        // Create a dummy writer (cursor over a vector).\n        let writer = Cursor::new(Vec::new());\n        // Create a new GeneralPurpose engine.\n        let engine = general_purpose::STANDARD;\n\n        // Create a new EncoderWriter.\n        let encoder = EncoderWriter::new(writer, &engine);\n\n        // Assert properties of the EncoderWriter.\n        assert!(encoder.delegate.is_some());\n        assert_eq!(encoder.extra_input_occupied_len, 0);\n        assert_eq!(encoder.output_occupied_len, 0);\n        assert!(!encoder.panicked);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596448, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=164, prompt_tokens=10942, total_tokens=11106, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq6lKXgqxIK64stuLM1516NUUnCE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::{self, general_purpose};\n\n    #[test]\n    fn test_write_all_encoded_output_empty() {\n        let mut writer = Cursor::new(Vec::new());\n        let mut encoder = EncoderWriter::new(writer, &general_purpose::STANDARD);\n\n        let result = encoder.write_all_encoded_output();\n        assert!(result.is_ok());\n        assert_eq!(encoder.output_occupied_len, 0);\n    }\n\n    #[test]\n    fn test_write_all_encoded_output_partial() {\n        let mut writer = Cursor::new(Vec::new());\n        let mut encoder = EncoderWriter::new(writer, &general_purpose::STANDARD);\n\n        // Simulate adding to output\n        encoder.output_occupied_len = 4; // Pretend we have 4 bytes ready\n        encoder.output[..4].copy_from_slice(b"abcd"); // Sample output\n\n        let result = encoder.write_all_encoded_output();\n        assert!(result.is_ok());\n        assert_eq!(encoder.output_occupied_len, 0);\n    }\n\n    #[test]\n    fn test_write_all_encoded_output_interrupted() {\n        let mut writer = Cursor::new(Vec::new());\n        let mut encoder = EncoderWriter::new(writer, &general_purpose::STANDARD);\n\n        // Mock behavior of writer to return interrupted error\n        encoder.output_occupied_len = 4; // Pretend we have 4 bytes ready\n        encoder.output[..4].copy_from_slice(b"abcd"); // Sample output\n\n        // Simulate interrupted error\n        encoder.write_to_delegate = |_current_output_len| {\n            Err(std::io::Error::new(std::io::ErrorKind::Interrupted, "interrupted"))\n        };\n\n        let result = encoder.write_all_encoded_output();\n        assert!(result.is_ok());\n        assert_eq!(encoder.output_occupied_len, 4); // Should still have 4 bytes to write\n    }\n\n    #[test]\n    fn test_write_all_encoded_output_io_error() {\n        let mut writer = Cursor::new(Vec::new());\n        let mut encoder = EncoderWriter::new(writer, &general_purpose::STANDARD);\n\n        // Mock behavior of writer to return an actual IO error\n        encoder.output_occupied_len = 4; // Pretend we have 4 bytes ready\n        encoder.output[..4].copy_from_slice(b"abcd"); // Sample output\n\n        encoder.write_to_delegate = |_current_output_len| {\n            Err(std::io::Error::new(std::io::ErrorKind::Other, "IO error"))\n        };\n\n        let result = encoder.write_all_encoded_output();\n        assert!(result.is_err());\n        assert_eq!(encoder.output_occupied_len, 4); // Should still have 4 bytes to write\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596467, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=585, prompt_tokens=11061, total_tokens=11646, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq6zCz5RrXbs6JmY9mhHFDIhq5fq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_write_final_leftovers_empty() {\n        let mut writer = EncoderWriter::new(Cursor::new(Vec::new()), &general_purpose::STANDARD);\n        writer.extra_input_occupied_len = 0;\n        let result = writer.write_final_leftovers();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_write_final_leftovers_with_extra_input() {\n        let mut writer = EncoderWriter::new(Cursor::new(Vec::new()), &general_purpose::STANDARD);\n        writer.extra_input_occupied_len = 2;\n        writer.extra_input[..2].copy_from_slice(&[0b01100001, 0b01100010]); // "ab"\n        writer.output_occupied_len = 0;\n\n        let result = writer.write_final_leftovers();\n        assert!(result.is_ok());\n        let output = writer.output[..writer.output_occupied_len].to_vec();\n        assert_eq!(output, b"YWI="); // Check that "ab" is encoded correctly\n    }\n\n    #[test]\n    fn test_write_final_leftovers_with_non_empty_output() {\n        let mut writer = EncoderWriter::new(Cursor::new(Vec::new()), &general_purpose::STANDARD);\n        writer.output_occupied_len = 4;\n        writer.output[..4].copy_from_slice(b"YWI="); // Pre-fill output with "YWI="\n\n        let result = writer.write_final_leftovers();\n        assert!(result.is_ok());\n        // Output should still contain "YWI=" if encoded correctly\n        assert_eq!(writer.output[..4], b"YWI=");\n    }\n\n    #[test]\n    fn test_write_final_leftovers_with_no_delegate() {\n        let mut writer = EncoderWriter::new(Cursor::new(Vec::new()), &general_purpose::STANDARD);\n        writer.delegate = None; // Simulate finishing process\n        let result = writer.write_final_leftovers();\n        assert!(result.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596481, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=440, prompt_tokens=11034, total_tokens=11474, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq7Ax34MSDTokh7WdiEk5pqUsRu5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::{Cursor, Write};\n\n    struct MockWriter {\n        buffer: Vec<u8>,\n        write_fail: bool,\n    }\n\n    impl MockWriter {\n        fn new() -> Self {\n            MockWriter {\n                buffer: Vec::new(),\n                write_fail: false,\n            }\n        }\n\n        fn set_write_fail(&mut self, fail: bool) {\n            self.write_fail = fail;\n        }\n\n        fn get_buffer(&self) -> Vec<u8> {\n            self.buffer.clone()\n        }\n    }\n\n    impl Write for MockWriter {\n        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n            if self.write_fail {\n                Err(std::io::Error::new(std::io::ErrorKind::Other, "Write failed"))\n            } else {\n                self.buffer.extend_from_slice(buf);\n                Ok(buf.len())\n            }\n        }\n\n        fn flush(&mut self) -> std::io::Result<()> {\n            Ok(())\n        }\n    }\n\n    #[test]\n    fn test_write_to_delegate_success() {\n        let engine = general_purpose::STANDARD;\n        let mut mock_writer = MockWriter::new();\n        let mut encoder = EncoderWriter::new(&mut mock_writer, &engine);\n\n        encoder.output[..8].copy_from_slice(b"testdata");\n        encoder.output_occupied_len = 8;\n\n        let result = encoder.write_to_delegate(8);\n        assert!(result.is_ok());\n        assert_eq!(mock_writer.get_buffer(), b"testdata");\n        assert_eq!(encoder.output_occupied_len, 0);\n    }\n\n    #[test]\n    fn test_write_to_delegate_partial_write() {\n        let engine = general_purpose::STANDARD;\n        let mut mock_writer = MockWriter::new();\n        let mut encoder = EncoderWriter::new(&mut mock_writer, &engine);\n\n        encoder.output[..8].copy_from_slice(b"testdata");\n        encoder.output_occupied_len = 8;\n\n        mock_writer.set_write_fail(true);\n        let result = encoder.write_to_delegate(8);\n        assert!(result.is_err());\n        assert_eq!(encoder.output_occupied_len, 8);\n    }\n\n    #[test]\n    fn test_write_to_delegate_resize_buffer() {\n        let engine = general_purpose::STANDARD;\n        let mut mock_writer = MockWriter::new();\n        let mut encoder = EncoderWriter::new(&mut mock_writer, &engine);\n\n        encoder.output[..10].copy_from_slice(b"longdataxx");\n        encoder.output_occupied_len = 10;\n\n        let result = encoder.write_to_delegate(10);\n        assert!(result.is_ok());\n        assert_eq!(encoder.output_occupied_len, 0);\n    }\n\n    #[test]\n    fn test_write_to_delegate_consume_partial() {\n        let engine = general_purpose::STANDARD;\n        let mut mock_writer = MockWriter::new();\n        let mut encoder = EncoderWriter::new(&mut mock_writer, &engine);\n\n        encoder.output[..8].copy_from_slice(b"testdata");\n        encoder.output_occupied_len = 8;\n\n        // Mock writing of only 5 bytes\n        mock_writer.set_write_fail(false);\n        let result = encoder.write_to_delegate(8);\n        assert!(result.is_ok());\n        assert_eq!(encoder.output_occupied_len, 3); // 8 - 5 = 3 bytes left\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596492, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=714, prompt_tokens=11121, total_tokens=11835, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq7TRxRhSMJrcmPwYmAWLaBELDMu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::string::String;\n    use base64::engine::{self, general_purpose};\n    \n    #[test]\n    fn test_from_consumer() {\n        let mut output_string = String::new();\n        let engine = general_purpose::STANDARD;\n\n        // Create an EncoderStringWriter from a String consumer\n        let encoder = EncoderStringWriter::from_consumer(&mut output_string, &engine);\n\n        // Ensure the encoder is not empty (just a basic instantiation test)\n        assert!(encoder.encoder.delegate.is_some());\n\n        // Write some data\n        let data = b"hello";\n        encoder.write_all(data).unwrap();\n\n        // Finish and obtain the result\n        encoder.into_inner();\n\n        // Validate the output\n        assert_eq!(output_string, "aGVsbG8="); // base64 of "hello"\n    }\n\n    #[test]\n    fn test_from_consumer_with_existing_string() {\n        let mut output_string = String::from("Base64 Encoded: ");\n        let engine = general_purpose::STANDARD;\n\n        // Create an EncoderStringWriter that will append to the existing string\n        let mut encoder = EncoderStringWriter::from_consumer(&mut output_string, &engine);\n        \n        // Write some data\n        let data = b"world";\n        encoder.write_all(data).unwrap();\n\n        // Finish and obtain the result\n        encoder.into_inner();\n\n        // Validate the output\n        assert_eq!(output_string, "Base64 Encoded: d29ybGQ="); // base64 of "world"\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596511, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=338, prompt_tokens=11819, total_tokens=12157, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq7cnrxZhCkcimJlE2CNeDc60GM1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{general_purpose, Engine};\n\n    #[test]\n    fn test_into_inner() {\n        let engine = &general_purpose::STANDARD;\n        let mut encoder = EncoderStringWriter::new(engine);\n        \n        encoder.write_all(b"test").unwrap();\n        let result = encoder.into_inner();\n\n        assert_eq!(result, "dGVzdA==");\n    }\n\n    #[test]\n    fn test_into_inner_with_existing_string() {\n        let engine = &general_purpose::STANDARD;\n        let mut output = String::from("Encoded: ");\n        let mut encoder = EncoderStringWriter::from_consumer(&mut output, engine);\n        \n        encoder.write_all(b"hello").unwrap();\n        let result = encoder.into_inner();\n\n        assert_eq!(result, "Encoded: aGVsbG8=");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596520, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=188, prompt_tokens=11819, total_tokens=12007, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcq7iF0qdFbp5rGlu29pUfQNuvJPt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_encoder_string_writer_new() {\n        let engine = general_purpose::STANDARD;\n        let writer = EncoderStringWriter::new(&engine);\n\n        // assert that the writer is created successfully\n        assert!(writer.encoder.delegate.is_some());\n        assert_eq!(writer.encoder.extra_input_occupied_len, 0);\n        assert_eq!(writer.encoder.output_occupied_len, 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748596526, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=112, prompt_tokens=11801, total_tokens=11913, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
({'dependencies': {'<&mut S as write::encoder_string_writer::StrConsumer>::consume': [], '<alphabet::Alphabet as std::clone::Clone>::clone': ['alphabet::Alphabet'], '<alphabet::Alphabet as std::cmp::Eq>::assert_receiver_is_total_eq': ['alphabet::Alphabet'], '<alphabet::Alphabet as std::cmp::PartialEq>::eq': ['alphabet::Alphabet'], '<alphabet::Alphabet as std::convert::TryFrom<&str>>::try_from': ['std::marker::Sized', 'std::result::Result'], '<alphabet::Alphabet as std::fmt::Debug>::fmt': ['alphabet::Alphabet', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<alphabet::ParseAlphabetError as std::cmp::Eq>::assert_receiver_is_total_eq': ['alphabet::ParseAlphabetError'], '<alphabet::ParseAlphabetError as std::cmp::PartialEq>::eq': ['alphabet::ParseAlphabetError'], '<alphabet::ParseAlphabetError as std::fmt::Debug>::fmt': ['alphabet::ParseAlphabetError', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<alphabet::ParseAlphabetError as std::fmt::Display>::fmt': ['alphabet::ParseAlphabetError', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], "<chunked_encoder::StringSink<'a> as chunked_encoder::Sink>::write_encoded_bytes": ['chunked_encoder::StringSink', 'std::marker::Sized', 'std::result::Result', 'std::string::String'], '<decode::DecodeError as std::clone::Clone>::clone': ['decode::DecodeError'], '<decode::DecodeError as std::cmp::Eq>::assert_receiver_is_total_eq': ['decode::DecodeError'], '<decode::DecodeError as std::cmp::PartialEq>::eq': ['decode::DecodeError'], '<decode::DecodeError as std::fmt::Debug>::fmt': ['decode::DecodeError', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<decode::DecodeError as std::fmt::Display>::fmt': ['decode::DecodeError', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<decode::DecodeSliceError as std::clone::Clone>::clone': ['decode::DecodeError', 'decode::DecodeSliceError'], '<decode::DecodeSliceError as std::cmp::Eq>::assert_receiver_is_total_eq': ['decode::DecodeError', 'decode::DecodeSliceError'], '<decode::DecodeSliceError as std::cmp::PartialEq>::eq': ['decode::DecodeError', 'decode::DecodeSliceError'], '<decode::DecodeSliceError as std::convert::From<decode::DecodeError>>::from': ['decode::DecodeError', 'decode::DecodeSliceError'], '<decode::DecodeSliceError as std::error::Error>::source': ['decode::DecodeError', 'decode::DecodeSliceError', 'std::marker::Sized', 'std::option::Option'], '<decode::DecodeSliceError as std::fmt::Debug>::fmt': ['decode::DecodeError', 'decode::DecodeSliceError', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<decode::DecodeSliceError as std::fmt::Display>::fmt': ['decode::DecodeError', 'decode::DecodeSliceError', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], "<display::Base64Display<'a, 'e, E> as std::fmt::Display>::fmt": ['chunked_encoder::ChunkedEncoder', 'display::Base64Display', 'engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::fmt::Formatter', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::result::Result'], "<display::FormatterSink<'a, 'b> as chunked_encoder::Sink>::write_encoded_bytes": ['display::FormatterSink', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<encode::EncodeSliceError as std::clone::Clone>::clone': ['encode::EncodeSliceError'], '<encode::EncodeSliceError as std::cmp::Eq>::assert_receiver_is_total_eq': ['encode::EncodeSliceError'], '<encode::EncodeSliceError as std::cmp::PartialEq>::eq': ['encode::EncodeSliceError'], '<encode::EncodeSliceError as std::fmt::Debug>::fmt': ['encode::EncodeSliceError', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<encode::EncodeSliceError as std::fmt::Display>::fmt': ['encode::EncodeSliceError', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<engine::DecodeMetadata as std::cmp::Eq>::assert_receiver_is_total_eq': ['engine::DecodeMetadata', 'std::marker::Sized', 'std::option::Option'], '<engine::DecodeMetadata as std::cmp::PartialEq>::eq': ['engine::DecodeMetadata', 'std::marker::Sized', 'std::option::Option'], '<engine::DecodeMetadata as std::fmt::Debug>::fmt': ['engine::DecodeMetadata', 'std::fmt::Formatter', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], '<engine::DecodePaddingMode as std::clone::Clone>::clone': ['engine::DecodePaddingMode'], '<engine::DecodePaddingMode as std::cmp::Eq>::assert_receiver_is_total_eq': ['engine::DecodePaddingMode'], '<engine::DecodePaddingMode as std::cmp::PartialEq>::eq': ['engine::DecodePaddingMode'], '<engine::DecodePaddingMode as std::fmt::Debug>::fmt': ['engine::DecodePaddingMode', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::config': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_decode': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::marker::Sized', 'std::result::Result'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_decoded_len_estimate': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_encode': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig'], '<engine::general_purpose::GeneralPurpose as std::clone::Clone>::clone': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig'], '<engine::general_purpose::GeneralPurpose as std::fmt::Debug>::fmt': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<engine::general_purpose::GeneralPurposeConfig as engine::Config>::encode_padding': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurposeConfig'], '<engine::general_purpose::GeneralPurposeConfig as std::clone::Clone>::clone': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurposeConfig'], '<engine::general_purpose::GeneralPurposeConfig as std::default::Default>::default': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurposeConfig'], '<engine::general_purpose::GeneralPurposeConfig as std::fmt::Debug>::fmt': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurposeConfig', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<engine::general_purpose::decode::GeneralPurposeEstimate as engine::DecodeEstimate>::decoded_len_estimate': ['engine::general_purpose::decode::GeneralPurposeEstimate'], "<read::decoder::DecoderReader<'e, E, R> as std::fmt::Debug>::fmt": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'read::decoder::DecoderReader', 'std::fmt::Formatter', 'std::io::Read', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result'], "<read::decoder::DecoderReader<'e, E, R> as std::io::Read>::read": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'read::decoder::DecoderReader', 'std::io::Read', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result'], '<std::string::String as write::encoder_string_writer::StrConsumer>::consume': ['std::string::String'], "<write::encoder::EncoderWriter<'e, E, W> as std::fmt::Debug>::fmt": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::fmt::Formatter', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'write::encoder::EncoderWriter'], "<write::encoder::EncoderWriter<'e, E, W> as std::io::Write>::flush": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'write::encoder::EncoderWriter'], "<write::encoder::EncoderWriter<'e, E, W> as std::io::Write>::write": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'write::encoder::EncoderWriter'], "<write::encoder::EncoderWriter<'e, E, W> as std::ops::Drop>::drop": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'write::encoder::EncoderWriter'], "<write::encoder_string_writer::EncoderStringWriter<'e, E, S> as std::io::Write>::flush": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'std::string::String', 'write::encoder::EncoderWriter', 'write::encoder_string_writer::EncoderStringWriter', 'write::encoder_string_writer::StrConsumer'], "<write::encoder_string_writer::EncoderStringWriter<'e, E, S> as std::io::Write>::write": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'std::string::String', 'write::encoder::EncoderWriter', 'write::encoder_string_writer::EncoderStringWriter', 'write::encoder_string_writer::StrConsumer'], '<write::encoder_string_writer::Utf8SingleCodeUnitWriter<S> as std::io::Write>::flush': ['std::marker::Sized', 'std::result::Result', 'std::string::String', 'write::encoder_string_writer::StrConsumer', 'write::encoder_string_writer::Utf8SingleCodeUnitWriter'], '<write::encoder_string_writer::Utf8SingleCodeUnitWriter<S> as std::io::Write>::write': ['std::marker::Sized', 'std::result::Result', 'std::string::String', 'write::encoder_string_writer::StrConsumer', 'write::encoder_string_writer::Utf8SingleCodeUnitWriter'], 'alphabet::Alphabet': ['alphabet::Alphabet'], 'alphabet::Alphabet::as_str': ['alphabet::Alphabet'], 'alphabet::Alphabet::from_str_unchecked': ['alphabet::Alphabet'], 'alphabet::Alphabet::new': ['std::marker::Sized', 'std::result::Result'], 'alphabet::ParseAlphabetError': ['alphabet::ParseAlphabetError'], 'chunked_encoder::ChunkedEncoder': ['chunked_encoder::ChunkedEncoder', 'engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::marker::Send', 'std::marker::Sync'], "chunked_encoder::ChunkedEncoder::<'e, E>::encode": ['chunked_encoder::ChunkedEncoder', 'chunked_encoder::Sink', 'chunked_encoder::StringSink', 'engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::result::Result', 'std::string::String'], "chunked_encoder::ChunkedEncoder::<'e, E>::new": ['chunked_encoder::ChunkedEncoder', 'engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::marker::Send', 'std::marker::Sync'], 'chunked_encoder::Sink::write_encoded_bytes': ['std::marker::Sized', 'std::result::Result'], 'chunked_encoder::StringSink': ['chunked_encoder::StringSink', 'std::string::String'], "chunked_encoder::StringSink::<'a>::new": ['chunked_encoder::StringSink', 'std::string::String'], 'decode::DecodeError': ['decode::DecodeError'], 'decode::DecodeSliceError': ['decode::DecodeError', 'decode::DecodeSliceError'], 'decode::decode': ['std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'decode::decode_engine': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'decode::decode_engine_slice': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'decode::decode_engine_vec': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::alloc::Allocator', 'std::convert::AsRef', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'decode::decoded_len_estimate': [], 'display::Base64Display': ['chunked_encoder::ChunkedEncoder', 'display::Base64Display', 'engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync'], "display::Base64Display::<'a, 'e, E>::new": ['chunked_encoder::ChunkedEncoder', 'display::Base64Display', 'engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync'], 'display::FormatterSink': ['display::FormatterSink', 'std::fmt::Formatter'], 'encode::EncodeSliceError': ['encode::EncodeSliceError'], 'encode::add_padding': [], 'encode::encode': ['std::convert::AsRef', 'std::marker::Sized', 'std::string::String'], 'encode::encode_engine': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::convert::AsRef', 'std::marker::Sized', 'std::string::String'], 'encode::encode_engine_slice': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'encode::encode_engine_string': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::convert::AsRef', 'std::marker::Sized', 'std::string::String'], 'encode::encode_with_padding': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig'], 'encode::encoded_len': ['std::marker::Sized', 'std::option::Option'], 'engine::Config::encode_padding': [], 'engine::DecodeEstimate::decoded_len_estimate': [], 'engine::DecodeMetadata': ['engine::DecodeMetadata', 'std::marker::Sized', 'std::option::Option'], 'engine::DecodeMetadata::new': ['engine::DecodeMetadata', 'std::marker::Sized', 'std::option::Option'], 'engine::DecodePaddingMode': ['engine::DecodePaddingMode'], 'engine::Engine::config': [], 'engine::Engine::decode': ['std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'engine::Engine::decode::inner': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::marker::Sized', 'std::result::Result'], 'engine::Engine::decode_slice': ['std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'engine::Engine::decode_slice::inner': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::marker::Sized', 'std::result::Result'], 'engine::Engine::decode_slice_unchecked': ['std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'engine::Engine::decode_slice_unchecked::inner': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::marker::Sized', 'std::result::Result'], 'engine::Engine::decode_vec': ['std::alloc::Allocator', 'std::convert::AsRef', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'engine::Engine::decode_vec::inner': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::alloc::Allocator', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'engine::Engine::encode': ['std::convert::AsRef', 'std::marker::Sized', 'std::string::String'], 'engine::Engine::encode::inner': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::string::String'], 'engine::Engine::encode_slice': ['std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'engine::Engine::encode_slice::inner': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::marker::Sized', 'std::result::Result'], 'engine::Engine::encode_string': ['std::convert::AsRef', 'std::marker::Sized', 'std::string::String'], 'engine::Engine::encode_string::inner': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::string::String'], 'engine::Engine::internal_decode': ['std::marker::Sized', 'std::result::Result'], 'engine::Engine::internal_decoded_len_estimate': [], 'engine::Engine::internal_encode': [], 'engine::general_purpose::GeneralPurpose': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig'], 'engine::general_purpose::GeneralPurpose::new': ['alphabet::Alphabet', 'engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig'], 'engine::general_purpose::GeneralPurposeConfig': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurposeConfig'], 'engine::general_purpose::GeneralPurposeConfig::new': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurposeConfig'], 'engine::general_purpose::GeneralPurposeConfig::with_decode_allow_trailing_bits': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurposeConfig'], 'engine::general_purpose::GeneralPurposeConfig::with_decode_padding_mode': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurposeConfig'], 'engine::general_purpose::GeneralPurposeConfig::with_encode_padding': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurposeConfig'], 'engine::general_purpose::decode::GeneralPurposeEstimate': ['engine::general_purpose::decode::GeneralPurposeEstimate'], 'engine::general_purpose::decode::GeneralPurposeEstimate::new': ['engine::general_purpose::decode::GeneralPurposeEstimate'], 'engine::general_purpose::decode::complete_quads_len': ['std::marker::Sized', 'std::result::Result'], 'engine::general_purpose::decode::decode_chunk_4': ['std::marker::Sized', 'std::result::Result'], 'engine::general_purpose::decode::decode_chunk_8': ['std::marker::Sized', 'std::result::Result'], 'engine::general_purpose::decode::decode_helper': ['engine::DecodePaddingMode', 'engine::general_purpose::decode::GeneralPurposeEstimate', 'std::marker::Sized', 'std::result::Result'], 'engine::general_purpose::decode_suffix::decode_suffix': ['engine::DecodePaddingMode', 'std::marker::Sized', 'std::result::Result'], 'engine::general_purpose::decode_table': ['alphabet::Alphabet'], 'engine::general_purpose::encode_table': ['alphabet::Alphabet'], 'engine::general_purpose::read_u64': [], 'read::decoder::DecoderReader': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'read::decoder::DecoderReader', 'std::io::Read', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option'], "read::decoder::DecoderReader::<'e, E, R>::decode_to_buf": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'read::decoder::DecoderReader', 'std::io::Read', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result'], "read::decoder::DecoderReader::<'e, E, R>::flush_decoded_buf": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'read::decoder::DecoderReader', 'std::io::Read', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result'], "read::decoder::DecoderReader::<'e, E, R>::into_inner": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'read::decoder::DecoderReader', 'std::io::Read', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option'], "read::decoder::DecoderReader::<'e, E, R>::new": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'read::decoder::DecoderReader', 'std::io::Read', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option'], "read::decoder::DecoderReader::<'e, E, R>::read_from_delegate": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'read::decoder::DecoderReader', 'std::io::Read', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result'], 'write::encoder::EncoderWriter': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'write::encoder::EncoderWriter'], "write::encoder::EncoderWriter::<'e, E, W>::finish": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'write::encoder::EncoderWriter'], "write::encoder::EncoderWriter::<'e, E, W>::into_inner": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'write::encoder::EncoderWriter'], "write::encoder::EncoderWriter::<'e, E, W>::new": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'write::encoder::EncoderWriter'], "write::encoder::EncoderWriter::<'e, E, W>::write_all_encoded_output": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'write::encoder::EncoderWriter'], "write::encoder::EncoderWriter::<'e, E, W>::write_final_leftovers": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'write::encoder::EncoderWriter'], "write::encoder::EncoderWriter::<'e, E, W>::write_to_delegate": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'write::encoder::EncoderWriter'], 'write::encoder_string_writer::EncoderStringWriter': ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::string::String', 'write::encoder::EncoderWriter', 'write::encoder_string_writer::EncoderStringWriter', 'write::encoder_string_writer::StrConsumer'], "write::encoder_string_writer::EncoderStringWriter::<'e, E, S>::from_consumer": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::string::String', 'write::encoder::EncoderWriter', 'write::encoder_string_writer::EncoderStringWriter', 'write::encoder_string_writer::StrConsumer'], "write::encoder_string_writer::EncoderStringWriter::<'e, E, S>::into_inner": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::string::String', 'write::encoder::EncoderWriter', 'write::encoder_string_writer::EncoderStringWriter', 'write::encoder_string_writer::StrConsumer'], "write::encoder_string_writer::EncoderStringWriter::<'e, E, std::string::String>::new": ['engine::DecodePaddingMode', 'engine::Engine', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'std::io::Write', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::string::String', 'write::encoder::EncoderWriter', 'write::encoder_string_writer::EncoderStringWriter', 'write::encoder_string_writer::StrConsumer'], 'write::encoder_string_writer::StrConsumer::consume': [], 'write::encoder_string_writer::Utf8SingleCodeUnitWriter': ['std::marker::Sized', 'std::string::String', 'write::encoder_string_writer::StrConsumer', 'write::encoder_string_writer::Utf8SingleCodeUnitWriter']}, 'glob_path_import': {}, 'self_to_fn': {'alphabet::Alphabet': ['Clone', 'Debug', 'Eq', 'PartialEq', "impl Alphabet {\n    /// Performs no checks so that it can be const.\n    /// Used only for known-valid strings.\n    const fn from_str_unchecked(alphabet: &str) -> Self {\n        let mut symbols = [0_u8; ALPHABET_SIZE];\n        let source_bytes = alphabet.as_bytes();\n\n        // a way to copy that's allowed in const fn\n        let mut index = 0;\n        while index < ALPHABET_SIZE {\n            symbols[index] = source_bytes[index];\n            index += 1;\n        }\n\n        Self { symbols }\n    }\n\n    /// Create an `Alphabet` from a string of 64 unique printable ASCII bytes.\n    ///\n    /// The `=` byte is not allowed as it is used for padding.\n    pub const fn new(alphabet: &str) -> Result<Self, ParseAlphabetError> {\n        let bytes = alphabet.as_bytes();\n        if bytes.len() != ALPHABET_SIZE {\n            return Err(ParseAlphabetError::InvalidLength);\n        }\n\n        {\n            let mut index = 0;\n            while index < ALPHABET_SIZE {\n                let byte = bytes[index];\n\n                // must be ascii printable. 127 (DEL) is commonly considered printable\n                // for some reason but clearly unsuitable for base64.\n                if !(byte >= 32_u8 && byte <= 126_u8) {\n                    return Err(ParseAlphabetError::UnprintableByte(byte));\n                }\n                // = is assumed to be padding, so cannot be used as a symbol\n                if byte == PAD_BYTE {\n                    return Err(ParseAlphabetError::ReservedByte(byte));\n                }\n\n                // Check for duplicates while staying within what const allows.\n                // It's n^2, but only over 64 hot bytes, and only once, so it's likely in the single digit\n                // microsecond range.\n\n                let mut probe_index = 0;\n                while probe_index < ALPHABET_SIZE {\n                    if probe_index == index {\n                        probe_index += 1;\n                        continue;\n                    }\n\n                    let probe_byte = bytes[probe_index];\n\n                    if byte == probe_byte {\n                        return Err(ParseAlphabetError::DuplicatedByte(byte));\n                    }\n\n                    probe_index += 1;\n                }\n\n                index += 1;\n            }\n        }\n\n        Ok(Self::from_str_unchecked(alphabet))\n    }\n\n    /// Create a `&str` from the symbols in the `Alphabet`\n    #[must_use]\n    pub fn as_str(&self) -> &str {\n        core::str::from_utf8(&self.symbols).unwrap()\n    }\n}", 'impl convert::TryFrom<&str> for Alphabet {\n    type Error = ParseAlphabetError;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Self::new(value)\n    }\n}'], 'alphabet::ParseAlphabetError': ['Debug', 'Eq', 'PartialEq', 'impl error::Error for ParseAlphabetError {}', 'impl fmt::Display for ParseAlphabetError {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match self {\n            Self::InvalidLength => write!(f, "Invalid length - must be 64 bytes"),\n            Self::DuplicatedByte(b) => write!(f, "Duplicated byte: {:#04x}", b),\n            Self::UnprintableByte(b) => write!(f, "Unprintable byte: {:#04x}", b),\n            Self::ReservedByte(b) => write!(f, "Reserved byte: {:#04x}", b),\n        }\n    }\n}'], 'chunked_encoder::ChunkedEncoder': ["impl<'e, E: Engine + ?Sized> ChunkedEncoder<'e, E> {\n    pub fn new(engine: &'e E) -> ChunkedEncoder<'e, E> {\n        ChunkedEncoder { engine }\n    }\n\n    pub fn encode<S: Sink>(&self, bytes: &[u8], sink: &mut S) -> Result<(), S::Error> {\n        const BUF_SIZE: usize = 1024;\n        const CHUNK_SIZE: usize = BUF_SIZE / 4 * 3;\n\n        let mut buf = [0; BUF_SIZE];\n        for chunk in bytes.chunks(CHUNK_SIZE) {\n            let mut len = self.engine.internal_encode(chunk, &mut buf);\n            if chunk.len() != CHUNK_SIZE && self.engine.config().encode_padding() {\n                // Final, potentially partial, chunk.\n                // Only need to consider if padding is needed on a partial chunk since full chunk\n                // is a multiple of 3, which therefore won't be padded.\n                // Pad output to multiple of four bytes if required by config.\n                len += add_padding(len, &mut buf[len..]);\n            }\n            sink.write_encoded_bytes(&buf[..len])?;\n        }\n\n        Ok(())\n    }\n}"], 'chunked_encoder::StringSink': ["impl<'a> Sink for StringSink<'a> {\n    type Error = ();\n\n    fn write_encoded_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error> {\n        self.string.push_str(str::from_utf8(s).unwrap());\n\n        Ok(())\n    }\n}", "impl<'a> StringSink<'a> {\n    pub(crate) fn new(s: &mut String) -> StringSink {\n        StringSink { string: s }\n    }\n}"], 'decode::DecodeError': ['Clone', 'Debug', 'Eq', 'PartialEq', 'impl error::Error for DecodeError {}', 'impl fmt::Display for DecodeError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Self::InvalidByte(index, byte) => {\n                write!(f, "Invalid symbol {}, offset {}.", byte, index)\n            }\n            Self::InvalidLength(len) => write!(f, "Invalid input length: {}", len),\n            Self::InvalidLastSymbol(index, byte) => {\n                write!(f, "Invalid last symbol {}, offset {}.", byte, index)\n            }\n            Self::InvalidPadding => write!(f, "Invalid padding"),\n        }\n    }\n}'], 'decode::DecodeSliceError': ['Clone', 'Debug', 'Eq', 'PartialEq', 'impl From<DecodeError> for DecodeSliceError {\n    fn from(e: DecodeError) -> Self {\n        DecodeSliceError::DecodeError(e)\n    }\n}', "impl error::Error for DecodeSliceError {\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        match self {\n            DecodeSliceError::DecodeError(e) => Some(e),\n            DecodeSliceError::OutputSliceTooSmall => None,\n        }\n    }\n}", 'impl fmt::Display for DecodeSliceError {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match self {\n            Self::DecodeError(e) => write!(f, "DecodeError: {}", e),\n            Self::OutputSliceTooSmall => write!(f, "Output slice too small"),\n        }\n    }\n}'], 'display::Base64Display': ["impl<'a, 'e, E: Engine> Base64Display<'a, 'e, E> {\n    /// Create a `Base64Display` with the provided engine.\n    pub fn new(bytes: &'a [u8], engine: &'e E) -> Base64Display<'a, 'e, E> {\n        Base64Display {\n            bytes,\n            chunked_encoder: ChunkedEncoder::new(engine),\n        }\n    }\n}", "impl<'a, 'e, E: Engine> Display for Base64Display<'a, 'e, E> {\n    fn fmt(&self, formatter: &mut Formatter) -> Result<(), fmt::Error> {\n        let mut sink = FormatterSink { f: formatter };\n        self.chunked_encoder.encode(self.bytes, &mut sink)\n    }\n}"], 'display::FormatterSink': ['impl<\'a, \'b: \'a> super::chunked_encoder::Sink for FormatterSink<\'a, \'b> {\n    type Error = fmt::Error;\n\n    fn write_encoded_bytes(&mut self, encoded: &[u8]) -> Result<(), Self::Error> {\n        // Avoid unsafe. If max performance is needed, write your own display wrapper that uses\n        // unsafe here to gain about 10-15%.\n        self.f\n            .write_str(str::from_utf8(encoded).expect("base64 data was not utf8"))\n    }\n}'], 'encode::EncodeSliceError': ['Clone', 'Debug', 'Eq', 'PartialEq', 'impl error::Error for EncodeSliceError {}', 'impl fmt::Display for EncodeSliceError {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match self {\n            Self::OutputSliceTooSmall => write!(f, "Output slice too small"),\n        }\n    }\n}'], 'engine::DecodeMetadata': ['Debug', 'Eq', 'PartialEq', 'impl DecodeMetadata {\n    pub(crate) fn new(decoded_bytes: usize, padding_index: Option<usize>) -> Self {\n        Self {\n            decoded_len: decoded_bytes,\n            padding_offset: padding_index,\n        }\n    }\n}'], 'engine::DecodePaddingMode': ['Clone', 'Copy', 'Debug', 'Eq', 'PartialEq'], 'engine::general_purpose::GeneralPurpose': ['Clone', 'Debug', 'impl GeneralPurpose {\n    /// Create a `GeneralPurpose` engine from an [Alphabet].\n    ///\n    /// While not very expensive to initialize, ideally these should be cached\n    /// if the engine will be used repeatedly.\n    #[must_use]\n    pub const fn new(alphabet: &Alphabet, config: GeneralPurposeConfig) -> Self {\n        Self {\n            encode_table: encode_table(alphabet),\n            decode_table: decode_table(alphabet),\n            config,\n        }\n    }\n}', "impl super::Engine for GeneralPurpose {\n    type Config = GeneralPurposeConfig;\n    type DecodeEstimate = GeneralPurposeEstimate;\n\n    fn internal_encode(&self, input: &[u8], output: &mut [u8]) -> usize {\n        let mut input_index: usize = 0;\n\n        const BLOCKS_PER_FAST_LOOP: usize = 4;\n        const LOW_SIX_BITS: u64 = 0x3F;\n\n        // we read 8 bytes at a time (u64) but only actually consume 6 of those bytes. Thus, we need\n        // 2 trailing bytes to be available to read..\n        let last_fast_index = input.len().saturating_sub(BLOCKS_PER_FAST_LOOP * 6 + 2);\n        let mut output_index = 0;\n\n        if last_fast_index > 0 {\n            while input_index <= last_fast_index {\n                // Major performance wins from letting the optimizer do the bounds check once, mostly\n                // on the output side\n                let input_chunk =\n                    &input[input_index..(input_index + (BLOCKS_PER_FAST_LOOP * 6 + 2))];\n                let output_chunk =\n                    &mut output[output_index..(output_index + BLOCKS_PER_FAST_LOOP * 8)];\n\n                // Hand-unrolling for 32 vs 16 or 8 bytes produces yields performance about equivalent\n                // to unsafe pointer code on a Xeon E5-1650v3. 64 byte unrolling was slightly better for\n                // large inputs but significantly worse for 50-byte input, unsurprisingly. I suspect\n                // that it's a not uncommon use case to encode smallish chunks of data (e.g. a 64-byte\n                // SHA-512 digest), so it would be nice if that fit in the unrolled loop at least once.\n                // Plus, single-digit percentage performance differences might well be quite different\n                // on different hardware.\n\n                let input_u64 = read_u64(&input_chunk[0..]);\n\n                output_chunk[0] = self.encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];\n                output_chunk[1] = self.encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];\n                output_chunk[2] = self.encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];\n                output_chunk[3] = self.encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];\n                output_chunk[4] = self.encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];\n                output_chunk[5] = self.encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];\n                output_chunk[6] = self.encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];\n                output_chunk[7] = self.encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];\n\n                let input_u64 = read_u64(&input_chunk[6..]);\n\n                output_chunk[8] = self.encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];\n                output_chunk[9] = self.encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];\n                output_chunk[10] = self.encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];\n                output_chunk[11] = self.encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];\n                output_chunk[12] = self.encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];\n                output_chunk[13] = self.encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];\n                output_chunk[14] = self.encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];\n                output_chunk[15] = self.encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];\n\n                let input_u64 = read_u64(&input_chunk[12..]);\n\n                output_chunk[16] = self.encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];\n                output_chunk[17] = self.encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];\n                output_chunk[18] = self.encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];\n                output_chunk[19] = self.encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];\n                output_chunk[20] = self.encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];\n                output_chunk[21] = self.encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];\n                output_chunk[22] = self.encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];\n                output_chunk[23] = self.encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];\n\n                let input_u64 = read_u64(&input_chunk[18..]);\n\n                output_chunk[24] = self.encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];\n                output_chunk[25] = self.encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];\n                output_chunk[26] = self.encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];\n                output_chunk[27] = self.encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];\n                output_chunk[28] = self.encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];\n                output_chunk[29] = self.encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];\n                output_chunk[30] = self.encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];\n                output_chunk[31] = self.encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];\n\n                output_index += BLOCKS_PER_FAST_LOOP * 8;\n                input_index += BLOCKS_PER_FAST_LOOP * 6;\n            }\n        }\n\n        // Encode what's left after the fast loop.\n\n        const LOW_SIX_BITS_U8: u8 = 0x3F;\n\n        let rem = input.len() % 3;\n        let start_of_rem = input.len() - rem;\n\n        // start at the first index not handled by fast loop, which may be 0.\n\n        while input_index < start_of_rem {\n            let input_chunk = &input[input_index..(input_index + 3)];\n            let output_chunk = &mut output[output_index..(output_index + 4)];\n\n            output_chunk[0] = self.encode_table[(input_chunk[0] >> 2) as usize];\n            output_chunk[1] = self.encode_table\n                [((input_chunk[0] << 4 | input_chunk[1] >> 4) & LOW_SIX_BITS_U8) as usize];\n            output_chunk[2] = self.encode_table\n                [((input_chunk[1] << 2 | input_chunk[2] >> 6) & LOW_SIX_BITS_U8) as usize];\n            output_chunk[3] = self.encode_table[(input_chunk[2] & LOW_SIX_BITS_U8) as usize];\n\n            input_index += 3;\n            output_index += 4;\n        }\n\n        if rem == 2 {\n            output[output_index] = self.encode_table[(input[start_of_rem] >> 2) as usize];\n            output[output_index + 1] =\n                self.encode_table[((input[start_of_rem] << 4 | input[start_of_rem + 1] >> 4)\n                    & LOW_SIX_BITS_U8) as usize];\n            output[output_index + 2] =\n                self.encode_table[((input[start_of_rem + 1] << 2) & LOW_SIX_BITS_U8) as usize];\n            output_index += 3;\n        } else if rem == 1 {\n            output[output_index] = self.encode_table[(input[start_of_rem] >> 2) as usize];\n            output[output_index + 1] =\n                self.encode_table[((input[start_of_rem] << 4) & LOW_SIX_BITS_U8) as usize];\n            output_index += 2;\n        }\n\n        output_index\n    }\n\n    fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {\n        GeneralPurposeEstimate::new(input_len)\n    }\n\n    fn internal_decode(\n        &self,\n        input: &[u8],\n        output: &mut [u8],\n        estimate: Self::DecodeEstimate,\n    ) -> Result<DecodeMetadata, DecodeSliceError> {\n        decode::decode_helper(\n            input,\n            &estimate,\n            output,\n            &self.decode_table,\n            self.config.decode_allow_trailing_bits,\n            self.config.decode_padding_mode,\n        )\n    }\n\n    fn config(&self) -> &Self::Config {\n        &self.config\n    }\n}"], 'engine::general_purpose::GeneralPurposeConfig': ['Clone', 'Copy', 'Debug', 'impl Config for GeneralPurposeConfig {\n    fn encode_padding(&self) -> bool {\n        self.encode_padding\n    }\n}', 'impl Default for GeneralPurposeConfig {\n    /// Delegates to [`GeneralPurposeConfig::new`].\n    fn default() -> Self {\n        Self::new()\n    }\n}', 'impl GeneralPurposeConfig {\n    /// Create a new config with `padding` = `true`, `decode_allow_trailing_bits` = `false`, and\n    /// `decode_padding_mode = DecodePaddingMode::RequireCanonicalPadding`.\n    ///\n    /// This probably matches most people\'s expectations, but consider disabling padding to save\n    /// a few bytes unless you specifically need it for compatibility with some legacy system.\n    #[must_use]\n    pub const fn new() -> Self {\n        Self {\n            // RFC states that padding must be applied by default\n            encode_padding: true,\n            decode_allow_trailing_bits: false,\n            decode_padding_mode: DecodePaddingMode::RequireCanonical,\n        }\n    }\n\n    /// Create a new config based on `self` with an updated `padding` setting.\n    ///\n    /// If `padding` is `true`, encoding will append either 1 or 2 `=` padding characters as needed\n    /// to produce an output whose length is a multiple of 4.\n    ///\n    /// Padding is not needed for correct decoding and only serves to waste bytes, but it\'s in the\n    /// [spec](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2).\n    ///\n    /// For new applications, consider not using padding if the decoders you\'re using don\'t require\n    /// padding to be present.\n    #[must_use]\n    pub const fn with_encode_padding(self, padding: bool) -> Self {\n        Self {\n            encode_padding: padding,\n            ..self\n        }\n    }\n\n    /// Create a new config based on `self` with an updated `decode_allow_trailing_bits` setting.\n    ///\n    /// Most users will not need to configure this. It\'s useful if you need to decode base64\n    /// produced by a buggy encoder that has bits set in the unused space on the last base64\n    /// character as per [forgiving-base64 decode](https://infra.spec.whatwg.org/#forgiving-base64-decode).\n    /// If invalid trailing bits are present and this is `true`, those bits will\n    /// be silently ignored, else `DecodeError::InvalidLastSymbol` will be emitted.\n    #[must_use]\n    pub const fn with_decode_allow_trailing_bits(self, allow: bool) -> Self {\n        Self {\n            decode_allow_trailing_bits: allow,\n            ..self\n        }\n    }\n\n    /// Create a new config based on `self` with an updated `decode_padding_mode` setting.\n    ///\n    /// Padding is not useful in terms of representing encoded data -- it makes no difference to\n    /// the decoder if padding is present or not, so if you have some un-padded input to decode, it\n    /// is perfectly fine to use `DecodePaddingMode::Indifferent` to prevent errors from being\n    /// emitted.\n    ///\n    /// However, since in practice\n    /// [people who learned nothing from BER vs DER seem to expect base64 to have one canonical encoding](https://eprint.iacr.org/2022/361),\n    /// the default setting is the stricter `DecodePaddingMode::RequireCanonicalPadding`.\n    ///\n    /// Or, if "canonical" in your circumstance means _no_ padding rather than padding to the\n    /// next multiple of four, there\'s `DecodePaddingMode::RequireNoPadding`.\n    #[must_use]\n    pub const fn with_decode_padding_mode(self, mode: DecodePaddingMode) -> Self {\n        Self {\n            decode_padding_mode: mode,\n            ..self\n        }\n    }\n}'], 'engine::general_purpose::decode::GeneralPurposeEstimate': ['impl DecodeEstimate for GeneralPurposeEstimate {\n    fn decoded_len_estimate(&self) -> usize {\n        self.conservative_decoded_len\n    }\n}', 'impl GeneralPurposeEstimate {\n    pub(crate) fn new(encoded_len: usize) -> Self {\n        let rem = encoded_len % 4;\n        Self {\n            rem,\n            conservative_decoded_len: (encoded_len / 4 + usize::from(rem > 0)) * 3,\n        }\n    }\n}'], 'read::decoder::DecoderReader': ['impl<\'e, E: Engine, R: io::Read> DecoderReader<\'e, E, R> {\n    /// Create a new decoder that will read from the provided reader `r`.\n    pub fn new(reader: R, engine: &\'e E) -> Self {\n        DecoderReader {\n            engine,\n            inner: reader,\n            b64_buffer: [0; BUF_SIZE],\n            b64_offset: 0,\n            b64_len: 0,\n            decoded_chunk_buffer: [0; DECODED_CHUNK_SIZE],\n            decoded_offset: 0,\n            decoded_len: 0,\n            input_consumed_len: 0,\n            padding_offset: None,\n        }\n    }\n\n    /// Write as much as possible of the decoded buffer into the target buffer.\n    /// Must only be called when there is something to write and space to write into.\n    /// Returns a Result with the number of (decoded) bytes copied.\n    fn flush_decoded_buf(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        debug_assert!(self.decoded_len > 0);\n        debug_assert!(!buf.is_empty());\n\n        let copy_len = cmp::min(self.decoded_len, buf.len());\n        debug_assert!(copy_len > 0);\n        debug_assert!(copy_len <= self.decoded_len);\n\n        buf[..copy_len].copy_from_slice(\n            &self.decoded_chunk_buffer[self.decoded_offset..self.decoded_offset + copy_len],\n        );\n\n        self.decoded_offset += copy_len;\n        self.decoded_len -= copy_len;\n\n        debug_assert!(self.decoded_len < DECODED_CHUNK_SIZE);\n\n        Ok(copy_len)\n    }\n\n    /// Read into the remaining space in the buffer after the current contents.\n    /// Must only be called when there is space to read into in the buffer.\n    /// Returns the number of bytes read.\n    fn read_from_delegate(&mut self) -> io::Result<usize> {\n        debug_assert!(self.b64_offset + self.b64_len < BUF_SIZE);\n\n        let read = self\n            .inner\n            .read(&mut self.b64_buffer[self.b64_offset + self.b64_len..])?;\n        self.b64_len += read;\n\n        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);\n\n        Ok(read)\n    }\n\n    /// Decode the requested number of bytes from the b64 buffer into the provided buffer. It\'s the\n    /// caller\'s responsibility to choose the number of b64 bytes to decode correctly.\n    ///\n    /// Returns a Result with the number of decoded bytes written to `buf`.\n    ///\n    /// # Panics\n    ///\n    /// panics if `buf` is too small\n    fn decode_to_buf(&mut self, b64_len_to_decode: usize, buf: &mut [u8]) -> io::Result<usize> {\n        debug_assert!(self.b64_len >= b64_len_to_decode);\n        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);\n        debug_assert!(!buf.is_empty());\n\n        let b64_to_decode = &self.b64_buffer[self.b64_offset..self.b64_offset + b64_len_to_decode];\n        let decode_metadata = self\n            .engine\n            .internal_decode(\n                b64_to_decode,\n                buf,\n                self.engine.internal_decoded_len_estimate(b64_len_to_decode),\n            )\n            .map_err(|dse| match dse {\n                DecodeSliceError::DecodeError(de) => {\n                    match de {\n                        DecodeError::InvalidByte(offset, byte) => {\n                            match (byte, self.padding_offset) {\n                                // if there was padding in a previous block of decoding that happened to\n                                // be correct, and we now find more padding that happens to be incorrect,\n                                // to be consistent with non-reader decodes, record the error at the first\n                                // padding\n                                (PAD_BYTE, Some(first_pad_offset)) => {\n                                    DecodeError::InvalidByte(first_pad_offset, PAD_BYTE)\n                                }\n                                _ => {\n                                    DecodeError::InvalidByte(self.input_consumed_len + offset, byte)\n                                }\n                            }\n                        }\n                        DecodeError::InvalidLength(len) => {\n                            DecodeError::InvalidLength(self.input_consumed_len + len)\n                        }\n                        DecodeError::InvalidLastSymbol(offset, byte) => {\n                            DecodeError::InvalidLastSymbol(self.input_consumed_len + offset, byte)\n                        }\n                        DecodeError::InvalidPadding => DecodeError::InvalidPadding,\n                    }\n                }\n                DecodeSliceError::OutputSliceTooSmall => {\n                    unreachable!("buf is sized correctly in calling code")\n                }\n            })\n            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;\n\n        if let Some(offset) = self.padding_offset {\n            // we\'ve already seen padding\n            if decode_metadata.decoded_len > 0 {\n                // we read more after already finding padding; report error at first padding byte\n                return Err(io::Error::new(\n                    io::ErrorKind::InvalidData,\n                    DecodeError::InvalidByte(offset, PAD_BYTE),\n                ));\n            }\n        }\n\n        self.padding_offset = self.padding_offset.or(decode_metadata\n            .padding_offset\n            .map(|offset| self.input_consumed_len + offset));\n        self.input_consumed_len += b64_len_to_decode;\n        self.b64_offset += b64_len_to_decode;\n        self.b64_len -= b64_len_to_decode;\n\n        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);\n\n        Ok(decode_metadata.decoded_len)\n    }\n\n    /// Unwraps this `DecoderReader`, returning the base reader which it reads base64 encoded\n    /// input from.\n    ///\n    /// Because `DecoderReader` performs internal buffering, the state of the inner reader is\n    /// unspecified. This function is mainly provided because the inner reader type may provide\n    /// additional functionality beyond the `Read` implementation which may still be useful.\n    pub fn into_inner(self) -> R {\n        self.inner\n    }\n}', 'impl<\'e, E: Engine, R: io::Read> fmt::Debug for DecoderReader<\'e, E, R> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct("DecoderReader")\n            .field("b64_offset", &self.b64_offset)\n            .field("b64_len", &self.b64_len)\n            .field("decoded_chunk_buffer", &self.decoded_chunk_buffer)\n            .field("decoded_offset", &self.decoded_offset)\n            .field("decoded_len", &self.decoded_len)\n            .field("input_consumed_len", &self.input_consumed_len)\n            .field("padding_offset", &self.padding_offset)\n            .finish()\n    }\n}', 'impl<\'e, E: Engine, R: io::Read> io::Read for DecoderReader<\'e, E, R> {\n    /// Decode input from the wrapped reader.\n    ///\n    /// Under non-error circumstances, this returns `Ok` with the value being the number of bytes\n    /// written in `buf`.\n    ///\n    /// Where possible, this function buffers base64 to minimize the number of `read()` calls to the\n    /// delegate reader.\n    ///\n    /// # Errors\n    ///\n    /// Any errors emitted by the delegate reader are returned. Decoding errors due to invalid\n    /// base64 are also possible, and will have `io::ErrorKind::InvalidData`.\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        if buf.is_empty() {\n            return Ok(0);\n        }\n\n        // offset == BUF_SIZE when we copied it all last time\n        debug_assert!(self.b64_offset <= BUF_SIZE);\n        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);\n        debug_assert!(if self.b64_offset == BUF_SIZE {\n            self.b64_len == 0\n        } else {\n            self.b64_len <= BUF_SIZE\n        });\n\n        debug_assert!(if self.decoded_len == 0 {\n            // can be = when we were able to copy the complete chunk\n            self.decoded_offset <= DECODED_CHUNK_SIZE\n        } else {\n            self.decoded_offset < DECODED_CHUNK_SIZE\n        });\n\n        // We shouldn\'t ever decode into decoded_buffer when we can\'t immediately write at least one\n        // byte into the provided buf, so the effective length should only be 3 momentarily between\n        // when we decode and when we copy into the target buffer.\n        debug_assert!(self.decoded_len < DECODED_CHUNK_SIZE);\n        debug_assert!(self.decoded_len + self.decoded_offset <= DECODED_CHUNK_SIZE);\n\n        if self.decoded_len > 0 {\n            // we have a few leftover decoded bytes; flush that rather than pull in more b64\n            self.flush_decoded_buf(buf)\n        } else {\n            let mut at_eof = false;\n            while self.b64_len < BASE64_CHUNK_SIZE {\n                // Copy any bytes we have to the start of the buffer.\n                self.b64_buffer\n                    .copy_within(self.b64_offset..self.b64_offset + self.b64_len, 0);\n                self.b64_offset = 0;\n\n                // then fill in more data\n                let read = self.read_from_delegate()?;\n                if read == 0 {\n                    // we never read into an empty buf, so 0 => we\'ve hit EOF\n                    at_eof = true;\n                    break;\n                }\n            }\n\n            if self.b64_len == 0 {\n                debug_assert!(at_eof);\n                // we must be at EOF, and we have no data left to decode\n                return Ok(0);\n            };\n\n            debug_assert!(if at_eof {\n                // if we are at eof, we may not have a complete chunk\n                self.b64_len > 0\n            } else {\n                // otherwise, we must have at least one chunk\n                self.b64_len >= BASE64_CHUNK_SIZE\n            });\n\n            debug_assert_eq!(0, self.decoded_len);\n\n            if buf.len() < DECODED_CHUNK_SIZE {\n                // caller requested an annoyingly short read\n                // have to write to a tmp buf first to avoid double mutable borrow\n                let mut decoded_chunk = [0_u8; DECODED_CHUNK_SIZE];\n                // if we are at eof, could have less than BASE64_CHUNK_SIZE, in which case we have\n                // to assume that these last few tokens are, in fact, valid (i.e. must be 2-4 b64\n                // tokens, not 1, since 1 token can\'t decode to 1 byte).\n                let to_decode = cmp::min(self.b64_len, BASE64_CHUNK_SIZE);\n\n                let decoded = self.decode_to_buf(to_decode, &mut decoded_chunk[..])?;\n                self.decoded_chunk_buffer[..decoded].copy_from_slice(&decoded_chunk[..decoded]);\n\n                self.decoded_offset = 0;\n                self.decoded_len = decoded;\n\n                // can be less than 3 on last block due to padding\n                debug_assert!(decoded <= 3);\n\n                self.flush_decoded_buf(buf)\n            } else {\n                let b64_bytes_that_can_decode_into_buf = (buf.len() / DECODED_CHUNK_SIZE)\n                    .checked_mul(BASE64_CHUNK_SIZE)\n                    .expect("too many chunks");\n                debug_assert!(b64_bytes_that_can_decode_into_buf >= BASE64_CHUNK_SIZE);\n\n                let b64_bytes_available_to_decode = if at_eof {\n                    self.b64_len\n                } else {\n                    // only use complete chunks\n                    self.b64_len - self.b64_len % 4\n                };\n\n                let actual_decode_len = cmp::min(\n                    b64_bytes_that_can_decode_into_buf,\n                    b64_bytes_available_to_decode,\n                );\n                self.decode_to_buf(actual_decode_len, buf)\n            }\n        }\n    }\n}'], 'std::string::String': ['impl StrConsumer for String {\n    fn consume(&mut self, buf: &str) {\n        self.push_str(buf);\n    }\n}'], 'write::encoder::EncoderWriter': ["impl<'e, E: Engine, W: io::Write> Drop for EncoderWriter<'e, E, W> {\n    fn drop(&mut self) {\n        if !self.panicked {\n            // like `BufWriter`, ignore errors during drop\n            let _ = self.write_final_leftovers();\n        }\n    }\n}", 'impl<\'e, E: Engine, W: io::Write> EncoderWriter<\'e, E, W> {\n    /// Create a new encoder that will write to the provided delegate writer.\n    pub fn new(delegate: W, engine: &\'e E) -> EncoderWriter<\'e, E, W> {\n        EncoderWriter {\n            engine,\n            delegate: Some(delegate),\n            extra_input: [0u8; MIN_ENCODE_CHUNK_SIZE],\n            extra_input_occupied_len: 0,\n            output: [0u8; BUF_SIZE],\n            output_occupied_len: 0,\n            panicked: false,\n        }\n    }\n\n    /// Encode all remaining buffered data and write it, including any trailing incomplete input\n    /// triples and associated padding.\n    ///\n    /// Once this succeeds, no further writes or calls to this method are allowed.\n    ///\n    /// This may write to the delegate writer multiple times if the delegate writer does not accept\n    /// all input provided to its `write` each invocation.\n    ///\n    /// If you don\'t care about error handling, it is not necessary to call this function, as the\n    /// equivalent finalization is done by the Drop impl.\n    ///\n    /// Returns the writer that this was constructed around.\n    ///\n    /// # Errors\n    ///\n    /// The first error that is not of `ErrorKind::Interrupted` will be returned.\n    pub fn finish(&mut self) -> Result<W> {\n        // If we could consume self in finish(), we wouldn\'t have to worry about this case, but\n        // finish() is retryable in the face of I/O errors, so we can\'t consume here.\n        assert!(\n            self.delegate.is_some(),\n            "Encoder has already had finish() called"\n        );\n\n        self.write_final_leftovers()?;\n\n        let writer = self.delegate.take().expect("Writer must be present");\n\n        Ok(writer)\n    }\n\n    /// Write any remaining buffered data to the delegate writer.\n    fn write_final_leftovers(&mut self) -> Result<()> {\n        if self.delegate.is_none() {\n            // finish() has already successfully called this, and we are now in drop() with a None\n            // writer, so just no-op\n            return Ok(());\n        }\n\n        self.write_all_encoded_output()?;\n\n        if self.extra_input_occupied_len > 0 {\n            let encoded_len = self\n                .engine\n                .encode_slice(\n                    &self.extra_input[..self.extra_input_occupied_len],\n                    &mut self.output[..],\n                )\n                .expect("buffer is large enough");\n\n            self.output_occupied_len = encoded_len;\n\n            self.write_all_encoded_output()?;\n\n            // write succeeded, do not write the encoding of extra again if finish() is retried\n            self.extra_input_occupied_len = 0;\n        }\n\n        Ok(())\n    }\n\n    /// Write as much of the encoded output to the delegate writer as it will accept, and store the\n    /// leftovers to be attempted at the next `write()` call. Updates `self.output_occupied_len`.\n    ///\n    /// # Errors\n    ///\n    /// Errors from the delegate writer are returned. In the case of an error,\n    /// `self.output_occupied_len` will not be updated, as errors from `write` are specified to mean\n    /// that no write took place.\n    fn write_to_delegate(&mut self, current_output_len: usize) -> Result<()> {\n        self.panicked = true;\n        let res = self\n            .delegate\n            .as_mut()\n            .expect("Writer must be present")\n            .write(&self.output[..current_output_len]);\n        self.panicked = false;\n\n        res.map(|consumed| {\n            debug_assert!(consumed <= current_output_len);\n\n            if consumed < current_output_len {\n                self.output_occupied_len = current_output_len.checked_sub(consumed).unwrap();\n                // If we\'re blocking on I/O, the minor inefficiency of copying bytes to the\n                // start of the buffer is the least of our concerns...\n                // TODO Rotate moves more than we need to; copy_within now stable.\n                self.output.rotate_left(consumed);\n            } else {\n                self.output_occupied_len = 0;\n            }\n        })\n    }\n\n    /// Write all buffered encoded output. If this returns `Ok`, `self.output_occupied_len` is `0`.\n    ///\n    /// This is basically `write_all` for the remaining buffered data but without the undesirable\n    /// abort-on-`Ok(0)` behavior.\n    ///\n    /// # Errors\n    ///\n    /// Any error emitted by the delegate writer abort the write loop and is returned, unless it\'s\n    /// `Interrupted`, in which case the error is ignored and writes will continue.\n    fn write_all_encoded_output(&mut self) -> Result<()> {\n        while self.output_occupied_len > 0 {\n            let remaining_len = self.output_occupied_len;\n            match self.write_to_delegate(remaining_len) {\n                // try again on interrupts ala write_all\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                // other errors return\n                Err(e) => return Err(e),\n                // success no-ops because remaining length is already updated\n                Ok(()) => {}\n            };\n        }\n\n        debug_assert_eq!(0, self.output_occupied_len);\n        Ok(())\n    }\n\n    /// Unwraps this `EncoderWriter`, returning the base writer it writes base64 encoded output\n    /// to.\n    ///\n    /// Normally this method should not be needed, since `finish()` returns the inner writer if\n    /// it completes successfully. That will also ensure all data has been flushed, which the\n    /// `into_inner()` function does *not* do.\n    ///\n    /// Calling this method after `finish()` has completed successfully will panic, since the\n    /// writer has already been returned.\n    ///\n    /// This method may be useful if the writer implements additional APIs beyond the `Write`\n    /// trait. Note that the inner writer might be in an error state or have an incomplete\n    /// base64 string written to it.\n    pub fn into_inner(mut self) -> W {\n        self.delegate\n            .take()\n            .expect("Encoder has already had finish() called")\n    }\n}', 'impl<\'e, E: Engine, W: io::Write> fmt::Debug for EncoderWriter<\'e, E, W> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            "extra_input: {:?} extra_input_occupied_len:{:?} output[..5]: {:?} output_occupied_len: {:?}",\n            self.extra_input,\n            self.extra_input_occupied_len,\n            &self.output[0..5],\n            self.output_occupied_len\n        )\n    }\n}', 'impl<\'e, E: Engine, W: io::Write> io::Write for EncoderWriter<\'e, E, W> {\n    /// Encode input and then write to the delegate writer.\n    ///\n    /// Under non-error circumstances, this returns `Ok` with the value being the number of bytes\n    /// of `input` consumed. The value may be `0`, which interacts poorly with `write_all`, which\n    /// interprets `Ok(0)` as an error, despite it being allowed by the contract of `write`. See\n    /// <https://github.com/rust-lang/rust/issues/56889> for more on that.\n    ///\n    /// If the previous call to `write` provided more (encoded) data than the delegate writer could\n    /// accept in a single call to its `write`, the remaining data is buffered. As long as buffered\n    /// data is present, subsequent calls to `write` will try to write the remaining buffered data\n    /// to the delegate and return either `Ok(0)` -- and therefore not consume any of `input` -- or\n    /// an error.\n    ///\n    /// # Errors\n    ///\n    /// Any errors emitted by the delegate writer are returned.\n    fn write(&mut self, input: &[u8]) -> Result<usize> {\n        assert!(\n            self.delegate.is_some(),\n            "Cannot write more after calling finish()"\n        );\n\n        if input.is_empty() {\n            return Ok(0);\n        }\n\n        // The contract of `Write::write` places some constraints on this implementation:\n        // - a call to `write()` represents at most one call to a wrapped `Write`, so we can\'t\n        // iterate over the input and encode multiple chunks.\n        // - Errors mean that "no bytes were written to this writer", so we need to reset the\n        // internal state to what it was before the error occurred\n\n        // before reading any input, write any leftover encoded output from last time\n        if self.output_occupied_len > 0 {\n            let current_len = self.output_occupied_len;\n            return self\n                .write_to_delegate(current_len)\n                // did not read any input\n                .map(|()| 0);\n        }\n\n        debug_assert_eq!(0, self.output_occupied_len);\n\n        // how many bytes, if any, were read into `extra` to create a triple to encode\n        let mut extra_input_read_len = 0;\n        let mut input = input;\n\n        let orig_extra_len = self.extra_input_occupied_len;\n\n        let mut encoded_size = 0;\n        // always a multiple of MIN_ENCODE_CHUNK_SIZE\n        let mut max_input_len = MAX_INPUT_LEN;\n\n        // process leftover un-encoded input from last write\n        if self.extra_input_occupied_len > 0 {\n            debug_assert!(self.extra_input_occupied_len < 3);\n            if input.len() + self.extra_input_occupied_len >= MIN_ENCODE_CHUNK_SIZE {\n                // Fill up `extra`, encode that into `output`, and consume as much of the rest of\n                // `input` as possible.\n                // We could write just the encoding of `extra` by itself but then we\'d have to\n                // return after writing only 4 bytes, which is inefficient if the underlying writer\n                // would make a syscall.\n                extra_input_read_len = MIN_ENCODE_CHUNK_SIZE - self.extra_input_occupied_len;\n                debug_assert!(extra_input_read_len > 0);\n                // overwrite only bytes that weren\'t already used. If we need to rollback extra_len\n                // (when the subsequent write errors), the old leading bytes will still be there.\n                self.extra_input[self.extra_input_occupied_len..MIN_ENCODE_CHUNK_SIZE]\n                    .copy_from_slice(&input[0..extra_input_read_len]);\n\n                let len = self.engine.internal_encode(\n                    &self.extra_input[0..MIN_ENCODE_CHUNK_SIZE],\n                    &mut self.output[..],\n                );\n                debug_assert_eq!(4, len);\n\n                input = &input[extra_input_read_len..];\n\n                // consider extra to be used up, since we encoded it\n                self.extra_input_occupied_len = 0;\n                // don\'t clobber where we just encoded to\n                encoded_size = 4;\n                // and don\'t read more than can be encoded\n                max_input_len = MAX_INPUT_LEN - MIN_ENCODE_CHUNK_SIZE;\n\n            // fall through to normal encoding\n            } else {\n                // `extra` and `input` are non empty, but `|extra| + |input| < 3`, so there must be\n                // 1 byte in each.\n                debug_assert_eq!(1, input.len());\n                debug_assert_eq!(1, self.extra_input_occupied_len);\n\n                self.extra_input[self.extra_input_occupied_len] = input[0];\n                self.extra_input_occupied_len += 1;\n                return Ok(1);\n            };\n        } else if input.len() < MIN_ENCODE_CHUNK_SIZE {\n            // `extra` is empty, and `input` fits inside it\n            self.extra_input[0..input.len()].copy_from_slice(input);\n            self.extra_input_occupied_len = input.len();\n            return Ok(input.len());\n        };\n\n        // either 0 or 1 complete chunks encoded from extra\n        debug_assert!(encoded_size == 0 || encoded_size == 4);\n        debug_assert!(\n            // didn\'t encode extra input\n            MAX_INPUT_LEN == max_input_len\n                // encoded one triple\n                || MAX_INPUT_LEN == max_input_len + MIN_ENCODE_CHUNK_SIZE\n        );\n\n        // encode complete triples only\n        let input_complete_chunks_len = input.len() - (input.len() % MIN_ENCODE_CHUNK_SIZE);\n        let input_chunks_to_encode_len = cmp::min(input_complete_chunks_len, max_input_len);\n        debug_assert_eq!(0, max_input_len % MIN_ENCODE_CHUNK_SIZE);\n        debug_assert_eq!(0, input_chunks_to_encode_len % MIN_ENCODE_CHUNK_SIZE);\n\n        encoded_size += self.engine.internal_encode(\n            &input[..(input_chunks_to_encode_len)],\n            &mut self.output[encoded_size..],\n        );\n\n        // not updating `self.output_occupied_len` here because if the below write fails, it should\n        // "never take place" -- the buffer contents we encoded are ignored and perhaps retried\n        // later, if the consumer chooses.\n\n        self.write_to_delegate(encoded_size)\n            // no matter whether we wrote the full encoded buffer or not, we consumed the same\n            // input\n            .map(|()| extra_input_read_len + input_chunks_to_encode_len)\n            .map_err(|e| {\n                // in case we filled and encoded `extra`, reset extra_len\n                self.extra_input_occupied_len = orig_extra_len;\n\n                e\n            })\n    }\n\n    /// Because this is usually treated as OK to call multiple times, it will *not* flush any\n    /// incomplete chunks of input or write padding.\n    /// # Errors\n    ///\n    /// The first error that is not of [`ErrorKind::Interrupted`] will be returned.\n    fn flush(&mut self) -> Result<()> {\n        self.write_all_encoded_output()?;\n        self.delegate\n            .as_mut()\n            .expect("Writer must be present")\n            .flush()\n    }\n}'], 'write::encoder_string_writer::EncoderStringWriter': ['impl<\'e, E: Engine, S: StrConsumer> EncoderStringWriter<\'e, E, S> {\n    /// Create a `EncoderStringWriter` that will append to the provided `StrConsumer`.\n    pub fn from_consumer(str_consumer: S, engine: &\'e E) -> Self {\n        EncoderStringWriter {\n            encoder: EncoderWriter::new(Utf8SingleCodeUnitWriter { str_consumer }, engine),\n        }\n    }\n\n    /// Encode all remaining buffered data, including any trailing incomplete input triples and\n    /// associated padding.\n    ///\n    /// Returns the base64-encoded form of the accumulated written data.\n    pub fn into_inner(mut self) -> S {\n        self.encoder\n            .finish()\n            .expect("Writing to a consumer should never fail")\n            .str_consumer\n    }\n}', "impl<'e, E: Engine, S: StrConsumer> io::Write for EncoderStringWriter<'e, E, S> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.encoder.write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.encoder.flush()\n    }\n}", "impl<'e, E: Engine> EncoderStringWriter<'e, E, String> {\n    /// Create a `EncoderStringWriter` that will encode into a new `String` with the provided config.\n    pub fn new(engine: &'e E) -> Self {\n        EncoderStringWriter::from_consumer(String::new(), engine)\n    }\n}"], 'write::encoder_string_writer::Utf8SingleCodeUnitWriter': ['impl<S: StrConsumer> io::Write for Utf8SingleCodeUnitWriter<S> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        // Because we expect all input to be valid utf-8 individual bytes, we can encode any buffer\n        // length\n        let s = std::str::from_utf8(buf).expect("Input must be valid UTF-8");\n\n        self.str_consumer.consume(s);\n\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        // no op\n        Ok(())\n    }\n}']}, 'single_path_import': {'decode::DecodeError': 'DecodeError', 'decode::DecodeSliceError': 'DecodeSliceError', 'decode::decode': 'decode', 'decode::decode_engine': 'decode_engine', 'decode::decode_engine_slice': 'decode_engine_slice', 'decode::decode_engine_vec': 'decode_engine_vec', 'decode::decoded_len_estimate': 'decoded_len_estimate', 'encode::EncodeSliceError': 'EncodeSliceError', 'encode::encode': 'encode', 'encode::encode_engine': 'encode_engine', 'encode::encode_engine_slice': 'encode_engine_slice', 'encode::encode_engine_string': 'encode_engine_string', 'encode::encoded_len': 'encoded_len', 'engine::Engine': 'prelude::Engine', 'engine::general_purpose::GeneralPurpose': 'engine::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig': 'engine::GeneralPurposeConfig', 'engine::general_purpose::STANDARD': 'prelude::STANDARD', 'engine::general_purpose::STANDARD_NO_PAD': 'prelude::STANDARD_NO_PAD', 'engine::general_purpose::URL_SAFE': 'prelude::URL_SAFE', 'engine::general_purpose::URL_SAFE_NO_PAD': 'prelude::URL_SAFE_NO_PAD', 'engine::general_purpose::decode::GeneralPurposeEstimate': 'engine::general_purpose::GeneralPurposeEstimate', 'read::decoder::DecoderReader': 'read::DecoderReader', 'write::encoder::EncoderWriter': 'write::EncoderWriter', 'write::encoder_string_writer::EncoderStringWriter': 'write::EncoderStringWriter', 'write::encoder_string_writer::StrConsumer': 'write::StrConsumer'}, 'srcs': {'<&mut S as write::encoder_string_writer::StrConsumer>::consume': ['fn consume(&mut self, buf: &str){\n        (**self).consume(buf);\n    }', 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], '<alphabet::Alphabet as std::convert::TryFrom<&str>>::try_from': ['fn try_from(value: &str) -> Result<Self, Self::Error>{\n        Self::new(value)\n    }', 'Real(LocalPath("src/alphabet.rs"))'], '<alphabet::ParseAlphabetError as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        match self {\n            Self::InvalidLength => write!(f, "Invalid length - must be 64 bytes"),\n            Self::DuplicatedByte(b) => write!(f, "Duplicated byte: {:#04x}", b),\n            Self::UnprintableByte(b) => write!(f, "Unprintable byte: {:#04x}", b),\n            Self::ReservedByte(b) => write!(f, "Reserved byte: {:#04x}", b),\n        }\n    }', 'Real(LocalPath("src/alphabet.rs"))'], "<chunked_encoder::StringSink<'a> as chunked_encoder::Sink>::write_encoded_bytes": ['fn write_encoded_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error>{\n        self.string.push_str(str::from_utf8(s).unwrap());\n\n        Ok(())\n    }', 'Real(LocalPath("src/chunked_encoder.rs"))'], '<decode::DecodeError as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match *self {\n            Self::InvalidByte(index, byte) => {\n                write!(f, "Invalid symbol {}, offset {}.", byte, index)\n            }\n            Self::InvalidLength(len) => write!(f, "Invalid input length: {}", len),\n            Self::InvalidLastSymbol(index, byte) => {\n                write!(f, "Invalid last symbol {}, offset {}.", byte, index)\n            }\n            Self::InvalidPadding => write!(f, "Invalid padding"),\n        }\n    }', 'Real(LocalPath("src/decode.rs"))'], '<decode::DecodeSliceError as std::convert::From<decode::DecodeError>>::from': ['fn from(e: DecodeError) -> Self{\n        DecodeSliceError::DecodeError(e)\n    }', 'Real(LocalPath("src/decode.rs"))'], '<decode::DecodeSliceError as std::error::Error>::source': ["fn source(&self) -> Option<&(dyn error::Error + 'static)>{\n        match self {\n            DecodeSliceError::DecodeError(e) => Some(e),\n            DecodeSliceError::OutputSliceTooSmall => None,\n        }\n    }", 'Real(LocalPath("src/decode.rs"))'], '<decode::DecodeSliceError as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        match self {\n            Self::DecodeError(e) => write!(f, "DecodeError: {}", e),\n            Self::OutputSliceTooSmall => write!(f, "Output slice too small"),\n        }\n    }', 'Real(LocalPath("src/decode.rs"))'], "<display::Base64Display<'a, 'e, E> as std::fmt::Display>::fmt": ['fn fmt(&self, formatter: &mut Formatter) -> Result<(), fmt::Error>{\n        let mut sink = FormatterSink { f: formatter };\n        self.chunked_encoder.encode(self.bytes, &mut sink)\n    }', 'Real(LocalPath("src/display.rs"))'], "<display::FormatterSink<'a, 'b> as chunked_encoder::Sink>::write_encoded_bytes": ['fn write_encoded_bytes(&mut self, encoded: &[u8]) -> Result<(), Self::Error>{\n        // Avoid unsafe. If max performance is needed, write your own display wrapper that uses\n        // unsafe here to gain about 10-15%.\n        self.f\n            .write_str(str::from_utf8(encoded).expect("base64 data was not utf8"))\n    }', 'Real(LocalPath("src/display.rs"))'], '<encode::EncodeSliceError as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        match self {\n            Self::OutputSliceTooSmall => write!(f, "Output slice too small"),\n        }\n    }', 'Real(LocalPath("src/encode.rs"))'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::config': ['fn config(&self) -> &Self::Config{\n        &self.config\n    }', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_decode': ['fn internal_decode(\n        &self,\n        input: &[u8],\n        output: &mut [u8],\n        estimate: Self::DecodeEstimate,\n    ) -> Result<DecodeMetadata, DecodeSliceError>{\n        decode::decode_helper(\n            input,\n            &estimate,\n            output,\n            &self.decode_table,\n            self.config.decode_allow_trailing_bits,\n            self.config.decode_padding_mode,\n        )\n    }', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_decoded_len_estimate': ['fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate{\n        GeneralPurposeEstimate::new(input_len)\n    }', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_encode': ["fn internal_encode(&self, input: &[u8], output: &mut [u8]) -> usize{\n        let mut input_index: usize = 0;\n\n        const BLOCKS_PER_FAST_LOOP: usize = 4;\n        const LOW_SIX_BITS: u64 = 0x3F;\n\n        // we read 8 bytes at a time (u64) but only actually consume 6 of those bytes. Thus, we need\n        // 2 trailing bytes to be available to read..\n        let last_fast_index = input.len().saturating_sub(BLOCKS_PER_FAST_LOOP * 6 + 2);\n        let mut output_index = 0;\n\n        if last_fast_index > 0 {\n            while input_index <= last_fast_index {\n                // Major performance wins from letting the optimizer do the bounds check once, mostly\n                // on the output side\n                let input_chunk =\n                    &input[input_index..(input_index + (BLOCKS_PER_FAST_LOOP * 6 + 2))];\n                let output_chunk =\n                    &mut output[output_index..(output_index + BLOCKS_PER_FAST_LOOP * 8)];\n\n                // Hand-unrolling for 32 vs 16 or 8 bytes produces yields performance about equivalent\n                // to unsafe pointer code on a Xeon E5-1650v3. 64 byte unrolling was slightly better for\n                // large inputs but significantly worse for 50-byte input, unsurprisingly. I suspect\n                // that it's a not uncommon use case to encode smallish chunks of data (e.g. a 64-byte\n                // SHA-512 digest), so it would be nice if that fit in the unrolled loop at least once.\n                // Plus, single-digit percentage performance differences might well be quite different\n                // on different hardware.\n\n                let input_u64 = read_u64(&input_chunk[0..]);\n\n                output_chunk[0] = self.encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];\n                output_chunk[1] = self.encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];\n                output_chunk[2] = self.encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];\n                output_chunk[3] = self.encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];\n                output_chunk[4] = self.encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];\n                output_chunk[5] = self.encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];\n                output_chunk[6] = self.encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];\n                output_chunk[7] = self.encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];\n\n                let input_u64 = read_u64(&input_chunk[6..]);\n\n                output_chunk[8] = self.encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];\n                output_chunk[9] = self.encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];\n                output_chunk[10] = self.encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];\n                output_chunk[11] = self.encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];\n                output_chunk[12] = self.encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];\n                output_chunk[13] = self.encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];\n                output_chunk[14] = self.encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];\n                output_chunk[15] = self.encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];\n\n                let input_u64 = read_u64(&input_chunk[12..]);\n\n                output_chunk[16] = self.encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];\n                output_chunk[17] = self.encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];\n                output_chunk[18] = self.encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];\n                output_chunk[19] = self.encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];\n                output_chunk[20] = self.encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];\n                output_chunk[21] = self.encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];\n                output_chunk[22] = self.encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];\n                output_chunk[23] = self.encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];\n\n                let input_u64 = read_u64(&input_chunk[18..]);\n\n                output_chunk[24] = self.encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];\n                output_chunk[25] = self.encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];\n                output_chunk[26] = self.encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];\n                output_chunk[27] = self.encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];\n                output_chunk[28] = self.encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];\n                output_chunk[29] = self.encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];\n                output_chunk[30] = self.encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];\n                output_chunk[31] = self.encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];\n\n                output_index += BLOCKS_PER_FAST_LOOP * 8;\n                input_index += BLOCKS_PER_FAST_LOOP * 6;\n            }\n        }\n\n        // Encode what's left after the fast loop.\n\n        const LOW_SIX_BITS_U8: u8 = 0x3F;\n\n        let rem = input.len() % 3;\n        let start_of_rem = input.len() - rem;\n\n        // start at the first index not handled by fast loop, which may be 0.\n\n        while input_index < start_of_rem {\n            let input_chunk = &input[input_index..(input_index + 3)];\n            let output_chunk = &mut output[output_index..(output_index + 4)];\n\n            output_chunk[0] = self.encode_table[(input_chunk[0] >> 2) as usize];\n            output_chunk[1] = self.encode_table\n                [((input_chunk[0] << 4 | input_chunk[1] >> 4) & LOW_SIX_BITS_U8) as usize];\n            output_chunk[2] = self.encode_table\n                [((input_chunk[1] << 2 | input_chunk[2] >> 6) & LOW_SIX_BITS_U8) as usize];\n            output_chunk[3] = self.encode_table[(input_chunk[2] & LOW_SIX_BITS_U8) as usize];\n\n            input_index += 3;\n            output_index += 4;\n        }\n\n        if rem == 2 {\n            output[output_index] = self.encode_table[(input[start_of_rem] >> 2) as usize];\n            output[output_index + 1] =\n                self.encode_table[((input[start_of_rem] << 4 | input[start_of_rem + 1] >> 4)\n                    & LOW_SIX_BITS_U8) as usize];\n            output[output_index + 2] =\n                self.encode_table[((input[start_of_rem + 1] << 2) & LOW_SIX_BITS_U8) as usize];\n            output_index += 3;\n        } else if rem == 1 {\n            output[output_index] = self.encode_table[(input[start_of_rem] >> 2) as usize];\n            output[output_index + 1] =\n                self.encode_table[((input[start_of_rem] << 4) & LOW_SIX_BITS_U8) as usize];\n            output_index += 2;\n        }\n\n        output_index\n    }", 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], '<engine::general_purpose::GeneralPurposeConfig as engine::Config>::encode_padding': ['fn encode_padding(&self) -> bool{\n        self.encode_padding\n    }', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], '<engine::general_purpose::GeneralPurposeConfig as std::default::Default>::default': ['/// Delegates to [`GeneralPurposeConfig::new`].\nfn default() -> Self{\n        Self::new()\n    }', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], '<engine::general_purpose::decode::GeneralPurposeEstimate as engine::DecodeEstimate>::decoded_len_estimate': ['fn decoded_len_estimate(&self) -> usize{\n        self.conservative_decoded_len\n    }', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))'], "<read::decoder::DecoderReader<'e, E, R> as std::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct("DecoderReader")\n            .field("b64_offset", &self.b64_offset)\n            .field("b64_len", &self.b64_len)\n            .field("decoded_chunk_buffer", &self.decoded_chunk_buffer)\n            .field("decoded_offset", &self.decoded_offset)\n            .field("decoded_len", &self.decoded_len)\n            .field("input_consumed_len", &self.input_consumed_len)\n            .field("padding_offset", &self.padding_offset)\n            .finish()\n    }', 'Real(LocalPath("src/read/decoder.rs"))'], "<read::decoder::DecoderReader<'e, E, R> as std::io::Read>::read": ['/// Decode input from the wrapped reader.\n///\n/// Under non-error circumstances, this returns `Ok` with the value being the number of bytes\n/// written in `buf`.\n///\n/// Where possible, this function buffers base64 to minimize the number of `read()` calls to the\n/// delegate reader.\n///\n/// # Errors\n///\n/// Any errors emitted by the delegate reader are returned. Decoding errors due to invalid\n/// base64 are also possible, and will have `io::ErrorKind::InvalidData`.\nfn read(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        if buf.is_empty() {\n            return Ok(0);\n        }\n\n        // offset == BUF_SIZE when we copied it all last time\n        debug_assert!(self.b64_offset <= BUF_SIZE);\n        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);\n        debug_assert!(if self.b64_offset == BUF_SIZE {\n            self.b64_len == 0\n        } else {\n            self.b64_len <= BUF_SIZE\n        });\n\n        debug_assert!(if self.decoded_len == 0 {\n            // can be = when we were able to copy the complete chunk\n            self.decoded_offset <= DECODED_CHUNK_SIZE\n        } else {\n            self.decoded_offset < DECODED_CHUNK_SIZE\n        });\n\n        // We shouldn\'t ever decode into decoded_buffer when we can\'t immediately write at least one\n        // byte into the provided buf, so the effective length should only be 3 momentarily between\n        // when we decode and when we copy into the target buffer.\n        debug_assert!(self.decoded_len < DECODED_CHUNK_SIZE);\n        debug_assert!(self.decoded_len + self.decoded_offset <= DECODED_CHUNK_SIZE);\n\n        if self.decoded_len > 0 {\n            // we have a few leftover decoded bytes; flush that rather than pull in more b64\n            self.flush_decoded_buf(buf)\n        } else {\n            let mut at_eof = false;\n            while self.b64_len < BASE64_CHUNK_SIZE {\n                // Copy any bytes we have to the start of the buffer.\n                self.b64_buffer\n                    .copy_within(self.b64_offset..self.b64_offset + self.b64_len, 0);\n                self.b64_offset = 0;\n\n                // then fill in more data\n                let read = self.read_from_delegate()?;\n                if read == 0 {\n                    // we never read into an empty buf, so 0 => we\'ve hit EOF\n                    at_eof = true;\n                    break;\n                }\n            }\n\n            if self.b64_len == 0 {\n                debug_assert!(at_eof);\n                // we must be at EOF, and we have no data left to decode\n                return Ok(0);\n            };\n\n            debug_assert!(if at_eof {\n                // if we are at eof, we may not have a complete chunk\n                self.b64_len > 0\n            } else {\n                // otherwise, we must have at least one chunk\n                self.b64_len >= BASE64_CHUNK_SIZE\n            });\n\n            debug_assert_eq!(0, self.decoded_len);\n\n            if buf.len() < DECODED_CHUNK_SIZE {\n                // caller requested an annoyingly short read\n                // have to write to a tmp buf first to avoid double mutable borrow\n                let mut decoded_chunk = [0_u8; DECODED_CHUNK_SIZE];\n                // if we are at eof, could have less than BASE64_CHUNK_SIZE, in which case we have\n                // to assume that these last few tokens are, in fact, valid (i.e. must be 2-4 b64\n                // tokens, not 1, since 1 token can\'t decode to 1 byte).\n                let to_decode = cmp::min(self.b64_len, BASE64_CHUNK_SIZE);\n\n                let decoded = self.decode_to_buf(to_decode, &mut decoded_chunk[..])?;\n                self.decoded_chunk_buffer[..decoded].copy_from_slice(&decoded_chunk[..decoded]);\n\n                self.decoded_offset = 0;\n                self.decoded_len = decoded;\n\n                // can be less than 3 on last block due to padding\n                debug_assert!(decoded <= 3);\n\n                self.flush_decoded_buf(buf)\n            } else {\n                let b64_bytes_that_can_decode_into_buf = (buf.len() / DECODED_CHUNK_SIZE)\n                    .checked_mul(BASE64_CHUNK_SIZE)\n                    .expect("too many chunks");\n                debug_assert!(b64_bytes_that_can_decode_into_buf >= BASE64_CHUNK_SIZE);\n\n                let b64_bytes_available_to_decode = if at_eof {\n                    self.b64_len\n                } else {\n                    // only use complete chunks\n                    self.b64_len - self.b64_len % 4\n                };\n\n                let actual_decode_len = cmp::min(\n                    b64_bytes_that_can_decode_into_buf,\n                    b64_bytes_available_to_decode,\n                );\n                self.decode_to_buf(actual_decode_len, buf)\n            }\n        }\n    }', 'Real(LocalPath("src/read/decoder.rs"))'], '<std::string::String as write::encoder_string_writer::StrConsumer>::consume': ['fn consume(&mut self, buf: &str){\n        self.push_str(buf);\n    }', 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], "<write::encoder::EncoderWriter<'e, E, W> as std::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(\n            f,\n            "extra_input: {:?} extra_input_occupied_len:{:?} output[..5]: {:?} output_occupied_len: {:?}",\n            self.extra_input,\n            self.extra_input_occupied_len,\n            &self.output[0..5],\n            self.output_occupied_len\n        )\n    }', 'Real(LocalPath("src/write/encoder.rs"))'], "<write::encoder::EncoderWriter<'e, E, W> as std::io::Write>::flush": ['/// Because this is usually treated as OK to call multiple times, it will *not* flush any\n/// incomplete chunks of input or write padding.\n/// # Errors\n///\n/// The first error that is not of [`ErrorKind::Interrupted`] will be returned.\nfn flush(&mut self) -> Result<()>{\n        self.write_all_encoded_output()?;\n        self.delegate\n            .as_mut()\n            .expect("Writer must be present")\n            .flush()\n    }', 'Real(LocalPath("src/write/encoder.rs"))'], "<write::encoder::EncoderWriter<'e, E, W> as std::io::Write>::write": ['/// Encode input and then write to the delegate writer.\n///\n/// Under non-error circumstances, this returns `Ok` with the value being the number of bytes\n/// of `input` consumed. The value may be `0`, which interacts poorly with `write_all`, which\n/// interprets `Ok(0)` as an error, despite it being allowed by the contract of `write`. See\n/// <https://github.com/rust-lang/rust/issues/56889> for more on that.\n///\n/// If the previous call to `write` provided more (encoded) data than the delegate writer could\n/// accept in a single call to its `write`, the remaining data is buffered. As long as buffered\n/// data is present, subsequent calls to `write` will try to write the remaining buffered data\n/// to the delegate and return either `Ok(0)` -- and therefore not consume any of `input` -- or\n/// an error.\n///\n/// # Errors\n///\n/// Any errors emitted by the delegate writer are returned.\nfn write(&mut self, input: &[u8]) -> Result<usize>{\n        assert!(\n            self.delegate.is_some(),\n            "Cannot write more after calling finish()"\n        );\n\n        if input.is_empty() {\n            return Ok(0);\n        }\n\n        // The contract of `Write::write` places some constraints on this implementation:\n        // - a call to `write()` represents at most one call to a wrapped `Write`, so we can\'t\n        // iterate over the input and encode multiple chunks.\n        // - Errors mean that "no bytes were written to this writer", so we need to reset the\n        // internal state to what it was before the error occurred\n\n        // before reading any input, write any leftover encoded output from last time\n        if self.output_occupied_len > 0 {\n            let current_len = self.output_occupied_len;\n            return self\n                .write_to_delegate(current_len)\n                // did not read any input\n                .map(|()| 0);\n        }\n\n        debug_assert_eq!(0, self.output_occupied_len);\n\n        // how many bytes, if any, were read into `extra` to create a triple to encode\n        let mut extra_input_read_len = 0;\n        let mut input = input;\n\n        let orig_extra_len = self.extra_input_occupied_len;\n\n        let mut encoded_size = 0;\n        // always a multiple of MIN_ENCODE_CHUNK_SIZE\n        let mut max_input_len = MAX_INPUT_LEN;\n\n        // process leftover un-encoded input from last write\n        if self.extra_input_occupied_len > 0 {\n            debug_assert!(self.extra_input_occupied_len < 3);\n            if input.len() + self.extra_input_occupied_len >= MIN_ENCODE_CHUNK_SIZE {\n                // Fill up `extra`, encode that into `output`, and consume as much of the rest of\n                // `input` as possible.\n                // We could write just the encoding of `extra` by itself but then we\'d have to\n                // return after writing only 4 bytes, which is inefficient if the underlying writer\n                // would make a syscall.\n                extra_input_read_len = MIN_ENCODE_CHUNK_SIZE - self.extra_input_occupied_len;\n                debug_assert!(extra_input_read_len > 0);\n                // overwrite only bytes that weren\'t already used. If we need to rollback extra_len\n                // (when the subsequent write errors), the old leading bytes will still be there.\n                self.extra_input[self.extra_input_occupied_len..MIN_ENCODE_CHUNK_SIZE]\n                    .copy_from_slice(&input[0..extra_input_read_len]);\n\n                let len = self.engine.internal_encode(\n                    &self.extra_input[0..MIN_ENCODE_CHUNK_SIZE],\n                    &mut self.output[..],\n                );\n                debug_assert_eq!(4, len);\n\n                input = &input[extra_input_read_len..];\n\n                // consider extra to be used up, since we encoded it\n                self.extra_input_occupied_len = 0;\n                // don\'t clobber where we just encoded to\n                encoded_size = 4;\n                // and don\'t read more than can be encoded\n                max_input_len = MAX_INPUT_LEN - MIN_ENCODE_CHUNK_SIZE;\n\n            // fall through to normal encoding\n            } else {\n                // `extra` and `input` are non empty, but `|extra| + |input| < 3`, so there must be\n                // 1 byte in each.\n                debug_assert_eq!(1, input.len());\n                debug_assert_eq!(1, self.extra_input_occupied_len);\n\n                self.extra_input[self.extra_input_occupied_len] = input[0];\n                self.extra_input_occupied_len += 1;\n                return Ok(1);\n            };\n        } else if input.len() < MIN_ENCODE_CHUNK_SIZE {\n            // `extra` is empty, and `input` fits inside it\n            self.extra_input[0..input.len()].copy_from_slice(input);\n            self.extra_input_occupied_len = input.len();\n            return Ok(input.len());\n        };\n\n        // either 0 or 1 complete chunks encoded from extra\n        debug_assert!(encoded_size == 0 || encoded_size == 4);\n        debug_assert!(\n            // didn\'t encode extra input\n            MAX_INPUT_LEN == max_input_len\n                // encoded one triple\n                || MAX_INPUT_LEN == max_input_len + MIN_ENCODE_CHUNK_SIZE\n        );\n\n        // encode complete triples only\n        let input_complete_chunks_len = input.len() - (input.len() % MIN_ENCODE_CHUNK_SIZE);\n        let input_chunks_to_encode_len = cmp::min(input_complete_chunks_len, max_input_len);\n        debug_assert_eq!(0, max_input_len % MIN_ENCODE_CHUNK_SIZE);\n        debug_assert_eq!(0, input_chunks_to_encode_len % MIN_ENCODE_CHUNK_SIZE);\n\n        encoded_size += self.engine.internal_encode(\n            &input[..(input_chunks_to_encode_len)],\n            &mut self.output[encoded_size..],\n        );\n\n        // not updating `self.output_occupied_len` here because if the below write fails, it should\n        // "never take place" -- the buffer contents we encoded are ignored and perhaps retried\n        // later, if the consumer chooses.\n\n        self.write_to_delegate(encoded_size)\n            // no matter whether we wrote the full encoded buffer or not, we consumed the same\n            // input\n            .map(|()| extra_input_read_len + input_chunks_to_encode_len)\n            .map_err(|e| {\n                // in case we filled and encoded `extra`, reset extra_len\n                self.extra_input_occupied_len = orig_extra_len;\n\n                e\n            })\n    }', 'Real(LocalPath("src/write/encoder.rs"))'], "<write::encoder::EncoderWriter<'e, E, W> as std::ops::Drop>::drop": ['fn drop(&mut self){\n        if !self.panicked {\n            // like `BufWriter`, ignore errors during drop\n            let _ = self.write_final_leftovers();\n        }\n    }', 'Real(LocalPath("src/write/encoder.rs"))'], "<write::encoder_string_writer::EncoderStringWriter<'e, E, S> as std::io::Write>::flush": ['fn flush(&mut self) -> io::Result<()>{\n        self.encoder.flush()\n    }', 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], "<write::encoder_string_writer::EncoderStringWriter<'e, E, S> as std::io::Write>::write": ['fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        self.encoder.write(buf)\n    }', 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], '<write::encoder_string_writer::Utf8SingleCodeUnitWriter<S> as std::io::Write>::flush': ['fn flush(&mut self) -> io::Result<()>{\n        // no op\n        Ok(())\n    }', 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], '<write::encoder_string_writer::Utf8SingleCodeUnitWriter<S> as std::io::Write>::write': ['fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        // Because we expect all input to be valid utf-8 individual bytes, we can encode any buffer\n        // length\n        let s = std::str::from_utf8(buf).expect("Input must be valid UTF-8");\n\n        self.str_consumer.consume(s);\n\n        Ok(buf.len())\n    }', 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], 'alphabet::Alphabet': ['/// An alphabet defines the 64 ASCII characters (symbols) used for base64.\n///\n/// Common alphabets are provided as constants, and custom alphabets\n/// can be made via `from_str` or the `TryFrom<str>` implementation.\n///\n/// # Examples\n///\n/// Building and using a custom Alphabet:\n///\n/// ```\n/// let custom = base64::alphabet::Alphabet::new("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").unwrap();\n///\n/// let engine = base64::engine::GeneralPurpose::new(\n///     &custom,\n///     base64::engine::general_purpose::PAD);\n/// ```\n///\n/// Building a const:\n///\n/// ```\n/// use base64::alphabet::Alphabet;\n///\n/// static CUSTOM: Alphabet = {\n///     // Result::unwrap() isn\'t const yet, but panic!() is OK\n///     match Alphabet::new("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") {\n///         Ok(x) => x,\n///         Err(_) => panic!("creation of alphabet failed"),\n///     }\n/// };\n/// ```\n///\n/// Building lazily:\n///\n/// ```\n/// use base64::{\n///     alphabet::Alphabet,\n///     engine::{general_purpose::GeneralPurpose, GeneralPurposeConfig},\n/// };\n/// use once_cell::sync::Lazy;\n///\n/// static CUSTOM: Lazy<Alphabet> = Lazy::new(||\n///     Alphabet::new("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").unwrap()\n/// );\n/// ```\npub struct Alphabet {\n    pub(crate) symbols: [u8; ALPHABET_SIZE],\n}', 'Real(LocalPath("src/alphabet.rs"))'], 'alphabet::Alphabet::as_str': ['/// Create a `&str` from the symbols in the `Alphabet`\n#[must_use]\npub fn as_str(&self) -> &str{\n        core::str::from_utf8(&self.symbols).unwrap()\n    }', 'Real(LocalPath("src/alphabet.rs"))'], 'alphabet::Alphabet::from_str_unchecked': ["/// Performs no checks so that it can be const.\n/// Used only for known-valid strings.\nconst fn from_str_unchecked(alphabet: &str) -> Self{\n        let mut symbols = [0_u8; ALPHABET_SIZE];\n        let source_bytes = alphabet.as_bytes();\n\n        // a way to copy that's allowed in const fn\n        let mut index = 0;\n        while index < ALPHABET_SIZE {\n            symbols[index] = source_bytes[index];\n            index += 1;\n        }\n\n        Self { symbols }\n    }", 'Real(LocalPath("src/alphabet.rs"))'], 'alphabet::Alphabet::new': ["/// Create an `Alphabet` from a string of 64 unique printable ASCII bytes.\n///\n/// The `=` byte is not allowed as it is used for padding.\npub const fn new(alphabet: &str) -> Result<Self, ParseAlphabetError>{\n        let bytes = alphabet.as_bytes();\n        if bytes.len() != ALPHABET_SIZE {\n            return Err(ParseAlphabetError::InvalidLength);\n        }\n\n        {\n            let mut index = 0;\n            while index < ALPHABET_SIZE {\n                let byte = bytes[index];\n\n                // must be ascii printable. 127 (DEL) is commonly considered printable\n                // for some reason but clearly unsuitable for base64.\n                if !(byte >= 32_u8 && byte <= 126_u8) {\n                    return Err(ParseAlphabetError::UnprintableByte(byte));\n                }\n                // = is assumed to be padding, so cannot be used as a symbol\n                if byte == PAD_BYTE {\n                    return Err(ParseAlphabetError::ReservedByte(byte));\n                }\n\n                // Check for duplicates while staying within what const allows.\n                // It's n^2, but only over 64 hot bytes, and only once, so it's likely in the single digit\n                // microsecond range.\n\n                let mut probe_index = 0;\n                while probe_index < ALPHABET_SIZE {\n                    if probe_index == index {\n                        probe_index += 1;\n                        continue;\n                    }\n\n                    let probe_byte = bytes[probe_index];\n\n                    if byte == probe_byte {\n                        return Err(ParseAlphabetError::DuplicatedByte(byte));\n                    }\n\n                    probe_index += 1;\n                }\n\n                index += 1;\n            }\n        }\n\n        Ok(Self::from_str_unchecked(alphabet))\n    }", 'Real(LocalPath("src/alphabet.rs"))'], 'alphabet::ParseAlphabetError': ['/// Possible errors when constructing an [Alphabet] from a `str`.\npub enum ParseAlphabetError {\n    /// Alphabets must be 64 ASCII bytes\n    InvalidLength,\n    /// All bytes must be unique\n    DuplicatedByte(u8),\n    /// All bytes must be printable (in the range `[32, 126]`).\n    UnprintableByte(u8),\n    /// `=` cannot be used\n    ReservedByte(u8),\n}', 'Real(LocalPath("src/alphabet.rs"))'], 'chunked_encoder::ChunkedEncoder': ["/// A base64 encoder that emits encoded bytes in chunks without heap allocation.\npub struct ChunkedEncoder<'e, E: Engine + ?Sized> {\n    engine: &'e E,\n}", 'Real(LocalPath("src/chunked_encoder.rs"))'], "chunked_encoder::ChunkedEncoder::<'e, E>::encode": ["pub fn encode<S: Sink>(&self, bytes: &[u8], sink: &mut S) -> Result<(), S::Error>{\n        const BUF_SIZE: usize = 1024;\n        const CHUNK_SIZE: usize = BUF_SIZE / 4 * 3;\n\n        let mut buf = [0; BUF_SIZE];\n        for chunk in bytes.chunks(CHUNK_SIZE) {\n            let mut len = self.engine.internal_encode(chunk, &mut buf);\n            if chunk.len() != CHUNK_SIZE && self.engine.config().encode_padding() {\n                // Final, potentially partial, chunk.\n                // Only need to consider if padding is needed on a partial chunk since full chunk\n                // is a multiple of 3, which therefore won't be padded.\n                // Pad output to multiple of four bytes if required by config.\n                len += add_padding(len, &mut buf[len..]);\n            }\n            sink.write_encoded_bytes(&buf[..len])?;\n        }\n\n        Ok(())\n    }", 'Real(LocalPath("src/chunked_encoder.rs"))'], "chunked_encoder::ChunkedEncoder::<'e, E>::new": ["pub fn new(engine: &'e E) -> ChunkedEncoder<'e, E>{\n        ChunkedEncoder { engine }\n    }", 'Real(LocalPath("src/chunked_encoder.rs"))'], 'chunked_encoder::Sink': ["/// The output mechanism for `ChunkedEncoder`'s encoded bytes.\npub trait Sink {\n    type Error;\n\n    /// Handle a chunk of encoded base64 data (as UTF-8 bytes)\n    fn write_encoded_bytes(&mut self, encoded: &[u8]) -> Result<(), Self::Error>;\n}", 'Real(LocalPath("src/chunked_encoder.rs"))'], 'chunked_encoder::StringSink': ['#[cfg(any(feature = "alloc", test))]\npub(crate) struct StringSink<\'a> {\n    string: &\'a mut String,\n}', 'Real(LocalPath("src/chunked_encoder.rs"))'], "chunked_encoder::StringSink::<'a>::new": ['pub(crate) fn new(s: &mut String) -> StringSink{\n        StringSink { string: s }\n    }', 'Real(LocalPath("src/chunked_encoder.rs"))'], 'decode::DecodeError': ["/// Errors that can occur while decoding.\npub enum DecodeError {\n    /// An invalid byte was found in the input. The offset and offending byte are provided.\n    ///\n    /// Padding characters (`=`) interspersed in the encoded form are invalid, as they may only\n    /// be present as the last 0-2 bytes of input.\n    ///\n    /// This error may also indicate that extraneous trailing input bytes are present, causing\n    /// otherwise valid padding to no longer be the last bytes of input.\n    InvalidByte(usize, u8),\n    /// The length of the input, as measured in valid base64 symbols, is invalid.\n    /// There must be 2-4 symbols in the last input quad.\n    InvalidLength(usize),\n    /// The last non-padding input symbol's encoded 6 bits have nonzero bits that will be discarded.\n    /// This is indicative of corrupted or truncated Base64.\n    /// Unlike [`DecodeError::InvalidByte`], which reports symbols that aren't in the alphabet,\n    /// this error is for symbols that are in the alphabet but represent nonsensical encodings.\n    InvalidLastSymbol(usize, u8),\n    /// The nature of the padding was not as configured: absent or incorrect when it must be\n    /// canonical, or present when it must be absent, etc.\n    InvalidPadding,\n}", 'Real(LocalPath("src/decode.rs"))'], 'decode::DecodeSliceError': ['/// Errors that can occur while decoding into a slice.\npub enum DecodeSliceError {\n    /// A [`DecodeError`] occurred\n    DecodeError(DecodeError),\n    /// The provided slice is too small.\n    OutputSliceTooSmall,\n}', 'Real(LocalPath("src/decode.rs"))'], 'decode::decode': ['/// Decode base64 using the [`STANDARD` engine](STANDARD).\n///\n/// See [`Engine::decode`].\n#[deprecated(since = "0.21.0", note = "Use Engine::decode")]\n#[cfg(any(feature = "alloc", test))]\npub fn decode<T: AsRef<[u8]>>(input: T) -> Result<Vec<u8>, DecodeError>{\n    STANDARD.decode(input)\n}', 'Real(LocalPath("src/decode.rs"))'], 'decode::decode_engine': ['/// Decode from string reference as octets using the specified [Engine].\n///\n/// See [`Engine::decode`].\n///Returns a `Result` containing a `Vec<u8>`.\n#[deprecated(since = "0.21.0", note = "Use Engine::decode")]\n#[cfg(any(feature = "alloc", test))]\npub fn decode_engine<E: Engine, T: AsRef<[u8]>>(\n    input: T,\n    engine: &E,\n) -> Result<Vec<u8>, DecodeError>{\n    engine.decode(input)\n}', 'Real(LocalPath("src/decode.rs"))'], 'decode::decode_engine_slice': ['/// Decode the input into the provided output slice.\n///\n/// See [`Engine::decode_slice`].\n#[deprecated(since = "0.21.0", note = "Use Engine::decode_slice")]\npub fn decode_engine_slice<E: Engine, T: AsRef<[u8]>>(\n    input: T,\n    output: &mut [u8],\n    engine: &E,\n) -> Result<usize, DecodeSliceError>{\n    engine.decode_slice(input, output)\n}', 'Real(LocalPath("src/decode.rs"))'], 'decode::decode_engine_vec': ['/// Decode from string reference as octets.\n///\n/// See [`Engine::decode_vec`].\n#[cfg(any(feature = "alloc", test))]\n#[deprecated(since = "0.21.0", note = "Use Engine::decode_vec")]\npub fn decode_engine_vec<E: Engine, T: AsRef<[u8]>>(\n    input: T,\n    buffer: &mut Vec<u8>,\n    engine: &E,\n) -> Result<(), DecodeError>{\n    engine.decode_vec(input, buffer)\n}', 'Real(LocalPath("src/decode.rs"))'], 'decode::decoded_len_estimate': ["/// Returns a conservative estimate of the decoded size of `encoded_len` base64 symbols (rounded up\n/// to the next group of 3 decoded bytes).\n///\n/// The resulting length will be a safe choice for the size of a decode buffer, but may have up to\n/// 2 trailing bytes that won't end up being needed.\n///\n/// # Examples\n///\n/// ```\n/// use base64::decoded_len_estimate;\n///\n/// assert_eq!(3, decoded_len_estimate(1));\n/// assert_eq!(3, decoded_len_estimate(2));\n/// assert_eq!(3, decoded_len_estimate(3));\n/// assert_eq!(3, decoded_len_estimate(4));\n/// // start of the next quad of encoded symbols\n/// assert_eq!(6, decoded_len_estimate(5));\n/// ```\n#[must_use]\npub fn decoded_len_estimate(encoded_len: usize) -> usize{\n    STANDARD\n        .internal_decoded_len_estimate(encoded_len)\n        .decoded_len_estimate()\n}", 'Real(LocalPath("src/decode.rs"))'], 'display::Base64Display': ["/// A convenience wrapper for base64'ing bytes into a format string without heap allocation.\npub struct Base64Display<'a, 'e, E: Engine> {\n    bytes: &'a [u8],\n    chunked_encoder: ChunkedEncoder<'e, E>,\n}", 'Real(LocalPath("src/display.rs"))'], "display::Base64Display::<'a, 'e, E>::new": ["/// Create a `Base64Display` with the provided engine.\npub fn new(bytes: &'a [u8], engine: &'e E) -> Base64Display<'a, 'e, E>{\n        Base64Display {\n            bytes,\n            chunked_encoder: ChunkedEncoder::new(engine),\n        }\n    }", 'Real(LocalPath("src/display.rs"))'], 'display::FormatterSink': ["struct FormatterSink<'a, 'b: 'a> {\n    f: &'a mut Formatter<'b>,\n}", 'Real(LocalPath("src/display.rs"))'], 'encode::EncodeSliceError': ['/// Errors that can occur while encoding into a slice.\npub enum EncodeSliceError {\n    /// The provided slice is too small.\n    OutputSliceTooSmall,\n}', 'Real(LocalPath("src/encode.rs"))'], 'encode::add_padding': ['/// Write padding characters.\n/// `unpadded_output_len` is the size of the unpadded but base64 encoded data.\n/// `output` is the slice where padding should be written, of length at least 2.\n///\n/// Returns the number of padding bytes written.\npub(crate) fn add_padding(unpadded_output_len: usize, output: &mut [u8]) -> usize{\n    let pad_bytes = (4 - (unpadded_output_len % 4)) % 4;\n    // for just a couple bytes, this has better performance than using\n    // .fill(), or iterating over mutable refs, which call memset()\n    #[allow(clippy::needless_range_loop)]\n    for i in 0..pad_bytes {\n        output[i] = PAD_BYTE;\n    }\n\n    pad_bytes\n}', 'Real(LocalPath("src/encode.rs"))'], 'encode::encode': ['/// Encode arbitrary octets as base64 using the [`STANDARD` engine](STANDARD).\n///\n/// See [`Engine::encode`].\n#[allow(unused)]\n#[deprecated(since = "0.21.0", note = "Use Engine::encode")]\n#[cfg(any(feature = "alloc", test))]\npub fn encode<T: AsRef<[u8]>>(input: T) -> String{\n    STANDARD.encode(input)\n}', 'Real(LocalPath("src/encode.rs"))'], 'encode::encode_engine': ['///Encode arbitrary octets as base64 using the provided `Engine` into a new `String`.\n///\n/// See [`Engine::encode`].\n#[allow(unused)]\n#[deprecated(since = "0.21.0", note = "Use Engine::encode")]\n#[cfg(any(feature = "alloc", test))]\npub fn encode_engine<E: Engine, T: AsRef<[u8]>>(input: T, engine: &E) -> String{\n    engine.encode(input)\n}', 'Real(LocalPath("src/encode.rs"))'], 'encode::encode_engine_slice': ['/// Encode arbitrary octets as base64 into a supplied slice.\n///\n/// See [`Engine::encode_slice`].\n#[allow(unused)]\n#[deprecated(since = "0.21.0", note = "Use Engine::encode_slice")]\npub fn encode_engine_slice<E: Engine, T: AsRef<[u8]>>(\n    input: T,\n    output_buf: &mut [u8],\n    engine: &E,\n) -> Result<usize, EncodeSliceError>{\n    engine.encode_slice(input, output_buf)\n}', 'Real(LocalPath("src/encode.rs"))'], 'encode::encode_engine_string': ['///Encode arbitrary octets as base64 into a supplied `String`.\n///\n/// See [`Engine::encode_string`].\n#[allow(unused)]\n#[deprecated(since = "0.21.0", note = "Use Engine::encode_string")]\n#[cfg(any(feature = "alloc", test))]\npub fn encode_engine_string<E: Engine, T: AsRef<[u8]>>(\n    input: T,\n    output_buf: &mut String,\n    engine: &E,\n){\n    engine.encode_string(input, output_buf);\n}', 'Real(LocalPath("src/encode.rs"))'], 'encode::encode_with_padding': ['/// B64-encode and pad (if configured).\n///\n/// This helper exists to avoid recalculating `encoded_size`, which is relatively expensive on short\n/// inputs.\n///\n/// `encoded_size` is the encoded size calculated for `input`.\n///\n/// `output` must be of size `encoded_size`.\n///\n/// All bytes in `output` will be written to since it is exactly the size of the output.\npub(crate) fn encode_with_padding<E: Engine + ?Sized>(\n    input: &[u8],\n    output: &mut [u8],\n    engine: &E,\n    expected_encoded_size: usize,\n){\n    debug_assert_eq!(expected_encoded_size, output.len());\n\n    let b64_bytes_written = engine.internal_encode(input, output);\n\n    let padding_bytes = if engine.config().encode_padding() {\n        add_padding(b64_bytes_written, &mut output[b64_bytes_written..])\n    } else {\n        0\n    };\n\n    let encoded_bytes = b64_bytes_written\n        .checked_add(padding_bytes)\n        .expect("usize overflow when calculating b64 length");\n\n    debug_assert_eq!(expected_encoded_size, encoded_bytes);\n}', 'Real(LocalPath("src/encode.rs"))'], 'encode::encoded_len': ["/// Calculate the base64 encoded length for a given input length, optionally including any\n/// appropriate padding bytes.\n///\n/// Returns `None` if the encoded length can't be represented in `usize`. This will happen for\n/// input lengths in approximately the top quarter of the range of `usize`.\n#[must_use]\npub const fn encoded_len(bytes_len: usize, padding: bool) -> Option<usize>{\n    let rem = bytes_len % 3;\n\n    let complete_input_chunks = bytes_len / 3;\n    // `?` is disallowed in const, and `let Some(_) = _ else` requires 1.65.0, whereas this\n    // messier syntax works on 1.48\n    let complete_chunk_output =\n        if let Some(complete_chunk_output) = complete_input_chunks.checked_mul(4) {\n            complete_chunk_output\n        } else {\n            return None;\n        };\n\n    if rem > 0 {\n        if padding {\n            complete_chunk_output.checked_add(4)\n        } else {\n            let encoded_rem = match rem {\n                1 => 2,\n                // only other possible remainder is 2\n                // can't use a separate _ => unreachable!() in const fns in ancient rust versions\n                _ => 3,\n            };\n            complete_chunk_output.checked_add(encoded_rem)\n        }\n    } else {\n        Some(complete_chunk_output)\n    }\n}", 'Real(LocalPath("src/encode.rs"))'], 'engine::Config': ['/// The minimal level of configuration that engines must support.\npub trait Config {\n    /// Returns `true` if padding should be added after the encoded output.\n    ///\n    /// Padding is added outside the engine\'s `encode()` since the engine may be used\n    /// to encode only a chunk of the overall output, so it can\'t always know when\n    /// the output is "done" and would therefore need padding (if configured).\n    // It could be provided as a separate parameter when encoding, but that feels like\n    // leaking an implementation detail to the user, and it\'s hopefully more convenient\n    // to have to only pass one thing (the engine) to any part of the API.\n    fn encode_padding(&self) -> bool;\n}', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::DecodeEstimate': ['/// The decode estimate used by an engine implementation. Users do not need to interact with this;\n/// it is only for engine implementors.\n///\n/// Implementors may store relevant data here when constructing this to avoid having to calculate\n/// them again during actual decoding.\npub trait DecodeEstimate {\n    /// Returns a conservative (err on the side of too big) estimate of the decoded length to use\n    /// for pre-allocating buffers, etc.\n    ///\n    /// The estimate must be no larger than the next largest complete triple of decoded bytes.\n    /// That is, the final quad of tokens to decode may be assumed to be complete with no padding.\n    fn decoded_len_estimate(&self) -> usize;\n}', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::DecodeMetadata': ['/// Metadata about the result of a decode operation\npub struct DecodeMetadata {\n    /// Number of decoded bytes output\n    pub(crate) decoded_len: usize,\n    /// Offset of the first padding byte in the input, if any\n    pub(crate) padding_offset: Option<usize>,\n}', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::DecodeMetadata::new': ['pub(crate) fn new(decoded_bytes: usize, padding_index: Option<usize>) -> Self{\n        Self {\n            decoded_len: decoded_bytes,\n            padding_offset: padding_index,\n        }\n    }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::DecodePaddingMode': ['/// Controls how pad bytes are handled when decoding.\n///\n/// Each [Engine] must support at least the behavior indicated by\n/// [`DecodePaddingMode::RequireCanonical`], and may support other modes.\npub enum DecodePaddingMode {\n    /// Canonical padding is allowed, but any fewer padding bytes than that is also allowed.\n    Indifferent,\n    /// Padding must be canonical (0, 1, or 2 `=` as needed to produce a 4 byte suffix).\n    RequireCanonical,\n    /// Padding must be absent -- for when you want predictable padding, without any wasted bytes.\n    RequireNone,\n}', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine': ['/// An `Engine` provides low-level encoding and decoding operations that all other higher-level parts of the API use. Users of the library will generally not need to implement this.\n///\n/// Different implementations offer different characteristics. The library currently ships with\n/// [`GeneralPurpose`] that offers good speed and works on any CPU, with more choices\n/// coming later, like a constant-time one when side channel resistance is called for, and vendor-specific vectorized ones for more speed.\n///\n/// See [`general_purpose::STANDARD_NO_PAD`] if you just want standard base64. Otherwise, when possible, it\'s\n/// recommended to store the engine in a `const` so that references to it won\'t pose any lifetime\n/// issues, and to avoid repeating the cost of engine setup.\n///\n/// Since almost nobody will need to implement `Engine`, docs for internal methods are hidden.\npub trait Engine: Send + Sync {\n    /// The config type used by this engine\n    type Config: Config;\n    /// The decode estimate used by this engine\n    type DecodeEstimate: DecodeEstimate;\n\n    /// This is not meant to be called directly; it is only for `Engine` implementors.\n    /// See the other `encode*` functions on this trait.\n    ///\n    /// Encode the `input` bytes into the `output` buffer based on the mapping in `encode_table`.\n    ///\n    /// `output` will be long enough to hold the encoded data.\n    ///\n    /// Returns the number of bytes written.\n    ///\n    /// No padding should be written; that is handled separately.\n    ///\n    /// Must not write any bytes into the output slice other than the encoded data.\n    #[doc(hidden)]\n    fn internal_encode(&self, input: &[u8], output: &mut [u8]) -> usize;\n\n    /// This is not meant to be called directly; it is only for `Engine` implementors.\n    ///\n    /// As an optimization to prevent the decoded length from being calculated twice, it is\n    /// sometimes helpful to have a conservative estimate of the decoded size before doing the\n    /// decoding, so this calculation is done separately and passed to [Engine::decode()] as needed.\n    #[doc(hidden)]\n    fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate;\n\n    /// This is not meant to be called directly; it is only for `Engine` implementors.\n    /// See the other `decode*` functions on this trait.\n    ///\n    /// Decode `input` base64 bytes into the `output` buffer.\n    ///\n    /// `decode_estimate` is the result of [Engine::internal_decoded_len_estimate()], which is passed in to avoid\n    /// calculating it again (expensive on short inputs).`\n    ///\n    /// Each complete 4-byte chunk of encoded data decodes to 3 bytes of decoded data, but this\n    /// function must also handle the final possibly partial chunk.\n    /// If the input length is not a multiple of 4, or uses padding bytes to reach a multiple of 4,\n    /// the trailing 2 or 3 bytes must decode to 1 or 2 bytes, respectively, as per the\n    /// [RFC](https://tools.ietf.org/html/rfc4648#section-3.5).\n    ///\n    /// Decoding must not write any bytes into the output slice other than the decoded data.\n    ///\n    /// Non-canonical trailing bits in the final tokens or non-canonical padding must be reported as\n    /// errors unless the engine is configured otherwise.\n    #[doc(hidden)]\n    fn internal_decode(\n        &self,\n        input: &[u8],\n        output: &mut [u8],\n        decode_estimate: Self::DecodeEstimate,\n    ) -> Result<DecodeMetadata, DecodeSliceError>;\n\n    /// Returns the config for this engine.\n    fn config(&self) -> &Self::Config;\n\n    /// Encode arbitrary octets as base64 using the provided `Engine`.\n    /// Returns a `String`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use base64::{Engine as _, engine::{self, general_purpose}, alphabet};\n    ///\n    /// let b64 = general_purpose::STANDARD.encode(b"hello world~");\n    /// println!("{}", b64);\n    ///\n    /// const CUSTOM_ENGINE: engine::GeneralPurpose =\n    ///     engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);\n    ///\n    /// let b64_url = CUSTOM_ENGINE.encode(b"hello internet~");\n    /// ```\n    #[cfg(any(feature = "alloc", test))]\n    #[inline]\n    fn encode<T: AsRef<[u8]>>(&self, input: T) -> String {\n        fn inner<E>(engine: &E, input_bytes: &[u8]) -> String\n        where\n            E: Engine + ?Sized,\n        {\n            let encoded_size = encoded_len(input_bytes.len(), engine.config().encode_padding())\n                .expect("integer overflow when calculating buffer size");\n\n            let mut buf = vec![0; encoded_size];\n\n            encode_with_padding(input_bytes, &mut buf[..], engine, encoded_size);\n\n            String::from_utf8(buf).expect("Invalid UTF8")\n        }\n\n        inner(self, input.as_ref())\n    }\n\n    /// Encode arbitrary octets as base64 into a supplied `String`.\n    /// Writes into the supplied `String`, which may allocate if its internal buffer isn\'t big enough.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use base64::{Engine as _, engine::{self, general_purpose}, alphabet};\n    /// const CUSTOM_ENGINE: engine::GeneralPurpose =\n    ///     engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);\n    ///\n    /// fn main() {\n    ///     let mut buf = String::new();\n    ///     general_purpose::STANDARD.encode_string(b"hello world~", &mut buf);\n    ///     println!("{}", buf);\n    ///\n    ///     buf.clear();\n    ///     CUSTOM_ENGINE.encode_string(b"hello internet~", &mut buf);\n    ///     println!("{}", buf);\n    /// }\n    /// ```\n    #[cfg(any(feature = "alloc", test))]\n    #[inline]\n    fn encode_string<T: AsRef<[u8]>>(&self, input: T, output_buf: &mut String) {\n        fn inner<E>(engine: &E, input_bytes: &[u8], output_buf: &mut String)\n        where\n            E: Engine + ?Sized,\n        {\n            let mut sink = chunked_encoder::StringSink::new(output_buf);\n\n            chunked_encoder::ChunkedEncoder::new(engine)\n                .encode(input_bytes, &mut sink)\n                .expect("Writing to a String shouldn\'t fail");\n        }\n\n        inner(self, input.as_ref(), output_buf);\n    }\n\n    /// Encode arbitrary octets as base64 into a supplied slice.\n    /// Writes into the supplied output buffer.\n    ///\n    /// This is useful if you wish to avoid allocation entirely (e.g. encoding into a stack-resident\n    /// or statically-allocated buffer).\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = "alloc", doc = "```")]\n    #[cfg_attr(not(feature = "alloc"), doc = "```ignore")]\n    /// use base64::{Engine as _, engine::general_purpose};\n    /// let s = b"hello internet!";\n    /// let mut buf = Vec::new();\n    /// // make sure we\'ll have a slice big enough for base64 + padding\n    /// buf.resize(s.len() * 4 / 3 + 4, 0);\n    ///\n    /// let bytes_written = general_purpose::STANDARD.encode_slice(s, &mut buf).unwrap();\n    ///\n    /// // shorten our vec down to just what was written\n    /// buf.truncate(bytes_written);\n    ///\n    /// assert_eq!(s, general_purpose::STANDARD.decode(&buf).unwrap().as_slice());\n    /// ```\n    #[inline]\n    fn encode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output_buf: &mut [u8],\n    ) -> Result<usize, EncodeSliceError> {\n        fn inner<E>(\n            engine: &E,\n            input_bytes: &[u8],\n            output_buf: &mut [u8],\n        ) -> Result<usize, EncodeSliceError>\n        where\n            E: Engine + ?Sized,\n        {\n            let encoded_size = encoded_len(input_bytes.len(), engine.config().encode_padding())\n                .expect("usize overflow when calculating buffer size");\n\n            if output_buf.len() < encoded_size {\n                return Err(EncodeSliceError::OutputSliceTooSmall);\n            }\n\n            let b64_output = &mut output_buf[0..encoded_size];\n\n            encode_with_padding(input_bytes, b64_output, engine, encoded_size);\n\n            Ok(encoded_size)\n        }\n\n        inner(self, input.as_ref(), output_buf)\n    }\n\n    /// Decode the input into a new `Vec`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use base64::{Engine as _, alphabet, engine::{self, general_purpose}};\n    ///\n    /// let bytes = general_purpose::STANDARD\n    ///     .decode("aGVsbG8gd29ybGR+Cg==").unwrap();\n    /// println!("{:?}", bytes);\n    ///\n    /// // custom engine setup\n    /// let bytes_url = engine::GeneralPurpose::new(\n    ///              &alphabet::URL_SAFE,\n    ///              general_purpose::NO_PAD)\n    ///     .decode("aGVsbG8gaW50ZXJuZXR-Cg").unwrap();\n    /// println!("{:?}", bytes_url);\n    /// ```\n    #[cfg(any(feature = "alloc", test))]\n    #[inline]\n    fn decode<T: AsRef<[u8]>>(&self, input: T) -> Result<Vec<u8>, DecodeError> {\n        fn inner<E>(engine: &E, input_bytes: &[u8]) -> Result<Vec<u8>, DecodeError>\n        where\n            E: Engine + ?Sized,\n        {\n            let estimate = engine.internal_decoded_len_estimate(input_bytes.len());\n            let mut buffer = vec![0; estimate.decoded_len_estimate()];\n\n            let bytes_written = engine\n                .internal_decode(input_bytes, &mut buffer, estimate)\n                .map_err(|e| match e {\n                    DecodeSliceError::DecodeError(e) => e,\n                    DecodeSliceError::OutputSliceTooSmall => {\n                        unreachable!("Vec is sized conservatively")\n                    }\n                })?\n                .decoded_len;\n\n            buffer.truncate(bytes_written);\n\n            Ok(buffer)\n        }\n\n        inner(self, input.as_ref())\n    }\n\n    /// Decode the `input` into the supplied `buffer`.\n    ///\n    /// Writes into the supplied `Vec`, which may allocate if its internal buffer isn\'t big enough.\n    /// Returns a `Result` containing an empty tuple, aka `()`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use base64::{Engine as _, alphabet, engine::{self, general_purpose}};\n    /// const CUSTOM_ENGINE: engine::GeneralPurpose =\n    ///     engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::PAD);\n    ///\n    /// fn main() {\n    ///     use base64::Engine;\n    ///     let mut buffer = Vec::<u8>::new();\n    ///     // with the default engine\n    ///     general_purpose::STANDARD\n    ///         .decode_vec("aGVsbG8gd29ybGR+Cg==", &mut buffer,).unwrap();\n    ///     println!("{:?}", buffer);\n    ///\n    ///     buffer.clear();\n    ///\n    ///     // with a custom engine\n    ///     CUSTOM_ENGINE.decode_vec(\n    ///         "aGVsbG8gaW50ZXJuZXR-Cg==",\n    ///         &mut buffer,\n    ///     ).unwrap();\n    ///     println!("{:?}", buffer);\n    /// }\n    /// ```\n    #[cfg(any(feature = "alloc", test))]\n    #[inline]\n    fn decode_vec<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        buffer: &mut Vec<u8>,\n    ) -> Result<(), DecodeError> {\n        fn inner<E>(engine: &E, input_bytes: &[u8], buffer: &mut Vec<u8>) -> Result<(), DecodeError>\n        where\n            E: Engine + ?Sized,\n        {\n            let starting_output_len = buffer.len();\n            let estimate = engine.internal_decoded_len_estimate(input_bytes.len());\n\n            let total_len_estimate = estimate\n                .decoded_len_estimate()\n                .checked_add(starting_output_len)\n                .expect("Overflow when calculating output buffer length");\n\n            buffer.resize(total_len_estimate, 0);\n\n            let buffer_slice = &mut buffer.as_mut_slice()[starting_output_len..];\n\n            let bytes_written = engine\n                .internal_decode(input_bytes, buffer_slice, estimate)\n                .map_err(|e| match e {\n                    DecodeSliceError::DecodeError(e) => e,\n                    DecodeSliceError::OutputSliceTooSmall => {\n                        unreachable!("Vec is sized conservatively")\n                    }\n                })?\n                .decoded_len;\n\n            buffer.truncate(starting_output_len + bytes_written);\n\n            Ok(())\n        }\n\n        inner(self, input.as_ref(), buffer)\n    }\n\n    /// Decode the input into the provided output slice.\n    ///\n    /// Returns the number of bytes written to the slice, or an error if `output` is smaller than\n    /// the estimated decoded length.\n    ///\n    /// This will not write any bytes past exactly what is decoded (no stray garbage bytes at the end).\n    ///\n    /// See [`crate::decoded_len_estimate`] for calculating buffer sizes.\n    ///\n    /// See [`Engine::decode_slice_unchecked`] for a version that panics instead of returning an error\n    /// if the output buffer is too small.\n    #[inline]\n    fn decode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output: &mut [u8],\n    ) -> Result<usize, DecodeSliceError> {\n        fn inner<E>(\n            engine: &E,\n            input_bytes: &[u8],\n            output: &mut [u8],\n        ) -> Result<usize, DecodeSliceError>\n        where\n            E: Engine + ?Sized,\n        {\n            engine\n                .internal_decode(\n                    input_bytes,\n                    output,\n                    engine.internal_decoded_len_estimate(input_bytes.len()),\n                )\n                .map(|dm| dm.decoded_len)\n        }\n\n        inner(self, input.as_ref(), output)\n    }\n\n    /// Decode the input into the provided output slice.\n    ///\n    /// Returns the number of bytes written to the slice.\n    ///\n    /// This will not write any bytes past exactly what is decoded (no stray garbage bytes at the end).\n    ///\n    /// See [`crate::decoded_len_estimate`] for calculating buffer sizes.\n    ///\n    /// See [`Engine::decode_slice`] for a version that returns an error instead of panicking if the output\n    /// buffer is too small.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the provided output buffer is too small for the decoded data.\n    #[inline]\n    fn decode_slice_unchecked<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output: &mut [u8],\n    ) -> Result<usize, DecodeError> {\n        fn inner<E>(engine: &E, input_bytes: &[u8], output: &mut [u8]) -> Result<usize, DecodeError>\n        where\n            E: Engine + ?Sized,\n        {\n            engine\n                .internal_decode(\n                    input_bytes,\n                    output,\n                    engine.internal_decoded_len_estimate(input_bytes.len()),\n                )\n                .map(|dm| dm.decoded_len)\n                .map_err(|e| match e {\n                    DecodeSliceError::DecodeError(e) => e,\n                    DecodeSliceError::OutputSliceTooSmall => {\n                        panic!("Output slice is too small")\n                    }\n                })\n        }\n\n        inner(self, input.as_ref(), output)\n    }\n}', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::decode': ['/// Decode the input into a new `Vec`.\n///\n/// # Example\n///\n/// ```rust\n/// use base64::{Engine as _, alphabet, engine::{self, general_purpose}};\n///\n/// let bytes = general_purpose::STANDARD\n///     .decode("aGVsbG8gd29ybGR+Cg==").unwrap();\n/// println!("{:?}", bytes);\n///\n/// // custom engine setup\n/// let bytes_url = engine::GeneralPurpose::new(\n///              &alphabet::URL_SAFE,\n///              general_purpose::NO_PAD)\n///     .decode("aGVsbG8gaW50ZXJuZXR-Cg").unwrap();\n/// println!("{:?}", bytes_url);\n/// ```\n#[cfg(any(feature = "alloc", test))]\n#[inline]\nfn decode<T: AsRef<[u8]>>(&self, input: T) -> Result<Vec<u8>, DecodeError>{\n        fn inner<E>(engine: &E, input_bytes: &[u8]) -> Result<Vec<u8>, DecodeError>\n        where\n            E: Engine + ?Sized,\n        {\n            let estimate = engine.internal_decoded_len_estimate(input_bytes.len());\n            let mut buffer = vec![0; estimate.decoded_len_estimate()];\n\n            let bytes_written = engine\n                .internal_decode(input_bytes, &mut buffer, estimate)\n                .map_err(|e| match e {\n                    DecodeSliceError::DecodeError(e) => e,\n                    DecodeSliceError::OutputSliceTooSmall => {\n                        unreachable!("Vec is sized conservatively")\n                    }\n                })?\n                .decoded_len;\n\n            buffer.truncate(bytes_written);\n\n            Ok(buffer)\n        }\n\n        inner(self, input.as_ref())\n    }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::decode::inner': ['fn inner<E>(engine: &E, input_bytes: &[u8]) -> Result<Vec<u8>, DecodeError>\n        where\n            E: Engine + ?Sized,{\n            let estimate = engine.internal_decoded_len_estimate(input_bytes.len());\n            let mut buffer = vec![0; estimate.decoded_len_estimate()];\n\n            let bytes_written = engine\n                .internal_decode(input_bytes, &mut buffer, estimate)\n                .map_err(|e| match e {\n                    DecodeSliceError::DecodeError(e) => e,\n                    DecodeSliceError::OutputSliceTooSmall => {\n                        unreachable!("Vec is sized conservatively")\n                    }\n                })?\n                .decoded_len;\n\n            buffer.truncate(bytes_written);\n\n            Ok(buffer)\n        }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::decode_slice': ['/// Decode the input into the provided output slice.\n///\n/// Returns the number of bytes written to the slice, or an error if `output` is smaller than\n/// the estimated decoded length.\n///\n/// This will not write any bytes past exactly what is decoded (no stray garbage bytes at the end).\n///\n/// See [`crate::decoded_len_estimate`] for calculating buffer sizes.\n///\n/// See [`Engine::decode_slice_unchecked`] for a version that panics instead of returning an error\n/// if the output buffer is too small.\n#[inline]\nfn decode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output: &mut [u8],\n    ) -> Result<usize, DecodeSliceError>{\n        fn inner<E>(\n            engine: &E,\n            input_bytes: &[u8],\n            output: &mut [u8],\n        ) -> Result<usize, DecodeSliceError>\n        where\n            E: Engine + ?Sized,\n        {\n            engine\n                .internal_decode(\n                    input_bytes,\n                    output,\n                    engine.internal_decoded_len_estimate(input_bytes.len()),\n                )\n                .map(|dm| dm.decoded_len)\n        }\n\n        inner(self, input.as_ref(), output)\n    }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::decode_slice::inner': ['fn inner<E>(\n            engine: &E,\n            input_bytes: &[u8],\n            output: &mut [u8],\n        ) -> Result<usize, DecodeSliceError>\n        where\n            E: Engine + ?Sized,{\n            engine\n                .internal_decode(\n                    input_bytes,\n                    output,\n                    engine.internal_decoded_len_estimate(input_bytes.len()),\n                )\n                .map(|dm| dm.decoded_len)\n        }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::decode_slice_unchecked': ['/// Decode the input into the provided output slice.\n///\n/// Returns the number of bytes written to the slice.\n///\n/// This will not write any bytes past exactly what is decoded (no stray garbage bytes at the end).\n///\n/// See [`crate::decoded_len_estimate`] for calculating buffer sizes.\n///\n/// See [`Engine::decode_slice`] for a version that returns an error instead of panicking if the output\n/// buffer is too small.\n///\n/// # Panics\n///\n/// Panics if the provided output buffer is too small for the decoded data.\n#[inline]\nfn decode_slice_unchecked<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output: &mut [u8],\n    ) -> Result<usize, DecodeError>{\n        fn inner<E>(engine: &E, input_bytes: &[u8], output: &mut [u8]) -> Result<usize, DecodeError>\n        where\n            E: Engine + ?Sized,\n        {\n            engine\n                .internal_decode(\n                    input_bytes,\n                    output,\n                    engine.internal_decoded_len_estimate(input_bytes.len()),\n                )\n                .map(|dm| dm.decoded_len)\n                .map_err(|e| match e {\n                    DecodeSliceError::DecodeError(e) => e,\n                    DecodeSliceError::OutputSliceTooSmall => {\n                        panic!("Output slice is too small")\n                    }\n                })\n        }\n\n        inner(self, input.as_ref(), output)\n    }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::decode_slice_unchecked::inner': ['fn inner<E>(engine: &E, input_bytes: &[u8], output: &mut [u8]) -> Result<usize, DecodeError>\n        where\n            E: Engine + ?Sized,{\n            engine\n                .internal_decode(\n                    input_bytes,\n                    output,\n                    engine.internal_decoded_len_estimate(input_bytes.len()),\n                )\n                .map(|dm| dm.decoded_len)\n                .map_err(|e| match e {\n                    DecodeSliceError::DecodeError(e) => e,\n                    DecodeSliceError::OutputSliceTooSmall => {\n                        panic!("Output slice is too small")\n                    }\n                })\n        }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::decode_vec': ['/// Decode the `input` into the supplied `buffer`.\n///\n/// Writes into the supplied `Vec`, which may allocate if its internal buffer isn\'t big enough.\n/// Returns a `Result` containing an empty tuple, aka `()`.\n///\n/// # Example\n///\n/// ```rust\n/// use base64::{Engine as _, alphabet, engine::{self, general_purpose}};\n/// const CUSTOM_ENGINE: engine::GeneralPurpose =\n///     engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::PAD);\n///\n/// fn main() {\n///     use base64::Engine;\n///     let mut buffer = Vec::<u8>::new();\n///     // with the default engine\n///     general_purpose::STANDARD\n///         .decode_vec("aGVsbG8gd29ybGR+Cg==", &mut buffer,).unwrap();\n///     println!("{:?}", buffer);\n///\n///     buffer.clear();\n///\n///     // with a custom engine\n///     CUSTOM_ENGINE.decode_vec(\n///         "aGVsbG8gaW50ZXJuZXR-Cg==",\n///         &mut buffer,\n///     ).unwrap();\n///     println!("{:?}", buffer);\n/// }\n/// ```\n#[cfg(any(feature = "alloc", test))]\n#[inline]\nfn decode_vec<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        buffer: &mut Vec<u8>,\n    ) -> Result<(), DecodeError>{\n        fn inner<E>(engine: &E, input_bytes: &[u8], buffer: &mut Vec<u8>) -> Result<(), DecodeError>\n        where\n            E: Engine + ?Sized,\n        {\n            let starting_output_len = buffer.len();\n            let estimate = engine.internal_decoded_len_estimate(input_bytes.len());\n\n            let total_len_estimate = estimate\n                .decoded_len_estimate()\n                .checked_add(starting_output_len)\n                .expect("Overflow when calculating output buffer length");\n\n            buffer.resize(total_len_estimate, 0);\n\n            let buffer_slice = &mut buffer.as_mut_slice()[starting_output_len..];\n\n            let bytes_written = engine\n                .internal_decode(input_bytes, buffer_slice, estimate)\n                .map_err(|e| match e {\n                    DecodeSliceError::DecodeError(e) => e,\n                    DecodeSliceError::OutputSliceTooSmall => {\n                        unreachable!("Vec is sized conservatively")\n                    }\n                })?\n                .decoded_len;\n\n            buffer.truncate(starting_output_len + bytes_written);\n\n            Ok(())\n        }\n\n        inner(self, input.as_ref(), buffer)\n    }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::decode_vec::inner': ['fn inner<E>(engine: &E, input_bytes: &[u8], buffer: &mut Vec<u8>) -> Result<(), DecodeError>\n        where\n            E: Engine + ?Sized,{\n            let starting_output_len = buffer.len();\n            let estimate = engine.internal_decoded_len_estimate(input_bytes.len());\n\n            let total_len_estimate = estimate\n                .decoded_len_estimate()\n                .checked_add(starting_output_len)\n                .expect("Overflow when calculating output buffer length");\n\n            buffer.resize(total_len_estimate, 0);\n\n            let buffer_slice = &mut buffer.as_mut_slice()[starting_output_len..];\n\n            let bytes_written = engine\n                .internal_decode(input_bytes, buffer_slice, estimate)\n                .map_err(|e| match e {\n                    DecodeSliceError::DecodeError(e) => e,\n                    DecodeSliceError::OutputSliceTooSmall => {\n                        unreachable!("Vec is sized conservatively")\n                    }\n                })?\n                .decoded_len;\n\n            buffer.truncate(starting_output_len + bytes_written);\n\n            Ok(())\n        }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::encode': ['/// Encode arbitrary octets as base64 using the provided `Engine`.\n/// Returns a `String`.\n///\n/// # Example\n///\n/// ```rust\n/// use base64::{Engine as _, engine::{self, general_purpose}, alphabet};\n///\n/// let b64 = general_purpose::STANDARD.encode(b"hello world~");\n/// println!("{}", b64);\n///\n/// const CUSTOM_ENGINE: engine::GeneralPurpose =\n///     engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);\n///\n/// let b64_url = CUSTOM_ENGINE.encode(b"hello internet~");\n/// ```\n#[cfg(any(feature = "alloc", test))]\n#[inline]\nfn encode<T: AsRef<[u8]>>(&self, input: T) -> String{\n        fn inner<E>(engine: &E, input_bytes: &[u8]) -> String\n        where\n            E: Engine + ?Sized,\n        {\n            let encoded_size = encoded_len(input_bytes.len(), engine.config().encode_padding())\n                .expect("integer overflow when calculating buffer size");\n\n            let mut buf = vec![0; encoded_size];\n\n            encode_with_padding(input_bytes, &mut buf[..], engine, encoded_size);\n\n            String::from_utf8(buf).expect("Invalid UTF8")\n        }\n\n        inner(self, input.as_ref())\n    }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::encode::inner': ['fn inner<E>(engine: &E, input_bytes: &[u8]) -> String\n        where\n            E: Engine + ?Sized,{\n            let encoded_size = encoded_len(input_bytes.len(), engine.config().encode_padding())\n                .expect("integer overflow when calculating buffer size");\n\n            let mut buf = vec![0; encoded_size];\n\n            encode_with_padding(input_bytes, &mut buf[..], engine, encoded_size);\n\n            String::from_utf8(buf).expect("Invalid UTF8")\n        }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::encode_slice': ['/// Encode arbitrary octets as base64 into a supplied slice.\n/// Writes into the supplied output buffer.\n///\n/// This is useful if you wish to avoid allocation entirely (e.g. encoding into a stack-resident\n/// or statically-allocated buffer).\n///\n/// # Example\n///\ndoc = "```"\n/// use base64::{Engine as _, engine::general_purpose};\n/// let s = b"hello internet!";\n/// let mut buf = Vec::new();\n/// // make sure we\'ll have a slice big enough for base64 + padding\n/// buf.resize(s.len() * 4 / 3 + 4, 0);\n///\n/// let bytes_written = general_purpose::STANDARD.encode_slice(s, &mut buf).unwrap();\n///\n/// // shorten our vec down to just what was written\n/// buf.truncate(bytes_written);\n///\n/// assert_eq!(s, general_purpose::STANDARD.decode(&buf).unwrap().as_slice());\n/// ```\n#[inline]\nfn encode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output_buf: &mut [u8],\n    ) -> Result<usize, EncodeSliceError>{\n        fn inner<E>(\n            engine: &E,\n            input_bytes: &[u8],\n            output_buf: &mut [u8],\n        ) -> Result<usize, EncodeSliceError>\n        where\n            E: Engine + ?Sized,\n        {\n            let encoded_size = encoded_len(input_bytes.len(), engine.config().encode_padding())\n                .expect("usize overflow when calculating buffer size");\n\n            if output_buf.len() < encoded_size {\n                return Err(EncodeSliceError::OutputSliceTooSmall);\n            }\n\n            let b64_output = &mut output_buf[0..encoded_size];\n\n            encode_with_padding(input_bytes, b64_output, engine, encoded_size);\n\n            Ok(encoded_size)\n        }\n\n        inner(self, input.as_ref(), output_buf)\n    }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::encode_slice::inner': ['fn inner<E>(\n            engine: &E,\n            input_bytes: &[u8],\n            output_buf: &mut [u8],\n        ) -> Result<usize, EncodeSliceError>\n        where\n            E: Engine + ?Sized,{\n            let encoded_size = encoded_len(input_bytes.len(), engine.config().encode_padding())\n                .expect("usize overflow when calculating buffer size");\n\n            if output_buf.len() < encoded_size {\n                return Err(EncodeSliceError::OutputSliceTooSmall);\n            }\n\n            let b64_output = &mut output_buf[0..encoded_size];\n\n            encode_with_padding(input_bytes, b64_output, engine, encoded_size);\n\n            Ok(encoded_size)\n        }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::encode_string': ['/// Encode arbitrary octets as base64 into a supplied `String`.\n/// Writes into the supplied `String`, which may allocate if its internal buffer isn\'t big enough.\n///\n/// # Example\n///\n/// ```rust\n/// use base64::{Engine as _, engine::{self, general_purpose}, alphabet};\n/// const CUSTOM_ENGINE: engine::GeneralPurpose =\n///     engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);\n///\n/// fn main() {\n///     let mut buf = String::new();\n///     general_purpose::STANDARD.encode_string(b"hello world~", &mut buf);\n///     println!("{}", buf);\n///\n///     buf.clear();\n///     CUSTOM_ENGINE.encode_string(b"hello internet~", &mut buf);\n///     println!("{}", buf);\n/// }\n/// ```\n#[cfg(any(feature = "alloc", test))]\n#[inline]\nfn encode_string<T: AsRef<[u8]>>(&self, input: T, output_buf: &mut String){\n        fn inner<E>(engine: &E, input_bytes: &[u8], output_buf: &mut String)\n        where\n            E: Engine + ?Sized,\n        {\n            let mut sink = chunked_encoder::StringSink::new(output_buf);\n\n            chunked_encoder::ChunkedEncoder::new(engine)\n                .encode(input_bytes, &mut sink)\n                .expect("Writing to a String shouldn\'t fail");\n        }\n\n        inner(self, input.as_ref(), output_buf);\n    }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::Engine::encode_string::inner': ['fn inner<E>(engine: &E, input_bytes: &[u8], output_buf: &mut String)\n        where\n            E: Engine + ?Sized,{\n            let mut sink = chunked_encoder::StringSink::new(output_buf);\n\n            chunked_encoder::ChunkedEncoder::new(engine)\n                .encode(input_bytes, &mut sink)\n                .expect("Writing to a String shouldn\'t fail");\n        }', 'Real(LocalPath("src/engine/mod.rs"))'], 'engine::general_purpose::GeneralPurpose': ['/// A general-purpose base64 engine.\n///\n/// - It uses no vector CPU instructions, so it will work on any system.\n/// - It is reasonably fast (~2-3GiB/s).\n/// - It is not constant-time, though, so it is vulnerable to timing side-channel attacks. For loading cryptographic keys, etc, it is suggested to use the forthcoming constant-time implementation.\npub struct GeneralPurpose {\n    encode_table: [u8; 64],\n    decode_table: [u8; 256],\n    config: GeneralPurposeConfig,\n}', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], 'engine::general_purpose::GeneralPurpose::new': ['/// Create a `GeneralPurpose` engine from an [Alphabet].\n///\n/// While not very expensive to initialize, ideally these should be cached\n/// if the engine will be used repeatedly.\n#[must_use]\npub const fn new(alphabet: &Alphabet, config: GeneralPurposeConfig) -> Self{\n        Self {\n            encode_table: encode_table(alphabet),\n            decode_table: decode_table(alphabet),\n            config,\n        }\n    }', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], 'engine::general_purpose::GeneralPurposeConfig': ['/// Contains configuration parameters for base64 encoding and decoding.\n///\n/// ```\n/// # use base64::engine::GeneralPurposeConfig;\n/// let config = GeneralPurposeConfig::new()\n///     .with_encode_padding(false);\n///     // further customize using `.with_*` methods as needed\n/// ```\n///\n/// The constants [PAD] and [`NO_PAD`] cover most use cases.\n///\n/// To specify the characters used, see [Alphabet].\npub struct GeneralPurposeConfig {\n    encode_padding: bool,\n    decode_allow_trailing_bits: bool,\n    decode_padding_mode: DecodePaddingMode,\n}', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], 'engine::general_purpose::GeneralPurposeConfig::new': ["/// Create a new config with `padding` = `true`, `decode_allow_trailing_bits` = `false`, and\n/// `decode_padding_mode = DecodePaddingMode::RequireCanonicalPadding`.\n///\n/// This probably matches most people's expectations, but consider disabling padding to save\n/// a few bytes unless you specifically need it for compatibility with some legacy system.\n#[must_use]\npub const fn new() -> Self{\n        Self {\n            // RFC states that padding must be applied by default\n            encode_padding: true,\n            decode_allow_trailing_bits: false,\n            decode_padding_mode: DecodePaddingMode::RequireCanonical,\n        }\n    }", 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], 'engine::general_purpose::GeneralPurposeConfig::with_decode_allow_trailing_bits': ["/// Create a new config based on `self` with an updated `decode_allow_trailing_bits` setting.\n///\n/// Most users will not need to configure this. It's useful if you need to decode base64\n/// produced by a buggy encoder that has bits set in the unused space on the last base64\n/// character as per [forgiving-base64 decode](https://infra.spec.whatwg.org/#forgiving-base64-decode).\n/// If invalid trailing bits are present and this is `true`, those bits will\n/// be silently ignored, else `DecodeError::InvalidLastSymbol` will be emitted.\n#[must_use]\npub const fn with_decode_allow_trailing_bits(self, allow: bool) -> Self{\n        Self {\n            decode_allow_trailing_bits: allow,\n            ..self\n        }\n    }", 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], 'engine::general_purpose::GeneralPurposeConfig::with_decode_padding_mode': ['/// Create a new config based on `self` with an updated `decode_padding_mode` setting.\n///\n/// Padding is not useful in terms of representing encoded data -- it makes no difference to\n/// the decoder if padding is present or not, so if you have some un-padded input to decode, it\n/// is perfectly fine to use `DecodePaddingMode::Indifferent` to prevent errors from being\n/// emitted.\n///\n/// However, since in practice\n/// [people who learned nothing from BER vs DER seem to expect base64 to have one canonical encoding](https://eprint.iacr.org/2022/361),\n/// the default setting is the stricter `DecodePaddingMode::RequireCanonicalPadding`.\n///\n/// Or, if "canonical" in your circumstance means _no_ padding rather than padding to the\n/// next multiple of four, there\'s `DecodePaddingMode::RequireNoPadding`.\n#[must_use]\npub const fn with_decode_padding_mode(self, mode: DecodePaddingMode) -> Self{\n        Self {\n            decode_padding_mode: mode,\n            ..self\n        }\n    }', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], 'engine::general_purpose::GeneralPurposeConfig::with_encode_padding': ["/// Create a new config based on `self` with an updated `padding` setting.\n///\n/// If `padding` is `true`, encoding will append either 1 or 2 `=` padding characters as needed\n/// to produce an output whose length is a multiple of 4.\n///\n/// Padding is not needed for correct decoding and only serves to waste bytes, but it's in the\n/// [spec](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2).\n///\n/// For new applications, consider not using padding if the decoders you're using don't require\n/// padding to be present.\n#[must_use]\npub const fn with_encode_padding(self, padding: bool) -> Self{\n        Self {\n            encode_padding: padding,\n            ..self\n        }\n    }", 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], 'engine::general_purpose::decode::GeneralPurposeEstimate': ['#[doc(hidden)]\npub struct GeneralPurposeEstimate {\n    /// input len % 4\n    rem: usize,\n    conservative_decoded_len: usize,\n}', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))'], 'engine::general_purpose::decode::GeneralPurposeEstimate::new': ['pub(crate) fn new(encoded_len: usize) -> Self{\n        let rem = encoded_len % 4;\n        Self {\n            rem,\n            conservative_decoded_len: (encoded_len / 4 + usize::from(rem > 0)) * 3,\n        }\n    }', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))'], 'engine::general_purpose::decode::complete_quads_len': ["/// Returns the length of complete quads, except for the last one, even if it is complete.\n///\n/// Returns an error if the output len is not big enough for decoding those complete quads, or if\n/// the input % 4 == 1, and that last byte is an invalid value other than a pad byte.\n///\n/// - `input` is the base64 input\n/// - `input_len_rem` is input len % 4\n/// - `output_len` is the length of the output slice\npub(crate) fn complete_quads_len(\n    input: &[u8],\n    input_len_rem: usize,\n    output_len: usize,\n    decode_table: &[u8; 256],\n) -> Result<usize, DecodeSliceError>{\n    debug_assert!(input.len() % 4 == input_len_rem);\n\n    // detect a trailing invalid byte, like a newline, as a user convenience\n    if input_len_rem == 1 {\n        let last_byte = input[input.len() - 1];\n        // exclude pad bytes; might be part of padding that extends from earlier in the input\n        if last_byte != PAD_BYTE && decode_table[usize::from(last_byte)] == INVALID_VALUE {\n            return Err(DecodeError::InvalidByte(input.len() - 1, last_byte).into());\n        }\n    };\n\n    // skip last quad, even if it's complete, as it may have padding\n    let input_complete_nonterminal_quads_len = input\n        .len()\n        .saturating_sub(input_len_rem)\n        // if rem was 0, subtract 4 to avoid padding\n        .saturating_sub(usize::from(input_len_rem == 0) * 4);\n    debug_assert!(\n        input.is_empty() || (1..=4).contains(&(input.len() - input_complete_nonterminal_quads_len))\n    );\n\n    // check that everything except the last quad handled by decode_suffix will fit\n    if output_len < input_complete_nonterminal_quads_len / 4 * 3 {\n        return Err(DecodeSliceError::OutputSliceTooSmall);\n    };\n    Ok(input_complete_nonterminal_quads_len)\n}", 'Real(LocalPath("src/engine/general_purpose/decode.rs"))'], 'engine::general_purpose::decode::decode_chunk_4': ['/// Like [`decode_chunk_8`] but for 4 bytes of input and 3 bytes of output.\n#[inline(always)]\nfn decode_chunk_4(\n    input: &[u8],\n    index_at_start_of_input: usize,\n    decode_table: &[u8; 256],\n    output: &mut [u8],\n) -> Result<(), DecodeError>{\n    let morsel = decode_table[usize::from(input[0])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(index_at_start_of_input, input[0]));\n    }\n    let mut accum = u32::from(morsel) << 26;\n\n    let morsel = decode_table[usize::from(input[1])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 1,\n            input[1],\n        ));\n    }\n    accum |= u32::from(morsel) << 20;\n\n    let morsel = decode_table[usize::from(input[2])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 2,\n            input[2],\n        ));\n    }\n    accum |= u32::from(morsel) << 14;\n\n    let morsel = decode_table[usize::from(input[3])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 3,\n            input[3],\n        ));\n    }\n    accum |= u32::from(morsel) << 8;\n\n    output[..3].copy_from_slice(&accum.to_be_bytes()[..3]);\n\n    Ok(())\n}', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))'], 'engine::general_purpose::decode::decode_chunk_8': ['/// Decode 8 bytes of input into 6 bytes of output.\n///\n/// `input` is the 8 bytes to decode.\n/// `index_at_start_of_input` is the offset in the overall input (used for reporting errors\n/// accurately)\n/// `decode_table` is the lookup table for the particular base64 alphabet.\n/// `output` will have its first 6 bytes overwritten\n#[inline(always)]\nfn decode_chunk_8(\n    input: &[u8],\n    index_at_start_of_input: usize,\n    decode_table: &[u8; 256],\n    output: &mut [u8],\n) -> Result<(), DecodeError>{\n    let morsel = decode_table[usize::from(input[0])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(index_at_start_of_input, input[0]));\n    }\n    let mut accum = u64::from(morsel) << 58;\n\n    let morsel = decode_table[usize::from(input[1])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 1,\n            input[1],\n        ));\n    }\n    accum |= u64::from(morsel) << 52;\n\n    let morsel = decode_table[usize::from(input[2])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 2,\n            input[2],\n        ));\n    }\n    accum |= u64::from(morsel) << 46;\n\n    let morsel = decode_table[usize::from(input[3])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 3,\n            input[3],\n        ));\n    }\n    accum |= u64::from(morsel) << 40;\n\n    let morsel = decode_table[usize::from(input[4])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 4,\n            input[4],\n        ));\n    }\n    accum |= u64::from(morsel) << 34;\n\n    let morsel = decode_table[usize::from(input[5])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 5,\n            input[5],\n        ));\n    }\n    accum |= u64::from(morsel) << 28;\n\n    let morsel = decode_table[usize::from(input[6])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 6,\n            input[6],\n        ));\n    }\n    accum |= u64::from(morsel) << 22;\n\n    let morsel = decode_table[usize::from(input[7])];\n    if morsel == INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 7,\n            input[7],\n        ));\n    }\n    accum |= u64::from(morsel) << 16;\n\n    output[..6].copy_from_slice(&accum.to_be_bytes()[..6]);\n\n    Ok(())\n}', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))'], 'engine::general_purpose::decode::decode_helper': ['/// Helper to avoid duplicating `num_chunks` calculation, which is costly on short inputs.\n/// Returns the decode metadata, or an error.\n#[inline]\npub(crate) fn decode_helper(\n    input: &[u8],\n    estimate: &GeneralPurposeEstimate,\n    output: &mut [u8],\n    decode_table: &[u8; 256],\n    decode_allow_trailing_bits: bool,\n    padding_mode: DecodePaddingMode,\n) -> Result<DecodeMetadata, DecodeSliceError>{\n    let input_complete_nonterminal_quads_len =\n        complete_quads_len(input, estimate.rem, output.len(), decode_table)?;\n\n    const UNROLLED_INPUT_CHUNK_SIZE: usize = 32;\n    const UNROLLED_OUTPUT_CHUNK_SIZE: usize = UNROLLED_INPUT_CHUNK_SIZE / 4 * 3;\n\n    let input_complete_quads_after_unrolled_chunks_len =\n        input_complete_nonterminal_quads_len % UNROLLED_INPUT_CHUNK_SIZE;\n\n    let input_unrolled_loop_len =\n        input_complete_nonterminal_quads_len - input_complete_quads_after_unrolled_chunks_len;\n\n    // chunks of 32 bytes\n    for (chunk_index, chunk) in input[..input_unrolled_loop_len]\n        .chunks_exact(UNROLLED_INPUT_CHUNK_SIZE)\n        .enumerate()\n    {\n        let input_index = chunk_index * UNROLLED_INPUT_CHUNK_SIZE;\n        let chunk_output = &mut output[chunk_index * UNROLLED_OUTPUT_CHUNK_SIZE\n            ..(chunk_index + 1) * UNROLLED_OUTPUT_CHUNK_SIZE];\n\n        decode_chunk_8(\n            &chunk[0..8],\n            input_index,\n            decode_table,\n            &mut chunk_output[0..6],\n        )?;\n        decode_chunk_8(\n            &chunk[8..16],\n            input_index + 8,\n            decode_table,\n            &mut chunk_output[6..12],\n        )?;\n        decode_chunk_8(\n            &chunk[16..24],\n            input_index + 16,\n            decode_table,\n            &mut chunk_output[12..18],\n        )?;\n        decode_chunk_8(\n            &chunk[24..32],\n            input_index + 24,\n            decode_table,\n            &mut chunk_output[18..24],\n        )?;\n    }\n\n    // remaining quads, except for the last possibly partial one, as it may have padding\n    let output_unrolled_loop_len = input_unrolled_loop_len / 4 * 3;\n    let output_complete_quad_len = input_complete_nonterminal_quads_len / 4 * 3;\n    {\n        let output_after_unroll = &mut output[output_unrolled_loop_len..output_complete_quad_len];\n\n        for (chunk_index, chunk) in input\n            [input_unrolled_loop_len..input_complete_nonterminal_quads_len]\n            .chunks_exact(4)\n            .enumerate()\n        {\n            let chunk_output = &mut output_after_unroll[chunk_index * 3..chunk_index * 3 + 3];\n\n            decode_chunk_4(\n                chunk,\n                input_unrolled_loop_len + chunk_index * 4,\n                decode_table,\n                chunk_output,\n            )?;\n        }\n    }\n\n    super::decode_suffix::decode_suffix(\n        input,\n        input_complete_nonterminal_quads_len,\n        output,\n        output_complete_quad_len,\n        decode_table,\n        decode_allow_trailing_bits,\n        padding_mode,\n    )\n}', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))'], 'engine::general_purpose::decode_suffix::decode_suffix': ['/// Decode the last 0-4 bytes, checking for trailing set bits and padding per the provided\n/// parameters.\n///\n/// Returns the decode metadata representing the total number of bytes decoded, including the ones\n/// indicated as already written by `output_index`.\npub(crate) fn decode_suffix(\n    input: &[u8],\n    input_index: usize,\n    output: &mut [u8],\n    mut output_index: usize,\n    decode_table: &[u8; 256],\n    decode_allow_trailing_bits: bool,\n    padding_mode: DecodePaddingMode,\n) -> Result<DecodeMetadata, DecodeSliceError>{\n    debug_assert!((input.len() - input_index) <= 4);\n\n    // Decode any leftovers that might not be a complete input chunk of 4 bytes.\n    // Use a u32 as a stack-resident 4 byte buffer.\n    let mut morsels_in_leftover = 0;\n    let mut padding_bytes_count = 0;\n    // offset from input_index\n    let mut first_padding_offset: usize = 0;\n    let mut last_symbol = 0_u8;\n    let mut morsels = [0_u8; 4];\n\n    for (leftover_index, &b) in input[input_index..].iter().enumerate() {\n        // \'=\' padding\n        if b == PAD_BYTE {\n            // There can be bad padding bytes in a few ways:\n            // 1 - Padding with non-padding characters after it\n            // 2 - Padding after zero or one characters in the current quad (should only\n            //     be after 2 or 3 chars)\n            // 3 - More than two characters of padding. If 3 or 4 padding chars\n            //     are in the same quad, that implies it will be caught by #2.\n            //     If it spreads from one quad to another, it will be an invalid byte\n            //     in the first quad.\n            // 4 - Non-canonical padding -- 1 byte when it should be 2, etc.\n            //     Per config, non-canonical but still functional non- or partially-padded base64\n            //     may be treated as an error condition.\n\n            if leftover_index < 2 {\n                // Check for error #2.\n                // Either the previous byte was padding, in which case we would have already hit\n                // this case, or it wasn\'t, in which case this is the first such error.\n                debug_assert!(\n                    leftover_index == 0 || (leftover_index == 1 && padding_bytes_count == 0)\n                );\n                let bad_padding_index = input_index + leftover_index;\n                return Err(DecodeError::InvalidByte(bad_padding_index, b).into());\n            }\n\n            if padding_bytes_count == 0 {\n                first_padding_offset = leftover_index;\n            }\n\n            padding_bytes_count += 1;\n            continue;\n        }\n\n        // Check for case #1.\n        // To make \'=\' handling consistent with the main loop, don\'t allow\n        // non-suffix \'=\' in trailing chunk either. Report error as first\n        // erroneous padding.\n        if padding_bytes_count > 0 {\n            return Err(\n                DecodeError::InvalidByte(input_index + first_padding_offset, PAD_BYTE).into(),\n            );\n        }\n\n        last_symbol = b;\n\n        // can use up to 8 * 6 = 48 bits of the u64, if last chunk has no padding.\n        // Pack the leftovers from left to right.\n        let morsel = decode_table[b as usize];\n        if morsel == INVALID_VALUE {\n            return Err(DecodeError::InvalidByte(input_index + leftover_index, b).into());\n        }\n\n        morsels[morsels_in_leftover] = morsel;\n        morsels_in_leftover += 1;\n    }\n\n    // If there was 1 trailing byte, and it was valid, and we got to this point without hitting\n    // an invalid byte, now we can report invalid length\n    if !input.is_empty() && morsels_in_leftover < 2 {\n        return Err(DecodeError::InvalidLength(input_index + morsels_in_leftover).into());\n    }\n\n    match padding_mode {\n        DecodePaddingMode::Indifferent => { /* everything we care about was already checked */ }\n        DecodePaddingMode::RequireCanonical => {\n            // allow empty input\n            if (padding_bytes_count + morsels_in_leftover) % 4 != 0 {\n                return Err(DecodeError::InvalidPadding.into());\n            }\n        }\n        DecodePaddingMode::RequireNone => {\n            if padding_bytes_count > 0 {\n                // check at the end to make sure we let the cases of padding that should be InvalidByte\n                // get hit\n                return Err(DecodeError::InvalidPadding.into());\n            }\n        }\n    }\n\n    // When encoding 1 trailing byte (e.g. 0xFF), 2 base64 bytes ("/w") are needed.\n    // / is the symbol for 63 (0x3F, bottom 6 bits all set) and w is 48 (0x30, top 2 bits\n    // of bottom 6 bits set).\n    // When decoding two symbols back to one trailing byte, any final symbol higher than\n    // w would still decode to the original byte because we only care about the top two\n    // bits in the bottom 6, but would be a non-canonical encoding. So, we calculate a\n    // mask based on how many bits are used for just the canonical encoding, and optionally\n    // error if any other bits are set. In the example of one encoded byte -> 2 symbols,\n    // 2 symbols can technically encode 12 bits, but the last 4 are non-canonical, and\n    // useless since there are no more symbols to provide the necessary 4 additional bits\n    // to finish the second original byte.\n\n    let leftover_bytes_to_append = morsels_in_leftover * 6 / 8;\n    // Put the up to 6 complete bytes as the high bytes.\n    // Gain a couple percent speedup from nudging these ORs to use more ILP with a two-way split.\n    let mut leftover_num = (u32::from(morsels[0]) << 26)\n        | (u32::from(morsels[1]) << 20)\n        | (u32::from(morsels[2]) << 14)\n        | (u32::from(morsels[3]) << 8);\n\n    // if there are bits set outside the bits we care about, last symbol encodes trailing bits that\n    // will not be included in the output\n    let mask = !0_u32 >> (leftover_bytes_to_append * 8);\n    if !decode_allow_trailing_bits && (leftover_num & mask) != 0 {\n        // last morsel is at `morsels_in_leftover` - 1\n        return Err(DecodeError::InvalidLastSymbol(\n            input_index + morsels_in_leftover - 1,\n            last_symbol,\n        )\n        .into());\n    }\n\n    // Strangely, this approach benchmarks better than writing bytes one at a time,\n    // or copy_from_slice into output.\n    for _ in 0..leftover_bytes_to_append {\n        let hi_byte = (leftover_num >> 24) as u8;\n        leftover_num <<= 8;\n        *output\n            .get_mut(output_index)\n            .ok_or(DecodeSliceError::OutputSliceTooSmall)? = hi_byte;\n        output_index += 1;\n    }\n\n    Ok(DecodeMetadata::new(\n        output_index,\n        if padding_bytes_count > 0 {\n            Some(input_index + first_padding_offset)\n        } else {\n            None\n        },\n    ))\n}', 'Real(LocalPath("src/engine/general_purpose/decode_suffix.rs"))'], 'engine::general_purpose::decode_table': ["/// Returns a table mapping base64 bytes as the lookup index to either:\n/// - [`INVALID_VALUE`] for bytes that aren't members of the alphabet\n/// - a byte whose lower 6 bits are the value that was encoded into the index byte\npub(crate) const fn decode_table(alphabet: &Alphabet) -> [u8; 256]{\n    let mut decode_table = [INVALID_VALUE; 256];\n\n    // Since the table is full of `INVALID_VALUE` already, we only need to overwrite\n    // the parts that are valid.\n    let mut index = 0;\n    while index < 64 {\n        // The index in the alphabet is the 6-bit value we care about.\n        // Since the index is in 0-63, it is safe to cast to u8.\n        decode_table[alphabet.symbols[index] as usize] = index as u8;\n        index += 1;\n    }\n\n    decode_table\n}", 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], 'engine::general_purpose::encode_table': ['/// Returns a table mapping a 6-bit index to the ASCII byte encoding of the index\npub(crate) const fn encode_table(alphabet: &Alphabet) -> [u8; 64]{\n    // the encode table is just the alphabet:\n    // 6-bit index lookup -> printable byte\n    let mut encode_table = [0_u8; 64];\n    {\n        let mut index = 0;\n        while index < 64 {\n            encode_table[index] = alphabet.symbols[index];\n            index += 1;\n        }\n    }\n\n    encode_table\n}', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], 'engine::general_purpose::read_u64': ['#[inline]\nfn read_u64(s: &[u8]) -> u64{\n    u64::from_be_bytes(s[..8].try_into().unwrap())\n}', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))'], 'read::decoder::DecoderReader': ['/// A `Read` implementation that decodes base64 data read from an underlying reader.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::Read;\n/// use std::io::Cursor;\n/// use base64::engine::general_purpose;\n///\n/// // use a cursor as the simplest possible `Read` -- in real code this is probably a file, etc.\n/// let mut wrapped_reader = Cursor::new(b"YXNkZg==");\n/// let mut decoder = base64::read::DecoderReader::new(\n///     &mut wrapped_reader,\n///     &general_purpose::STANDARD);\n///\n/// // handle errors as you normally would\n/// let mut result = Vec::new();\n/// decoder.read_to_end(&mut result).unwrap();\n///\n/// assert_eq!(b"asdf", &result[..]);\n///\n/// ```\npub struct DecoderReader<\'e, E: Engine, R: io::Read> {\n    engine: &\'e E,\n    /// Where b64 data is read from\n    inner: R,\n\n    /// Holds b64 data read from the delegate reader.\n    b64_buffer: [u8; BUF_SIZE],\n    /// The start of the pending buffered data in `b64_buffer`.\n    b64_offset: usize,\n    /// The amount of buffered b64 data after `b64_offset` in `b64_len`.\n    b64_len: usize,\n    /// Since the caller may provide us with a buffer of size 1 or 2 that\'s too small to copy a\n    /// decoded chunk in to, we have to be able to hang on to a few decoded bytes.\n    /// Technically we only need to hold 2 bytes, but then we\'d need a separate temporary buffer to\n    /// decode 3 bytes into and then juggle copying one byte into the provided read buf and the rest\n    /// into here, which seems like a lot of complexity for 1 extra byte of storage.\n    decoded_chunk_buffer: [u8; DECODED_CHUNK_SIZE],\n    /// Index of start of decoded data in `decoded_chunk_buffer`\n    decoded_offset: usize,\n    /// Length of decoded data after `decoded_offset` in `decoded_chunk_buffer`\n    decoded_len: usize,\n    /// Input length consumed so far.\n    /// Used to provide accurate offsets in errors\n    input_consumed_len: usize,\n    /// offset of previously seen padding, if any\n    padding_offset: Option<usize>,\n}', 'Real(LocalPath("src/read/decoder.rs"))'], "read::decoder::DecoderReader::<'e, E, R>::decode_to_buf": ['/// Decode the requested number of bytes from the b64 buffer into the provided buffer. It\'s the\n/// caller\'s responsibility to choose the number of b64 bytes to decode correctly.\n///\n/// Returns a Result with the number of decoded bytes written to `buf`.\n///\n/// # Panics\n///\n/// panics if `buf` is too small\nfn decode_to_buf(&mut self, b64_len_to_decode: usize, buf: &mut [u8]) -> io::Result<usize>{\n        debug_assert!(self.b64_len >= b64_len_to_decode);\n        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);\n        debug_assert!(!buf.is_empty());\n\n        let b64_to_decode = &self.b64_buffer[self.b64_offset..self.b64_offset + b64_len_to_decode];\n        let decode_metadata = self\n            .engine\n            .internal_decode(\n                b64_to_decode,\n                buf,\n                self.engine.internal_decoded_len_estimate(b64_len_to_decode),\n            )\n            .map_err(|dse| match dse {\n                DecodeSliceError::DecodeError(de) => {\n                    match de {\n                        DecodeError::InvalidByte(offset, byte) => {\n                            match (byte, self.padding_offset) {\n                                // if there was padding in a previous block of decoding that happened to\n                                // be correct, and we now find more padding that happens to be incorrect,\n                                // to be consistent with non-reader decodes, record the error at the first\n                                // padding\n                                (PAD_BYTE, Some(first_pad_offset)) => {\n                                    DecodeError::InvalidByte(first_pad_offset, PAD_BYTE)\n                                }\n                                _ => {\n                                    DecodeError::InvalidByte(self.input_consumed_len + offset, byte)\n                                }\n                            }\n                        }\n                        DecodeError::InvalidLength(len) => {\n                            DecodeError::InvalidLength(self.input_consumed_len + len)\n                        }\n                        DecodeError::InvalidLastSymbol(offset, byte) => {\n                            DecodeError::InvalidLastSymbol(self.input_consumed_len + offset, byte)\n                        }\n                        DecodeError::InvalidPadding => DecodeError::InvalidPadding,\n                    }\n                }\n                DecodeSliceError::OutputSliceTooSmall => {\n                    unreachable!("buf is sized correctly in calling code")\n                }\n            })\n            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;\n\n        if let Some(offset) = self.padding_offset {\n            // we\'ve already seen padding\n            if decode_metadata.decoded_len > 0 {\n                // we read more after already finding padding; report error at first padding byte\n                return Err(io::Error::new(\n                    io::ErrorKind::InvalidData,\n                    DecodeError::InvalidByte(offset, PAD_BYTE),\n                ));\n            }\n        }\n\n        self.padding_offset = self.padding_offset.or(decode_metadata\n            .padding_offset\n            .map(|offset| self.input_consumed_len + offset));\n        self.input_consumed_len += b64_len_to_decode;\n        self.b64_offset += b64_len_to_decode;\n        self.b64_len -= b64_len_to_decode;\n\n        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);\n\n        Ok(decode_metadata.decoded_len)\n    }', 'Real(LocalPath("src/read/decoder.rs"))'], "read::decoder::DecoderReader::<'e, E, R>::flush_decoded_buf": ['/// Write as much as possible of the decoded buffer into the target buffer.\n/// Must only be called when there is something to write and space to write into.\n/// Returns a Result with the number of (decoded) bytes copied.\nfn flush_decoded_buf(&mut self, buf: &mut [u8]) -> io::Result<usize>{\n        debug_assert!(self.decoded_len > 0);\n        debug_assert!(!buf.is_empty());\n\n        let copy_len = cmp::min(self.decoded_len, buf.len());\n        debug_assert!(copy_len > 0);\n        debug_assert!(copy_len <= self.decoded_len);\n\n        buf[..copy_len].copy_from_slice(\n            &self.decoded_chunk_buffer[self.decoded_offset..self.decoded_offset + copy_len],\n        );\n\n        self.decoded_offset += copy_len;\n        self.decoded_len -= copy_len;\n\n        debug_assert!(self.decoded_len < DECODED_CHUNK_SIZE);\n\n        Ok(copy_len)\n    }', 'Real(LocalPath("src/read/decoder.rs"))'], "read::decoder::DecoderReader::<'e, E, R>::into_inner": ['/// Unwraps this `DecoderReader`, returning the base reader which it reads base64 encoded\n/// input from.\n///\n/// Because `DecoderReader` performs internal buffering, the state of the inner reader is\n/// unspecified. This function is mainly provided because the inner reader type may provide\n/// additional functionality beyond the `Read` implementation which may still be useful.\npub fn into_inner(self) -> R{\n        self.inner\n    }', 'Real(LocalPath("src/read/decoder.rs"))'], "read::decoder::DecoderReader::<'e, E, R>::new": ["/// Create a new decoder that will read from the provided reader `r`.\npub fn new(reader: R, engine: &'e E) -> Self{\n        DecoderReader {\n            engine,\n            inner: reader,\n            b64_buffer: [0; BUF_SIZE],\n            b64_offset: 0,\n            b64_len: 0,\n            decoded_chunk_buffer: [0; DECODED_CHUNK_SIZE],\n            decoded_offset: 0,\n            decoded_len: 0,\n            input_consumed_len: 0,\n            padding_offset: None,\n        }\n    }", 'Real(LocalPath("src/read/decoder.rs"))'], "read::decoder::DecoderReader::<'e, E, R>::read_from_delegate": ['/// Read into the remaining space in the buffer after the current contents.\n/// Must only be called when there is space to read into in the buffer.\n/// Returns the number of bytes read.\nfn read_from_delegate(&mut self) -> io::Result<usize>{\n        debug_assert!(self.b64_offset + self.b64_len < BUF_SIZE);\n\n        let read = self\n            .inner\n            .read(&mut self.b64_buffer[self.b64_offset + self.b64_len..])?;\n        self.b64_len += read;\n\n        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);\n\n        Ok(read)\n    }', 'Real(LocalPath("src/read/decoder.rs"))'], 'write::encoder::EncoderWriter': ['/// A `Write` implementation that base64 encodes data before delegating to the wrapped writer.\n///\n/// Because base64 has special handling for the end of the input data (padding, etc), there\'s a\n/// `finish()` method on this type that encodes any leftover input bytes and adds padding if\n/// appropriate. It\'s called automatically when deallocated (see the `Drop` implementation), but\n/// any error that occurs when invoking the underlying writer will be suppressed. If you want to\n/// handle such errors, call `finish()` yourself.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::Write;\n/// use base64::engine::general_purpose;\n///\n/// // use a vec as the simplest possible `Write` -- in real code this is probably a file, etc.\n/// let mut enc = base64::write::EncoderWriter::new(Vec::new(), &general_purpose::STANDARD);\n///\n/// // handle errors as you normally would\n/// enc.write_all(b"asdf").unwrap();\n///\n/// // could leave this out to be called by Drop, if you don\'t care\n/// // about handling errors or getting the delegate writer back\n/// let delegate = enc.finish().unwrap();\n///\n/// // base64 was written to the writer\n/// assert_eq!(b"YXNkZg==", &delegate[..]);\n///\n/// ```\n///\n/// # Panics\n///\n/// Calling `write()` (or related methods) or `finish()` after `finish()` has completed without\n/// error is invalid and will panic.\n///\n/// # Errors\n///\n/// Base64 encoding itself does not generate errors, but errors from the wrapped writer will be\n/// returned as per the contract of `Write`.\n///\n/// # Performance\n///\n/// It has some minor performance loss compared to encoding slices (a couple percent).\n/// It does not do any heap allocation.\n///\n/// # Limitations\n///\n/// Owing to the specification of the `write` and `flush` methods on the `Write` trait and their\n/// implications for a buffering implementation, these methods may not behave as expected. In\n/// particular, calling `write_all` on this interface may fail with `io::ErrorKind::WriteZero`.\n/// See the documentation of the `Write` trait implementation for further details.\npub struct EncoderWriter<\'e, E: Engine, W: io::Write> {\n    engine: &\'e E,\n    /// Where encoded data is written to. It\'s an Option as it\'s None immediately before Drop is\n    /// called so that `finish()` can return the underlying writer. None implies that `finish()` has\n    /// been called successfully.\n    delegate: Option<W>,\n    /// Holds a partial chunk, if any, after the last `write()`, so that we may then fill the chunk\n    /// with the next `write()`, encode it, then proceed with the rest of the input normally.\n    extra_input: [u8; MIN_ENCODE_CHUNK_SIZE],\n    /// How much of `extra` is occupied, in `[0, MIN_ENCODE_CHUNK_SIZE]`.\n    extra_input_occupied_len: usize,\n    /// Buffer to encode into. May hold leftover encoded bytes from a previous write call that the underlying writer\n    /// did not write last time.\n    output: [u8; BUF_SIZE],\n    /// How much of `output` is occupied with encoded data that couldn\'t be written last time\n    output_occupied_len: usize,\n    /// panic safety: don\'t write again in destructor if writer panicked while we were writing to it\n    panicked: bool,\n}', 'Real(LocalPath("src/write/encoder.rs"))'], "write::encoder::EncoderWriter::<'e, E, W>::finish": ['/// Encode all remaining buffered data and write it, including any trailing incomplete input\n/// triples and associated padding.\n///\n/// Once this succeeds, no further writes or calls to this method are allowed.\n///\n/// This may write to the delegate writer multiple times if the delegate writer does not accept\n/// all input provided to its `write` each invocation.\n///\n/// If you don\'t care about error handling, it is not necessary to call this function, as the\n/// equivalent finalization is done by the Drop impl.\n///\n/// Returns the writer that this was constructed around.\n///\n/// # Errors\n///\n/// The first error that is not of `ErrorKind::Interrupted` will be returned.\npub fn finish(&mut self) -> Result<W>{\n        // If we could consume self in finish(), we wouldn\'t have to worry about this case, but\n        // finish() is retryable in the face of I/O errors, so we can\'t consume here.\n        assert!(\n            self.delegate.is_some(),\n            "Encoder has already had finish() called"\n        );\n\n        self.write_final_leftovers()?;\n\n        let writer = self.delegate.take().expect("Writer must be present");\n\n        Ok(writer)\n    }', 'Real(LocalPath("src/write/encoder.rs"))'], "write::encoder::EncoderWriter::<'e, E, W>::into_inner": ['/// Unwraps this `EncoderWriter`, returning the base writer it writes base64 encoded output\n/// to.\n///\n/// Normally this method should not be needed, since `finish()` returns the inner writer if\n/// it completes successfully. That will also ensure all data has been flushed, which the\n/// `into_inner()` function does *not* do.\n///\n/// Calling this method after `finish()` has completed successfully will panic, since the\n/// writer has already been returned.\n///\n/// This method may be useful if the writer implements additional APIs beyond the `Write`\n/// trait. Note that the inner writer might be in an error state or have an incomplete\n/// base64 string written to it.\npub fn into_inner(mut self) -> W{\n        self.delegate\n            .take()\n            .expect("Encoder has already had finish() called")\n    }', 'Real(LocalPath("src/write/encoder.rs"))'], "write::encoder::EncoderWriter::<'e, E, W>::new": ["/// Create a new encoder that will write to the provided delegate writer.\npub fn new(delegate: W, engine: &'e E) -> EncoderWriter<'e, E, W>{\n        EncoderWriter {\n            engine,\n            delegate: Some(delegate),\n            extra_input: [0u8; MIN_ENCODE_CHUNK_SIZE],\n            extra_input_occupied_len: 0,\n            output: [0u8; BUF_SIZE],\n            output_occupied_len: 0,\n            panicked: false,\n        }\n    }", 'Real(LocalPath("src/write/encoder.rs"))'], "write::encoder::EncoderWriter::<'e, E, W>::write_all_encoded_output": ["/// Write all buffered encoded output. If this returns `Ok`, `self.output_occupied_len` is `0`.\n///\n/// This is basically `write_all` for the remaining buffered data but without the undesirable\n/// abort-on-`Ok(0)` behavior.\n///\n/// # Errors\n///\n/// Any error emitted by the delegate writer abort the write loop and is returned, unless it's\n/// `Interrupted`, in which case the error is ignored and writes will continue.\nfn write_all_encoded_output(&mut self) -> Result<()>{\n        while self.output_occupied_len > 0 {\n            let remaining_len = self.output_occupied_len;\n            match self.write_to_delegate(remaining_len) {\n                // try again on interrupts ala write_all\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                // other errors return\n                Err(e) => return Err(e),\n                // success no-ops because remaining length is already updated\n                Ok(()) => {}\n            };\n        }\n\n        debug_assert_eq!(0, self.output_occupied_len);\n        Ok(())\n    }", 'Real(LocalPath("src/write/encoder.rs"))'], "write::encoder::EncoderWriter::<'e, E, W>::write_final_leftovers": ['/// Write any remaining buffered data to the delegate writer.\nfn write_final_leftovers(&mut self) -> Result<()>{\n        if self.delegate.is_none() {\n            // finish() has already successfully called this, and we are now in drop() with a None\n            // writer, so just no-op\n            return Ok(());\n        }\n\n        self.write_all_encoded_output()?;\n\n        if self.extra_input_occupied_len > 0 {\n            let encoded_len = self\n                .engine\n                .encode_slice(\n                    &self.extra_input[..self.extra_input_occupied_len],\n                    &mut self.output[..],\n                )\n                .expect("buffer is large enough");\n\n            self.output_occupied_len = encoded_len;\n\n            self.write_all_encoded_output()?;\n\n            // write succeeded, do not write the encoding of extra again if finish() is retried\n            self.extra_input_occupied_len = 0;\n        }\n\n        Ok(())\n    }', 'Real(LocalPath("src/write/encoder.rs"))'], "write::encoder::EncoderWriter::<'e, E, W>::write_to_delegate": ['/// Write as much of the encoded output to the delegate writer as it will accept, and store the\n/// leftovers to be attempted at the next `write()` call. Updates `self.output_occupied_len`.\n///\n/// # Errors\n///\n/// Errors from the delegate writer are returned. In the case of an error,\n/// `self.output_occupied_len` will not be updated, as errors from `write` are specified to mean\n/// that no write took place.\nfn write_to_delegate(&mut self, current_output_len: usize) -> Result<()>{\n        self.panicked = true;\n        let res = self\n            .delegate\n            .as_mut()\n            .expect("Writer must be present")\n            .write(&self.output[..current_output_len]);\n        self.panicked = false;\n\n        res.map(|consumed| {\n            debug_assert!(consumed <= current_output_len);\n\n            if consumed < current_output_len {\n                self.output_occupied_len = current_output_len.checked_sub(consumed).unwrap();\n                // If we\'re blocking on I/O, the minor inefficiency of copying bytes to the\n                // start of the buffer is the least of our concerns...\n                // TODO Rotate moves more than we need to; copy_within now stable.\n                self.output.rotate_left(consumed);\n            } else {\n                self.output_occupied_len = 0;\n            }\n        })\n    }', 'Real(LocalPath("src/write/encoder.rs"))'], 'write::encoder_string_writer::EncoderStringWriter': ['/// A `Write` implementation that base64-encodes data using the provided config and accumulates the\n/// resulting base64 utf8 `&str` in a [`StrConsumer`] implementation (typically `String`), which is\n/// then exposed via `into_inner()`.\n///\n/// # Examples\n///\n/// Buffer base64 in a new String:\n///\n/// ```\n/// use std::io::Write;\n/// use base64::engine::general_purpose;\n///\n/// let mut enc = base64::write::EncoderStringWriter::new(&general_purpose::STANDARD);\n///\n/// enc.write_all(b"asdf").unwrap();\n///\n/// // get the resulting String\n/// let b64_string = enc.into_inner();\n///\n/// assert_eq!("YXNkZg==", &b64_string);\n/// ```\n///\n/// Or, append to an existing `String`, which implements `StrConsumer`:\n///\n/// ```\n/// use std::io::Write;\n/// use base64::engine::general_purpose;\n///\n/// let mut buf = String::from("base64: ");\n///\n/// let mut enc = base64::write::EncoderStringWriter::from_consumer(\n///     &mut buf,\n///     &general_purpose::STANDARD);\n///\n/// enc.write_all(b"asdf").unwrap();\n///\n/// // release the &mut reference on buf\n/// let _ = enc.into_inner();\n///\n/// assert_eq!("base64: YXNkZg==", &buf);\n/// ```\n///\n/// # Performance\n///\n/// Because it has to validate that the base64 is UTF-8, it is about 80% as fast as writing plain\n/// bytes to a `io::Write`.\npub struct EncoderStringWriter<\'e, E: Engine, S: StrConsumer> {\n    encoder: EncoderWriter<\'e, E, Utf8SingleCodeUnitWriter<S>>,\n}', 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], "write::encoder_string_writer::EncoderStringWriter::<'e, E, S>::from_consumer": ["/// Create a `EncoderStringWriter` that will append to the provided `StrConsumer`.\npub fn from_consumer(str_consumer: S, engine: &'e E) -> Self{\n        EncoderStringWriter {\n            encoder: EncoderWriter::new(Utf8SingleCodeUnitWriter { str_consumer }, engine),\n        }\n    }", 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], "write::encoder_string_writer::EncoderStringWriter::<'e, E, S>::into_inner": ['/// Encode all remaining buffered data, including any trailing incomplete input triples and\n/// associated padding.\n///\n/// Returns the base64-encoded form of the accumulated written data.\npub fn into_inner(mut self) -> S{\n        self.encoder\n            .finish()\n            .expect("Writing to a consumer should never fail")\n            .str_consumer\n    }', 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], "write::encoder_string_writer::EncoderStringWriter::<'e, E, std::string::String>::new": ["/// Create a `EncoderStringWriter` that will encode into a new `String` with the provided config.\npub fn new(engine: &'e E) -> Self{\n        EncoderStringWriter::from_consumer(String::new(), engine)\n    }", 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], 'write::encoder_string_writer::StrConsumer': ['/// An abstraction around consuming `str`s produced by base64 encoding.\npub trait StrConsumer {\n    /// Consume the base64 encoded data in `buf`\n    fn consume(&mut self, buf: &str);\n}', 'Real(LocalPath("src/write/encoder_string_writer.rs"))'], 'write::encoder_string_writer::Utf8SingleCodeUnitWriter': ['/// A `Write` that only can handle bytes that are valid single-byte UTF-8 code units.\n///\n/// This is safe because we only use it when writing base64, which is always valid UTF-8.\nstruct Utf8SingleCodeUnitWriter<S: StrConsumer> {\n    str_consumer: S,\n}', 'Real(LocalPath("src/write/encoder_string_writer.rs"))']}, 'struct_constructor': {'&\'^0.Named(DefId(0:684 ~ base64[4822]::engine::general_purpose::{impl#1}::config::\'_), "\'_") Alias(Projection, AliasTy { args: [engine::general_purpose::GeneralPurpose], def_id: DefId(0:328 ~ base64[4822]::engine::Engine::Config) })': ['config'], '&\'^0.Named(DefId(0:696 ~ base64[4822]::engine::Engine::config::\'_), "\'_") Alias(Projection, AliasTy { args: [Self/#0], def_id: DefId(0:328 ~ base64[4822]::engine::Engine::Config) })': ['config'], '&\'^0.Named(DefId(0:733 ~ base64[4822]::alphabet::{impl#0}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:757 ~ base64[4822]::decode::{impl#3}::source::\'_), "\'_") dyn [Binder { value: Trait(std::error::Error), bound_vars: [] }] + \'static': ['source'], 'Alias(Projection, AliasTy { args: [Self/#0], def_id: DefId(0:329 ~ base64[4822]::engine::Engine::DecodeEstimate) })': ['internal_decoded_len_estimate'], 'Alias(Projection, AliasTy { args: [engine::general_purpose::GeneralPurpose], def_id: DefId(0:329 ~ base64[4822]::engine::Engine::DecodeEstimate) })': ['internal_decoded_len_estimate'], '[u8; 256_usize]': ['decode_table'], '[u8; 64_usize]': ['encode_table'], 'alphabet::Alphabet': ['clone', 'from_str_unchecked', 'new', 'try_from'], 'bool': ['encode_padding', 'eq'], 'chunked_encoder::ChunkedEncoder': ['new'], 'chunked_encoder::StringSink': ['new'], 'decode::DecodeError': ['clone'], 'decode::DecodeSliceError': ['clone', 'from'], 'display::Base64Display': ['new'], 'encode::EncodeSliceError': ['clone'], 'engine::DecodeMetadata': ['decode_helper', 'decode_suffix', 'internal_decode', 'new'], 'engine::DecodePaddingMode': ['clone'], 'engine::general_purpose::GeneralPurpose': ['clone', 'new'], 'engine::general_purpose::GeneralPurposeConfig': ['clone', 'default', 'new'], 'engine::general_purpose::decode::GeneralPurposeEstimate': ['new'], 'read::decoder::DecoderReader': ['new'], 'std::string::String': ['encode', 'encode_engine', 'inner'], 'std::vec::Vec': ['decode', 'decode_engine', 'inner'], 'u64': ['read_u64'], 'usize': ['decode_engine_slice', 'decode_slice', 'decode_slice_unchecked', 'decoded_len_estimate', 'encode_engine_slice', 'encode_slice', 'flush_decoded_buf', 'inner', 'internal_encode', 'read', 'read_from_delegate', 'write'], 'write::encoder::EncoderWriter': ['new'], 'write::encoder_string_writer::EncoderStringWriter': ['from_consumer', 'new']}, 'struct_to_trait': {'alphabet::Alphabet': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::TryFrom', 'std::fmt::Debug', 'std::marker::StructuralPartialEq'], 'alphabet::ParseAlphabetError': ['std::cmp::Eq', 'std::cmp::PartialEq', 'std::error::Error', 'std::fmt::Debug', 'std::fmt::Display', 'std::marker::StructuralPartialEq'], 'chunked_encoder::StringSink': ['chunked_encoder::Sink'], 'decode::DecodeError': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::error::Error', 'std::fmt::Debug', 'std::fmt::Display', 'std::marker::StructuralPartialEq'], 'decode::DecodeSliceError': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::From', 'std::error::Error', 'std::fmt::Debug', 'std::fmt::Display', 'std::marker::StructuralPartialEq'], 'display::Base64Display': ['std::fmt::Display'], 'display::FormatterSink': ['chunked_encoder::Sink'], 'encode::EncodeSliceError': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::error::Error', 'std::fmt::Debug', 'std::fmt::Display', 'std::marker::StructuralPartialEq'], 'engine::DecodeMetadata': ['std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::marker::StructuralPartialEq'], 'engine::DecodePaddingMode': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::marker::Copy', 'std::marker::StructuralPartialEq'], 'engine::general_purpose::GeneralPurpose': ['engine::Engine', 'std::clone::Clone', 'std::fmt::Debug'], 'engine::general_purpose::GeneralPurposeConfig': ['engine::Config', 'std::clone::Clone', 'std::default::Default', 'std::fmt::Debug', 'std::marker::Copy'], 'engine::general_purpose::decode::GeneralPurposeEstimate': ['engine::DecodeEstimate'], 'read::decoder::DecoderReader': ['std::fmt::Debug', 'std::io::Read'], 'std::string::String': ['write::encoder_string_writer::StrConsumer'], 'write::encoder::EncoderWriter': ['std::fmt::Debug', 'std::io::Write', 'std::ops::Drop'], 'write::encoder_string_writer::EncoderStringWriter': ['std::io::Write'], 'write::encoder_string_writer::Utf8SingleCodeUnitWriter': ['std::io::Write']}, 'targets': {'<&mut S as write::encoder_string_writer::StrConsumer>::consume': ['consume', 'Real(LocalPath("src/write/encoder_string_writer.rs"))', 'write::encoder_string_writer::StrConsumer'], '<alphabet::Alphabet as std::convert::TryFrom<&str>>::try_from': ['try_from', 'Real(LocalPath("src/alphabet.rs"))', 'std::convert::TryFrom'], '<alphabet::ParseAlphabetError as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/alphabet.rs"))', 'std::fmt::Display'], "<chunked_encoder::StringSink<'a> as chunked_encoder::Sink>::write_encoded_bytes": ['write_encoded_bytes', 'Real(LocalPath("src/chunked_encoder.rs"))', 'chunked_encoder::Sink'], '<decode::DecodeError as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/decode.rs"))', 'std::fmt::Display'], '<decode::DecodeSliceError as std::convert::From<decode::DecodeError>>::from': ['from', 'Real(LocalPath("src/decode.rs"))', 'std::convert::From'], '<decode::DecodeSliceError as std::error::Error>::source': ['source', 'Real(LocalPath("src/decode.rs"))', 'std::error::Error'], '<decode::DecodeSliceError as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/decode.rs"))', 'std::fmt::Display'], "<display::Base64Display<'a, 'e, E> as std::fmt::Display>::fmt": ['fmt', 'Real(LocalPath("src/display.rs"))', 'std::fmt::Display'], "<display::FormatterSink<'a, 'b> as chunked_encoder::Sink>::write_encoded_bytes": ['write_encoded_bytes', 'Real(LocalPath("src/display.rs"))', 'chunked_encoder::Sink'], '<encode::EncodeSliceError as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/encode.rs"))', 'std::fmt::Display'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::config': ['config', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', 'engine::Engine'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_decode': ['internal_decode', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', 'engine::Engine'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_decoded_len_estimate': ['internal_decoded_len_estimate', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', 'engine::Engine'], '<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_encode': ['internal_encode', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', 'engine::Engine'], '<engine::general_purpose::GeneralPurposeConfig as engine::Config>::encode_padding': ['encode_padding', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', 'engine::Config'], '<engine::general_purpose::GeneralPurposeConfig as std::default::Default>::default': ['default', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', 'std::default::Default'], '<engine::general_purpose::decode::GeneralPurposeEstimate as engine::DecodeEstimate>::decoded_len_estimate': ['decoded_len_estimate', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))', 'engine::DecodeEstimate'], "<read::decoder::DecoderReader<'e, E, R> as std::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/read/decoder.rs"))', 'std::fmt::Debug'], "<read::decoder::DecoderReader<'e, E, R> as std::io::Read>::read": ['read', 'Real(LocalPath("src/read/decoder.rs"))', 'std::io::Read'], '<std::string::String as write::encoder_string_writer::StrConsumer>::consume': ['consume', 'Real(LocalPath("src/write/encoder_string_writer.rs"))', 'write::encoder_string_writer::StrConsumer'], "<write::encoder::EncoderWriter<'e, E, W> as std::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/write/encoder.rs"))', 'std::fmt::Debug'], "<write::encoder::EncoderWriter<'e, E, W> as std::io::Write>::flush": ['flush', 'Real(LocalPath("src/write/encoder.rs"))', 'std::io::Write'], "<write::encoder::EncoderWriter<'e, E, W> as std::io::Write>::write": ['write', 'Real(LocalPath("src/write/encoder.rs"))', 'std::io::Write'], "<write::encoder::EncoderWriter<'e, E, W> as std::ops::Drop>::drop": ['drop', 'Real(LocalPath("src/write/encoder.rs"))', 'std::ops::Drop'], "<write::encoder_string_writer::EncoderStringWriter<'e, E, S> as std::io::Write>::flush": ['flush', 'Real(LocalPath("src/write/encoder_string_writer.rs"))', 'std::io::Write'], "<write::encoder_string_writer::EncoderStringWriter<'e, E, S> as std::io::Write>::write": ['write', 'Real(LocalPath("src/write/encoder_string_writer.rs"))', 'std::io::Write'], '<write::encoder_string_writer::Utf8SingleCodeUnitWriter<S> as std::io::Write>::flush': ['flush', 'Real(LocalPath("src/write/encoder_string_writer.rs"))', 'std::io::Write'], '<write::encoder_string_writer::Utf8SingleCodeUnitWriter<S> as std::io::Write>::write': ['write', 'Real(LocalPath("src/write/encoder_string_writer.rs"))', 'std::io::Write'], 'alphabet::Alphabet::as_str': ['as_str', 'Real(LocalPath("src/alphabet.rs"))', ''], 'alphabet::Alphabet::from_str_unchecked': ['from_str_unchecked', 'Real(LocalPath("src/alphabet.rs"))', ''], 'alphabet::Alphabet::new': ['new', 'Real(LocalPath("src/alphabet.rs"))', ''], "chunked_encoder::ChunkedEncoder::<'e, E>::encode": ['encode', 'Real(LocalPath("src/chunked_encoder.rs"))', ''], "chunked_encoder::ChunkedEncoder::<'e, E>::new": ['new', 'Real(LocalPath("src/chunked_encoder.rs"))', ''], "chunked_encoder::StringSink::<'a>::new": ['new', 'Real(LocalPath("src/chunked_encoder.rs"))', ''], 'decode::decode': ['decode', 'Real(LocalPath("src/decode.rs"))', ''], 'decode::decode_engine': ['decode_engine', 'Real(LocalPath("src/decode.rs"))', ''], 'decode::decode_engine_slice': ['decode_engine_slice', 'Real(LocalPath("src/decode.rs"))', ''], 'decode::decode_engine_vec': ['decode_engine_vec', 'Real(LocalPath("src/decode.rs"))', ''], 'decode::decoded_len_estimate': ['decoded_len_estimate', 'Real(LocalPath("src/decode.rs"))', ''], "display::Base64Display::<'a, 'e, E>::new": ['new', 'Real(LocalPath("src/display.rs"))', ''], 'encode::add_padding': ['add_padding', 'Real(LocalPath("src/encode.rs"))', ''], 'encode::encode': ['encode', 'Real(LocalPath("src/encode.rs"))', ''], 'encode::encode_engine': ['encode_engine', 'Real(LocalPath("src/encode.rs"))', ''], 'encode::encode_engine_slice': ['encode_engine_slice', 'Real(LocalPath("src/encode.rs"))', ''], 'encode::encode_engine_string': ['encode_engine_string', 'Real(LocalPath("src/encode.rs"))', ''], 'encode::encode_with_padding': ['encode_with_padding', 'Real(LocalPath("src/encode.rs"))', ''], 'encode::encoded_len': ['encoded_len', 'Real(LocalPath("src/encode.rs"))', ''], 'engine::DecodeMetadata::new': ['new', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::decode': ['decode', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::decode::inner': ['inner', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::decode_slice': ['decode_slice', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::decode_slice::inner': ['inner', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::decode_slice_unchecked': ['decode_slice_unchecked', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::decode_slice_unchecked::inner': ['inner', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::decode_vec': ['decode_vec', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::decode_vec::inner': ['inner', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::encode': ['encode', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::encode::inner': ['inner', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::encode_slice': ['encode_slice', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::encode_slice::inner': ['inner', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::encode_string': ['encode_string', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::Engine::encode_string::inner': ['inner', 'Real(LocalPath("src/engine/mod.rs"))', ''], 'engine::general_purpose::GeneralPurpose::new': ['new', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', ''], 'engine::general_purpose::GeneralPurposeConfig::new': ['new', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', ''], 'engine::general_purpose::GeneralPurposeConfig::with_decode_allow_trailing_bits': ['with_decode_allow_trailing_bits', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', ''], 'engine::general_purpose::GeneralPurposeConfig::with_decode_padding_mode': ['with_decode_padding_mode', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', ''], 'engine::general_purpose::GeneralPurposeConfig::with_encode_padding': ['with_encode_padding', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', ''], 'engine::general_purpose::decode::GeneralPurposeEstimate::new': ['new', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))', ''], 'engine::general_purpose::decode::complete_quads_len': ['complete_quads_len', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))', ''], 'engine::general_purpose::decode::decode_chunk_4': ['decode_chunk_4', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))', ''], 'engine::general_purpose::decode::decode_chunk_8': ['decode_chunk_8', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))', ''], 'engine::general_purpose::decode::decode_helper': ['decode_helper', 'Real(LocalPath("src/engine/general_purpose/decode.rs"))', ''], 'engine::general_purpose::decode_suffix::decode_suffix': ['decode_suffix', 'Real(LocalPath("src/engine/general_purpose/decode_suffix.rs"))', ''], 'engine::general_purpose::decode_table': ['decode_table', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', ''], 'engine::general_purpose::encode_table': ['encode_table', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', ''], 'engine::general_purpose::read_u64': ['read_u64', 'Real(LocalPath("src/engine/general_purpose/mod.rs"))', ''], "read::decoder::DecoderReader::<'e, E, R>::decode_to_buf": ['decode_to_buf', 'Real(LocalPath("src/read/decoder.rs"))', ''], "read::decoder::DecoderReader::<'e, E, R>::flush_decoded_buf": ['flush_decoded_buf', 'Real(LocalPath("src/read/decoder.rs"))', ''], "read::decoder::DecoderReader::<'e, E, R>::into_inner": ['into_inner', 'Real(LocalPath("src/read/decoder.rs"))', ''], "read::decoder::DecoderReader::<'e, E, R>::new": ['new', 'Real(LocalPath("src/read/decoder.rs"))', ''], "read::decoder::DecoderReader::<'e, E, R>::read_from_delegate": ['read_from_delegate', 'Real(LocalPath("src/read/decoder.rs"))', ''], "write::encoder::EncoderWriter::<'e, E, W>::finish": ['finish', 'Real(LocalPath("src/write/encoder.rs"))', ''], "write::encoder::EncoderWriter::<'e, E, W>::into_inner": ['into_inner', 'Real(LocalPath("src/write/encoder.rs"))', ''], "write::encoder::EncoderWriter::<'e, E, W>::new": ['new', 'Real(LocalPath("src/write/encoder.rs"))', ''], "write::encoder::EncoderWriter::<'e, E, W>::write_all_encoded_output": ['write_all_encoded_output', 'Real(LocalPath("src/write/encoder.rs"))', ''], "write::encoder::EncoderWriter::<'e, E, W>::write_final_leftovers": ['write_final_leftovers', 'Real(LocalPath("src/write/encoder.rs"))', ''], "write::encoder::EncoderWriter::<'e, E, W>::write_to_delegate": ['write_to_delegate', 'Real(LocalPath("src/write/encoder.rs"))', ''], "write::encoder_string_writer::EncoderStringWriter::<'e, E, S>::from_consumer": ['from_consumer', 'Real(LocalPath("src/write/encoder_string_writer.rs"))', ''], "write::encoder_string_writer::EncoderStringWriter::<'e, E, S>::into_inner": ['into_inner', 'Real(LocalPath("src/write/encoder_string_writer.rs"))', ''], "write::encoder_string_writer::EncoderStringWriter::<'e, E, std::string::String>::new": ['new', 'Real(LocalPath("src/write/encoder_string_writer.rs"))', '']}, 'trait_to_struct': {'chunked_encoder::Sink': ['chunked_encoder::StringSink', 'display::FormatterSink'], 'engine::Config': ['engine::general_purpose::GeneralPurposeConfig'], 'engine::DecodeEstimate': ['engine::general_purpose::decode::GeneralPurposeEstimate'], 'engine::Engine': ['engine::general_purpose::GeneralPurpose'], 'std::clone::Clone': ['alphabet::Alphabet', 'decode::DecodeError', 'decode::DecodeSliceError', 'encode::EncodeSliceError', 'engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig'], 'std::cmp::Eq': ['alphabet::Alphabet', 'alphabet::ParseAlphabetError', 'decode::DecodeError', 'decode::DecodeSliceError', 'encode::EncodeSliceError', 'engine::DecodeMetadata', 'engine::DecodePaddingMode'], 'std::cmp::PartialEq': ['alphabet::Alphabet', 'alphabet::ParseAlphabetError', 'decode::DecodeError', 'decode::DecodeSliceError', 'encode::EncodeSliceError', 'engine::DecodeMetadata', 'engine::DecodePaddingMode'], 'std::convert::From': ['decode::DecodeSliceError'], 'std::convert::TryFrom': ['alphabet::Alphabet'], 'std::default::Default': ['engine::general_purpose::GeneralPurposeConfig'], 'std::error::Error': ['alphabet::ParseAlphabetError', 'decode::DecodeError', 'decode::DecodeSliceError', 'encode::EncodeSliceError'], 'std::fmt::Debug': ['alphabet::Alphabet', 'alphabet::ParseAlphabetError', 'decode::DecodeError', 'decode::DecodeSliceError', 'encode::EncodeSliceError', 'engine::DecodeMetadata', 'engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig', 'read::decoder::DecoderReader', 'write::encoder::EncoderWriter'], 'std::fmt::Display': ['alphabet::ParseAlphabetError', 'decode::DecodeError', 'decode::DecodeSliceError', 'display::Base64Display', 'encode::EncodeSliceError'], 'std::io::Read': ['read::decoder::DecoderReader'], 'std::io::Write': ['write::encoder::EncoderWriter', 'write::encoder_string_writer::EncoderStringWriter', 'write::encoder_string_writer::Utf8SingleCodeUnitWriter'], 'std::marker::Copy': ['engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurposeConfig'], 'std::marker::StructuralPartialEq': ['alphabet::Alphabet', 'alphabet::ParseAlphabetError', 'decode::DecodeError', 'decode::DecodeSliceError', 'encode::EncodeSliceError', 'engine::DecodeMetadata', 'engine::DecodePaddingMode'], 'std::ops::Drop': ['write::encoder::EncoderWriter'], 'write::encoder_string_writer::StrConsumer': ['std::string::String']}, 'type_to_def_path': {'alphabet::Alphabet': 'alphabet::Alphabet', 'alphabet::ParseAlphabetError': 'alphabet::ParseAlphabetError', "chunked_encoder::ChunkedEncoder<'e, E>": 'chunked_encoder::ChunkedEncoder', "chunked_encoder::StringSink<'a>": 'chunked_encoder::StringSink', 'decode::DecodeError': 'decode::DecodeError', 'decode::DecodeSliceError': 'decode::DecodeSliceError', "display::Base64Display<'a, 'e, E>": 'display::Base64Display', "display::FormatterSink<'a, 'b>": 'display::FormatterSink', 'encode::EncodeSliceError': 'encode::EncodeSliceError', 'engine::DecodeMetadata': 'engine::DecodeMetadata', 'engine::DecodePaddingMode': 'engine::DecodePaddingMode', 'engine::general_purpose::GeneralPurpose': 'engine::general_purpose::GeneralPurpose', 'engine::general_purpose::GeneralPurposeConfig': 'engine::general_purpose::GeneralPurposeConfig', 'engine::general_purpose::decode::GeneralPurposeEstimate': 'engine::general_purpose::decode::GeneralPurposeEstimate', "read::decoder::DecoderReader<'e, E, R>": 'read::decoder::DecoderReader', "write::encoder::EncoderWriter<'e, E, W>": 'write::encoder::EncoderWriter', "write::encoder_string_writer::EncoderStringWriter<'e, E, S>": 'write::encoder_string_writer::EncoderStringWriter', 'write::encoder_string_writer::Utf8SingleCodeUnitWriter<S>': 'write::encoder_string_writer::Utf8SingleCodeUnitWriter'}}, 'rust-base64', 'base64') finished, time: 763.7727899090387s
