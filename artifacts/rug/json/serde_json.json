{
    "dependencies": {
        "<&'a map::Map<alloc::string::String, value::Value> as core::iter::IntoIterator>::into_iter": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<&'a mut map::Map<alloc::string::String, value::Value> as core::iter::IntoIterator>::into_iter": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::fmt::Display",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter": [
            "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter",
            "core::marker::Sized",
            "core::option::Option"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Serializer",
            "serde::Serialize"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Serializer",
            "serde::Serialize"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Serializer",
            "serde::Serialize"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Serializer"
        ],
        "<&'de map::Map<alloc::string::String, value::Value> as serde::de::IntoDeserializer<'de, error::Error>>::into_deserializer": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<&T as value::index::Index>::index_into": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<&T as value::index::Index>::index_into_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<&T as value::index::Index>::index_or_insert": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<&mut R as read::Read<'de>>::byte_offset": [],
        "<&mut R as read::Read<'de>>::decode_hex_escape": [
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<&mut R as read::Read<'de>>::discard": [],
        "<&mut R as read::Read<'de>>::ignore_str": [
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<&mut R as read::Read<'de>>::next": [
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<&mut R as read::Read<'de>>::parse_str": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<&mut R as read::Read<'de>>::parse_str_raw": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<&mut R as read::Read<'de>>::peek": [
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<&mut R as read::Read<'de>>::peek_position": [
            "read::Position"
        ],
        "<&mut R as read::Read<'de>>::position": [
            "read::Position"
        ],
        "<&mut R as read::Read<'de>>::set_failed": [],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_bool": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_bytes": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_char": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_enum": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_f32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_f64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_identifier": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_option": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_seq": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_str": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_string": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_tuple": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as core::fmt::Write>::write_str": [
            "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result"
        ],
        "<<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapAccess",
            "serde::de::MapAccess"
        ],
        "<<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "serde::de::Error"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::expecting": [
            "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64": [
            "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor",
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "serde::de::Error"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i128": [
            "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor",
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "serde::de::Error"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64": [
            "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u128": [
            "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor",
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "serde::de::Error"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64": [
            "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<<value::Value as core::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::flush": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<<value::Value as core::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::write": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<alloc::string::String as value::index::Index>::index_into": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<alloc::string::String as value::index::Index>::index_into_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<alloc::string::String as value::index::Index>::index_or_insert": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapAccess",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier"
        ],
        "<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed::has_next_key": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "de::Deserializer",
            "de::MapAccess",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Read",
            "std::io::Read"
        ],
        "<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapAccess",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::SeqAccess",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier"
        ],
        "<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed::has_next_element": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "de::Deserializer",
            "de::SeqAccess",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Read",
            "std::io::Read"
        ],
        "<de::StreamDeserializer<'de, R, T> as core::iter::Iterator>::next": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "core::option::Option",
            "de::Deserializer",
            "de::StreamDeserializer"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::UnitVariantAccess",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::UnitVariantAccess",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::UnitVariantAccess",
            "serde::de::Visitor"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::UnitVariantAccess",
            "serde::de::Visitor"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::UnitVariantAccess"
        ],
        "<de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::VariantAccess",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::VariantAccess",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::VariantAccess",
            "serde::de::Visitor"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::VariantAccess",
            "serde::de::Visitor"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::VariantAccess"
        ],
        "<error::Category as core::clone::Clone>::clone": [
            "error::Category"
        ],
        "<error::Category as core::cmp::Eq>::assert_receiver_is_total_eq": [
            "error::Category"
        ],
        "<error::Category as core::cmp::PartialEq>::eq": [
            "error::Category"
        ],
        "<error::Category as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category"
        ],
        "<error::Error as core::error::Error>::source": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "error::Error"
        ],
        "<error::Error as core::fmt::Debug>::fmt": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error"
        ],
        "<error::Error as core::fmt::Display>::fmt": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error"
        ],
        "<error::Error as serde::de::Error>::custom": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::fmt::Display",
            "core::marker::Sized",
            "error::Error"
        ],
        "<error::Error as serde::de::Error>::invalid_type": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error",
            "serde::de::Unexpected"
        ],
        "<error::Error as serde::de::Error>::invalid_value": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error",
            "serde::de::Unexpected"
        ],
        "<error::Error as serde::ser::Error>::custom": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::fmt::Display",
            "core::marker::Sized",
            "error::Error"
        ],
        "<error::ErrorCode as core::fmt::Display>::fmt": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::ErrorCode",
            "std::io::Error"
        ],
        "<error::ErrorImpl as core::fmt::Display>::fmt": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::ErrorCode",
            "error::ErrorImpl",
            "std::io::Error"
        ],
        "<error::JsonUnexpected<'a> as core::fmt::Display>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::JsonUnexpected",
            "serde::de::Unexpected"
        ],
        "<iter::LineColIterator<I> as core::iter::Iterator>::next": [
            "core::marker::Sized",
            "core::option::Option",
            "iter::LineColIterator"
        ],
        "<map::IntoIter as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::collections::btree_map::IntoIter",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::IntoIter"
        ],
        "<map::IntoIter as core::iter::ExactSizeIterator>::len": [
            "alloc::collections::btree_map::IntoIter",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::IntoIter"
        ],
        "<map::IntoIter as core::iter::Iterator>::next": [
            "alloc::collections::btree_map::IntoIter",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::IntoIter"
        ],
        "<map::IntoIter as core::iter::Iterator>::size_hint": [
            "alloc::collections::btree_map::IntoIter",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::IntoIter"
        ],
        "<map::IntoValues as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::collections::btree_map::IntoValues",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::IntoValues"
        ],
        "<map::IntoValues as core::iter::ExactSizeIterator>::len": [
            "alloc::collections::btree_map::IntoValues",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::IntoValues"
        ],
        "<map::IntoValues as core::iter::Iterator>::next": [
            "alloc::collections::btree_map::IntoValues",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::IntoValues"
        ],
        "<map::IntoValues as core::iter::Iterator>::size_hint": [
            "alloc::collections::btree_map::IntoValues",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::IntoValues"
        ],
        "<map::Iter<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::collections::btree_map::Iter",
            "core::marker::Sized",
            "core::option::Option",
            "map::Iter"
        ],
        "<map::Iter<'a> as core::iter::ExactSizeIterator>::len": [
            "alloc::collections::btree_map::Iter",
            "core::marker::Sized",
            "map::Iter"
        ],
        "<map::Iter<'a> as core::iter::Iterator>::next": [
            "alloc::collections::btree_map::Iter",
            "core::marker::Sized",
            "core::option::Option",
            "map::Iter"
        ],
        "<map::Iter<'a> as core::iter::Iterator>::size_hint": [
            "alloc::collections::btree_map::Iter",
            "core::marker::Sized",
            "core::option::Option",
            "map::Iter"
        ],
        "<map::IterMut<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::collections::btree_map::IterMut",
            "core::marker::Sized",
            "core::option::Option",
            "map::IterMut"
        ],
        "<map::IterMut<'a> as core::iter::ExactSizeIterator>::len": [
            "alloc::collections::btree_map::IterMut",
            "core::marker::Sized",
            "map::IterMut"
        ],
        "<map::IterMut<'a> as core::iter::Iterator>::next": [
            "alloc::collections::btree_map::IterMut",
            "core::marker::Sized",
            "core::option::Option",
            "map::IterMut"
        ],
        "<map::IterMut<'a> as core::iter::Iterator>::size_hint": [
            "alloc::collections::btree_map::IterMut",
            "core::marker::Sized",
            "core::option::Option",
            "map::IterMut"
        ],
        "<map::Keys<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::collections::btree_map::Keys",
            "core::marker::Sized",
            "core::option::Option",
            "map::Keys"
        ],
        "<map::Keys<'a> as core::iter::ExactSizeIterator>::len": [
            "alloc::collections::btree_map::Keys",
            "core::marker::Sized",
            "map::Keys"
        ],
        "<map::Keys<'a> as core::iter::Iterator>::next": [
            "alloc::collections::btree_map::Keys",
            "core::marker::Sized",
            "core::option::Option",
            "map::Keys"
        ],
        "<map::Keys<'a> as core::iter::Iterator>::size_hint": [
            "alloc::collections::btree_map::Keys",
            "core::marker::Sized",
            "core::option::Option",
            "map::Keys"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::clone::Clone>::clone": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::clone::Clone>::clone_from": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::cmp::PartialEq>::eq": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::default::Default>::default": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::fmt::Debug>::fmt": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::hash::Hash>::hash": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::hash::Hasher",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::iter::Extend<(alloc::string::String, value::Value)>>::extend": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::iter::FromIterator<(alloc::string::String, value::Value)>>::from_iter": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::iter::IntoIterator>::into_iter": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::ops::Index<&Q>>::index": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::ops::IndexMut<&Q>>::index_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::Deserializer"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::Serialize>::serialize": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::MapKeySerializer",
            "ser::Serializer",
            "serde::Serializer"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::de::IntoDeserializer<'de, error::Error>>::into_deserializer": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "<map::Values<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::collections::btree_map::Values",
            "core::marker::Sized",
            "core::option::Option",
            "map::Values"
        ],
        "<map::Values<'a> as core::iter::ExactSizeIterator>::len": [
            "alloc::collections::btree_map::Values",
            "core::marker::Sized",
            "map::Values"
        ],
        "<map::Values<'a> as core::iter::Iterator>::next": [
            "alloc::collections::btree_map::Values",
            "core::marker::Sized",
            "core::option::Option",
            "map::Values"
        ],
        "<map::Values<'a> as core::iter::Iterator>::size_hint": [
            "alloc::collections::btree_map::Values",
            "core::marker::Sized",
            "core::option::Option",
            "map::Values"
        ],
        "<map::ValuesMut<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::collections::btree_map::ValuesMut",
            "core::marker::Sized",
            "core::option::Option",
            "map::ValuesMut"
        ],
        "<map::ValuesMut<'a> as core::iter::ExactSizeIterator>::len": [
            "alloc::collections::btree_map::ValuesMut",
            "core::marker::Sized",
            "map::ValuesMut"
        ],
        "<map::ValuesMut<'a> as core::iter::Iterator>::next": [
            "alloc::collections::btree_map::ValuesMut",
            "core::marker::Sized",
            "core::option::Option",
            "map::ValuesMut"
        ],
        "<map::ValuesMut<'a> as core::iter::Iterator>::size_hint": [
            "alloc::collections::btree_map::ValuesMut",
            "core::marker::Sized",
            "core::option::Option",
            "map::ValuesMut"
        ],
        "<number::N as core::clone::Clone>::clone": [
            "number::N"
        ],
        "<number::N as core::cmp::PartialEq>::eq": [
            "number::N"
        ],
        "<number::N as core::hash::Hash>::hash": [
            "core::hash::Hasher",
            "core::marker::Sized",
            "number::N"
        ],
        "<number::Number as core::clone::Clone>::clone": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::cmp::Eq>::assert_receiver_is_total_eq": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::cmp::PartialEq>::eq": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<de::ParserNumber>>::from": [
            "de::ParserNumber",
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<i16>>::from": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<i32>>::from": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<i64>>::from": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<i8>>::from": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<isize>>::from": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<u16>>::from": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<u32>>::from": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<u64>>::from": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<u8>>::from": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::convert::From<usize>>::from": [
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::fmt::Display>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number"
        ],
        "<number::Number as core::hash::Hash>::hash": [
            "core::hash::Hasher",
            "core::marker::Sized",
            "number::N",
            "number::Number"
        ],
        "<number::Number as serde::Deserialize<'de>>::deserialize": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor": [
            "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_bool": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_bytes": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_char": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_enum": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_f32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_f64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_identifier": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_option": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_seq": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_str": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_string": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_tuple": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Serialize>::serialize": [
            "core::marker::Sized",
            "core::result::Result",
            "number::N",
            "number::Number",
            "ser::MapKeySerializer",
            "ser::Serializer",
            "serde::Serializer"
        ],
        "<read::IoRead<R> as read::Read<'de>>::byte_offset": [
            "core::marker::Sized",
            "core::option::Option",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::decode_hex_escape": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::discard": [
            "core::marker::Sized",
            "core::option::Option",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::ignore_str": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::next": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::parse_str": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::parse_str_raw": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::peek": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::peek_position": [
            "core::marker::Sized",
            "core::option::Option",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Position",
            "std::io::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::position": [
            "core::marker::Sized",
            "core::option::Option",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Position",
            "std::io::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::set_failed": [
            "core::marker::Sized",
            "core::option::Option",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "<read::Reference<'b, 'c, T> as core::ops::Deref>::deref": [
            "read::Reference"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::byte_offset": [
            "read::SliceRead"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::decode_hex_escape": [
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::discard": [
            "read::SliceRead"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::ignore_str": [
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::next": [
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::parse_str": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::parse_str_raw": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::peek": [
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::peek_position": [
            "read::Position",
            "read::SliceRead"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::position": [
            "read::Position",
            "read::SliceRead"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::set_failed": [
            "read::SliceRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::byte_offset": [
            "read::SliceRead",
            "read::StrRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::decode_hex_escape": [
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead",
            "read::StrRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::discard": [
            "read::SliceRead",
            "read::StrRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::ignore_str": [
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead",
            "read::StrRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::next": [
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead",
            "read::StrRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::parse_str": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead",
            "read::StrRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::parse_str_raw": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead",
            "read::StrRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::peek": [
            "core::marker::Sized",
            "core::result::Result",
            "read::SliceRead",
            "read::StrRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::peek_position": [
            "read::Position",
            "read::SliceRead",
            "read::StrRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::position": [
            "read::Position",
            "read::SliceRead",
            "read::StrRead"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::set_failed": [
            "read::SliceRead",
            "read::StrRead"
        ],
        "<ser::CompactFormatter as core::clone::Clone>::clone": [
            "ser::CompactFormatter"
        ],
        "<ser::CompactFormatter as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::CompactFormatter"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Compound",
            "ser::Serializer",
            "ser::State"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Compound",
            "ser::Serializer",
            "ser::State",
            "serde::Serialize"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Compound",
            "ser::Serializer",
            "ser::State",
            "serde::Serialize"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Compound",
            "ser::Serializer",
            "ser::State"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Compound",
            "ser::Serializer",
            "ser::State",
            "serde::Serialize"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Compound",
            "ser::Serializer",
            "ser::State"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Compound",
            "ser::Serializer",
            "ser::State",
            "serde::Serialize"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Compound",
            "ser::Serializer",
            "ser::State"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Compound",
            "ser::Serializer",
            "ser::State",
            "serde::Serialize"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Compound",
            "ser::Serializer",
            "ser::State"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Compound",
            "ser::Serializer",
            "ser::State",
            "serde::Serialize"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Compound",
            "ser::Serializer",
            "ser::State"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Compound",
            "ser::Serializer",
            "ser::State",
            "serde::Serialize"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::Compound",
            "ser::Serializer",
            "ser::State"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::Compound",
            "ser::Serializer",
            "ser::State",
            "serde::Serialize"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::fmt::Display",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::MapKeySerializer",
            "ser::Serializer",
            "serde::Serialize"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::MapKeySerializer",
            "ser::Serializer",
            "serde::Serialize"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "ser::MapKeySerializer",
            "ser::Serializer",
            "serde::Serialize"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "<ser::PrettyFormatter<'a> as core::clone::Clone>::clone": [
            "ser::PrettyFormatter"
        ],
        "<ser::PrettyFormatter<'a> as core::default::Default>::default": [
            "ser::PrettyFormatter"
        ],
        "<ser::PrettyFormatter<'a> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::PrettyFormatter"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::PrettyFormatter",
            "std::io::Write"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::PrettyFormatter",
            "std::io::Write"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::PrettyFormatter",
            "std::io::Write"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::PrettyFormatter",
            "std::io::Write"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::PrettyFormatter",
            "std::io::Write"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_array": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::PrettyFormatter",
            "std::io::Write"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::PrettyFormatter",
            "std::io::Write"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_object": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::PrettyFormatter",
            "std::io::Write"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::PrettyFormatter",
            "std::io::Write"
        ],
        "<ser::State as core::cmp::Eq>::assert_receiver_is_total_eq": [
            "ser::State"
        ],
        "<ser::State as core::cmp::PartialEq>::eq": [
            "ser::State"
        ],
        "<str as value::index::Index>::index_into": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<str as value::index::Index>::index_into_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<str as value::index::Index>::index_or_insert": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<usize as value::index::Index>::index_into": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<usize as value::index::Index>::index_into_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<usize as value::index::Index>::index_or_insert": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<value::Value as core::clone::Clone>::clone": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<value::Value as core::cmp::Eq>::assert_receiver_is_total_eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<value::Value as core::cmp::PartialEq>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<value::Value as core::default::Default>::default": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<value::Value as core::fmt::Debug>::fmt": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<value::Value as core::fmt::Display>::fmt": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<value::Value as core::fmt::Display>::fmt::WriterFormatter": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter"
        ],
        "<value::Value as core::fmt::Display>::fmt::io_error": [
            "core::fmt::Error",
            "std::io::Error"
        ],
        "<value::Value as core::hash::Hash>::hash": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::hash::Hasher",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool": [
            "core::marker::Sized",
            "core::result::Result",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64": [
            "core::marker::Sized",
            "core::result::Result",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i128": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "serde::de::Error",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64": [
            "core::marker::Sized",
            "core::result::Result",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapAccess",
            "serde::de::MapAccess",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none": [
            "core::marker::Sized",
            "core::result::Result",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::SeqAccess",
            "serde::de::SeqAccess",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::Deserializer",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "serde::de::Error",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string": [
            "alloc::string::String",
            "core::marker::Sized",
            "core::result::Result",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u128": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "serde::de::Error",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64": [
            "core::marker::Sized",
            "core::result::Result",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit": [
            "core::marker::Sized",
            "core::result::Result",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed": [
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::BorrowedCowStrDeserializer",
            "value::de::KeyClassifier"
        ],
        "<value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed": [
            "alloc::string::String",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::EnumDeserializer",
            "value::de::KeyClassifier"
        ],
        "<value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::EnumRefDeserializer",
            "value::de::KeyClassifier"
        ],
        "<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::Deserializer",
            "value::de::KeyClassifier"
        ],
        "<value::de::KeyClassifier as serde::de::Visitor<'de>>::expecting": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "value::de::KeyClassifier"
        ],
        "<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "serde::de::Error",
            "value::de::KeyClassifier"
        ],
        "<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string": [
            "alloc::boxed::Box",
            "alloc::string::String",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "serde::de::Error",
            "value::de::KeyClassifier"
        ],
        "<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier",
            "value::de::MapDeserializer"
        ],
        "<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier",
            "value::de::MapDeserializer"
        ],
        "<value::de::MapDeserializer as serde::de::MapAccess<'de>>::size_hint": [
            "core::marker::Sized",
            "core::option::Option",
            "value::de::MapDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::MapKeyDeserializer"
        ],
        "<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier",
            "value::de::MapRefDeserializer"
        ],
        "<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier",
            "value::de::MapRefDeserializer"
        ],
        "<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::size_hint": [
            "core::marker::Sized",
            "core::option::Option",
            "value::de::MapRefDeserializer"
        ],
        "<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier",
            "value::de::SeqDeserializer"
        ],
        "<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "value::de::SeqDeserializer"
        ],
        "<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed": [
            "core::marker::Sized",
            "core::result::Result",
            "core::slice::Iter",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier",
            "value::de::SeqRefDeserializer"
        ],
        "<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::size_hint": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "value::de::SeqRefDeserializer"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier",
            "value::de::UnitOnly"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::UnitOnly"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::UnitOnly"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::unit_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "value::de::UnitOnly"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier",
            "value::de::VariantDeserializer"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::VariantDeserializer"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::VariantDeserializer"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::unit_variant": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "value::de::VariantDeserializer"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::DeserializeSeed",
            "value::de::KeyClassifier",
            "value::de::VariantRefDeserializer"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::VariantRefDeserializer"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "serde::de::Visitor",
            "value::de::VariantRefDeserializer"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::unit_variant": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "value::de::VariantRefDeserializer"
        ],
        "<value::index::Type<'a> as core::fmt::Display>::fmt": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value",
            "value::index::Type"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::collect_str": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::fmt::Display",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_bool": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_bytes": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_char": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_f32": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_f64": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i128": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i16": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i32": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i64": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i8": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_map": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_none": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_seq": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_some": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_str": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u128": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u16": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u32": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u64": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u8": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::MapKeySerializer"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeMap>::end": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "value::ser::SerializeMap"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::SerializeMap"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::SerializeMap"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeStruct>::end": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "value::ser::SerializeMap"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::SerializeMap"
        ],
        "<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::end": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "value::ser::SerializeStructVariant"
        ],
        "<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::SerializeStructVariant"
        ],
        "<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::end": [
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::SerializeTupleVariant"
        ],
        "<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::SerializeTupleVariant"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeSeq>::end": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::SerializeVec"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element": [
            "alloc::collections::BTreeMap",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::SerializeVec"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTuple>::end": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::SerializeVec"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element": [
            "alloc::collections::BTreeMap",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::SerializeVec"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::end": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::SerializeVec"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field": [
            "alloc::collections::BTreeMap",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::SerializeVec"
        ],
        "<value::ser::Serializer as serde::Serializer>::collect_str": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::fmt::Display",
            "core::marker::Sized",
            "core::result::Result",
            "error::Error",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_bool": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_bytes": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_char": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_f32": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_f64": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i128": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i16": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i32": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i64": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i8": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_map": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_newtype_struct": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_newtype_variant": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_none": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_seq": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_some": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_str": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_struct_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_tuple": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_tuple_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_tuple_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u128": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u16": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u32": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u64": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u8": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_unit": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_unit_struct": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_unit_variant": [
            "core::marker::Sized",
            "core::result::Result",
            "value::ser::Serializer"
        ],
        "de::<impl core::str::FromStr for number::Number>::from_str": [
            "core::marker::Sized",
            "core::result::Result"
        ],
        "de::Deserializer": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::deserialize_number": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "de::Deserializer::<R>::do_deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "de::Deserializer::<R>::do_deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "serde::de::Visitor"
        ],
        "de::Deserializer::<R>::eat_char": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::end": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::end_map": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::end_seq": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::error": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "error::Error",
            "error::ErrorCode",
            "std::io::Error"
        ],
        "de::Deserializer::<R>::f64_from_parts": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::fix_position": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "error::Error"
        ],
        "de::Deserializer::<R>::ignore_decimal": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::ignore_exponent": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::ignore_integer": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::ignore_value": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::into_iter": [
            "alloc::collections::BTreeMap",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "de::Deserializer",
            "de::StreamDeserializer",
            "error::Category",
            "map::Map",
            "serde::Deserialize"
        ],
        "de::Deserializer::<R>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::next_char": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::next_char_or_null": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_any_number": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_any_signed_number": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_decimal": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_decimal_overflow": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_exponent": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_exponent_overflow": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_ident": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_integer": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_long_integer": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_number": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_object_colon": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::parse_whitespace": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::peek": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::peek_error": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "error::Error",
            "error::ErrorCode",
            "std::io::Error"
        ],
        "de::Deserializer::<R>::peek_invalid_type": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "error::Error"
        ],
        "de::Deserializer::<R>::peek_or_null": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<R>::scan_integer128": [
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer"
        ],
        "de::Deserializer::<read::IoRead<R>>::from_reader": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer"
        ],
        "de::Deserializer::<read::SliceRead<'a>>::from_slice": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer"
        ],
        "de::Deserializer::<read::StrRead<'a>>::from_str": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer"
        ],
        "de::MapAccess": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "de::MapAccess"
        ],
        "de::MapAccess::<'a, R>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "de::MapAccess"
        ],
        "de::MapKey": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "de::MapKey"
        ],
        "de::MapKey::<'a, R>::deserialize_number": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::de::Visitor"
        ],
        "de::ParserNumber": [
            "de::ParserNumber"
        ],
        "de::ParserNumber::invalid_type": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::ParserNumber",
            "error::Error"
        ],
        "de::ParserNumber::visit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "core::marker::Sized",
            "core::result::Result",
            "de::ParserNumber",
            "serde::de::Visitor"
        ],
        "de::SeqAccess": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "de::SeqAccess"
        ],
        "de::SeqAccess::<'a, R>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "de::SeqAccess"
        ],
        "de::StreamDeserializer": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "de::Deserializer",
            "de::StreamDeserializer"
        ],
        "de::StreamDeserializer::<'de, R, T>::byte_offset": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "de::Deserializer",
            "de::StreamDeserializer"
        ],
        "de::StreamDeserializer::<'de, R, T>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "de::Deserializer",
            "de::StreamDeserializer"
        ],
        "de::StreamDeserializer::<'de, R, T>::peek_end_of_value": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::StreamDeserializer"
        ],
        "de::UnitVariantAccess": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "de::UnitVariantAccess"
        ],
        "de::UnitVariantAccess::<'a, R>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "de::UnitVariantAccess"
        ],
        "de::VariantAccess": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "de::VariantAccess"
        ],
        "de::VariantAccess::<'a, R>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "de::Deserializer",
            "de::VariantAccess"
        ],
        "de::from_reader": [
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::DeserializeOwned",
            "std::io::Read"
        ],
        "de::from_slice": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Deserialize"
        ],
        "de::from_str": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Deserialize"
        ],
        "de::from_trait": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "error::Category",
            "iter::LineColIterator",
            "map::Map",
            "read::IoRead",
            "read::Read",
            "serde::Deserialize",
            "std::io::Read"
        ],
        "error::<impl core::convert::From<error::Error> for std::io::Error>::from": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error",
            "std::io::Error"
        ],
        "error::Category": [
            "error::Category"
        ],
        "error::Error": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "error::Error::classify": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Category",
            "error::Error"
        ],
        "error::Error::column": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "error::Error::fix_position": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "error::Error"
        ],
        "error::Error::io": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error",
            "std::io::Error"
        ],
        "error::Error::io_error_kind": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "error::Error"
        ],
        "error::Error::is_data": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "error::Error::is_eof": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "error::Error::is_io": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "error::Error::is_syntax": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "error::Error::line": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "error::Error::syntax": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error",
            "error::ErrorCode",
            "std::io::Error"
        ],
        "error::ErrorCode": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::ErrorCode",
            "std::io::Error"
        ],
        "error::ErrorImpl": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::ErrorCode",
            "error::ErrorImpl",
            "std::io::Error"
        ],
        "error::JsonUnexpected": [
            "error::JsonUnexpected",
            "serde::de::Unexpected"
        ],
        "error::make_error": [
            "alloc::boxed::Box",
            "alloc::string::String",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "error::parse_line_col": [
            "alloc::string::String",
            "core::marker::Sized",
            "core::option::Option"
        ],
        "error::starts_with_digit": [],
        "iter::LineColIterator": [
            "core::marker::Sized",
            "iter::LineColIterator"
        ],
        "iter::LineColIterator::<I>::byte_offset": [
            "core::marker::Sized",
            "iter::LineColIterator"
        ],
        "iter::LineColIterator::<I>::col": [
            "core::marker::Sized",
            "iter::LineColIterator"
        ],
        "iter::LineColIterator::<I>::line": [
            "core::marker::Sized",
            "iter::LineColIterator"
        ],
        "iter::LineColIterator::<I>::new": [
            "core::marker::Sized",
            "iter::LineColIterator"
        ],
        "map::Entry": [
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::collections::btree_map::VacantEntry",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Entry",
            "map::OccupiedEntry",
            "map::VacantEntry"
        ],
        "map::Entry::<'a>::and_modify": [
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::collections::btree_map::VacantEntry",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "error::Category",
            "map::Entry",
            "map::OccupiedEntry",
            "map::VacantEntry"
        ],
        "map::Entry::<'a>::key": [
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::collections::btree_map::VacantEntry",
            "alloc::string::String",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Entry",
            "map::OccupiedEntry",
            "map::VacantEntry"
        ],
        "map::Entry::<'a>::or_insert": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::collections::btree_map::VacantEntry",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Entry",
            "map::Map",
            "map::OccupiedEntry",
            "map::VacantEntry",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "map::Entry::<'a>::or_insert_with": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::collections::btree_map::VacantEntry",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "error::Category",
            "map::Entry",
            "map::Map",
            "map::OccupiedEntry",
            "map::VacantEntry",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "map::IntoIter": [
            "alloc::collections::btree_map::IntoIter",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::IntoIter"
        ],
        "map::IntoValues": [
            "alloc::collections::btree_map::IntoValues",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::IntoValues"
        ],
        "map::Iter": [
            "alloc::collections::btree_map::Iter",
            "core::marker::Sized",
            "map::Iter"
        ],
        "map::IterMut": [
            "alloc::collections::btree_map::IterMut",
            "core::marker::Sized",
            "map::IterMut"
        ],
        "map::Keys": [
            "alloc::collections::btree_map::Keys",
            "core::marker::Sized",
            "map::Keys"
        ],
        "map::Map": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::append": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::clear": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::contains_key": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::borrow::Borrow",
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::Ord",
            "core::hash::Hash",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::entry": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::collections::btree_map::VacantEntry",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::convert::Into",
            "core::marker::Sized",
            "error::Category",
            "map::Entry",
            "map::Map",
            "map::OccupiedEntry",
            "map::VacantEntry"
        ],
        "map::Map::<alloc::string::String, value::Value>::get": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::borrow::Borrow",
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::Ord",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::get_key_value": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::borrow::Borrow",
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::Ord",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::get_mut": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::borrow::Borrow",
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::Ord",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::insert": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "map::Map::<alloc::string::String, value::Value>::into_values": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::IntoValues",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::IntoValues",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::is_empty": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::iter": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::Iter",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Iter",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::iter_mut": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::IterMut",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::IterMut",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::keys": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::Keys",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Keys",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::len": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::new": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::remove": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::borrow::Borrow",
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::Ord",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::remove_entry": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::borrow::Borrow",
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::Ord",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::retain": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::ops::FnMut",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::sort_keys": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "map::Map::<alloc::string::String, value::Value>::values": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::Values",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "map::Values"
        ],
        "map::Map::<alloc::string::String, value::Value>::values_mut": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::ValuesMut",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "map::ValuesMut"
        ],
        "map::Map::<alloc::string::String, value::Value>::with_capacity": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map"
        ],
        "map::OccupiedEntry": [
            "alloc::collections::btree_map::OccupiedEntry",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::OccupiedEntry"
        ],
        "map::OccupiedEntry::<'a>::get": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "map::OccupiedEntry",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "map::OccupiedEntry::<'a>::get_mut": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "map::OccupiedEntry",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "map::OccupiedEntry::<'a>::insert": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "map::OccupiedEntry",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "map::OccupiedEntry::<'a>::into_mut": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "map::OccupiedEntry",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "map::OccupiedEntry::<'a>::key": [
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::string::String",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::OccupiedEntry"
        ],
        "map::OccupiedEntry::<'a>::remove": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "map::OccupiedEntry",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "map::OccupiedEntry::<'a>::remove_entry": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::OccupiedEntry",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "map::OccupiedEntry",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "map::VacantEntry": [
            "alloc::collections::btree_map::VacantEntry",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::VacantEntry"
        ],
        "map::VacantEntry::<'a>::insert": [
            "alloc::collections::BTreeMap",
            "alloc::collections::btree_map::VacantEntry",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "map::VacantEntry",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "map::VacantEntry::<'a>::key": [
            "alloc::collections::btree_map::VacantEntry",
            "alloc::string::String",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::VacantEntry"
        ],
        "map::Values": [
            "alloc::collections::btree_map::Values",
            "core::marker::Sized",
            "map::Values"
        ],
        "map::ValuesMut": [
            "alloc::collections::btree_map::ValuesMut",
            "core::marker::Sized",
            "map::ValuesMut"
        ],
        "number::N": [
            "number::N"
        ],
        "number::Number": [
            "number::N",
            "number::Number"
        ],
        "number::Number::as_f32": [
            "core::marker::Sized",
            "core::option::Option",
            "number::N",
            "number::Number"
        ],
        "number::Number::as_f64": [
            "core::marker::Sized",
            "core::option::Option",
            "number::N",
            "number::Number"
        ],
        "number::Number::as_i128": [
            "core::marker::Sized",
            "core::option::Option",
            "number::N",
            "number::Number"
        ],
        "number::Number::as_i64": [
            "core::marker::Sized",
            "core::option::Option",
            "number::N",
            "number::Number"
        ],
        "number::Number::as_u128": [
            "core::marker::Sized",
            "core::option::Option",
            "number::N",
            "number::Number"
        ],
        "number::Number::as_u64": [
            "core::marker::Sized",
            "core::option::Option",
            "number::N",
            "number::Number"
        ],
        "number::Number::from_f32": [
            "core::marker::Sized",
            "core::option::Option"
        ],
        "number::Number::from_f64": [
            "core::marker::Sized",
            "core::option::Option"
        ],
        "number::Number::from_i128": [
            "core::marker::Sized",
            "core::option::Option"
        ],
        "number::Number::from_u128": [
            "core::marker::Sized",
            "core::option::Option"
        ],
        "number::Number::is_f64": [
            "number::N",
            "number::Number"
        ],
        "number::Number::is_i64": [
            "number::N",
            "number::Number"
        ],
        "number::Number::is_u64": [
            "number::N",
            "number::Number"
        ],
        "number::Number::unexpected": [
            "number::N",
            "number::Number",
            "serde::de::Unexpected"
        ],
        "read::IoRead": [
            "core::marker::Sized",
            "core::option::Option",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "read::IoRead::<R>::new": [
            "core::marker::Sized",
            "core::option::Option",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "read::IoRead::<R>::parse_str_bytes": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "std::io::Read"
        ],
        "read::Position": [
            "read::Position"
        ],
        "read::Read::byte_offset": [],
        "read::Read::decode_hex_escape": [
            "core::marker::Sized",
            "core::result::Result"
        ],
        "read::Read::discard": [],
        "read::Read::ignore_str": [
            "core::marker::Sized",
            "core::result::Result"
        ],
        "read::Read::next": [
            "core::marker::Sized",
            "core::result::Result"
        ],
        "read::Read::parse_str": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "read::Read::parse_str_raw": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "read::Read::peek": [
            "core::marker::Sized",
            "core::result::Result"
        ],
        "read::Read::peek_position": [
            "read::Position"
        ],
        "read::Read::position": [
            "read::Position"
        ],
        "read::Read::set_failed": [],
        "read::Reference": [
            "read::Reference"
        ],
        "read::SliceRead": [
            "read::SliceRead"
        ],
        "read::SliceRead::<'a>::new": [
            "read::SliceRead"
        ],
        "read::SliceRead::<'a>::parse_str_bytes": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "core::result::Result",
            "read::SliceRead"
        ],
        "read::SliceRead::<'a>::position_of_index": [
            "read::Position",
            "read::SliceRead"
        ],
        "read::SliceRead::<'a>::skip_to_escape": [
            "read::SliceRead"
        ],
        "read::SliceRead::<'a>::skip_to_escape_slow": [
            "read::SliceRead"
        ],
        "read::StrRead": [
            "read::SliceRead",
            "read::StrRead"
        ],
        "read::StrRead::<'a>::new": [
            "read::SliceRead",
            "read::StrRead"
        ],
        "read::as_str": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Read",
            "std::io::Read"
        ],
        "read::build_hex_table": [],
        "read::decode_four_hex_digits": [
            "core::marker::Sized",
            "core::option::Option"
        ],
        "read::decode_hex_val_slow": [
            "core::marker::Sized",
            "core::option::Option"
        ],
        "read::error": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "error::ErrorCode",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Read",
            "std::io::Error",
            "std::io::Read"
        ],
        "read::ignore_escape": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Read",
            "std::io::Read"
        ],
        "read::is_escape": [],
        "read::next_or_eof": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Read",
            "std::io::Read"
        ],
        "read::parse_escape": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Read",
            "std::io::Read"
        ],
        "read::parse_unicode_escape": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Read",
            "std::io::Read"
        ],
        "read::peek_or_eof": [
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "iter::LineColIterator",
            "read::IoRead",
            "read::Read",
            "std::io::Read"
        ],
        "read::push_wtf8_codepoint": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "ser::CharEscape": [
            "ser::CharEscape"
        ],
        "ser::CharEscape::from_escape_table": [
            "ser::CharEscape"
        ],
        "ser::CompactFormatter": [
            "ser::CompactFormatter"
        ],
        "ser::Compound": [
            "core::marker::Sized",
            "ser::Compound",
            "ser::Serializer",
            "ser::State"
        ],
        "ser::Formatter::begin_array": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::begin_array_value": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::begin_object": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::begin_object_key": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::begin_object_value": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::begin_string": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::end_array": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::end_array_value": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::end_object": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::end_object_key": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::end_object_value": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::end_string": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_bool": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_byte_array": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_char_escape": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::CharEscape",
            "std::io::Write"
        ],
        "ser::Formatter::write_f32": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_f64": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_i128": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_i16": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_i32": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_i64": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_i8": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_null": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_number_str": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_raw_fragment": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_string_fragment": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_u128": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_u16": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_u32": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_u64": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::Formatter::write_u8": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::MapKeySerializer": [
            "core::marker::Sized",
            "ser::MapKeySerializer",
            "ser::Serializer"
        ],
        "ser::PrettyFormatter": [
            "ser::PrettyFormatter"
        ],
        "ser::PrettyFormatter::<'a>::new": [
            "ser::PrettyFormatter"
        ],
        "ser::PrettyFormatter::<'a>::with_indent": [
            "ser::PrettyFormatter"
        ],
        "ser::Serializer": [
            "core::marker::Sized",
            "ser::Serializer"
        ],
        "ser::Serializer::<W, F>::into_inner": [
            "core::marker::Sized",
            "ser::Serializer"
        ],
        "ser::Serializer::<W, F>::with_formatter": [
            "core::marker::Sized",
            "ser::Serializer"
        ],
        "ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty": [
            "core::marker::Sized",
            "ser::Serializer"
        ],
        "ser::Serializer::<W>::new": [
            "core::marker::Sized",
            "ser::Serializer"
        ],
        "ser::State": [
            "ser::State"
        ],
        "ser::float_key_must_be_finite": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "ser::format_escaped_str": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::CompactFormatter",
            "ser::Formatter",
            "std::io::Write"
        ],
        "ser::format_escaped_str_contents": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "ser::CompactFormatter",
            "ser::Formatter",
            "std::io::Write"
        ],
        "ser::indent": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "std::io::Write"
        ],
        "ser::key_must_be_a_string": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "ser::to_string": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize"
        ],
        "ser::to_string_pretty": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize"
        ],
        "ser::to_vec": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize"
        ],
        "ser::to_vec_pretty": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize"
        ],
        "ser::to_writer": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "std::io::Write"
        ],
        "ser::to_writer_pretty": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize",
            "std::io::Write"
        ],
        "value::Value": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_array": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_array_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_bool": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_f64": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_i64": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_null": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_number": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_object": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_object_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_str": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::as_u64": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::get": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value",
            "value::index::Index"
        ],
        "value::Value::get_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value",
            "value::index::Index"
        ],
        "value::Value::is_array": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::is_boolean": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::is_f64": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::is_i64": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::is_null": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::is_number": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::is_object": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::is_string": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::is_u64": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::pointer": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::pointer_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::sort_all_objects": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::Value::take": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::de::<impl core::str::FromStr for value::Value>::from_str": [
            "core::marker::Sized",
            "core::result::Result"
        ],
        "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "de::Deserializer",
            "de::MapKey",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor": [
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_bool": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_byte_buf": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_bytes": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_char": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_enum": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_f32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_f64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_identifier": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_ignored_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_newtype_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_option": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_seq": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_str": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_string": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_tuple": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_tuple_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_unit_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_bool": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_byte_buf": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_bytes": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_char": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_enum": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_f32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_f64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_identifier": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_ignored_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_newtype_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_option": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_seq": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_str": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_string": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_tuple": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_tuple_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_unit_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::de::Visitor"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for &'de value::Value>::into_deserializer": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for value::Value>::into_deserializer": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::de::<impl value::Value>::invalid_type": [
            "alloc::boxed::Box",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "error::Error",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Error",
            "value::Value"
        ],
        "value::de::<impl value::Value>::unexpected": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Unexpected",
            "value::Value"
        ],
        "value::de::BorrowedCowStrDeserializer": [
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "value::de::BorrowedCowStrDeserializer::<'de>::new": [
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "value::de::BorrowedCowStrDeserializer"
        ],
        "value::de::EnumDeserializer": [
            "alloc::string::String",
            "core::marker::Sized",
            "core::option::Option",
            "value::de::EnumDeserializer"
        ],
        "value::de::EnumRefDeserializer": [
            "core::marker::Sized",
            "core::option::Option",
            "value::de::EnumRefDeserializer"
        ],
        "value::de::KeyClass": [
            "alloc::string::String",
            "value::de::KeyClass"
        ],
        "value::de::KeyClassifier": [
            "value::de::KeyClassifier"
        ],
        "value::de::MapDeserializer": [
            "core::marker::Sized",
            "core::option::Option",
            "value::de::MapDeserializer"
        ],
        "value::de::MapDeserializer::new": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "value::de::MapDeserializer"
        ],
        "value::de::MapKeyDeserializer": [
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "value::de::MapKeyDeserializer"
        ],
        "value::de::MapRefDeserializer": [
            "core::marker::Sized",
            "core::option::Option",
            "value::de::MapRefDeserializer"
        ],
        "value::de::MapRefDeserializer::<'de>::new": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "value::de::MapRefDeserializer"
        ],
        "value::de::SeqDeserializer": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "value::de::SeqDeserializer"
        ],
        "value::de::SeqDeserializer::new": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "value::de::SeqDeserializer"
        ],
        "value::de::SeqRefDeserializer": [
            "core::marker::Sized",
            "core::slice::Iter",
            "value::de::SeqRefDeserializer"
        ],
        "value::de::SeqRefDeserializer::<'de>::new": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::slice::Iter",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value",
            "value::de::SeqRefDeserializer"
        ],
        "value::de::UnitOnly": [
            "value::de::UnitOnly"
        ],
        "value::de::VariantDeserializer": [
            "core::marker::Sized",
            "core::option::Option",
            "value::de::VariantDeserializer"
        ],
        "value::de::VariantRefDeserializer": [
            "core::marker::Sized",
            "core::option::Option",
            "value::de::VariantRefDeserializer"
        ],
        "value::de::visit_array": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "serde::de::Visitor"
        ],
        "value::de::visit_array_ref": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::Visitor",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<&[T]> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<&str> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<()> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<[T; N]> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<alloc::borrow::Cow<'a, str>> for value::Value>::from": [
            "alloc::borrow::Cow",
            "alloc::borrow::ToOwned",
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<alloc::string::String> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<alloc::vec::Vec<T>> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<bool> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<core::option::Option<T>> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<f32> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<f64> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<i16> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<i32> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<i64> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<i8> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<isize> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<map::Map<alloc::string::String, value::Value>> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<number::Number> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<u16> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<u32> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<u64> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<u8> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::convert::From<usize> for value::Value>::from": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::iter::FromIterator<(K, V)> for value::Value>::from_iter": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from::<impl core::iter::FromIterator<T> for value::Value>::from_iter": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::from_value": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "serde::de::DeserializeOwned",
            "value::Value"
        ],
        "value::index::<impl core::ops::Index<I> for value::Value>::index": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::index::<impl core::ops::IndexMut<I> for value::Value>::index_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::index::Index::index_into": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::index::Index::index_into_mut": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::index::Index::index_or_insert": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::index::Type": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value",
            "value::index::Type"
        ],
        "value::parse_index": [
            "core::marker::Sized",
            "core::option::Option"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<&str> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<alloc::string::String> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<bool> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<bool> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<bool> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f32> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f32> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f32> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f64> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f64> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f64> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i16> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i16> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i16> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i32> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i32> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i32> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i64> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i64> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i64> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i8> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i8> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i8> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<isize> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<isize> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<isize> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<str> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u16> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u16> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u16> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u32> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u32> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u32> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u64> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u64> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u64> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u8> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u8> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u8> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<usize> for &'a mut value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<usize> for &'a value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<usize> for value::Value>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for &str>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for alloc::string::String>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for bool>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for f32>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for f64>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i16>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i32>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i64>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i8>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for isize>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for str>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u16>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u32>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u64>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u8>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for usize>::eq": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::eq_bool": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::eq_f32": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::eq_f64": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::eq_i64": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::eq_str": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::partial_eq::eq_u64": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "value::ser::<impl serde::Serialize for value::Value>::serialize": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "ser::MapKeySerializer",
            "ser::Serializer",
            "serde::Serializer",
            "value::Value"
        ],
        "value::ser::MapKeySerializer": [
            "value::ser::MapKeySerializer"
        ],
        "value::ser::SerializeMap": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::option::Option",
            "error::Category",
            "map::Map",
            "value::ser::SerializeMap"
        ],
        "value::ser::SerializeStructVariant": [
            "alloc::collections::BTreeMap",
            "alloc::string::String",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "error::Category",
            "map::Map",
            "value::ser::SerializeStructVariant"
        ],
        "value::ser::SerializeTupleVariant": [
            "alloc::string::String",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "value::ser::SerializeTupleVariant"
        ],
        "value::ser::SerializeVec": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "value::ser::SerializeVec"
        ],
        "value::ser::Serializer": [
            "value::ser::Serializer"
        ],
        "value::ser::float_key_must_be_finite": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "value::ser::key_must_be_a_string": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "error::Error"
        ],
        "value::to_value": [
            "alloc::collections::BTreeMap",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "core::result::Result",
            "error::Category",
            "map::Map",
            "serde::Serialize"
        ]
    },
    "glob_path_import": {},
    "self_to_fn": {
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter": [
            "impl<'ser, W, F> Write for Adapter<'ser, W, F>\n        where\n            W: io::Write,\n            F: Formatter,\n        {\n            fn write_str(&mut self, s: &str) -> fmt::Result {\n                debug_assert!(self.error.is_none());\n                match format_escaped_str_contents(self.writer, self.formatter, s) {\n                    Ok(()) => Ok(()),\n                    Err(err) => {\n                        self.error = Some(err);\n                        Err(fmt::Error)\n                    }\n                }\n            }\n        }"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor": [
            "impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Map<String, Value>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                Ok(Map::new())\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut values = Map::new();\n\n                while let Some((key, value)) = tri!(visitor.next_entry()) {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }\n        }"
        ],
        "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor": [
            "impl<'de> Visitor<'de> for NumberVisitor {\n            type Value = Number;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a JSON number\")\n            }\n\n            fn visit_i64<E>(self, value: i64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            fn visit_i128<E>(self, value: i128) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_i128(value)\n                    .ok_or_else(|| de::Error::custom(\"JSON number out of range\"))\n            }\n\n            fn visit_u64<E>(self, value: u64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            fn visit_u128<E>(self, value: u128) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_u128(value)\n                    .ok_or_else(|| de::Error::custom(\"JSON number out of range\"))\n            }\n\n            fn visit_f64<E>(self, value: f64) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_f64(value).ok_or_else(|| de::Error::custom(\"not a JSON number\"))\n            }\n\n            #[cfg(feature = \"arbitrary_precision\")]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Number, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let value = tri!(visitor.next_key::<NumberKey>());\n                if value.is_none() {\n                    return Err(de::Error::invalid_type(Unexpected::Map, &self));\n                }\n                let v: NumberFromString = tri!(visitor.next_value());\n                Ok(v.value)\n            }\n        }"
        ],
        "<value::Value as core::fmt::Display>::fmt::WriterFormatter": [
            "impl<'a, 'b> io::Write for WriterFormatter<'a, 'b> {\n            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n                // Safety: the serializer below only emits valid utf8 when using\n                // the default formatter.\n                let s = unsafe { str::from_utf8_unchecked(buf) };\n                tri!(self.inner.write_str(s).map_err(io_error));\n                Ok(buf.len())\n            }\n\n            fn flush(&mut self) -> io::Result<()> {\n                Ok(())\n            }\n        }"
        ],
        "alloc::string::String": [
            "impl Index for String {\n    fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {\n        self[..].index_into(v)\n    }\n    fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {\n        self[..].index_into_mut(v)\n    }\n    fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {\n        self[..].index_or_insert(v)\n    }\n}",
            "impl PartialEq<Value> for String {\n    fn eq(&self, other: &Value) -> bool {\n        eq_str(other, self.as_str())\n    }\n}",
            "impl Sealed for alloc::string::String {}"
        ],
        "de::Deserializer": [
            "impl<'a> Deserializer<read::SliceRead<'a>> {\n    /// Creates a JSON deserializer from a `&[u8]`.\n    pub fn from_slice(bytes: &'a [u8]) -> Self {\n        Deserializer::new(read::SliceRead::new(bytes))\n    }\n}",
            "impl<'a> Deserializer<read::StrRead<'a>> {\n    /// Creates a JSON deserializer from a `&str`.\n    pub fn from_str(s: &'a str) -> Self {\n        Deserializer::new(read::StrRead::new(s))\n    }\n}",
            "impl<'de, R: Read<'de>> Deserializer<R> {\n    /// The `Deserializer::end` method should be called after a value has been fully deserialized.\n    /// This allows the `Deserializer` to validate that the input stream is at the end or that it\n    /// only has trailing whitespace.\n    pub fn end(&mut self) -> Result<()> {\n        match tri!(self.parse_whitespace()) {\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Ok(()),\n        }\n    }\n\n    /// Turn a JSON deserializer into an iterator over values of type T.\n    pub fn into_iter<T>(self) -> StreamDeserializer<'de, R, T>\n    where\n        T: de::Deserialize<'de>,\n    {\n        // This cannot be an implementation of std::iter::IntoIterator because\n        // we need the caller to choose what T is.\n        let offset = self.read.byte_offset();\n        StreamDeserializer {\n            de: self,\n            offset,\n            failed: false,\n            output: PhantomData,\n            lifetime: PhantomData,\n        }\n    }\n\n    /// Parse arbitrarily deep JSON structures without any consideration for\n    /// overflowing the stack.\n    ///\n    /// You will want to provide some other way to protect against stack\n    /// overflows, such as by wrapping your Deserializer in the dynamically\n    /// growing stack adapter provided by the serde_stacker crate. Additionally\n    /// you will need to be careful around other recursive operations on the\n    /// parsed result which may overflow the stack after deserialization has\n    /// completed, including, but not limited to, Display and Debug and Drop\n    /// impls.\n    ///\n    /// *This method is only available if serde_json is built with the\n    /// `\"unbounded_depth\"` feature.*\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde::Deserialize;\n    /// use serde_json::Value;\n    ///\n    /// fn main() {\n    ///     let mut json = String::new();\n    ///     for _ in 0..10000 {\n    ///         json = format!(\"[{}]\", json);\n    ///     }\n    ///\n    ///     let mut deserializer = serde_json::Deserializer::from_str(&json);\n    ///     deserializer.disable_recursion_limit();\n    ///     let deserializer = serde_stacker::Deserializer::new(&mut deserializer);\n    ///     let value = Value::deserialize(deserializer).unwrap();\n    ///\n    ///     carefully_drop_nested_arrays(value);\n    /// }\n    ///\n    /// fn carefully_drop_nested_arrays(value: Value) {\n    ///     let mut stack = vec![value];\n    ///     while let Some(value) = stack.pop() {\n    ///         if let Value::Array(array) = value {\n    ///             stack.extend(array);\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[cfg(feature = \"unbounded_depth\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unbounded_depth\")))]\n    pub fn disable_recursion_limit(&mut self) {\n        self.disable_recursion_limit = true;\n    }\n\n    pub(crate) fn peek(&mut self) -> Result<Option<u8>> {\n        self.read.peek()\n    }\n\n    fn peek_or_null(&mut self) -> Result<u8> {\n        Ok(tri!(self.peek()).unwrap_or(b'\\x00'))\n    }\n\n    fn eat_char(&mut self) {\n        self.read.discard();\n    }\n\n    fn next_char(&mut self) -> Result<Option<u8>> {\n        self.read.next()\n    }\n\n    fn next_char_or_null(&mut self) -> Result<u8> {\n        Ok(tri!(self.next_char()).unwrap_or(b'\\x00'))\n    }\n\n    /// Error caused by a byte from next_char().\n    #[cold]\n    fn error(&self, reason: ErrorCode) -> Error {\n        let position = self.read.position();\n        Error::syntax(reason, position.line, position.column)\n    }\n\n    /// Error caused by a byte from peek().\n    #[cold]\n    fn peek_error(&self, reason: ErrorCode) -> Error {\n        let position = self.read.peek_position();\n        Error::syntax(reason, position.line, position.column)\n    }\n\n    /// Returns the first non-whitespace byte without consuming it, or `None` if\n    /// EOF is encountered.\n    fn parse_whitespace(&mut self) -> Result<Option<u8>> {\n        loop {\n            match tri!(self.peek()) {\n                Some(b' ' | b'\\n' | b'\\t' | b'\\r') => {\n                    self.eat_char();\n                }\n                other => {\n                    return Ok(other);\n                }\n            }\n        }\n    }\n\n    #[cold]\n    fn peek_invalid_type(&mut self, exp: &dyn Expected) -> Error {\n        let err = match self.peek_or_null().unwrap_or(b'\\x00') {\n            b'n' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"ull\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Unit, exp)\n            }\n            b't' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"rue\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Bool(true), exp)\n            }\n            b'f' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"alse\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Bool(false), exp)\n            }\n            b'-' => {\n                self.eat_char();\n                match self.parse_any_number(false) {\n                    Ok(n) => n.invalid_type(exp),\n                    Err(err) => return err,\n                }\n            }\n            b'0'..=b'9' => match self.parse_any_number(true) {\n                Ok(n) => n.invalid_type(exp),\n                Err(err) => return err,\n            },\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match self.read.parse_str(&mut self.scratch) {\n                    Ok(s) => de::Error::invalid_type(Unexpected::Str(&s), exp),\n                    Err(err) => return err,\n                }\n            }\n            b'[' => de::Error::invalid_type(Unexpected::Seq, exp),\n            b'{' => de::Error::invalid_type(Unexpected::Map, exp),\n            _ => self.peek_error(ErrorCode::ExpectedSomeValue),\n        };\n\n        self.fix_position(err)\n    }\n\n    pub(crate) fn deserialize_number<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,\n    {\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'-' => {\n                self.eat_char();\n                tri!(self.parse_integer(false)).visit(visitor)\n            }\n            b'0'..=b'9' => tri!(self.parse_integer(true)).visit(visitor),\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    pub(crate) fn do_deserialize_f32<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,\n    {\n        self.single_precision = true;\n        let val = self.deserialize_number(visitor);\n        self.single_precision = false;\n        val\n    }\n\n    pub(crate) fn do_deserialize_i128<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,\n    {\n        let mut buf = String::new();\n\n        match tri!(self.parse_whitespace()) {\n            Some(b'-') => {\n                self.eat_char();\n                buf.push('-');\n            }\n            Some(_) => {}\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        }\n\n        tri!(self.scan_integer128(&mut buf));\n\n        let value = match buf.parse() {\n            Ok(int) => visitor.visit_i128(int),\n            Err(_) => {\n                return Err(self.error(ErrorCode::NumberOutOfRange));\n            }\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }\n\n    pub(crate) fn do_deserialize_u128<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,\n    {\n        match tri!(self.parse_whitespace()) {\n            Some(b'-') => {\n                return Err(self.peek_error(ErrorCode::NumberOutOfRange));\n            }\n            Some(_) => {}\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        }\n\n        let mut buf = String::new();\n        tri!(self.scan_integer128(&mut buf));\n\n        let value = match buf.parse() {\n            Ok(int) => visitor.visit_u128(int),\n            Err(_) => {\n                return Err(self.error(ErrorCode::NumberOutOfRange));\n            }\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }\n\n    fn scan_integer128(&mut self, buf: &mut String) -> Result<()> {\n        match tri!(self.next_char_or_null()) {\n            b'0' => {\n                buf.push('0');\n                // There can be only one leading '0'.\n                match tri!(self.peek_or_null()) {\n                    b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),\n                    _ => Ok(()),\n                }\n            }\n            c @ b'1'..=b'9' => {\n                buf.push(c as char);\n                while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    self.eat_char();\n                    buf.push(c as char);\n                }\n                Ok(())\n            }\n            _ => Err(self.error(ErrorCode::InvalidNumber)),\n        }\n    }\n\n    #[cold]\n    fn fix_position(&self, err: Error) -> Error {\n        err.fix_position(move |code| self.error(code))\n    }\n\n    fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {\n        for expected in ident {\n            match tri!(self.next_char()) {\n                None => {\n                    return Err(self.error(ErrorCode::EofWhileParsingValue));\n                }\n                Some(next) => {\n                    if next != *expected {\n                        return Err(self.error(ErrorCode::ExpectedSomeIdent));\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    fn parse_integer(&mut self, positive: bool) -> Result<ParserNumber> {\n        let next = match tri!(self.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        match next {\n            b'0' => {\n                // There can be only one leading '0'.\n                match tri!(self.peek_or_null()) {\n                    b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),\n                    _ => self.parse_number(positive, 0),\n                }\n            }\n            c @ b'1'..=b'9' => {\n                let mut significand = (c - b'0') as u64;\n\n                loop {\n                    match tri!(self.peek_or_null()) {\n                        c @ b'0'..=b'9' => {\n                            let digit = (c - b'0') as u64;\n\n                            // We need to be careful with overflow. If we can,\n                            // try to keep the number as a `u64` until we grow\n                            // too large. At that point, switch to parsing the\n                            // value as a `f64`.\n                            if overflow!(significand * 10 + digit, u64::MAX) {\n                                return Ok(ParserNumber::F64(tri!(\n                                    self.parse_long_integer(positive, significand),\n                                )));\n                            }\n\n                            self.eat_char();\n                            significand = significand * 10 + digit;\n                        }\n                        _ => {\n                            return self.parse_number(positive, significand);\n                        }\n                    }\n                }\n            }\n            _ => Err(self.error(ErrorCode::InvalidNumber)),\n        }\n    }\n\n    fn parse_number(&mut self, positive: bool, significand: u64) -> Result<ParserNumber> {\n        Ok(match tri!(self.peek_or_null()) {\n            b'.' => ParserNumber::F64(tri!(self.parse_decimal(positive, significand, 0))),\n            b'e' | b'E' => ParserNumber::F64(tri!(self.parse_exponent(positive, significand, 0))),\n            _ => {\n                if positive {\n                    ParserNumber::U64(significand)\n                } else {\n                    let neg = (significand as i64).wrapping_neg();\n\n                    // Convert into a float if we underflow, or on `-0`.\n                    if neg >= 0 {\n                        ParserNumber::F64(-(significand as f64))\n                    } else {\n                        ParserNumber::I64(neg)\n                    }\n                }\n            }\n        })\n    }\n\n    fn parse_decimal(\n        &mut self,\n        positive: bool,\n        mut significand: u64,\n        exponent_before_decimal_point: i32,\n    ) -> Result<f64> {\n        self.eat_char();\n\n        let mut exponent_after_decimal_point = 0;\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            let digit = (c - b'0') as u64;\n\n            if overflow!(significand * 10 + digit, u64::MAX) {\n                let exponent = exponent_before_decimal_point + exponent_after_decimal_point;\n                return self.parse_decimal_overflow(positive, significand, exponent);\n            }\n\n            self.eat_char();\n            significand = significand * 10 + digit;\n            exponent_after_decimal_point -= 1;\n        }\n\n        // Error if there is not at least one digit after the decimal point.\n        if exponent_after_decimal_point == 0 {\n            match tri!(self.peek()) {\n                Some(_) => return Err(self.peek_error(ErrorCode::InvalidNumber)),\n                None => return Err(self.peek_error(ErrorCode::EofWhileParsingValue)),\n            }\n        }\n\n        let exponent = exponent_before_decimal_point + exponent_after_decimal_point;\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.parse_exponent(positive, significand, exponent),\n            _ => self.f64_from_parts(positive, significand, exponent),\n        }\n    }\n\n    fn parse_exponent(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        starting_exp: i32,\n    ) -> Result<f64> {\n        self.eat_char();\n\n        let positive_exp = match tri!(self.peek_or_null()) {\n            b'+' => {\n                self.eat_char();\n                true\n            }\n            b'-' => {\n                self.eat_char();\n                false\n            }\n            _ => true,\n        };\n\n        let next = match tri!(self.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        // Make sure a digit follows the exponent place.\n        let mut exp = match next {\n            c @ b'0'..=b'9' => (c - b'0') as i32,\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        };\n\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            let digit = (c - b'0') as i32;\n\n            if overflow!(exp * 10 + digit, i32::MAX) {\n                let zero_significand = significand == 0;\n                return self.parse_exponent_overflow(positive, zero_significand, positive_exp);\n            }\n\n            exp = exp * 10 + digit;\n        }\n\n        let final_exp = if positive_exp {\n            starting_exp.saturating_add(exp)\n        } else {\n            starting_exp.saturating_sub(exp)\n        };\n\n        self.f64_from_parts(positive, significand, final_exp)\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    fn f64_from_parts(&mut self, positive: bool, significand: u64, exponent: i32) -> Result<f64> {\n        let f = if self.single_precision {\n            lexical::parse_concise_float::<f32>(significand, exponent) as f64\n        } else {\n            lexical::parse_concise_float::<f64>(significand, exponent)\n        };\n\n        if f.is_infinite() {\n            Err(self.error(ErrorCode::NumberOutOfRange))\n        } else {\n            Ok(if positive { f } else { -f })\n        }\n    }\n\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    fn f64_from_parts(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        mut exponent: i32,\n    ) -> Result<f64> {\n        let mut f = significand as f64;\n        loop {\n            match POW10.get(exponent.wrapping_abs() as usize) {\n                Some(&pow) => {\n                    if exponent >= 0 {\n                        f *= pow;\n                        if f.is_infinite() {\n                            return Err(self.error(ErrorCode::NumberOutOfRange));\n                        }\n                    } else {\n                        f /= pow;\n                    }\n                    break;\n                }\n                None => {\n                    if f == 0.0 {\n                        break;\n                    }\n                    if exponent >= 0 {\n                        return Err(self.error(ErrorCode::NumberOutOfRange));\n                    }\n                    f /= 1e308;\n                    exponent += 308;\n                }\n            }\n        }\n        Ok(if positive { f } else { -f })\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    #[cold]\n    #[inline(never)]\n    fn parse_long_integer(&mut self, positive: bool, partial_significand: u64) -> Result<f64> {\n        // To deserialize floats we'll first push the integer and fraction\n        // parts, both as byte strings, into the scratch buffer and then feed\n        // both slices to lexical's parser. For example if the input is\n        // `12.34e5` we'll push b\"1234\" into scratch and then pass b\"12\" and\n        // b\"34\" to lexical. `integer_end` will be used to track where to split\n        // the scratch buffer.\n        //\n        // Note that lexical expects the integer part to contain *no* leading\n        // zeroes and the fraction part to contain *no* trailing zeroes. The\n        // first requirement is already handled by the integer parsing logic.\n        // The second requirement will be enforced just before passing the\n        // slices to lexical in f64_long_from_parts.\n        self.scratch.clear();\n        self.scratch\n            .extend_from_slice(itoa::Buffer::new().format(partial_significand).as_bytes());\n\n        loop {\n            match tri!(self.peek_or_null()) {\n                c @ b'0'..=b'9' => {\n                    self.scratch.push(c);\n                    self.eat_char();\n                }\n                b'.' => {\n                    self.eat_char();\n                    return self.parse_long_decimal(positive, self.scratch.len());\n                }\n                b'e' | b'E' => {\n                    return self.parse_long_exponent(positive, self.scratch.len());\n                }\n                _ => {\n                    return self.f64_long_from_parts(positive, self.scratch.len(), 0);\n                }\n            }\n        }\n    }\n\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    #[cold]\n    #[inline(never)]\n    fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {\n        let mut exponent = 0;\n        loop {\n            match tri!(self.peek_or_null()) {\n                b'0'..=b'9' => {\n                    self.eat_char();\n                    // This could overflow... if your integer is gigabytes long.\n                    // Ignore that possibility.\n                    exponent += 1;\n                }\n                b'.' => {\n                    return self.parse_decimal(positive, significand, exponent);\n                }\n                b'e' | b'E' => {\n                    return self.parse_exponent(positive, significand, exponent);\n                }\n                _ => {\n                    return self.f64_from_parts(positive, significand, exponent);\n                }\n            }\n        }\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    #[cold]\n    fn parse_long_decimal(&mut self, positive: bool, integer_end: usize) -> Result<f64> {\n        let mut at_least_one_digit = integer_end < self.scratch.len();\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.scratch.push(c);\n            self.eat_char();\n            at_least_one_digit = true;\n        }\n\n        if !at_least_one_digit {\n            match tri!(self.peek()) {\n                Some(_) => return Err(self.peek_error(ErrorCode::InvalidNumber)),\n                None => return Err(self.peek_error(ErrorCode::EofWhileParsingValue)),\n            }\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.parse_long_exponent(positive, integer_end),\n            _ => self.f64_long_from_parts(positive, integer_end, 0),\n        }\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    fn parse_long_exponent(&mut self, positive: bool, integer_end: usize) -> Result<f64> {\n        self.eat_char();\n\n        let positive_exp = match tri!(self.peek_or_null()) {\n            b'+' => {\n                self.eat_char();\n                true\n            }\n            b'-' => {\n                self.eat_char();\n                false\n            }\n            _ => true,\n        };\n\n        let next = match tri!(self.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        // Make sure a digit follows the exponent place.\n        let mut exp = match next {\n            c @ b'0'..=b'9' => (c - b'0') as i32,\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        };\n\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            let digit = (c - b'0') as i32;\n\n            if overflow!(exp * 10 + digit, i32::MAX) {\n                let zero_significand = self.scratch.iter().all(|&digit| digit == b'0');\n                return self.parse_exponent_overflow(positive, zero_significand, positive_exp);\n            }\n\n            exp = exp * 10 + digit;\n        }\n\n        let final_exp = if positive_exp { exp } else { -exp };\n\n        self.f64_long_from_parts(positive, integer_end, final_exp)\n    }\n\n    // This cold code should not be inlined into the middle of the hot\n    // decimal-parsing loop above.\n    #[cfg(feature = \"float_roundtrip\")]\n    #[cold]\n    #[inline(never)]\n    fn parse_decimal_overflow(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        exponent: i32,\n    ) -> Result<f64> {\n        let mut buffer = itoa::Buffer::new();\n        let significand = buffer.format(significand);\n        let fraction_digits = -exponent as usize;\n        self.scratch.clear();\n        if let Some(zeros) = fraction_digits.checked_sub(significand.len() + 1) {\n            self.scratch.extend(iter::repeat(b'0').take(zeros + 1));\n        }\n        self.scratch.extend_from_slice(significand.as_bytes());\n        let integer_end = self.scratch.len() - fraction_digits;\n        self.parse_long_decimal(positive, integer_end)\n    }\n\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    #[cold]\n    #[inline(never)]\n    fn parse_decimal_overflow(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        exponent: i32,\n    ) -> Result<f64> {\n        // The next multiply/add would overflow, so just ignore all further\n        // digits.\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.parse_exponent(positive, significand, exponent),\n            _ => self.f64_from_parts(positive, significand, exponent),\n        }\n    }\n\n    // This cold code should not be inlined into the middle of the hot\n    // exponent-parsing loop above.\n    #[cold]\n    #[inline(never)]\n    fn parse_exponent_overflow(\n        &mut self,\n        positive: bool,\n        zero_significand: bool,\n        positive_exp: bool,\n    ) -> Result<f64> {\n        // Error instead of +/- infinity.\n        if !zero_significand && positive_exp {\n            return Err(self.error(ErrorCode::NumberOutOfRange));\n        }\n\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n        Ok(if positive { 0.0 } else { -0.0 })\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    fn f64_long_from_parts(\n        &mut self,\n        positive: bool,\n        integer_end: usize,\n        exponent: i32,\n    ) -> Result<f64> {\n        let integer = &self.scratch[..integer_end];\n        let fraction = &self.scratch[integer_end..];\n\n        let f = if self.single_precision {\n            lexical::parse_truncated_float::<f32>(integer, fraction, exponent) as f64\n        } else {\n            lexical::parse_truncated_float::<f64>(integer, fraction, exponent)\n        };\n\n        if f.is_infinite() {\n            Err(self.error(ErrorCode::NumberOutOfRange))\n        } else {\n            Ok(if positive { f } else { -f })\n        }\n    }\n\n    fn parse_any_signed_number(&mut self) -> Result<ParserNumber> {\n        let peek = match tri!(self.peek()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'-' => {\n                self.eat_char();\n                self.parse_any_number(false)\n            }\n            b'0'..=b'9' => self.parse_any_number(true),\n            _ => Err(self.peek_error(ErrorCode::InvalidNumber)),\n        };\n\n        let value = match tri!(self.peek()) {\n            Some(_) => Err(self.peek_error(ErrorCode::InvalidNumber)),\n            None => value,\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            // The de::Error impl creates errors with unknown line and column.\n            // Fill in the position here by looking at the current index in the\n            // input. There is no way to tell whether this should call `error`\n            // or `peek_error` so pick the one that seems correct more often.\n            // Worst case, the position is off by one character.\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }\n\n    #[cfg(not(feature = \"arbitrary_precision\"))]\n    fn parse_any_number(&mut self, positive: bool) -> Result<ParserNumber> {\n        self.parse_integer(positive)\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn parse_any_number(&mut self, positive: bool) -> Result<ParserNumber> {\n        let mut buf = String::with_capacity(16);\n        if !positive {\n            buf.push('-');\n        }\n        tri!(self.scan_integer(&mut buf));\n        if positive {\n            if let Ok(unsigned) = buf.parse() {\n                return Ok(ParserNumber::U64(unsigned));\n            }\n        } else {\n            if let Ok(signed) = buf.parse() {\n                return Ok(ParserNumber::I64(signed));\n            }\n        }\n        Ok(ParserNumber::String(buf))\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_or_eof(&mut self, buf: &mut String) -> Result<u8> {\n        match tri!(self.next_char()) {\n            Some(b) => {\n                buf.push(b as char);\n                Ok(b)\n            }\n            None => Err(self.error(ErrorCode::EofWhileParsingValue)),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_integer(&mut self, buf: &mut String) -> Result<()> {\n        match tri!(self.scan_or_eof(buf)) {\n            b'0' => {\n                // There can be only one leading '0'.\n                match tri!(self.peek_or_null()) {\n                    b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),\n                    _ => self.scan_number(buf),\n                }\n            }\n            b'1'..=b'9' => loop {\n                match tri!(self.peek_or_null()) {\n                    c @ b'0'..=b'9' => {\n                        self.eat_char();\n                        buf.push(c as char);\n                    }\n                    _ => {\n                        return self.scan_number(buf);\n                    }\n                }\n            },\n            _ => Err(self.error(ErrorCode::InvalidNumber)),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_number(&mut self, buf: &mut String) -> Result<()> {\n        match tri!(self.peek_or_null()) {\n            b'.' => self.scan_decimal(buf),\n            e @ (b'e' | b'E') => self.scan_exponent(e as char, buf),\n            _ => Ok(()),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_decimal(&mut self, buf: &mut String) -> Result<()> {\n        self.eat_char();\n        buf.push('.');\n\n        let mut at_least_one_digit = false;\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            buf.push(c as char);\n            at_least_one_digit = true;\n        }\n\n        if !at_least_one_digit {\n            match tri!(self.peek()) {\n                Some(_) => return Err(self.peek_error(ErrorCode::InvalidNumber)),\n                None => return Err(self.peek_error(ErrorCode::EofWhileParsingValue)),\n            }\n        }\n\n        match tri!(self.peek_or_null()) {\n            e @ (b'e' | b'E') => self.scan_exponent(e as char, buf),\n            _ => Ok(()),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_exponent(&mut self, e: char, buf: &mut String) -> Result<()> {\n        self.eat_char();\n        buf.push(e);\n\n        match tri!(self.peek_or_null()) {\n            b'+' => {\n                self.eat_char();\n                buf.push('+');\n            }\n            b'-' => {\n                self.eat_char();\n                buf.push('-');\n            }\n            _ => {}\n        }\n\n        // Make sure a digit follows the exponent place.\n        match tri!(self.scan_or_eof(buf)) {\n            b'0'..=b'9' => {}\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        }\n\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            buf.push(c as char);\n        }\n\n        Ok(())\n    }\n\n    fn parse_object_colon(&mut self) -> Result<()> {\n        match tri!(self.parse_whitespace()) {\n            Some(b':') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(_) => Err(self.peek_error(ErrorCode::ExpectedColon)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n        }\n    }\n\n    fn end_seq(&mut self) -> Result<()> {\n        match tri!(self.parse_whitespace()) {\n            Some(b']') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(b',') => {\n                self.eat_char();\n                match self.parse_whitespace() {\n                    Ok(Some(b']')) => Err(self.peek_error(ErrorCode::TrailingComma)),\n                    _ => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n                }\n            }\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingList)),\n        }\n    }\n\n    fn end_map(&mut self) -> Result<()> {\n        match tri!(self.parse_whitespace()) {\n            Some(b'}') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(b',') => Err(self.peek_error(ErrorCode::TrailingComma)),\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n        }\n    }\n\n    fn ignore_value(&mut self) -> Result<()> {\n        self.scratch.clear();\n        let mut enclosing = None;\n\n        loop {\n            let peek = match tri!(self.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n                }\n            };\n\n            let frame = match peek {\n                b'n' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"ull\"));\n                    None\n                }\n                b't' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"rue\"));\n                    None\n                }\n                b'f' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"alse\"));\n                    None\n                }\n                b'-' => {\n                    self.eat_char();\n                    tri!(self.ignore_integer());\n                    None\n                }\n                b'0'..=b'9' => {\n                    tri!(self.ignore_integer());\n                    None\n                }\n                b'\"' => {\n                    self.eat_char();\n                    tri!(self.read.ignore_str());\n                    None\n                }\n                frame @ (b'[' | b'{') => {\n                    self.scratch.extend(enclosing.take());\n                    self.eat_char();\n                    Some(frame)\n                }\n                _ => return Err(self.peek_error(ErrorCode::ExpectedSomeValue)),\n            };\n\n            let (mut accept_comma, mut frame) = match frame {\n                Some(frame) => (false, frame),\n                None => match enclosing.take() {\n                    Some(frame) => (true, frame),\n                    None => match self.scratch.pop() {\n                        Some(frame) => (true, frame),\n                        None => return Ok(()),\n                    },\n                },\n            };\n\n            loop {\n                match tri!(self.parse_whitespace()) {\n                    Some(b',') if accept_comma => {\n                        self.eat_char();\n                        break;\n                    }\n                    Some(b']') if frame == b'[' => {}\n                    Some(b'}') if frame == b'{' => {}\n                    Some(_) => {\n                        if accept_comma {\n                            return Err(self.peek_error(match frame {\n                                b'[' => ErrorCode::ExpectedListCommaOrEnd,\n                                b'{' => ErrorCode::ExpectedObjectCommaOrEnd,\n                                _ => unreachable!(),\n                            }));\n                        } else {\n                            break;\n                        }\n                    }\n                    None => {\n                        return Err(self.peek_error(match frame {\n                            b'[' => ErrorCode::EofWhileParsingList,\n                            b'{' => ErrorCode::EofWhileParsingObject,\n                            _ => unreachable!(),\n                        }));\n                    }\n                }\n\n                self.eat_char();\n                frame = match self.scratch.pop() {\n                    Some(frame) => frame,\n                    None => return Ok(()),\n                };\n                accept_comma = true;\n            }\n\n            if frame == b'{' {\n                match tri!(self.parse_whitespace()) {\n                    Some(b'\"') => self.eat_char(),\n                    Some(_) => return Err(self.peek_error(ErrorCode::KeyMustBeAString)),\n                    None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n                }\n                tri!(self.read.ignore_str());\n                match tri!(self.parse_whitespace()) {\n                    Some(b':') => self.eat_char(),\n                    Some(_) => return Err(self.peek_error(ErrorCode::ExpectedColon)),\n                    None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n                }\n            }\n\n            enclosing = Some(frame);\n        }\n    }\n\n    fn ignore_integer(&mut self) -> Result<()> {\n        match tri!(self.next_char_or_null()) {\n            b'0' => {\n                // There can be only one leading '0'.\n                if let b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    return Err(self.peek_error(ErrorCode::InvalidNumber));\n                }\n            }\n            b'1'..=b'9' => {\n                while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    self.eat_char();\n                }\n            }\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'.' => self.ignore_decimal(),\n            b'e' | b'E' => self.ignore_exponent(),\n            _ => Ok(()),\n        }\n    }\n\n    fn ignore_decimal(&mut self) -> Result<()> {\n        self.eat_char();\n\n        let mut at_least_one_digit = false;\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            at_least_one_digit = true;\n        }\n\n        if !at_least_one_digit {\n            return Err(self.peek_error(ErrorCode::InvalidNumber));\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.ignore_exponent(),\n            _ => Ok(()),\n        }\n    }\n\n    fn ignore_exponent(&mut self) -> Result<()> {\n        self.eat_char();\n\n        match tri!(self.peek_or_null()) {\n            b'+' | b'-' => self.eat_char(),\n            _ => {}\n        }\n\n        // Make sure a digit follows the exponent place.\n        match tri!(self.next_char_or_null()) {\n            b'0'..=b'9' => {}\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        }\n\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n\n        Ok(())\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn deserialize_raw_value<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        tri!(self.parse_whitespace());\n        self.read.begin_raw_buffering();\n        tri!(self.ignore_value());\n        self.read.end_raw_buffering(visitor)\n    }\n}",
            "impl<'de, R> Deserializer<R>\nwhere\n    R: read::Read<'de>,\n{\n    /// Create a JSON deserializer from one of the possible serde_json input\n    /// sources.\n    ///\n    /// When reading from a source against which short reads are not efficient, such\n    /// as a [`File`], you will want to apply your own buffering because serde_json\n    /// will not buffer the input. See [`std::io::BufReader`].\n    ///\n    /// Typically it is more convenient to use one of these methods instead:\n    ///\n    ///   - Deserializer::from_str\n    ///   - Deserializer::from_slice\n    ///   - Deserializer::from_reader\n    ///\n    /// [`File`]: std::fs::File\n    pub fn new(read: R) -> Self {\n        Deserializer {\n            read,\n            scratch: Vec::new(),\n            remaining_depth: 128,\n            #[cfg(feature = \"float_roundtrip\")]\n            single_precision: false,\n            #[cfg(feature = \"unbounded_depth\")]\n            disable_recursion_limit: false,\n        }\n    }\n}",
            "impl<R> Deserializer<read::IoRead<R>>\nwhere\n    R: crate::io::Read,\n{\n    /// Creates a JSON deserializer from an `io::Read`.\n    ///\n    /// Reader-based deserializers do not support deserializing borrowed types\n    /// like `&str`, since the `std::io::Read` trait has no non-copying methods\n    /// -- everything it does involves copying bytes out of the data source.\n    pub fn from_reader(reader: R) -> Self {\n        Deserializer::new(read::IoRead::new(reader))\n    }\n}"
        ],
        "de::MapAccess": [
            "impl<'a, R: 'a> MapAccess<'a, R> {\n    fn new(de: &'a mut Deserializer<R>) -> Self {\n        MapAccess { de, first: true }\n    }\n}",
            "impl<'de, 'a, R: Read<'de> + 'a> de::MapAccess<'de> for MapAccess<'a, R> {\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>\n    where\n        K: de::DeserializeSeed<'de>,\n    {\n        fn has_next_key<'de, 'a, R: Read<'de> + 'a>(map: &mut MapAccess<'a, R>) -> Result<bool> {\n            let peek = match tri!(map.de.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(map.de.peek_error(ErrorCode::EofWhileParsingObject));\n                }\n            };\n\n            if peek == b'}' {\n                Ok(false)\n            } else if map.first {\n                map.first = false;\n                if peek == b'\"' {\n                    Ok(true)\n                } else {\n                    Err(map.de.peek_error(ErrorCode::KeyMustBeAString))\n                }\n            } else if peek == b',' {\n                map.de.eat_char();\n                match tri!(map.de.parse_whitespace()) {\n                    Some(b'\"') => Ok(true),\n                    Some(b'}') => Err(map.de.peek_error(ErrorCode::TrailingComma)),\n                    Some(_) => Err(map.de.peek_error(ErrorCode::KeyMustBeAString)),\n                    None => Err(map.de.peek_error(ErrorCode::EofWhileParsingValue)),\n                }\n            } else {\n                Err(map.de.peek_error(ErrorCode::ExpectedObjectCommaOrEnd))\n            }\n        }\n\n        if tri!(has_next_key(self)) {\n            Ok(Some(tri!(seed.deserialize(MapKey { de: &mut *self.de }))))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        tri!(self.de.parse_object_colon());\n\n        seed.deserialize(&mut *self.de)\n    }\n}"
        ],
        "de::MapKey": [
            "impl<'de, 'a, R> MapKey<'a, R>\nwhere\n    R: Read<'de>,\n{\n    deserialize_numeric_key!(deserialize_number, deserialize_number);\n}",
            "impl<'de, 'a, R> de::Deserializer<'de> for MapKey<'a, R>\nwhere\n    R: Read<'de>,\n{\n    type Error = Error;\n\n    #[inline]\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.de.eat_char();\n        self.de.scratch.clear();\n        match tri!(self.de.read.parse_str(&mut self.de.scratch)) {\n            Reference::Borrowed(s) => visitor.visit_borrowed_str(s),\n            Reference::Copied(s) => visitor.visit_str(s),\n        }\n    }\n\n    deserialize_numeric_key!(deserialize_i8);\n    deserialize_numeric_key!(deserialize_i16);\n    deserialize_numeric_key!(deserialize_i32);\n    deserialize_numeric_key!(deserialize_i64);\n    deserialize_numeric_key!(deserialize_i128, deserialize_i128);\n    deserialize_numeric_key!(deserialize_u8);\n    deserialize_numeric_key!(deserialize_u16);\n    deserialize_numeric_key!(deserialize_u32);\n    deserialize_numeric_key!(deserialize_u64);\n    deserialize_numeric_key!(deserialize_u128, deserialize_u128);\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    deserialize_numeric_key!(deserialize_f32);\n    #[cfg(feature = \"float_roundtrip\")]\n    deserialize_numeric_key!(deserialize_f32, deserialize_f32);\n    deserialize_numeric_key!(deserialize_f64);\n\n    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.de.eat_char();\n\n        let peek = match tri!(self.de.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.de.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b't' => {\n                tri!(self.de.parse_ident(b\"rue\\\"\"));\n                visitor.visit_bool(true)\n            }\n            b'f' => {\n                tri!(self.de.parse_ident(b\"alse\\\"\"));\n                visitor.visit_bool(false)\n            }\n            _ => {\n                self.de.scratch.clear();\n                let s = tri!(self.de.read.parse_str(&mut self.de.scratch));\n                Err(de::Error::invalid_type(Unexpected::Str(&s), &visitor))\n            }\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.de.fix_position(err)),\n        }\n    }\n\n    #[inline]\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        // Map keys cannot be null.\n        visitor.visit_some(self)\n    }\n\n    #[inline]\n    fn deserialize_newtype_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return self.de.deserialize_raw_value(visitor);\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }\n\n    #[inline]\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.de.deserialize_enum(name, variants, visitor)\n    }\n\n    #[inline]\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.de.deserialize_bytes(visitor)\n    }\n\n    #[inline]\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.de.deserialize_bytes(visitor)\n    }\n\n    forward_to_deserialize_any! {\n        char str string unit unit_struct seq tuple tuple_struct map struct\n        identifier ignored_any\n    }\n}"
        ],
        "de::ParserNumber": [
            "impl ParserNumber {\n    fn visit<'de, V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self {\n            ParserNumber::F64(x) => visitor.visit_f64(x),\n            ParserNumber::U64(x) => visitor.visit_u64(x),\n            ParserNumber::I64(x) => visitor.visit_i64(x),\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(x) => visitor.visit_map(NumberDeserializer { number: x.into() }),\n        }\n    }\n\n    fn invalid_type(self, exp: &dyn Expected) -> Error {\n        match self {\n            ParserNumber::F64(x) => de::Error::invalid_type(Unexpected::Float(x), exp),\n            ParserNumber::U64(x) => de::Error::invalid_type(Unexpected::Unsigned(x), exp),\n            ParserNumber::I64(x) => de::Error::invalid_type(Unexpected::Signed(x), exp),\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(_) => de::Error::invalid_type(Unexpected::Other(\"number\"), exp),\n        }\n    }\n}"
        ],
        "de::SeqAccess": [
            "impl<'a, R: 'a> SeqAccess<'a, R> {\n    fn new(de: &'a mut Deserializer<R>) -> Self {\n        SeqAccess { de, first: true }\n    }\n}",
            "impl<'de, 'a, R: Read<'de> + 'a> de::SeqAccess<'de> for SeqAccess<'a, R> {\n    type Error = Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        fn has_next_element<'de, 'a, R: Read<'de> + 'a>(\n            seq: &mut SeqAccess<'a, R>,\n        ) -> Result<bool> {\n            let peek = match tri!(seq.de.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(seq.de.peek_error(ErrorCode::EofWhileParsingList));\n                }\n            };\n\n            if peek == b']' {\n                Ok(false)\n            } else if seq.first {\n                seq.first = false;\n                Ok(true)\n            } else if peek == b',' {\n                seq.de.eat_char();\n                match tri!(seq.de.parse_whitespace()) {\n                    Some(b']') => Err(seq.de.peek_error(ErrorCode::TrailingComma)),\n                    Some(_) => Ok(true),\n                    None => Err(seq.de.peek_error(ErrorCode::EofWhileParsingValue)),\n                }\n            } else {\n                Err(seq.de.peek_error(ErrorCode::ExpectedListCommaOrEnd))\n            }\n        }\n\n        if tri!(has_next_element(self)) {\n            Ok(Some(tri!(seed.deserialize(&mut *self.de))))\n        } else {\n            Ok(None)\n        }\n    }\n}"
        ],
        "de::StreamDeserializer": [
            "impl<'de, R, T> FusedIterator for StreamDeserializer<'de, R, T>\nwhere\n    R: Read<'de> + Fused,\n    T: de::Deserialize<'de>,\n{\n}",
            "impl<'de, R, T> Iterator for StreamDeserializer<'de, R, T>\nwhere\n    R: Read<'de>,\n    T: de::Deserialize<'de>,\n{\n    type Item = Result<T>;\n\n    fn next(&mut self) -> Option<Result<T>> {\n        if R::should_early_return_if_failed && self.failed {\n            return None;\n        }\n\n        // skip whitespaces, if any\n        // this helps with trailing whitespaces, since whitespaces between\n        // values are handled for us.\n        match self.de.parse_whitespace() {\n            Ok(None) => {\n                self.offset = self.de.read.byte_offset();\n                None\n            }\n            Ok(Some(b)) => {\n                // If the value does not have a clear way to show the end of the value\n                // (like numbers, null, true etc.) we have to look for whitespace or\n                // the beginning of a self-delineated value.\n                let self_delineated_value = match b {\n                    b'[' | b'\"' | b'{' => true,\n                    _ => false,\n                };\n                self.offset = self.de.read.byte_offset();\n                let result = de::Deserialize::deserialize(&mut self.de);\n\n                Some(match result {\n                    Ok(value) => {\n                        self.offset = self.de.read.byte_offset();\n                        if self_delineated_value {\n                            Ok(value)\n                        } else {\n                            self.peek_end_of_value().map(|()| value)\n                        }\n                    }\n                    Err(e) => {\n                        self.de.read.set_failed(&mut self.failed);\n                        Err(e)\n                    }\n                })\n            }\n            Err(e) => {\n                self.de.read.set_failed(&mut self.failed);\n                Some(Err(e))\n            }\n        }\n    }\n}",
            "impl<'de, R, T> StreamDeserializer<'de, R, T>\nwhere\n    R: read::Read<'de>,\n    T: de::Deserialize<'de>,\n{\n    /// Create a JSON stream deserializer from one of the possible serde_json\n    /// input sources.\n    ///\n    /// Typically it is more convenient to use one of these methods instead:\n    ///\n    ///   - Deserializer::from_str(...).into_iter()\n    ///   - Deserializer::from_slice(...).into_iter()\n    ///   - Deserializer::from_reader(...).into_iter()\n    pub fn new(read: R) -> Self {\n        let offset = read.byte_offset();\n        StreamDeserializer {\n            de: Deserializer::new(read),\n            offset,\n            failed: false,\n            output: PhantomData,\n            lifetime: PhantomData,\n        }\n    }\n\n    /// Returns the number of bytes so far deserialized into a successful `T`.\n    ///\n    /// If a stream deserializer returns an EOF error, new data can be joined to\n    /// `old_data[stream.byte_offset()..]` to try again.\n    ///\n    /// ```\n    /// let data = b\"[0] [1] [\";\n    ///\n    /// let de = serde_json::Deserializer::from_slice(data);\n    /// let mut stream = de.into_iter::<Vec<i32>>();\n    /// assert_eq!(0, stream.byte_offset());\n    ///\n    /// println!(\"{:?}\", stream.next()); // [0]\n    /// assert_eq!(3, stream.byte_offset());\n    ///\n    /// println!(\"{:?}\", stream.next()); // [1]\n    /// assert_eq!(7, stream.byte_offset());\n    ///\n    /// println!(\"{:?}\", stream.next()); // error\n    /// assert_eq!(8, stream.byte_offset());\n    ///\n    /// // If err.is_eof(), can join the remaining data to new data and continue.\n    /// let remaining = &data[stream.byte_offset()..];\n    /// ```\n    ///\n    /// *Note:* In the future this method may be changed to return the number of\n    /// bytes so far deserialized into a successful T *or* syntactically valid\n    /// JSON skipped over due to a type error. See [serde-rs/json#70] for an\n    /// example illustrating this.\n    ///\n    /// [serde-rs/json#70]: https://github.com/serde-rs/json/issues/70\n    pub fn byte_offset(&self) -> usize {\n        self.offset\n    }\n\n    fn peek_end_of_value(&mut self) -> Result<()> {\n        match tri!(self.de.peek()) {\n            Some(b' ' | b'\\n' | b'\\t' | b'\\r' | b'\"' | b'[' | b']' | b'{' | b'}' | b',' | b':')\n            | None => Ok(()),\n            Some(_) => {\n                let position = self.de.read.peek_position();\n                Err(Error::syntax(\n                    ErrorCode::TrailingCharacters,\n                    position.line,\n                    position.column,\n                ))\n            }\n        }\n    }\n}"
        ],
        "de::UnitVariantAccess": [
            "impl<'a, R: 'a> UnitVariantAccess<'a, R> {\n    fn new(de: &'a mut Deserializer<R>) -> Self {\n        UnitVariantAccess { de }\n    }\n}",
            "impl<'de, 'a, R: Read<'de> + 'a> de::EnumAccess<'de> for UnitVariantAccess<'a, R> {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        let variant = tri!(seed.deserialize(&mut *self.de));\n        Ok((variant, self))\n    }\n}",
            "impl<'de, 'a, R: Read<'de> + 'a> de::VariantAccess<'de> for UnitVariantAccess<'a, R> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<()> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"newtype variant\",\n        ))\n    }\n\n    fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"tuple variant\",\n        ))\n    }\n\n    fn struct_variant<V>(self, _fields: &'static [&'static str], _visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"struct variant\",\n        ))\n    }\n}"
        ],
        "de::VariantAccess": [
            "impl<'a, R: 'a> VariantAccess<'a, R> {\n    fn new(de: &'a mut Deserializer<R>) -> Self {\n        VariantAccess { de }\n    }\n}",
            "impl<'de, 'a, R: Read<'de> + 'a> de::EnumAccess<'de> for VariantAccess<'a, R> {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        let val = tri!(seed.deserialize(&mut *self.de));\n        tri!(self.de.parse_object_colon());\n        Ok((val, self))\n    }\n}",
            "impl<'de, 'a, R: Read<'de> + 'a> de::VariantAccess<'de> for VariantAccess<'a, R> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<()> {\n        de::Deserialize::deserialize(self.de)\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(self.de)\n    }\n\n    fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        de::Deserializer::deserialize_seq(self.de, visitor)\n    }\n\n    fn struct_variant<V>(self, fields: &'static [&'static str], visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        de::Deserializer::deserialize_struct(self.de, \"\", fields, visitor)\n    }\n}"
        ],
        "error::Category": [
            "Clone",
            "Copy",
            "Debug",
            "Eq",
            "PartialEq"
        ],
        "error::Error": [
            "impl Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Error({:?}, line: {}, column: {})\",\n            self.err.code.to_string(),\n            self.err.line,\n            self.err.column\n        )\n    }\n}",
            "impl Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&*self.err, f)\n    }\n}",
            "impl Error {\n    #[cold]\n    pub(crate) fn syntax(code: ErrorCode, line: usize, column: usize) -> Self {\n        Error {\n            err: Box::new(ErrorImpl { code, line, column }),\n        }\n    }\n\n    // Not public API. Should be pub(crate).\n    //\n    // Update `eager_json` crate when this function changes.\n    #[doc(hidden)]\n    #[cold]\n    pub fn io(error: io::Error) -> Self {\n        Error {\n            err: Box::new(ErrorImpl {\n                code: ErrorCode::Io(error),\n                line: 0,\n                column: 0,\n            }),\n        }\n    }\n\n    #[cold]\n    pub(crate) fn fix_position<F>(self, f: F) -> Self\n    where\n        F: FnOnce(ErrorCode) -> Error,\n    {\n        if self.err.line == 0 {\n            f(self.err.code)\n        } else {\n            self\n        }\n    }\n}",
            "impl Error {\n    /// One-based line number at which the error was detected.\n    ///\n    /// Characters in the first line of the input (before the first newline\n    /// character) are in line 1.\n    pub fn line(&self) -> usize {\n        self.err.line\n    }\n\n    /// One-based column number at which the error was detected.\n    ///\n    /// The first character in the input and any characters immediately\n    /// following a newline character are in column 1.\n    ///\n    /// Note that errors may occur in column 0, for example if a read from an\n    /// I/O stream fails immediately following a previously read newline\n    /// character.\n    pub fn column(&self) -> usize {\n        self.err.column\n    }\n\n    /// Categorizes the cause of this error.\n    ///\n    /// - `Category::Io` - failure to read or write bytes on an I/O stream\n    /// - `Category::Syntax` - input that is not syntactically valid JSON\n    /// - `Category::Data` - input data that is semantically incorrect\n    /// - `Category::Eof` - unexpected end of the input data\n    pub fn classify(&self) -> Category {\n        match self.err.code {\n            ErrorCode::Message(_) => Category::Data,\n            ErrorCode::Io(_) => Category::Io,\n            ErrorCode::EofWhileParsingList\n            | ErrorCode::EofWhileParsingObject\n            | ErrorCode::EofWhileParsingString\n            | ErrorCode::EofWhileParsingValue => Category::Eof,\n            ErrorCode::ExpectedColon\n            | ErrorCode::ExpectedListCommaOrEnd\n            | ErrorCode::ExpectedObjectCommaOrEnd\n            | ErrorCode::ExpectedSomeIdent\n            | ErrorCode::ExpectedSomeValue\n            | ErrorCode::ExpectedDoubleQuote\n            | ErrorCode::InvalidEscape\n            | ErrorCode::InvalidNumber\n            | ErrorCode::NumberOutOfRange\n            | ErrorCode::InvalidUnicodeCodePoint\n            | ErrorCode::ControlCharacterWhileParsingString\n            | ErrorCode::KeyMustBeAString\n            | ErrorCode::ExpectedNumericKey\n            | ErrorCode::FloatKeyMustBeFinite\n            | ErrorCode::LoneLeadingSurrogateInHexEscape\n            | ErrorCode::TrailingComma\n            | ErrorCode::TrailingCharacters\n            | ErrorCode::UnexpectedEndOfHexEscape\n            | ErrorCode::RecursionLimitExceeded => Category::Syntax,\n        }\n    }\n\n    /// Returns true if this error was caused by a failure to read or write\n    /// bytes on an I/O stream.\n    pub fn is_io(&self) -> bool {\n        self.classify() == Category::Io\n    }\n\n    /// Returns true if this error was caused by input that was not\n    /// syntactically valid JSON.\n    pub fn is_syntax(&self) -> bool {\n        self.classify() == Category::Syntax\n    }\n\n    /// Returns true if this error was caused by input data that was\n    /// semantically incorrect.\n    ///\n    /// For example, JSON containing a number is semantically incorrect when the\n    /// type being deserialized into holds a String.\n    pub fn is_data(&self) -> bool {\n        self.classify() == Category::Data\n    }\n\n    /// Returns true if this error was caused by prematurely reaching the end of\n    /// the input data.\n    ///\n    /// Callers that process streaming input may be interested in retrying the\n    /// deserialization once more data is available.\n    pub fn is_eof(&self) -> bool {\n        self.classify() == Category::Eof\n    }\n\n    /// The kind reported by the underlying standard library I/O error, if this\n    /// error was caused by a failure to read or write bytes on an I/O stream.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use serde_json::Value;\n    /// use std::io::{self, ErrorKind, Read};\n    /// use std::process;\n    ///\n    /// struct ReaderThatWillTimeOut<'a>(&'a [u8]);\n    ///\n    /// impl<'a> Read for ReaderThatWillTimeOut<'a> {\n    ///     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n    ///         if self.0.is_empty() {\n    ///             Err(io::Error::new(ErrorKind::TimedOut, \"timed out\"))\n    ///         } else {\n    ///             self.0.read(buf)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     let reader = ReaderThatWillTimeOut(br#\" {\"k\": \"#);\n    ///\n    ///     let _: Value = match serde_json::from_reader(reader) {\n    ///         Ok(value) => value,\n    ///         Err(error) => {\n    ///             if error.io_error_kind() == Some(ErrorKind::TimedOut) {\n    ///                 // Maybe this application needs to retry certain kinds of errors.\n    ///\n    ///                 # return;\n    ///             } else {\n    ///                 eprintln!(\"error: {}\", error);\n    ///                 process::exit(1);\n    ///             }\n    ///         }\n    ///     };\n    /// }\n    /// ```\n    #[cfg(feature = \"std\")]\n    pub fn io_error_kind(&self) -> Option<ErrorKind> {\n        if let ErrorCode::Io(io_error) = &self.err.code {\n            Some(io_error.kind())\n        } else {\n            None\n        }\n    }\n}",
            "impl de::Error for Error {\n    #[cold]\n    fn custom<T: Display>(msg: T) -> Error {\n        make_error(msg.to_string())\n    }\n\n    #[cold]\n    fn invalid_type(unexp: de::Unexpected, exp: &dyn de::Expected) -> Self {\n        Error::custom(format_args!(\n            \"invalid type: {}, expected {}\",\n            JsonUnexpected(unexp),\n            exp,\n        ))\n    }\n\n    #[cold]\n    fn invalid_value(unexp: de::Unexpected, exp: &dyn de::Expected) -> Self {\n        Error::custom(format_args!(\n            \"invalid value: {}, expected {}\",\n            JsonUnexpected(unexp),\n            exp,\n        ))\n    }\n}",
            "impl ser::Error for Error {\n    #[cold]\n    fn custom<T: Display>(msg: T) -> Error {\n        make_error(msg.to_string())\n    }\n}",
            "impl serde::de::StdError for Error {\n    #[cfg(feature = \"std\")]\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        match &self.err.code {\n            ErrorCode::Io(err) => err.source(),\n            _ => None,\n        }\n    }\n}"
        ],
        "error::ErrorCode": [
            "impl Display for ErrorCode {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            ErrorCode::Message(msg) => f.write_str(msg),\n            ErrorCode::Io(err) => Display::fmt(err, f),\n            ErrorCode::EofWhileParsingList => f.write_str(\"EOF while parsing a list\"),\n            ErrorCode::EofWhileParsingObject => f.write_str(\"EOF while parsing an object\"),\n            ErrorCode::EofWhileParsingString => f.write_str(\"EOF while parsing a string\"),\n            ErrorCode::EofWhileParsingValue => f.write_str(\"EOF while parsing a value\"),\n            ErrorCode::ExpectedColon => f.write_str(\"expected `:`\"),\n            ErrorCode::ExpectedListCommaOrEnd => f.write_str(\"expected `,` or `]`\"),\n            ErrorCode::ExpectedObjectCommaOrEnd => f.write_str(\"expected `,` or `}`\"),\n            ErrorCode::ExpectedSomeIdent => f.write_str(\"expected ident\"),\n            ErrorCode::ExpectedSomeValue => f.write_str(\"expected value\"),\n            ErrorCode::ExpectedDoubleQuote => f.write_str(\"expected `\\\"`\"),\n            ErrorCode::InvalidEscape => f.write_str(\"invalid escape\"),\n            ErrorCode::InvalidNumber => f.write_str(\"invalid number\"),\n            ErrorCode::NumberOutOfRange => f.write_str(\"number out of range\"),\n            ErrorCode::InvalidUnicodeCodePoint => f.write_str(\"invalid unicode code point\"),\n            ErrorCode::ControlCharacterWhileParsingString => {\n                f.write_str(\"control character (\\\\u0000-\\\\u001F) found while parsing a string\")\n            }\n            ErrorCode::KeyMustBeAString => f.write_str(\"key must be a string\"),\n            ErrorCode::ExpectedNumericKey => {\n                f.write_str(\"invalid value: expected key to be a number in quotes\")\n            }\n            ErrorCode::FloatKeyMustBeFinite => {\n                f.write_str(\"float key must be finite (got NaN or +/-inf)\")\n            }\n            ErrorCode::LoneLeadingSurrogateInHexEscape => {\n                f.write_str(\"lone leading surrogate in hex escape\")\n            }\n            ErrorCode::TrailingComma => f.write_str(\"trailing comma\"),\n            ErrorCode::TrailingCharacters => f.write_str(\"trailing characters\"),\n            ErrorCode::UnexpectedEndOfHexEscape => f.write_str(\"unexpected end of hex escape\"),\n            ErrorCode::RecursionLimitExceeded => f.write_str(\"recursion limit exceeded\"),\n        }\n    }\n}"
        ],
        "error::ErrorImpl": [
            "impl Display for ErrorImpl {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.line == 0 {\n            Display::fmt(&self.code, f)\n        } else {\n            write!(\n                f,\n                \"{} at line {} column {}\",\n                self.code, self.line, self.column\n            )\n        }\n    }\n}"
        ],
        "error::JsonUnexpected": [
            "impl<'a> Display for JsonUnexpected<'a> {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match self.0 {\n            de::Unexpected::Unit => formatter.write_str(\"null\"),\n            de::Unexpected::Float(value) => write!(\n                formatter,\n                \"floating point `{}`\",\n                ryu::Buffer::new().format(value),\n            ),\n            unexp => Display::fmt(&unexp, formatter),\n        }\n    }\n}"
        ],
        "iter::LineColIterator": [
            "impl<I> Iterator for LineColIterator<I>\nwhere\n    I: Iterator<Item = io::Result<u8>>,\n{\n    type Item = io::Result<u8>;\n\n    fn next(&mut self) -> Option<io::Result<u8>> {\n        match self.iter.next() {\n            None => None,\n            Some(Ok(b'\\n')) => {\n                self.start_of_line += self.col + 1;\n                self.line += 1;\n                self.col = 0;\n                Some(Ok(b'\\n'))\n            }\n            Some(Ok(c)) => {\n                self.col += 1;\n                Some(Ok(c))\n            }\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }\n}",
            "impl<I> LineColIterator<I>\nwhere\n    I: Iterator<Item = io::Result<u8>>,\n{\n    pub fn new(iter: I) -> LineColIterator<I> {\n        LineColIterator {\n            iter,\n            line: 1,\n            col: 0,\n            start_of_line: 0,\n        }\n    }\n\n    pub fn line(&self) -> usize {\n        self.line\n    }\n\n    pub fn col(&self) -> usize {\n        self.col\n    }\n\n    pub fn byte_offset(&self) -> usize {\n        self.start_of_line + self.col\n    }\n}"
        ],
        "map::Entry": [
            "impl<'a> Entry<'a> {\n    /// Returns a reference to this entry's key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut map = serde_json::Map::new();\n    /// assert_eq!(map.entry(\"serde\").key(), &\"serde\");\n    /// ```\n    pub fn key(&self) -> &String {\n        match self {\n            Entry::Vacant(e) => e.key(),\n            Entry::Occupied(e) => e.key(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and\n    /// returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut map = serde_json::Map::new();\n    /// map.entry(\"serde\").or_insert(json!(12));\n    ///\n    /// assert_eq!(map[\"serde\"], 12);\n    /// ```\n    pub fn or_insert(self, default: Value) -> &'a mut Value {\n        match self {\n            Entry::Vacant(entry) => entry.insert(default),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default\n    /// function if empty, and returns a mutable reference to the value in the\n    /// entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut map = serde_json::Map::new();\n    /// map.entry(\"serde\").or_insert_with(|| json!(\"hoho\"));\n    ///\n    /// assert_eq!(map[\"serde\"], \"hoho\".to_owned());\n    /// ```\n    pub fn or_insert_with<F>(self, default: F) -> &'a mut Value\n    where\n        F: FnOnce() -> Value,\n    {\n        match self {\n            Entry::Vacant(entry) => entry.insert(default()),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut map = serde_json::Map::new();\n    /// map.entry(\"serde\")\n    ///     .and_modify(|e| *e = json!(\"rust\"))\n    ///     .or_insert(json!(\"cpp\"));\n    ///\n    /// assert_eq!(map[\"serde\"], \"cpp\");\n    ///\n    /// map.entry(\"serde\")\n    ///     .and_modify(|e| *e = json!(\"rust\"))\n    ///     .or_insert(json!(\"cpp\"));\n    ///\n    /// assert_eq!(map[\"serde\"], \"rust\");\n    /// ```\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut Value),\n    {\n        match self {\n            Entry::Occupied(mut entry) => {\n                f(entry.get_mut());\n                Entry::Occupied(entry)\n            }\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }\n}"
        ],
        "map::IntoIter": [
            "impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }",
            "impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }",
            "impl $($generics)* FusedIterator for $name $($generics)* {}",
            "impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"
        ],
        "map::IntoValues": [
            "impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }",
            "impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }",
            "impl $($generics)* FusedIterator for $name $($generics)* {}",
            "impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"
        ],
        "map::Iter": [
            "impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }",
            "impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }",
            "impl $($generics)* FusedIterator for $name $($generics)* {}",
            "impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"
        ],
        "map::IterMut": [
            "impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }",
            "impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }",
            "impl $($generics)* FusedIterator for $name $($generics)* {}",
            "impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"
        ],
        "map::Keys": [
            "impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }",
            "impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }",
            "impl $($generics)* FusedIterator for $name $($generics)* {}",
            "impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"
        ],
        "map::Map": [
            "impl Clone for Map<String, Value> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Map {\n            map: self.map.clone(),\n        }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, source: &Self) {\n        self.map.clone_from(&source.map);\n    }\n}",
            "impl Debug for Map<String, Value> {\n    #[inline]\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        self.map.fmt(formatter)\n    }\n}",
            "impl Default for Map<String, Value> {\n    #[inline]\n    fn default() -> Self {\n        Map {\n            map: MapImpl::new(),\n        }\n    }\n}",
            "impl Eq for Map<String, Value> {}",
            "impl Extend<(String, Value)> for Map<String, Value> {\n    fn extend<T>(&mut self, iter: T)\n    where\n        T: IntoIterator<Item = (String, Value)>,\n    {\n        self.map.extend(iter);\n    }\n}",
            "impl FromIterator<(String, Value)> for Map<String, Value> {\n    fn from_iter<T>(iter: T) -> Self\n    where\n        T: IntoIterator<Item = (String, Value)>,\n    {\n        Map {\n            map: FromIterator::from_iter(iter),\n        }\n    }\n}",
            "impl Hash for Map<String, Value> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        #[cfg(not(feature = \"preserve_order\"))]\n        {\n            self.map.hash(state);\n        }\n\n        #[cfg(feature = \"preserve_order\")]\n        {\n            let mut kv = Vec::from_iter(&self.map);\n            kv.sort_unstable_by(|a, b| a.0.cmp(b.0));\n            kv.hash(state);\n        }\n    }\n}",
            "impl IntoIterator for Map<String, Value> {\n    type Item = (String, Value);\n    type IntoIter = IntoIter;\n    #[inline]\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter {\n            iter: self.map.into_iter(),\n        }\n    }\n}",
            "impl Map<String, Value> {\n    /// Makes a new empty Map.\n    #[inline]\n    pub fn new() -> Self {\n        Map {\n            map: MapImpl::new(),\n        }\n    }\n\n    /// Makes a new empty Map with the given initial capacity.\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Self {\n        Map {\n            #[cfg(not(feature = \"preserve_order\"))]\n            map: {\n                // does not support with_capacity\n                let _ = capacity;\n                BTreeMap::new()\n            },\n            #[cfg(feature = \"preserve_order\")]\n            map: IndexMap::with_capacity(capacity),\n        }\n    }\n\n    /// Clears the map, removing all values.\n    #[inline]\n    pub fn clear(&mut self) {\n        self.map.clear();\n    }\n\n    /// Returns a reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }\n\n    /// Returns true if the map contains a value for the specified key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.contains_key(key)\n    }\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get_mut(key)\n    }\n\n    /// Returns the key-value pair matching the given key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn get_key_value<Q>(&self, key: &Q) -> Option<(&String, &Value)>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get_key_value(key)\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not have this key present, `None` is returned.\n    ///\n    /// If the map did have this key present, the value is updated, and the old\n    /// value is returned.\n    #[inline]\n    pub fn insert(&mut self, k: String, v: Value) -> Option<Value> {\n        self.map.insert(k, v)\n    }\n\n    /// Insert a key-value pair in the map at the given index.\n    ///\n    /// If the map did not have this key present, `None` is returned.\n    ///\n    /// If the map did have this key present, the key is moved to the new\n    /// position, the value is updated, and the old value is returned.\n    #[cfg(feature = \"preserve_order\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"preserve_order\")))]\n    #[inline]\n    pub fn shift_insert(&mut self, index: usize, k: String, v: Value) -> Option<Value> {\n        self.map.shift_insert(index, k, v)\n    }\n\n    /// Removes a key from the map, returning the value at the key if the key\n    /// was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    ///\n    /// If serde_json's \"preserve_order\" is enabled, `.remove(key)` is\n    /// equivalent to [`.swap_remove(key)`][Self::swap_remove], replacing this\n    /// entry's position with the last element. If you need to preserve the\n    /// relative order of the keys in the map, use\n    /// [`.shift_remove(key)`][Self::shift_remove] instead.\n    #[inline]\n    pub fn remove<Q>(&mut self, key: &Q) -> Option<Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        #[cfg(feature = \"preserve_order\")]\n        return self.swap_remove(key);\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.map.remove(key);\n    }\n\n    /// Removes a key from the map, returning the stored key and value if the\n    /// key was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    ///\n    /// If serde_json's \"preserve_order\" is enabled, `.remove_entry(key)` is\n    /// equivalent to [`.swap_remove_entry(key)`][Self::swap_remove_entry],\n    /// replacing this entry's position with the last element. If you need to\n    /// preserve the relative order of the keys in the map, use\n    /// [`.shift_remove_entry(key)`][Self::shift_remove_entry] instead.\n    #[inline]\n    pub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(String, Value)>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        #[cfg(feature = \"preserve_order\")]\n        return self.swap_remove_entry(key);\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.map.remove_entry(key);\n    }\n\n    /// Removes and returns the value corresponding to the key from the map.\n    ///\n    /// Like [`Vec::swap_remove`], the entry is removed by swapping it with the\n    /// last element of the map and popping it off. This perturbs the position\n    /// of what used to be the last element!\n    ///\n    /// [`Vec::swap_remove`]: std::vec::Vec::swap_remove\n    #[cfg(feature = \"preserve_order\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"preserve_order\")))]\n    #[inline]\n    pub fn swap_remove<Q>(&mut self, key: &Q) -> Option<Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.swap_remove(key)\n    }\n\n    /// Remove and return the key-value pair.\n    ///\n    /// Like [`Vec::swap_remove`], the entry is removed by swapping it with the\n    /// last element of the map and popping it off. This perturbs the position\n    /// of what used to be the last element!\n    ///\n    /// [`Vec::swap_remove`]: std::vec::Vec::swap_remove\n    #[cfg(feature = \"preserve_order\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"preserve_order\")))]\n    #[inline]\n    pub fn swap_remove_entry<Q>(&mut self, key: &Q) -> Option<(String, Value)>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.swap_remove_entry(key)\n    }\n\n    /// Removes and returns the value corresponding to the key from the map.\n    ///\n    /// Like [`Vec::remove`], the entry is removed by shifting all of the\n    /// elements that follow it, preserving their relative order. This perturbs\n    /// the index of all of those elements!\n    ///\n    /// [`Vec::remove`]: std::vec::Vec::remove\n    #[cfg(feature = \"preserve_order\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"preserve_order\")))]\n    #[inline]\n    pub fn shift_remove<Q>(&mut self, key: &Q) -> Option<Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.shift_remove(key)\n    }\n\n    /// Remove and return the key-value pair.\n    ///\n    /// Like [`Vec::remove`], the entry is removed by shifting all of the\n    /// elements that follow it, preserving their relative order. This perturbs\n    /// the index of all of those elements!\n    ///\n    /// [`Vec::remove`]: std::vec::Vec::remove\n    #[cfg(feature = \"preserve_order\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"preserve_order\")))]\n    #[inline]\n    pub fn shift_remove_entry<Q>(&mut self, key: &Q) -> Option<(String, Value)>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.shift_remove_entry(key)\n    }\n\n    /// Moves all elements from other into self, leaving other empty.\n    #[inline]\n    pub fn append(&mut self, other: &mut Self) {\n        #[cfg(feature = \"preserve_order\")]\n        self.map\n            .extend(mem::replace(&mut other.map, MapImpl::default()));\n        #[cfg(not(feature = \"preserve_order\"))]\n        self.map.append(&mut other.map);\n    }\n\n    /// Gets the given key's corresponding entry in the map for in-place\n    /// manipulation.\n    pub fn entry<S>(&mut self, key: S) -> Entry\n    where\n        S: Into<String>,\n    {\n        #[cfg(not(feature = \"preserve_order\"))]\n        use alloc::collections::btree_map::Entry as EntryImpl;\n        #[cfg(feature = \"preserve_order\")]\n        use indexmap::map::Entry as EntryImpl;\n\n        match self.map.entry(key.into()) {\n            EntryImpl::Vacant(vacant) => Entry::Vacant(VacantEntry { vacant }),\n            EntryImpl::Occupied(occupied) => Entry::Occupied(OccupiedEntry { occupied }),\n        }\n    }\n\n    /// Returns the number of elements in the map.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.map.len()\n    }\n\n    /// Returns true if the map contains no elements.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.map.is_empty()\n    }\n\n    /// Gets an iterator over the entries of the map.\n    #[inline]\n    pub fn iter(&self) -> Iter {\n        Iter {\n            iter: self.map.iter(),\n        }\n    }\n\n    /// Gets a mutable iterator over the entries of the map.\n    #[inline]\n    pub fn iter_mut(&mut self) -> IterMut {\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }\n\n    /// Gets an iterator over the keys of the map.\n    #[inline]\n    pub fn keys(&self) -> Keys {\n        Keys {\n            iter: self.map.keys(),\n        }\n    }\n\n    /// Gets an iterator over the values of the map.\n    #[inline]\n    pub fn values(&self) -> Values {\n        Values {\n            iter: self.map.values(),\n        }\n    }\n\n    /// Gets an iterator over mutable values of the map.\n    #[inline]\n    pub fn values_mut(&mut self) -> ValuesMut {\n        ValuesMut {\n            iter: self.map.values_mut(),\n        }\n    }\n\n    /// Gets an iterator over the values of the map.\n    #[inline]\n    pub fn into_values(self) -> IntoValues {\n        IntoValues {\n            iter: self.map.into_values(),\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all pairs `(k, v)` such that `f(&k, &mut v)`\n    /// returns `false`.\n    #[inline]\n    pub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&String, &mut Value) -> bool,\n    {\n        self.map.retain(f);\n    }\n\n    /// Sorts this map's entries in-place using `str`'s usual ordering.\n    ///\n    /// If serde_json's \"preserve_order\" feature is not enabled, this method\n    /// does no work because all JSON maps are always kept in a sorted state.\n    ///\n    /// If serde_json's \"preserve_order\" feature is enabled, this method\n    /// destroys the original source order or insertion order of this map in\n    /// favor of an alphanumerical order that matches how a BTreeMap with the\n    /// same contents would be ordered. This takes **O(n log n + c)** time where\n    /// _n_ is the length of the map and _c_ is the capacity.\n    ///\n    /// Other maps nested within the values of this map are not sorted. If you\n    /// need the entire data structure to be sorted at all levels, you must also\n    /// call\n    /// <code>map.[values_mut]\\().for_each([Value::sort_all_objects])</code>.\n    ///\n    /// [values_mut]: Map::values_mut\n    #[inline]\n    pub fn sort_keys(&mut self) {\n        #[cfg(feature = \"preserve_order\")]\n        self.map.sort_unstable_keys();\n    }\n}",
            "impl PartialEq for Map<String, Value> {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n        self.map.eq(&other.map)\n    }\n}",
            "impl serde::ser::Serialize for Map<String, Value> {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::ser::Serializer,\n    {\n        use serde::ser::SerializeMap;\n        let mut map = tri!(serializer.serialize_map(Some(self.len())));\n        for (k, v) in self {\n            tri!(map.serialize_entry(k, v));\n        }\n        map.end()\n    }\n}",
            "impl<'de> de::Deserialize<'de> for Map<String, Value> {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct Visitor;\n\n        impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Map<String, Value>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                Ok(Map::new())\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut values = Map::new();\n\n                while let Some((key, value)) = tri!(visitor.next_entry()) {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        deserializer.deserialize_map(Visitor)\n    }\n}",
            "impl<'de> de::IntoDeserializer<'de, Error> for Map<String, Value> {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }\n}",
            "impl<'de> serde::Deserializer<'de> for Map<String, Value> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        let len = self.len();\n        let mut deserializer = MapDeserializer::new(self);\n        let map = tri!(visitor.visit_map(&mut deserializer));\n        let remaining = deserializer.iter.len();\n        if remaining == 0 {\n            Ok(map)\n        } else {\n            Err(serde::de::Error::invalid_length(\n                len,\n                &\"fewer elements in map\",\n            ))\n        }\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        _name: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        let mut iter = self.into_iter();\n        let (variant, value) = match iter.next() {\n            Some(v) => v,\n            None => {\n                return Err(serde::de::Error::invalid_value(\n                    Unexpected::Map,\n                    &\"map with a single key\",\n                ));\n            }\n        };\n        // enums are encoded in json as maps with a single key:value pair\n        if iter.next().is_some() {\n            return Err(serde::de::Error::invalid_value(\n                Unexpected::Map,\n                &\"map with a single key\",\n            ));\n        }\n\n        visitor.visit_enum(EnumDeserializer {\n            variant,\n            value: Some(value),\n        })\n    }\n\n    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        drop(self);\n        visitor.visit_unit()\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier\n    }\n}",
            "impl<Q> ops::Index<&Q> for Map<String, Value>\nwhere\n    String: Borrow<Q>,\n    Q: ?Sized + Ord + Eq + Hash,\n{\n    type Output = Value;\n\n    fn index(&self, index: &Q) -> &Value {\n        self.map.index(index)\n    }\n}",
            "impl<Q> ops::IndexMut<&Q> for Map<String, Value>\nwhere\n    String: Borrow<Q>,\n    Q: ?Sized + Ord + Eq + Hash,\n{\n    fn index_mut(&mut self, index: &Q) -> &mut Value {\n        self.map.get_mut(index).expect(\"no entry found for key\")\n    }\n}"
        ],
        "map::OccupiedEntry": [
            "impl<'a> OccupiedEntry<'a> {\n    /// Gets a reference to the key in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!(12));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(occupied) => {\n    ///         assert_eq!(occupied.key(), &\"serde\");\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn key(&self) -> &String {\n        self.occupied.key()\n    }\n\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!(12));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(occupied) => {\n    ///         assert_eq!(occupied.get(), 12);\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn get(&self) -> &Value {\n        self.occupied.get()\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!([1, 2, 3]));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(mut occupied) => {\n    ///         occupied.get_mut().as_array_mut().unwrap().push(json!(4));\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    ///\n    /// assert_eq!(map[\"serde\"].as_array().unwrap().len(), 4);\n    /// ```\n    #[inline]\n    pub fn get_mut(&mut self) -> &mut Value {\n        self.occupied.get_mut()\n    }\n\n    /// Converts the entry into a mutable reference to its value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!([1, 2, 3]));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(mut occupied) => {\n    ///         occupied.into_mut().as_array_mut().unwrap().push(json!(4));\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    ///\n    /// assert_eq!(map[\"serde\"].as_array().unwrap().len(), 4);\n    /// ```\n    #[inline]\n    pub fn into_mut(self) -> &'a mut Value {\n        self.occupied.into_mut()\n    }\n\n    /// Sets the value of the entry with the `OccupiedEntry`'s key, and returns\n    /// the entry's old value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!(12));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(mut occupied) => {\n    ///         assert_eq!(occupied.insert(json!(13)), 12);\n    ///         assert_eq!(occupied.get(), 13);\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn insert(&mut self, value: Value) -> Value {\n        self.occupied.insert(value)\n    }\n\n    /// Takes the value of the entry out of the map, and returns it.\n    ///\n    /// If serde_json's \"preserve_order\" is enabled, `.remove()` is\n    /// equivalent to [`.swap_remove()`][Self::swap_remove], replacing this\n    /// entry's position with the last element. If you need to preserve the\n    /// relative order of the keys in the map, use\n    /// [`.shift_remove()`][Self::shift_remove] instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!(12));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(occupied) => {\n    ///         assert_eq!(occupied.remove(), 12);\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn remove(self) -> Value {\n        #[cfg(feature = \"preserve_order\")]\n        return self.swap_remove();\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.occupied.remove();\n    }\n\n    /// Takes the value of the entry out of the map, and returns it.\n    ///\n    /// Like [`Vec::swap_remove`], the entry is removed by swapping it with the\n    /// last element of the map and popping it off. This perturbs the position\n    /// of what used to be the last element!\n    ///\n    /// [`Vec::swap_remove`]: std::vec::Vec::swap_remove\n    #[cfg(feature = \"preserve_order\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"preserve_order\")))]\n    #[inline]\n    pub fn swap_remove(self) -> Value {\n        self.occupied.swap_remove()\n    }\n\n    /// Takes the value of the entry out of the map, and returns it.\n    ///\n    /// Like [`Vec::remove`], the entry is removed by shifting all of the\n    /// elements that follow it, preserving their relative order. This perturbs\n    /// the index of all of those elements!\n    ///\n    /// [`Vec::remove`]: std::vec::Vec::remove\n    #[cfg(feature = \"preserve_order\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"preserve_order\")))]\n    #[inline]\n    pub fn shift_remove(self) -> Value {\n        self.occupied.shift_remove()\n    }\n\n    /// Removes the entry from the map, returning the stored key and value.\n    ///\n    /// If serde_json's \"preserve_order\" is enabled, `.remove_entry()` is\n    /// equivalent to [`.swap_remove_entry()`][Self::swap_remove_entry],\n    /// replacing this entry's position with the last element. If you need to\n    /// preserve the relative order of the keys in the map, use\n    /// [`.shift_remove_entry()`][Self::shift_remove_entry] instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!(12));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(occupied) => {\n    ///         let (key, value) = occupied.remove_entry();\n    ///         assert_eq!(key, \"serde\");\n    ///         assert_eq!(value, 12);\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn remove_entry(self) -> (String, Value) {\n        #[cfg(feature = \"preserve_order\")]\n        return self.swap_remove_entry();\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.occupied.remove_entry();\n    }\n\n    /// Removes the entry from the map, returning the stored key and value.\n    ///\n    /// Like [`Vec::swap_remove`], the entry is removed by swapping it with the\n    /// last element of the map and popping it off. This perturbs the position\n    /// of what used to be the last element!\n    ///\n    /// [`Vec::swap_remove`]: std::vec::Vec::swap_remove\n    #[cfg(feature = \"preserve_order\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"preserve_order\")))]\n    #[inline]\n    pub fn swap_remove_entry(self) -> (String, Value) {\n        self.occupied.swap_remove_entry()\n    }\n\n    /// Removes the entry from the map, returning the stored key and value.\n    ///\n    /// Like [`Vec::remove`], the entry is removed by shifting all of the\n    /// elements that follow it, preserving their relative order. This perturbs\n    /// the index of all of those elements!\n    ///\n    /// [`Vec::remove`]: std::vec::Vec::remove\n    #[cfg(feature = \"preserve_order\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"preserve_order\")))]\n    #[inline]\n    pub fn shift_remove_entry(self) -> (String, Value) {\n        self.occupied.shift_remove_entry()\n    }\n}"
        ],
        "map::VacantEntry": [
            "impl<'a> VacantEntry<'a> {\n    /// Gets a reference to the key that would be used when inserting a value\n    /// through the VacantEntry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Vacant(vacant) => {\n    ///         assert_eq!(vacant.key(), &\"serde\");\n    ///     }\n    ///     Entry::Occupied(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn key(&self) -> &String {\n        self.vacant.key()\n    }\n\n    /// Sets the value of the entry with the VacantEntry's key, and returns a\n    /// mutable reference to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Vacant(vacant) => {\n    ///         vacant.insert(json!(\"hoho\"));\n    ///     }\n    ///     Entry::Occupied(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn insert(self, value: Value) -> &'a mut Value {\n        self.vacant.insert(value)\n    }\n}"
        ],
        "map::Values": [
            "impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }",
            "impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }",
            "impl $($generics)* FusedIterator for $name $($generics)* {}",
            "impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"
        ],
        "map::ValuesMut": [
            "impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }",
            "impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }",
            "impl $($generics)* FusedIterator for $name $($generics)* {}",
            "impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"
        ],
        "number::N": [
            "Clone",
            "Copy",
            "impl Eq for N {}",
            "impl Hash for N {\n    fn hash<H: Hasher>(&self, h: &mut H) {\n        match *self {\n            N::PosInt(i) => i.hash(h),\n            N::NegInt(i) => i.hash(h),\n            N::Float(f) => {\n                if f == 0.0f64 {\n                    // There are 2 zero representations, +0 and -0, which\n                    // compare equal but have different bits. We use the +0 hash\n                    // for both so that hash(+0) == hash(-0).\n                    0.0f64.to_bits().hash(h);\n                } else {\n                    f.to_bits().hash(h);\n                }\n            }\n        }\n    }\n}",
            "impl PartialEq for N {\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (N::PosInt(a), N::PosInt(b)) => a == b,\n            (N::NegInt(a), N::NegInt(b)) => a == b,\n            (N::Float(a), N::Float(b)) => a == b,\n            _ => false,\n        }\n    }\n}"
        ],
        "number::Number": [
            "Clone",
            "Eq",
            "Hash",
            "PartialEq",
            "impl Debug for Number {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        write!(formatter, \"Number({})\", self)\n    }\n}",
            "impl Display for Number {\n    #[cfg(not(feature = \"arbitrary_precision\"))]\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match self.n {\n            N::PosInt(u) => formatter.write_str(itoa::Buffer::new().format(u)),\n            N::NegInt(i) => formatter.write_str(itoa::Buffer::new().format(i)),\n            N::Float(f) => formatter.write_str(ryu::Buffer::new().format_finite(f)),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&self.n, formatter)\n    }\n}",
            "impl From<$ty> for Number {\n                fn from(i: $ty) -> Self {\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }\n            }",
            "impl From<$ty> for Number {\n                fn from(u: $ty) -> Self {\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }\n            }",
            "impl From<ParserNumber> for Number {\n    fn from(value: ParserNumber) -> Self {\n        let n = match value {\n            ParserNumber::F64(f) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    ryu::Buffer::new().format_finite(f).to_owned()\n                }\n            }\n            ParserNumber::U64(u) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::PosInt(u)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    itoa::Buffer::new().format(u).to_owned()\n                }\n            }\n            ParserNumber::I64(i) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::NegInt(i)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    itoa::Buffer::new().format(i).to_owned()\n                }\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(s) => s,\n        };\n        Number { n }\n    }\n}",
            "impl FromStr for Number {\n    type Err = Error;\n\n    fn from_str(s: &str) -> result::Result<Self, Self::Err> {\n        Deserializer::from_str(s)\n            .parse_any_signed_number()\n            .map(Into::into)\n    }\n}",
            "impl Number {\n    #[cfg(not(feature = \"arbitrary_precision\"))]\n    #[cold]\n    pub(crate) fn unexpected(&self) -> Unexpected {\n        match self.n {\n            N::PosInt(u) => Unexpected::Unsigned(u),\n            N::NegInt(i) => Unexpected::Signed(i),\n            N::Float(f) => Unexpected::Float(f),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    #[cold]\n    pub(crate) fn unexpected(&self) -> Unexpected {\n        Unexpected::Other(\"number\")\n    }\n}",
            "impl Number {\n    /// Returns true if the `Number` is an integer between `i64::MIN` and\n    /// `i64::MAX`.\n    ///\n    /// For any Number on which `is_i64` returns true, `as_i64` is guaranteed to\n    /// return the integer value.\n    pub fn is_i64(&self) -> bool {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(v) => v <= i64::MAX as u64,\n            N::NegInt(_) => true,\n            N::Float(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.as_i64().is_some()\n    }\n\n    /// Returns true if the `Number` is an integer between zero and `u64::MAX`.\n    ///\n    /// For any Number on which `is_u64` returns true, `as_u64` is guaranteed to\n    /// return the integer value.\n    pub fn is_u64(&self) -> bool {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(_) => true,\n            N::NegInt(_) | N::Float(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.as_u64().is_some()\n    }\n\n    /// Returns true if the `Number` can be represented by f64.\n    ///\n    /// For any Number on which `is_f64` returns true, `as_f64` is guaranteed to\n    /// return the floating point value.\n    ///\n    /// Currently this function returns true if and only if both `is_i64` and\n    /// `is_u64` return false but this is not a guarantee in the future.\n    pub fn is_f64(&self) -> bool {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::Float(_) => true,\n            N::PosInt(_) | N::NegInt(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            for c in self.n.chars() {\n                if c == '.' || c == 'e' || c == 'E' {\n                    return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);\n                }\n            }\n            false\n        }\n    }\n\n    /// If the `Number` is an integer, represent it as i64 if possible. Returns\n    /// None otherwise.\n    pub fn as_i64(&self) -> Option<i64> {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => {\n                if n <= i64::MAX as u64 {\n                    Some(n as i64)\n                } else {\n                    None\n                }\n            }\n            N::NegInt(n) => Some(n),\n            N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }\n\n    /// If the `Number` is an integer, represent it as u64 if possible. Returns\n    /// None otherwise.\n    pub fn as_u64(&self) -> Option<u64> {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n),\n            N::NegInt(_) | N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }\n\n    /// Represents the number as f64 if possible. Returns None otherwise.\n    pub fn as_f64(&self) -> Option<f64> {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as f64),\n            N::NegInt(n) => Some(n as f64),\n            N::Float(n) => Some(n),\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse::<f64>().ok().filter(|float| float.is_finite())\n    }\n\n    /// Converts a finite `f64` to a `Number`. Infinite or NaN values are not JSON\n    /// numbers.\n    ///\n    /// ```\n    /// # use serde_json::Number;\n    /// #\n    /// assert!(Number::from_f64(256.0).is_some());\n    ///\n    /// assert!(Number::from_f64(f64::NAN).is_none());\n    /// ```\n    pub fn from_f64(f: f64) -> Option<Number> {\n        if f.is_finite() {\n            let n = {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    ryu::Buffer::new().format_finite(f).to_owned()\n                }\n            };\n            Some(Number { n })\n        } else {\n            None\n        }\n    }\n\n    /// If the `Number` is an integer, represent it as i128 if possible. Returns\n    /// None otherwise.\n    pub fn as_i128(&self) -> Option<i128> {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as i128),\n            N::NegInt(n) => Some(n as i128),\n            N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }\n\n    /// If the `Number` is an integer, represent it as u128 if possible. Returns\n    /// None otherwise.\n    pub fn as_u128(&self) -> Option<u128> {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as u128),\n            N::NegInt(_) | N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }\n\n    /// Converts an `i128` to a `Number`. Numbers smaller than i64::MIN or\n    /// larger than u64::MAX can only be represented in `Number` if serde_json's\n    /// \"arbitrary_precision\" feature is enabled.\n    ///\n    /// ```\n    /// # use serde_json::Number;\n    /// #\n    /// assert!(Number::from_i128(256).is_some());\n    /// ```\n    pub fn from_i128(i: i128) -> Option<Number> {\n        let n = {\n            #[cfg(not(feature = \"arbitrary_precision\"))]\n            {\n                if let Ok(u) = u64::try_from(i) {\n                    N::PosInt(u)\n                } else if let Ok(i) = i64::try_from(i) {\n                    N::NegInt(i)\n                } else {\n                    return None;\n                }\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            {\n                i.to_string()\n            }\n        };\n        Some(Number { n })\n    }\n\n    /// Converts a `u128` to a `Number`. Numbers greater than u64::MAX can only\n    /// be represented in `Number` if serde_json's \"arbitrary_precision\" feature\n    /// is enabled.\n    ///\n    /// ```\n    /// # use serde_json::Number;\n    /// #\n    /// assert!(Number::from_u128(256).is_some());\n    /// ```\n    pub fn from_u128(i: u128) -> Option<Number> {\n        let n = {\n            #[cfg(not(feature = \"arbitrary_precision\"))]\n            {\n                if let Ok(u) = u64::try_from(i) {\n                    N::PosInt(u)\n                } else {\n                    return None;\n                }\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            {\n                i.to_string()\n            }\n        };\n        Some(Number { n })\n    }\n\n    /// Returns the exact original JSON representation that this Number was\n    /// parsed from.\n    ///\n    /// For numbers constructed not via parsing, such as by `From<i32>`, returns\n    /// the JSON representation that serde\\_json would serialize for this\n    /// number.\n    ///\n    /// ```\n    /// # use serde_json::Number;\n    /// for value in [\n    ///     \"7\",\n    ///     \"12.34\",\n    ///     \"34e-56789\",\n    ///     \"0.0123456789000000012345678900000001234567890000123456789\",\n    ///     \"343412345678910111213141516171819202122232425262728293034\",\n    ///     \"-343412345678910111213141516171819202122232425262728293031\",\n    /// ] {\n    ///     let number: Number = serde_json::from_str(value).unwrap();\n    ///     assert_eq!(number.as_str(), value);\n    /// }\n    /// ```\n    #[cfg(feature = \"arbitrary_precision\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"arbitrary_precision\")))]\n    pub fn as_str(&self) -> &str {\n        &self.n\n    }\n\n    pub(crate) fn as_f32(&self) -> Option<f32> {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as f32),\n            N::NegInt(n) => Some(n as f32),\n            N::Float(n) => Some(n as f32),\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse::<f32>().ok().filter(|float| float.is_finite())\n    }\n\n    pub(crate) fn from_f32(f: f32) -> Option<Number> {\n        if f.is_finite() {\n            let n = {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f as f64)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    ryu::Buffer::new().format_finite(f).to_owned()\n                }\n            };\n            Some(Number { n })\n        } else {\n            None\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    /// Not public API. Only tests use this.\n    #[doc(hidden)]\n    #[inline]\n    pub fn from_string_unchecked(n: String) -> Self {\n        Number { n }\n    }\n}",
            "impl Serialize for Number {\n    #[cfg(not(feature = \"arbitrary_precision\"))]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self.n {\n            N::PosInt(u) => serializer.serialize_u64(u),\n            N::NegInt(i) => serializer.serialize_i64(i),\n            N::Float(f) => serializer.serialize_f64(f),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeStruct;\n\n        let mut s = tri!(serializer.serialize_struct(TOKEN, 1));\n        tri!(s.serialize_field(TOKEN, &self.n));\n        s.end()\n    }\n}",
            "impl<'de> Deserialize<'de> for Number {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Number, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct NumberVisitor;\n\n        impl<'de> Visitor<'de> for NumberVisitor {\n            type Value = Number;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a JSON number\")\n            }\n\n            fn visit_i64<E>(self, value: i64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            fn visit_i128<E>(self, value: i128) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_i128(value)\n                    .ok_or_else(|| de::Error::custom(\"JSON number out of range\"))\n            }\n\n            fn visit_u64<E>(self, value: u64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            fn visit_u128<E>(self, value: u128) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_u128(value)\n                    .ok_or_else(|| de::Error::custom(\"JSON number out of range\"))\n            }\n\n            fn visit_f64<E>(self, value: f64) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_f64(value).ok_or_else(|| de::Error::custom(\"not a JSON number\"))\n            }\n\n            #[cfg(feature = \"arbitrary_precision\")]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Number, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let value = tri!(visitor.next_key::<NumberKey>());\n                if value.is_none() {\n                    return Err(de::Error::invalid_type(Unexpected::Map, &self));\n                }\n                let v: NumberFromString = tri!(visitor.next_value());\n                Ok(v.value)\n            }\n        }\n\n        deserializer.deserialize_any(NumberVisitor)\n    }\n}",
            "impl<'de> Deserializer<'de> for Number {\n    type Error = Error;\n\n    deserialize_any!(owned);\n\n    deserialize_number!(deserialize_i8 => visit_i8);\n    deserialize_number!(deserialize_i16 => visit_i16);\n    deserialize_number!(deserialize_i32 => visit_i32);\n    deserialize_number!(deserialize_i64 => visit_i64);\n    deserialize_number!(deserialize_i128 => visit_i128);\n    deserialize_number!(deserialize_u8 => visit_u8);\n    deserialize_number!(deserialize_u16 => visit_u16);\n    deserialize_number!(deserialize_u32 => visit_u32);\n    deserialize_number!(deserialize_u64 => visit_u64);\n    deserialize_number!(deserialize_u128 => visit_u128);\n    deserialize_number!(deserialize_f32 => visit_f32);\n    deserialize_number!(deserialize_f64 => visit_f64);\n\n    forward_to_deserialize_any! {\n        bool char str string bytes byte_buf option unit unit_struct\n        newtype_struct seq tuple tuple_struct map struct enum identifier\n        ignored_any\n    }\n}"
        ],
        "read::IoRead": [
            "impl<'de, R> Read<'de> for IoRead<R>\nwhere\n    R: io::Read,\n{\n    #[inline]\n    fn next(&mut self) -> Result<Option<u8>> {\n        match self.ch.take() {\n            Some(ch) => {\n                #[cfg(feature = \"raw_value\")]\n                {\n                    if let Some(buf) = &mut self.raw_buffer {\n                        buf.push(ch);\n                    }\n                }\n                Ok(Some(ch))\n            }\n            None => match self.iter.next() {\n                Some(Err(err)) => Err(Error::io(err)),\n                Some(Ok(ch)) => {\n                    #[cfg(feature = \"raw_value\")]\n                    {\n                        if let Some(buf) = &mut self.raw_buffer {\n                            buf.push(ch);\n                        }\n                    }\n                    Ok(Some(ch))\n                }\n                None => Ok(None),\n            },\n        }\n    }\n\n    #[inline]\n    fn peek(&mut self) -> Result<Option<u8>> {\n        match self.ch {\n            Some(ch) => Ok(Some(ch)),\n            None => match self.iter.next() {\n                Some(Err(err)) => Err(Error::io(err)),\n                Some(Ok(ch)) => {\n                    self.ch = Some(ch);\n                    Ok(self.ch)\n                }\n                None => Ok(None),\n            },\n        }\n    }\n\n    #[cfg(not(feature = \"raw_value\"))]\n    #[inline]\n    fn discard(&mut self) {\n        self.ch = None;\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn discard(&mut self) {\n        if let Some(ch) = self.ch.take() {\n            if let Some(buf) = &mut self.raw_buffer {\n                buf.push(ch);\n            }\n        }\n    }\n\n    fn position(&self) -> Position {\n        Position {\n            line: self.iter.line(),\n            column: self.iter.col(),\n        }\n    }\n\n    fn peek_position(&self) -> Position {\n        // The LineColIterator updates its position during peek() so it has the\n        // right one here.\n        self.position()\n    }\n\n    fn byte_offset(&self) -> usize {\n        match self.ch {\n            Some(_) => self.iter.byte_offset() - 1,\n            None => self.iter.byte_offset(),\n        }\n    }\n\n    fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> {\n        self.parse_str_bytes(scratch, true, as_str)\n            .map(Reference::Copied)\n    }\n\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>> {\n        self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))\n            .map(Reference::Copied)\n    }\n\n    fn ignore_str(&mut self) -> Result<()> {\n        loop {\n            let ch = tri!(next_or_eof(self));\n            if !is_escape(ch, true) {\n                continue;\n            }\n            match ch {\n                b'\"' => {\n                    return Ok(());\n                }\n                b'\\\\' => {\n                    tri!(ignore_escape(self));\n                }\n                _ => {\n                    return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                }\n            }\n        }\n    }\n\n    fn decode_hex_escape(&mut self) -> Result<u16> {\n        let a = tri!(next_or_eof(self));\n        let b = tri!(next_or_eof(self));\n        let c = tri!(next_or_eof(self));\n        let d = tri!(next_or_eof(self));\n        match decode_four_hex_digits(a, b, c, d) {\n            Some(val) => Ok(val),\n            None => error(self, ErrorCode::InvalidEscape),\n        }\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn begin_raw_buffering(&mut self) {\n        self.raw_buffer = Some(Vec::new());\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'de>,\n    {\n        let raw = self.raw_buffer.take().unwrap();\n        let raw = match String::from_utf8(raw) {\n            Ok(raw) => raw,\n            Err(_) => return error(self, ErrorCode::InvalidUnicodeCodePoint),\n        };\n        visitor.visit_map(OwnedRawDeserializer {\n            raw_value: Some(raw),\n        })\n    }\n\n    const should_early_return_if_failed: bool = true;\n\n    #[inline]\n    #[cold]\n    fn set_failed(&mut self, failed: &mut bool) {\n        *failed = true;\n    }\n}",
            "impl<R> IoRead<R>\nwhere\n    R: io::Read,\n{\n    /// Create a JSON input source to read from a std::io input stream.\n    ///\n    /// When reading from a source against which short reads are not efficient, such\n    /// as a [`File`], you will want to apply your own buffering because serde_json\n    /// will not buffer the input. See [`std::io::BufReader`].\n    ///\n    /// [`File`]: std::fs::File\n    pub fn new(reader: R) -> Self {\n        IoRead {\n            iter: LineColIterator::new(reader.bytes()),\n            ch: None,\n            #[cfg(feature = \"raw_value\")]\n            raw_buffer: None,\n        }\n    }\n}",
            "impl<R> IoRead<R>\nwhere\n    R: io::Read,\n{\n    fn parse_str_bytes<'s, T, F>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n        validate: bool,\n        result: F,\n    ) -> Result<T>\n    where\n        T: 's,\n        F: FnOnce(&'s Self, &'s [u8]) -> Result<T>,\n    {\n        loop {\n            let ch = tri!(next_or_eof(self));\n            if !is_escape(ch, true) {\n                scratch.push(ch);\n                continue;\n            }\n            match ch {\n                b'\"' => {\n                    return result(self, scratch);\n                }\n                b'\\\\' => {\n                    tri!(parse_escape(self, validate, scratch));\n                }\n                _ => {\n                    if validate {\n                        return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                    }\n                    scratch.push(ch);\n                }\n            }\n        }\n    }\n}",
            "impl<R> private::Sealed for IoRead<R> where R: io::Read {}"
        ],
        "read::Reference": [
            "impl<'b, 'c, T> Deref for Reference<'b, 'c, T>\nwhere\n    T: ?Sized + 'static,\n{\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        match *self {\n            Reference::Borrowed(b) => b,\n            Reference::Copied(c) => c,\n        }\n    }\n}"
        ],
        "read::SliceRead": [
            "impl<'a> Fused for SliceRead<'a> {}",
            "impl<'a> Read<'a> for SliceRead<'a> {\n    #[inline]\n    fn next(&mut self) -> Result<Option<u8>> {\n        // `Ok(self.slice.get(self.index).map(|ch| { self.index += 1; *ch }))`\n        // is about 10% slower.\n        Ok(if self.index < self.slice.len() {\n            let ch = self.slice[self.index];\n            self.index += 1;\n            Some(ch)\n        } else {\n            None\n        })\n    }\n\n    #[inline]\n    fn peek(&mut self) -> Result<Option<u8>> {\n        // `Ok(self.slice.get(self.index).map(|ch| *ch))` is about 10% slower\n        // for some reason.\n        Ok(if self.index < self.slice.len() {\n            Some(self.slice[self.index])\n        } else {\n            None\n        })\n    }\n\n    #[inline]\n    fn discard(&mut self) {\n        self.index += 1;\n    }\n\n    fn position(&self) -> Position {\n        self.position_of_index(self.index)\n    }\n\n    fn peek_position(&self) -> Position {\n        // Cap it at slice.len() just in case the most recent call was next()\n        // and it returned the last byte.\n        self.position_of_index(cmp::min(self.slice.len(), self.index + 1))\n    }\n\n    fn byte_offset(&self) -> usize {\n        self.index\n    }\n\n    fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> {\n        self.parse_str_bytes(scratch, true, as_str)\n    }\n\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'a, 's, [u8]>> {\n        self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))\n    }\n\n    fn ignore_str(&mut self) -> Result<()> {\n        loop {\n            self.skip_to_escape(true);\n            if self.index == self.slice.len() {\n                return error(self, ErrorCode::EofWhileParsingString);\n            }\n            match self.slice[self.index] {\n                b'\"' => {\n                    self.index += 1;\n                    return Ok(());\n                }\n                b'\\\\' => {\n                    self.index += 1;\n                    tri!(ignore_escape(self));\n                }\n                _ => {\n                    return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn decode_hex_escape(&mut self) -> Result<u16> {\n        match self.slice[self.index..] {\n            [a, b, c, d, ..] => {\n                self.index += 4;\n                match decode_four_hex_digits(a, b, c, d) {\n                    Some(val) => Ok(val),\n                    None => error(self, ErrorCode::InvalidEscape),\n                }\n            }\n            _ => {\n                self.index = self.slice.len();\n                error(self, ErrorCode::EofWhileParsingString)\n            }\n        }\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn begin_raw_buffering(&mut self) {\n        self.raw_buffering_start_index = self.index;\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'a>,\n    {\n        let raw = &self.slice[self.raw_buffering_start_index..self.index];\n        let raw = match str::from_utf8(raw) {\n            Ok(raw) => raw,\n            Err(_) => return error(self, ErrorCode::InvalidUnicodeCodePoint),\n        };\n        visitor.visit_map(BorrowedRawDeserializer {\n            raw_value: Some(raw),\n        })\n    }\n\n    const should_early_return_if_failed: bool = false;\n\n    #[inline]\n    #[cold]\n    fn set_failed(&mut self, _failed: &mut bool) {\n        self.slice = &self.slice[..self.index];\n    }\n}",
            "impl<'a> SliceRead<'a> {\n    /// Create a JSON input source to read from a slice of bytes.\n    pub fn new(slice: &'a [u8]) -> Self {\n        SliceRead {\n            slice,\n            index: 0,\n            #[cfg(feature = \"raw_value\")]\n            raw_buffering_start_index: 0,\n        }\n    }\n\n    fn position_of_index(&self, i: usize) -> Position {\n        let start_of_line = match memchr::memrchr(b'\\n', &self.slice[..i]) {\n            Some(position) => position + 1,\n            None => 0,\n        };\n        Position {\n            line: 1 + memchr::memchr_iter(b'\\n', &self.slice[..start_of_line]).count(),\n            column: i - start_of_line,\n        }\n    }\n\n    fn skip_to_escape(&mut self, forbid_control_characters: bool) {\n        // Immediately bail-out on empty strings and consecutive escapes (e.g. \\u041b\\u0435)\n        if self.index == self.slice.len()\n            || is_escape(self.slice[self.index], forbid_control_characters)\n        {\n            return;\n        }\n        self.index += 1;\n\n        let rest = &self.slice[self.index..];\n\n        if !forbid_control_characters {\n            self.index += memchr::memchr2(b'\"', b'\\\\', rest).unwrap_or(rest.len());\n            return;\n        }\n\n        // We wish to find the first byte in range 0x00..=0x1F or \" or \\. Ideally, we'd use\n        // something akin to memchr3, but the memchr crate does not support this at the moment.\n        // Therefore, we use a variation on Mycroft's algorithm [1] to provide performance better\n        // than a naive loop. It runs faster than equivalent two-pass memchr2+SWAR code on\n        // benchmarks and it's cross-platform, so probably the right fit.\n        // [1]: https://groups.google.com/forum/#!original/comp.lang.c/2HtQXvg7iKc/xOJeipH6KLMJ\n\n        #[cfg(fast_arithmetic = \"64\")]\n        type Chunk = u64;\n        #[cfg(fast_arithmetic = \"32\")]\n        type Chunk = u32;\n\n        const STEP: usize = mem::size_of::<Chunk>();\n        const ONE_BYTES: Chunk = Chunk::MAX / 255; // 0x0101...01\n\n        for chunk in rest.chunks_exact(STEP) {\n            let chars = Chunk::from_le_bytes(chunk.try_into().unwrap());\n            let contains_ctrl = chars.wrapping_sub(ONE_BYTES * 0x20) & !chars;\n            let chars_quote = chars ^ (ONE_BYTES * Chunk::from(b'\"'));\n            let contains_quote = chars_quote.wrapping_sub(ONE_BYTES) & !chars_quote;\n            let chars_backslash = chars ^ (ONE_BYTES * Chunk::from(b'\\\\'));\n            let contains_backslash = chars_backslash.wrapping_sub(ONE_BYTES) & !chars_backslash;\n            let masked = (contains_ctrl | contains_quote | contains_backslash) & (ONE_BYTES << 7);\n            if masked != 0 {\n                // SAFETY: chunk is in-bounds for slice\n                self.index = unsafe { chunk.as_ptr().offset_from(self.slice.as_ptr()) } as usize\n                    + masked.trailing_zeros() as usize / 8;\n                return;\n            }\n        }\n\n        self.index += rest.len() / STEP * STEP;\n        self.skip_to_escape_slow();\n    }\n\n    #[cold]\n    #[inline(never)]\n    fn skip_to_escape_slow(&mut self) {\n        while self.index < self.slice.len() && !is_escape(self.slice[self.index], true) {\n            self.index += 1;\n        }\n    }\n\n    /// The big optimization here over IoRead is that if the string contains no\n    /// backslash escape sequences, the returned &str is a slice of the raw JSON\n    /// data so we avoid copying into the scratch space.\n    fn parse_str_bytes<'s, T, F>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n        validate: bool,\n        result: F,\n    ) -> Result<Reference<'a, 's, T>>\n    where\n        T: ?Sized + 's,\n        F: for<'f> FnOnce(&'s Self, &'f [u8]) -> Result<&'f T>,\n    {\n        // Index of the first byte not yet copied into the scratch space.\n        let mut start = self.index;\n\n        loop {\n            self.skip_to_escape(validate);\n            if self.index == self.slice.len() {\n                return error(self, ErrorCode::EofWhileParsingString);\n            }\n            match self.slice[self.index] {\n                b'\"' => {\n                    if scratch.is_empty() {\n                        // Fast path: return a slice of the raw JSON without any\n                        // copying.\n                        let borrowed = &self.slice[start..self.index];\n                        self.index += 1;\n                        return result(self, borrowed).map(Reference::Borrowed);\n                    } else {\n                        scratch.extend_from_slice(&self.slice[start..self.index]);\n                        self.index += 1;\n                        return result(self, scratch).map(Reference::Copied);\n                    }\n                }\n                b'\\\\' => {\n                    scratch.extend_from_slice(&self.slice[start..self.index]);\n                    self.index += 1;\n                    tri!(parse_escape(self, validate, scratch));\n                    start = self.index;\n                }\n                _ => {\n                    self.index += 1;\n                    return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                }\n            }\n        }\n    }\n}",
            "impl<'a> private::Sealed for SliceRead<'a> {}"
        ],
        "read::StrRead": [
            "impl<'a> Fused for StrRead<'a> {}",
            "impl<'a> Read<'a> for StrRead<'a> {\n    #[inline]\n    fn next(&mut self) -> Result<Option<u8>> {\n        self.delegate.next()\n    }\n\n    #[inline]\n    fn peek(&mut self) -> Result<Option<u8>> {\n        self.delegate.peek()\n    }\n\n    #[inline]\n    fn discard(&mut self) {\n        self.delegate.discard();\n    }\n\n    fn position(&self) -> Position {\n        self.delegate.position()\n    }\n\n    fn peek_position(&self) -> Position {\n        self.delegate.peek_position()\n    }\n\n    fn byte_offset(&self) -> usize {\n        self.delegate.byte_offset()\n    }\n\n    fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> {\n        self.delegate.parse_str_bytes(scratch, true, |_, bytes| {\n            // The deserialization input came in as &str with a UTF-8 guarantee,\n            // and the \\u-escapes are checked along the way, so don't need to\n            // check here.\n            Ok(unsafe { str::from_utf8_unchecked(bytes) })\n        })\n    }\n\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'a, 's, [u8]>> {\n        self.delegate.parse_str_raw(scratch)\n    }\n\n    fn ignore_str(&mut self) -> Result<()> {\n        self.delegate.ignore_str()\n    }\n\n    fn decode_hex_escape(&mut self) -> Result<u16> {\n        self.delegate.decode_hex_escape()\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn begin_raw_buffering(&mut self) {\n        self.delegate.begin_raw_buffering();\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'a>,\n    {\n        let raw = &self.data[self.delegate.raw_buffering_start_index..self.delegate.index];\n        visitor.visit_map(BorrowedRawDeserializer {\n            raw_value: Some(raw),\n        })\n    }\n\n    const should_early_return_if_failed: bool = false;\n\n    #[inline]\n    #[cold]\n    fn set_failed(&mut self, failed: &mut bool) {\n        self.delegate.set_failed(failed);\n    }\n}",
            "impl<'a> StrRead<'a> {\n    /// Create a JSON input source to read from a UTF-8 string.\n    pub fn new(s: &'a str) -> Self {\n        StrRead {\n            delegate: SliceRead::new(s.as_bytes()),\n            #[cfg(feature = \"raw_value\")]\n            data: s,\n        }\n    }\n}",
            "impl<'a> private::Sealed for StrRead<'a> {}"
        ],
        "ser::CharEscape": [
            "impl CharEscape {\n    #[inline]\n    fn from_escape_table(escape: u8, byte: u8) -> CharEscape {\n        match escape {\n            self::BB => CharEscape::Backspace,\n            self::TT => CharEscape::Tab,\n            self::NN => CharEscape::LineFeed,\n            self::FF => CharEscape::FormFeed,\n            self::RR => CharEscape::CarriageReturn,\n            self::QU => CharEscape::Quote,\n            self::BS => CharEscape::ReverseSolidus,\n            self::UU => CharEscape::AsciiControl(byte),\n            _ => unreachable!(),\n        }\n    }\n}"
        ],
        "ser::CompactFormatter": [
            "Clone",
            "Debug",
            "impl Formatter for CompactFormatter {}"
        ],
        "ser::Compound": [
            "impl<'a, W, F> ser::SerializeMap for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_key<T>(&mut self, key: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            Compound::Map { ser, state } => {\n                tri!(ser\n                    .formatter\n                    .begin_object_key(&mut ser.writer, *state == State::First)\n                    .map_err(Error::io));\n                *state = State::Rest;\n\n                tri!(key.serialize(MapKeySerializer { ser: *ser }));\n\n                ser.formatter\n                    .end_object_key(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    #[inline]\n    fn serialize_value<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            Compound::Map { ser, .. } => {\n                tri!(ser\n                    .formatter\n                    .begin_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                tri!(value.serialize(&mut **ser));\n                ser.formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        match self {\n            Compound::Map { ser, state } => match state {\n                State::Empty => Ok(()),\n                _ => ser.formatter.end_object(&mut ser.writer).map_err(Error::io),\n            },\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n}",
            "impl<'a, W, F> ser::SerializeSeq for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            Compound::Map { ser, state } => {\n                tri!(ser\n                    .formatter\n                    .begin_array_value(&mut ser.writer, *state == State::First)\n                    .map_err(Error::io));\n                *state = State::Rest;\n                tri!(value.serialize(&mut **ser));\n                ser.formatter\n                    .end_array_value(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        match self {\n            Compound::Map { ser, state } => match state {\n                State::Empty => Ok(()),\n                _ => ser.formatter.end_array(&mut ser.writer).map_err(Error::io),\n            },\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n}",
            "impl<'a, W, F> ser::SerializeStruct for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            Compound::Map { .. } => ser::SerializeMap::serialize_entry(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { ser, .. } => {\n                if key == crate::number::TOKEN {\n                    value.serialize(NumberStrEmitter(ser))\n                } else {\n                    Err(invalid_number())\n                }\n            }\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { ser, .. } => {\n                if key == crate::raw::TOKEN {\n                    value.serialize(RawValueStrEmitter(ser))\n                } else {\n                    Err(invalid_raw_value())\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        match self {\n            Compound::Map { .. } => ser::SerializeMap::end(self),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => Ok(()),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => Ok(()),\n        }\n    }\n}",
            "impl<'a, W, F> ser::SerializeStructVariant for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match *self {\n            Compound::Map { .. } => ser::SerializeStruct::serialize_field(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        match self {\n            Compound::Map { ser, state } => {\n                match state {\n                    State::Empty => {}\n                    _ => tri!(ser.formatter.end_object(&mut ser.writer).map_err(Error::io)),\n                }\n                tri!(ser\n                    .formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                ser.formatter.end_object(&mut ser.writer).map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n}",
            "impl<'a, W, F> ser::SerializeTuple for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        ser::SerializeSeq::end(self)\n    }\n}",
            "impl<'a, W, F> ser::SerializeTupleStruct for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        ser::SerializeSeq::end(self)\n    }\n}",
            "impl<'a, W, F> ser::SerializeTupleVariant for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        match self {\n            Compound::Map { ser, state } => {\n                match state {\n                    State::Empty => {}\n                    _ => tri!(ser.formatter.end_array(&mut ser.writer).map_err(Error::io)),\n                }\n                tri!(ser\n                    .formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                ser.formatter.end_object(&mut ser.writer).map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n}"
        ],
        "ser::MapKeySerializer": [
            "impl<'a, W, F> ser::Serializer for MapKeySerializer<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_str(self, value: &str) -> Result<()> {\n        self.ser.serialize_str(value)\n    }\n\n    #[inline]\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<()> {\n        self.ser.serialize_str(variant)\n    }\n\n    #[inline]\n    fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        value.serialize(self)\n    }\n\n    type SerializeSeq = Impossible<(), Error>;\n    type SerializeTuple = Impossible<(), Error>;\n    type SerializeTupleStruct = Impossible<(), Error>;\n    type SerializeTupleVariant = Impossible<(), Error>;\n    type SerializeMap = Impossible<(), Error>;\n    type SerializeStruct = Impossible<(), Error>;\n    type SerializeStructVariant = Impossible<(), Error>;\n\n    fn serialize_bool(self, value: bool) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_bool(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_i8(self, value: i8) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i8(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_i16(self, value: i16) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i16(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_i32(self, value: i32) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i32(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_i64(self, value: i64) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i64(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_i128(self, value: i128) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i128(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_u8(self, value: u8) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u8(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_u16(self, value: u16) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u16(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_u32(self, value: u32) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u32(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_u64(self, value: u64) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u64(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_u128(self, value: u128) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u128(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_f32(self, value: f32) -> Result<()> {\n        if !value.is_finite() {\n            return Err(float_key_must_be_finite());\n        }\n\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_f32(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_f64(self, value: f64) -> Result<()> {\n        if !value.is_finite() {\n            return Err(float_key_must_be_finite());\n        }\n\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_f64(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_char(self, value: char) -> Result<()> {\n        self.ser.serialize_str(value.encode_utf8(&mut [0u8; 4]))\n    }\n\n    fn serialize_bytes(self, _value: &[u8]) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_unit(self) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_none(self) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_some<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant> {\n        Err(key_must_be_a_string())\n    }\n\n    fn collect_str<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Display,\n    {\n        self.ser.collect_str(value)\n    }\n}"
        ],
        "ser::PrettyFormatter": [
            "Clone",
            "Debug",
            "impl<'a> Default for PrettyFormatter<'a> {\n    fn default() -> Self {\n        PrettyFormatter::new()\n    }\n}",
            "impl<'a> Formatter for PrettyFormatter<'a> {\n    #[inline]\n    fn begin_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.current_indent += 1;\n        self.has_value = false;\n        writer.write_all(b\"[\")\n    }\n\n    #[inline]\n    fn end_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.current_indent -= 1;\n\n        if self.has_value {\n            tri!(writer.write_all(b\"\\n\"));\n            tri!(indent(writer, self.current_indent, self.indent));\n        }\n\n        writer.write_all(b\"]\")\n    }\n\n    #[inline]\n    fn begin_array_value<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        tri!(writer.write_all(if first { b\"\\n\" } else { b\",\\n\" }));\n        indent(writer, self.current_indent, self.indent)\n    }\n\n    #[inline]\n    fn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.has_value = true;\n        Ok(())\n    }\n\n    #[inline]\n    fn begin_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.current_indent += 1;\n        self.has_value = false;\n        writer.write_all(b\"{\")\n    }\n\n    #[inline]\n    fn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.current_indent -= 1;\n\n        if self.has_value {\n            tri!(writer.write_all(b\"\\n\"));\n            tri!(indent(writer, self.current_indent, self.indent));\n        }\n\n        writer.write_all(b\"}\")\n    }\n\n    #[inline]\n    fn begin_object_key<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        tri!(writer.write_all(if first { b\"\\n\" } else { b\",\\n\" }));\n        indent(writer, self.current_indent, self.indent)\n    }\n\n    #[inline]\n    fn begin_object_value<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\": \")\n    }\n\n    #[inline]\n    fn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.has_value = true;\n        Ok(())\n    }\n}",
            "impl<'a> PrettyFormatter<'a> {\n    /// Construct a pretty printer formatter that defaults to using two spaces for indentation.\n    pub fn new() -> Self {\n        PrettyFormatter::with_indent(b\"  \")\n    }\n\n    /// Construct a pretty printer formatter that uses the `indent` string for indentation.\n    pub fn with_indent(indent: &'a [u8]) -> Self {\n        PrettyFormatter {\n            current_indent: 0,\n            has_value: false,\n            indent,\n        }\n    }\n}"
        ],
        "ser::Serializer": [
            "impl<'a, W> Serializer<W, PrettyFormatter<'a>>\nwhere\n    W: io::Write,\n{\n    /// Creates a new JSON pretty print serializer.\n    #[inline]\n    pub fn pretty(writer: W) -> Self {\n        Serializer::with_formatter(writer, PrettyFormatter::new())\n    }\n}",
            "impl<W, F> Serializer<W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    /// Creates a new JSON visitor whose output will be written to the writer\n    /// specified.\n    #[inline]\n    pub fn with_formatter(writer: W, formatter: F) -> Self {\n        Serializer { writer, formatter }\n    }\n\n    /// Unwrap the `Writer` from the `Serializer`.\n    #[inline]\n    pub fn into_inner(self) -> W {\n        self.writer\n    }\n}",
            "impl<W> Serializer<W>\nwhere\n    W: io::Write,\n{\n    /// Creates a new JSON serializer.\n    #[inline]\n    pub fn new(writer: W) -> Self {\n        Serializer::with_formatter(writer, CompactFormatter)\n    }\n}"
        ],
        "ser::State": [
            "Eq",
            "PartialEq"
        ],
        "std::io::Error": [
            "impl From<Error> for io::Error {\n    /// Convert a `serde_json::Error` into an `io::Error`.\n    ///\n    /// JSON syntax and data errors are turned into `InvalidData` I/O errors.\n    /// EOF errors are turned into `UnexpectedEof` I/O errors.\n    ///\n    /// ```\n    /// use std::io;\n    ///\n    /// enum MyError {\n    ///     Io(io::Error),\n    ///     Json(serde_json::Error),\n    /// }\n    ///\n    /// impl From<serde_json::Error> for MyError {\n    ///     fn from(err: serde_json::Error) -> MyError {\n    ///         use serde_json::error::Category;\n    ///         match err.classify() {\n    ///             Category::Io => {\n    ///                 MyError::Io(err.into())\n    ///             }\n    ///             Category::Syntax | Category::Data | Category::Eof => {\n    ///                 MyError::Json(err)\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn from(j: Error) -> Self {\n        if let ErrorCode::Io(err) = j.err.code {\n            err\n        } else {\n            match j.classify() {\n                Category::Io => unreachable!(),\n                Category::Syntax | Category::Data => io::Error::new(ErrorKind::InvalidData, j),\n                Category::Eof => io::Error::new(ErrorKind::UnexpectedEof, j),\n            }\n        }\n    }\n}"
        ],
        "value::Value": [
            "Clone",
            "Eq",
            "Hash",
            "PartialEq",
            "impl Debug for Value {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Value::Null => formatter.write_str(\"Null\"),\n            Value::Bool(boolean) => write!(formatter, \"Bool({})\", boolean),\n            Value::Number(number) => Debug::fmt(number, formatter),\n            Value::String(string) => write!(formatter, \"String({:?})\", string),\n            Value::Array(vec) => {\n                tri!(formatter.write_str(\"Array \"));\n                Debug::fmt(vec, formatter)\n            }\n            Value::Object(map) => {\n                tri!(formatter.write_str(\"Object \"));\n                Debug::fmt(map, formatter)\n            }\n        }\n    }\n}",
            "impl Default for Value {\n    fn default() -> Value {\n        Value::Null\n    }\n}",
            "impl Display for Value {\n    /// Display a JSON value as a string.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let json = json!({ \"city\": \"London\", \"street\": \"10 Downing Street\" });\n    ///\n    /// // Compact format:\n    /// //\n    /// // {\"city\":\"London\",\"street\":\"10 Downing Street\"}\n    /// let compact = format!(\"{}\", json);\n    /// assert_eq!(compact,\n    ///     \"{\\\"city\\\":\\\"London\\\",\\\"street\\\":\\\"10 Downing Street\\\"}\");\n    ///\n    /// // Pretty format:\n    /// //\n    /// // {\n    /// //   \"city\": \"London\",\n    /// //   \"street\": \"10 Downing Street\"\n    /// // }\n    /// let pretty = format!(\"{:#}\", json);\n    /// assert_eq!(pretty,\n    ///     \"{\\n  \\\"city\\\": \\\"London\\\",\\n  \\\"street\\\": \\\"10 Downing Street\\\"\\n}\");\n    /// ```\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        struct WriterFormatter<'a, 'b: 'a> {\n            inner: &'a mut fmt::Formatter<'b>,\n        }\n\n        impl<'a, 'b> io::Write for WriterFormatter<'a, 'b> {\n            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n                // Safety: the serializer below only emits valid utf8 when using\n                // the default formatter.\n                let s = unsafe { str::from_utf8_unchecked(buf) };\n                tri!(self.inner.write_str(s).map_err(io_error));\n                Ok(buf.len())\n            }\n\n            fn flush(&mut self) -> io::Result<()> {\n                Ok(())\n            }\n        }\n\n        fn io_error(_: fmt::Error) -> io::Error {\n            // Error value does not matter because Display impl just maps it\n            // back to fmt::Error.\n            io::Error::new(io::ErrorKind::Other, \"fmt error\")\n        }\n\n        let alternate = f.alternate();\n        let mut wr = WriterFormatter { inner: f };\n        if alternate {\n            // {:#}\n            super::ser::to_writer_pretty(&mut wr, self).map_err(|_| fmt::Error)\n        } else {\n            // {}\n            super::ser::to_writer(&mut wr, self).map_err(|_| fmt::Error)\n        }\n    }\n}",
            "impl From<$ty> for Value {\n                fn from(n: $ty) -> Self {\n                    Value::Number(n.into())\n                }\n            }",
            "impl From<&str> for Value {\n    /// Convert string slice to `Value::String`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let s: &str = \"lorem\";\n    /// let x: Value = s.into();\n    /// ```\n    fn from(f: &str) -> Self {\n        Value::String(f.to_owned())\n    }\n}",
            "impl From<()> for Value {\n    /// Convert `()` to `Value::Null`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let u = ();\n    /// let x: Value = u.into();\n    /// ```\n    fn from((): ()) -> Self {\n        Value::Null\n    }\n}",
            "impl From<Map<String, Value>> for Value {\n    /// Convert map (with string keys) to `Value::Object`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::{Map, Value};\n    ///\n    /// let mut m = Map::new();\n    /// m.insert(\"Lorem\".to_owned(), \"ipsum\".into());\n    /// let x: Value = m.into();\n    /// ```\n    fn from(f: Map<String, Value>) -> Self {\n        Value::Object(f)\n    }\n}",
            "impl From<Number> for Value {\n    /// Convert `Number` to `Value::Number`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::{Number, Value};\n    ///\n    /// let n = Number::from(7);\n    /// let x: Value = n.into();\n    /// ```\n    fn from(f: Number) -> Self {\n        Value::Number(f)\n    }\n}",
            "impl From<String> for Value {\n    /// Convert `String` to `Value::String`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let s: String = \"lorem\".to_owned();\n    /// let x: Value = s.into();\n    /// ```\n    fn from(f: String) -> Self {\n        Value::String(f)\n    }\n}",
            "impl From<bool> for Value {\n    /// Convert boolean to `Value::Bool`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let b = false;\n    /// let x: Value = b.into();\n    /// ```\n    fn from(f: bool) -> Self {\n        Value::Bool(f)\n    }\n}",
            "impl From<f32> for Value {\n    /// Convert 32-bit floating point number to `Value::Number`, or\n    /// `Value::Null` if infinite or NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let f: f32 = 13.37;\n    /// let x: Value = f.into();\n    /// ```\n    fn from(f: f32) -> Self {\n        Number::from_f32(f).map_or(Value::Null, Value::Number)\n    }\n}",
            "impl From<f64> for Value {\n    /// Convert 64-bit floating point number to `Value::Number`, or\n    /// `Value::Null` if infinite or NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let f: f64 = 13.37;\n    /// let x: Value = f.into();\n    /// ```\n    fn from(f: f64) -> Self {\n        Number::from_f64(f).map_or(Value::Null, Value::Number)\n    }\n}",
            "impl FromStr for Value {\n    type Err = Error;\n    fn from_str(s: &str) -> Result<Value, Error> {\n        super::super::de::from_str(s)\n    }\n}",
            "impl PartialEq<$ty> for Value {\n                fn eq(&self, other: &$ty) -> bool {\n                    $eq(self, *other as _)\n                }\n            }",
            "impl PartialEq<&str> for Value {\n    fn eq(&self, other: &&str) -> bool {\n        eq_str(self, *other)\n    }\n}",
            "impl PartialEq<String> for Value {\n    fn eq(&self, other: &String) -> bool {\n        eq_str(self, other.as_str())\n    }\n}",
            "impl PartialEq<str> for Value {\n    fn eq(&self, other: &str) -> bool {\n        eq_str(self, other)\n    }\n}",
            "impl Serialize for Value {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> result::Result<S::Ok, S::Error>\n    where\n        S: ::serde::Serializer,\n    {\n        match self {\n            Value::Null => serializer.serialize_unit(),\n            Value::Bool(b) => serializer.serialize_bool(*b),\n            Value::Number(n) => n.serialize(serializer),\n            Value::String(s) => serializer.serialize_str(s),\n            Value::Array(v) => v.serialize(serializer),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::Object(m) => {\n                use serde::ser::SerializeMap;\n                let mut map = tri!(serializer.serialize_map(Some(m.len())));\n                for (k, v) in m {\n                    tri!(map.serialize_entry(k, v));\n                }\n                map.end()\n            }\n            #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n            Value::Object(_) => unreachable!(),\n        }\n    }\n}",
            "impl Value {\n    #[cold]\n    fn invalid_type<E>(&self, exp: &dyn Expected) -> E\n    where\n        E: serde::de::Error,\n    {\n        serde::de::Error::invalid_type(self.unexpected(), exp)\n    }\n\n    #[cold]\n    fn unexpected(&self) -> Unexpected {\n        match self {\n            Value::Null => Unexpected::Unit,\n            Value::Bool(b) => Unexpected::Bool(*b),\n            Value::Number(n) => n.unexpected(),\n            Value::String(s) => Unexpected::Str(s),\n            Value::Array(_) => Unexpected::Seq,\n            Value::Object(_) => Unexpected::Map,\n        }\n    }\n}",
            "impl Value {\n    /// Index into a JSON array or map. A string index can be used to access a\n    /// value in a map, and a usize index can be used to access an element of an\n    /// array.\n    ///\n    /// Returns `None` if the type of `self` does not match the type of the\n    /// index, for example if the index is a string and `self` is an array or a\n    /// number. Also returns `None` if the given key does not exist in the map\n    /// or the given index is not within the bounds of the array.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let object = json!({ \"A\": 65, \"B\": 66, \"C\": 67 });\n    /// assert_eq!(*object.get(\"A\").unwrap(), json!(65));\n    ///\n    /// let array = json!([ \"A\", \"B\", \"C\" ]);\n    /// assert_eq!(*array.get(2).unwrap(), json!(\"C\"));\n    ///\n    /// assert_eq!(array.get(\"A\"), None);\n    /// ```\n    ///\n    /// Square brackets can also be used to index into a value in a more concise\n    /// way. This returns `Value::Null` in cases where `get` would have returned\n    /// `None`.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let object = json!({\n    ///     \"A\": [\"a\", \"\", \"\"],\n    ///     \"B\": [\"b\", \"b\"],\n    ///     \"C\": [\"c\", \"\", \"\", \"\"],\n    /// });\n    /// assert_eq!(object[\"B\"][0], json!(\"b\"));\n    ///\n    /// assert_eq!(object[\"D\"], json!(null));\n    /// assert_eq!(object[0][\"x\"][\"y\"][\"z\"], json!(null));\n    /// ```\n    pub fn get<I: Index>(&self, index: I) -> Option<&Value> {\n        index.index_into(self)\n    }\n\n    /// Mutably index into a JSON array or map. A string index can be used to\n    /// access a value in a map, and a usize index can be used to access an\n    /// element of an array.\n    ///\n    /// Returns `None` if the type of `self` does not match the type of the\n    /// index, for example if the index is a string and `self` is an array or a\n    /// number. Also returns `None` if the given key does not exist in the map\n    /// or the given index is not within the bounds of the array.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut object = json!({ \"A\": 65, \"B\": 66, \"C\": 67 });\n    /// *object.get_mut(\"A\").unwrap() = json!(69);\n    ///\n    /// let mut array = json!([ \"A\", \"B\", \"C\" ]);\n    /// *array.get_mut(2).unwrap() = json!(\"D\");\n    /// ```\n    pub fn get_mut<I: Index>(&mut self, index: I) -> Option<&mut Value> {\n        index.index_into_mut(self)\n    }\n\n    /// Returns true if the `Value` is an Object. Returns false otherwise.\n    ///\n    /// For any Value on which `is_object` returns true, `as_object` and\n    /// `as_object_mut` are guaranteed to return the map representation of the\n    /// object.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let obj = json!({ \"a\": { \"nested\": true }, \"b\": [\"an\", \"array\"] });\n    ///\n    /// assert!(obj.is_object());\n    /// assert!(obj[\"a\"].is_object());\n    ///\n    /// // array, not an object\n    /// assert!(!obj[\"b\"].is_object());\n    /// ```\n    pub fn is_object(&self) -> bool {\n        self.as_object().is_some()\n    }\n\n    /// If the `Value` is an Object, returns the associated Map. Returns None\n    /// otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": { \"nested\": true }, \"b\": [\"an\", \"array\"] });\n    ///\n    /// // The length of `{\"nested\": true}` is 1 entry.\n    /// assert_eq!(v[\"a\"].as_object().unwrap().len(), 1);\n    ///\n    /// // The array `[\"an\", \"array\"]` is not an object.\n    /// assert_eq!(v[\"b\"].as_object(), None);\n    /// ```\n    pub fn as_object(&self) -> Option<&Map<String, Value>> {\n        match self {\n            Value::Object(map) => Some(map),\n            _ => None,\n        }\n    }\n\n    /// If the `Value` is an Object, returns the associated mutable Map.\n    /// Returns None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut v = json!({ \"a\": { \"nested\": true } });\n    ///\n    /// v[\"a\"].as_object_mut().unwrap().clear();\n    /// assert_eq!(v, json!({ \"a\": {} }));\n    /// ```\n    pub fn as_object_mut(&mut self) -> Option<&mut Map<String, Value>> {\n        match self {\n            Value::Object(map) => Some(map),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is an Array. Returns false otherwise.\n    ///\n    /// For any Value on which `is_array` returns true, `as_array` and\n    /// `as_array_mut` are guaranteed to return the vector representing the\n    /// array.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let obj = json!({ \"a\": [\"an\", \"array\"], \"b\": { \"an\": \"object\" } });\n    ///\n    /// assert!(obj[\"a\"].is_array());\n    ///\n    /// // an object, not an array\n    /// assert!(!obj[\"b\"].is_array());\n    /// ```\n    pub fn is_array(&self) -> bool {\n        self.as_array().is_some()\n    }\n\n    /// If the `Value` is an Array, returns the associated vector. Returns None\n    /// otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": [\"an\", \"array\"], \"b\": { \"an\": \"object\" } });\n    ///\n    /// // The length of `[\"an\", \"array\"]` is 2 elements.\n    /// assert_eq!(v[\"a\"].as_array().unwrap().len(), 2);\n    ///\n    /// // The object `{\"an\": \"object\"}` is not an array.\n    /// assert_eq!(v[\"b\"].as_array(), None);\n    /// ```\n    pub fn as_array(&self) -> Option<&Vec<Value>> {\n        match self {\n            Value::Array(array) => Some(array),\n            _ => None,\n        }\n    }\n\n    /// If the `Value` is an Array, returns the associated mutable vector.\n    /// Returns None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut v = json!({ \"a\": [\"an\", \"array\"] });\n    ///\n    /// v[\"a\"].as_array_mut().unwrap().clear();\n    /// assert_eq!(v, json!({ \"a\": [] }));\n    /// ```\n    pub fn as_array_mut(&mut self) -> Option<&mut Vec<Value>> {\n        match self {\n            Value::Array(list) => Some(list),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is a String. Returns false otherwise.\n    ///\n    /// For any Value on which `is_string` returns true, `as_str` is guaranteed\n    /// to return the string slice.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": \"some string\", \"b\": false });\n    ///\n    /// assert!(v[\"a\"].is_string());\n    ///\n    /// // The boolean `false` is not a string.\n    /// assert!(!v[\"b\"].is_string());\n    /// ```\n    pub fn is_string(&self) -> bool {\n        self.as_str().is_some()\n    }\n\n    /// If the `Value` is a String, returns the associated str. Returns None\n    /// otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": \"some string\", \"b\": false });\n    ///\n    /// assert_eq!(v[\"a\"].as_str(), Some(\"some string\"));\n    ///\n    /// // The boolean `false` is not a string.\n    /// assert_eq!(v[\"b\"].as_str(), None);\n    ///\n    /// // JSON values are printed in JSON representation, so strings are in quotes.\n    /// //\n    /// //    The value is: \"some string\"\n    /// println!(\"The value is: {}\", v[\"a\"]);\n    ///\n    /// // Rust strings are printed without quotes.\n    /// //\n    /// //    The value is: some string\n    /// println!(\"The value is: {}\", v[\"a\"].as_str().unwrap());\n    /// ```\n    pub fn as_str(&self) -> Option<&str> {\n        match self {\n            Value::String(s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is a Number. Returns false otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 1, \"b\": \"2\" });\n    ///\n    /// assert!(v[\"a\"].is_number());\n    ///\n    /// // The string `\"2\"` is a string, not a number.\n    /// assert!(!v[\"b\"].is_number());\n    /// ```\n    pub fn is_number(&self) -> bool {\n        match *self {\n            Value::Number(_) => true,\n            _ => false,\n        }\n    }\n\n    /// If the `Value` is a Number, returns the associated [`Number`]. Returns\n    /// None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::{json, Number};\n    /// #\n    /// let v = json!({ \"a\": 1, \"b\": 2.2, \"c\": -3, \"d\": \"4\" });\n    ///\n    /// assert_eq!(v[\"a\"].as_number(), Some(&Number::from(1u64)));\n    /// assert_eq!(v[\"b\"].as_number(), Some(&Number::from_f64(2.2).unwrap()));\n    /// assert_eq!(v[\"c\"].as_number(), Some(&Number::from(-3i64)));\n    ///\n    /// // The string `\"4\"` is not a number.\n    /// assert_eq!(v[\"d\"].as_number(), None);\n    /// ```\n    pub fn as_number(&self) -> Option<&Number> {\n        match self {\n            Value::Number(number) => Some(number),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is an integer between `i64::MIN` and\n    /// `i64::MAX`.\n    ///\n    /// For any Value on which `is_i64` returns true, `as_i64` is guaranteed to\n    /// return the integer value.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let big = i64::max_value() as u64 + 10;\n    /// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n    ///\n    /// assert!(v[\"a\"].is_i64());\n    ///\n    /// // Greater than i64::MAX.\n    /// assert!(!v[\"b\"].is_i64());\n    ///\n    /// // Numbers with a decimal point are not considered integers.\n    /// assert!(!v[\"c\"].is_i64());\n    /// ```\n    pub fn is_i64(&self) -> bool {\n        match self {\n            Value::Number(n) => n.is_i64(),\n            _ => false,\n        }\n    }\n\n    /// Returns true if the `Value` is an integer between zero and `u64::MAX`.\n    ///\n    /// For any Value on which `is_u64` returns true, `as_u64` is guaranteed to\n    /// return the integer value.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n    ///\n    /// assert!(v[\"a\"].is_u64());\n    ///\n    /// // Negative integer.\n    /// assert!(!v[\"b\"].is_u64());\n    ///\n    /// // Numbers with a decimal point are not considered integers.\n    /// assert!(!v[\"c\"].is_u64());\n    /// ```\n    pub fn is_u64(&self) -> bool {\n        match self {\n            Value::Number(n) => n.is_u64(),\n            _ => false,\n        }\n    }\n\n    /// Returns true if the `Value` is a number that can be represented by f64.\n    ///\n    /// For any Value on which `is_f64` returns true, `as_f64` is guaranteed to\n    /// return the floating point value.\n    ///\n    /// Currently this function returns true if and only if both `is_i64` and\n    /// `is_u64` return false but this is not a guarantee in the future.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n    ///\n    /// assert!(v[\"a\"].is_f64());\n    ///\n    /// // Integers.\n    /// assert!(!v[\"b\"].is_f64());\n    /// assert!(!v[\"c\"].is_f64());\n    /// ```\n    pub fn is_f64(&self) -> bool {\n        match self {\n            Value::Number(n) => n.is_f64(),\n            _ => false,\n        }\n    }\n\n    /// If the `Value` is an integer, represent it as i64 if possible. Returns\n    /// None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let big = i64::max_value() as u64 + 10;\n    /// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n    ///\n    /// assert_eq!(v[\"a\"].as_i64(), Some(64));\n    /// assert_eq!(v[\"b\"].as_i64(), None);\n    /// assert_eq!(v[\"c\"].as_i64(), None);\n    /// ```\n    pub fn as_i64(&self) -> Option<i64> {\n        match self {\n            Value::Number(n) => n.as_i64(),\n            _ => None,\n        }\n    }\n\n    /// If the `Value` is an integer, represent it as u64 if possible. Returns\n    /// None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n    ///\n    /// assert_eq!(v[\"a\"].as_u64(), Some(64));\n    /// assert_eq!(v[\"b\"].as_u64(), None);\n    /// assert_eq!(v[\"c\"].as_u64(), None);\n    /// ```\n    pub fn as_u64(&self) -> Option<u64> {\n        match self {\n            Value::Number(n) => n.as_u64(),\n            _ => None,\n        }\n    }\n\n    /// If the `Value` is a number, represent it as f64 if possible. Returns\n    /// None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n    ///\n    /// assert_eq!(v[\"a\"].as_f64(), Some(256.0));\n    /// assert_eq!(v[\"b\"].as_f64(), Some(64.0));\n    /// assert_eq!(v[\"c\"].as_f64(), Some(-64.0));\n    /// ```\n    pub fn as_f64(&self) -> Option<f64> {\n        match self {\n            Value::Number(n) => n.as_f64(),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is a Boolean. Returns false otherwise.\n    ///\n    /// For any Value on which `is_boolean` returns true, `as_bool` is\n    /// guaranteed to return the boolean value.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": false, \"b\": \"false\" });\n    ///\n    /// assert!(v[\"a\"].is_boolean());\n    ///\n    /// // The string `\"false\"` is a string, not a boolean.\n    /// assert!(!v[\"b\"].is_boolean());\n    /// ```\n    pub fn is_boolean(&self) -> bool {\n        self.as_bool().is_some()\n    }\n\n    /// If the `Value` is a Boolean, returns the associated bool. Returns None\n    /// otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": false, \"b\": \"false\" });\n    ///\n    /// assert_eq!(v[\"a\"].as_bool(), Some(false));\n    ///\n    /// // The string `\"false\"` is a string, not a boolean.\n    /// assert_eq!(v[\"b\"].as_bool(), None);\n    /// ```\n    pub fn as_bool(&self) -> Option<bool> {\n        match *self {\n            Value::Bool(b) => Some(b),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is a Null. Returns false otherwise.\n    ///\n    /// For any Value on which `is_null` returns true, `as_null` is guaranteed\n    /// to return `Some(())`.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": null, \"b\": false });\n    ///\n    /// assert!(v[\"a\"].is_null());\n    ///\n    /// // The boolean `false` is not null.\n    /// assert!(!v[\"b\"].is_null());\n    /// ```\n    pub fn is_null(&self) -> bool {\n        self.as_null().is_some()\n    }\n\n    /// If the `Value` is a Null, returns (). Returns None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": null, \"b\": false });\n    ///\n    /// assert_eq!(v[\"a\"].as_null(), Some(()));\n    ///\n    /// // The boolean `false` is not null.\n    /// assert_eq!(v[\"b\"].as_null(), None);\n    /// ```\n    pub fn as_null(&self) -> Option<()> {\n        match *self {\n            Value::Null => Some(()),\n            _ => None,\n        }\n    }\n\n    /// Looks up a value by a JSON Pointer.\n    ///\n    /// JSON Pointer defines a string syntax for identifying a specific value\n    /// within a JavaScript Object Notation (JSON) document.\n    ///\n    /// A Pointer is a Unicode string with the reference tokens separated by `/`.\n    /// Inside tokens `/` is replaced by `~1` and `~` is replaced by `~0`. The\n    /// addressed value is returned and if there is no such value `None` is\n    /// returned.\n    ///\n    /// For more information read [RFC6901](https://tools.ietf.org/html/rfc6901).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let data = json!({\n    ///     \"x\": {\n    ///         \"y\": [\"z\", \"zz\"]\n    ///     }\n    /// });\n    ///\n    /// assert_eq!(data.pointer(\"/x/y/1\").unwrap(), &json!(\"zz\"));\n    /// assert_eq!(data.pointer(\"/a/b/c\"), None);\n    /// ```\n    pub fn pointer(&self, pointer: &str) -> Option<&Value> {\n        if pointer.is_empty() {\n            return Some(self);\n        }\n        if !pointer.starts_with('/') {\n            return None;\n        }\n        pointer\n            .split('/')\n            .skip(1)\n            .map(|x| x.replace(\"~1\", \"/\").replace(\"~0\", \"~\"))\n            .try_fold(self, |target, token| match target {\n                Value::Object(map) => map.get(&token),\n                Value::Array(list) => parse_index(&token).and_then(|x| list.get(x)),\n                _ => None,\n            })\n    }\n\n    /// Looks up a value by a JSON Pointer and returns a mutable reference to\n    /// that value.\n    ///\n    /// JSON Pointer defines a string syntax for identifying a specific value\n    /// within a JavaScript Object Notation (JSON) document.\n    ///\n    /// A Pointer is a Unicode string with the reference tokens separated by `/`.\n    /// Inside tokens `/` is replaced by `~1` and `~` is replaced by `~0`. The\n    /// addressed value is returned and if there is no such value `None` is\n    /// returned.\n    ///\n    /// For more information read [RFC6901](https://tools.ietf.org/html/rfc6901).\n    ///\n    /// # Example of Use\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// fn main() {\n    ///     let s = r#\"{\"x\": 1.0, \"y\": 2.0}\"#;\n    ///     let mut value: Value = serde_json::from_str(s).unwrap();\n    ///\n    ///     // Check value using read-only pointer\n    ///     assert_eq!(value.pointer(\"/x\"), Some(&1.0.into()));\n    ///     // Change value with direct assignment\n    ///     *value.pointer_mut(\"/x\").unwrap() = 1.5.into();\n    ///     // Check that new value was written\n    ///     assert_eq!(value.pointer(\"/x\"), Some(&1.5.into()));\n    ///     // Or change the value only if it exists\n    ///     value.pointer_mut(\"/x\").map(|v| *v = 1.5.into());\n    ///\n    ///     // \"Steal\" ownership of a value. Can replace with any valid Value.\n    ///     let old_x = value.pointer_mut(\"/x\").map(Value::take).unwrap();\n    ///     assert_eq!(old_x, 1.5);\n    ///     assert_eq!(value.pointer(\"/x\").unwrap(), &Value::Null);\n    /// }\n    /// ```\n    pub fn pointer_mut(&mut self, pointer: &str) -> Option<&mut Value> {\n        if pointer.is_empty() {\n            return Some(self);\n        }\n        if !pointer.starts_with('/') {\n            return None;\n        }\n        pointer\n            .split('/')\n            .skip(1)\n            .map(|x| x.replace(\"~1\", \"/\").replace(\"~0\", \"~\"))\n            .try_fold(self, |target, token| match target {\n                Value::Object(map) => map.get_mut(&token),\n                Value::Array(list) => parse_index(&token).and_then(move |x| list.get_mut(x)),\n                _ => None,\n            })\n    }\n\n    /// Takes the value out of the `Value`, leaving a `Null` in its place.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut v = json!({ \"x\": \"y\" });\n    /// assert_eq!(v[\"x\"].take(), json!(\"y\"));\n    /// assert_eq!(v, json!({ \"x\": null }));\n    /// ```\n    pub fn take(&mut self) -> Value {\n        mem::replace(self, Value::Null)\n    }\n\n    /// Reorders the entries of all `Value::Object` nested within this JSON\n    /// value according to `str`'s usual ordering.\n    ///\n    /// If serde_json's \"preserve_order\" feature is not enabled, this method\n    /// does no work because all JSON maps are always kept in a sorted state.\n    ///\n    /// If serde_json's \"preserve_order\" feature is enabled, this method\n    /// destroys the original source order or insertion order of the JSON\n    /// objects in favor of an alphanumerical order that matches how a BTreeMap\n    /// with the same contents would be ordered.\n    pub fn sort_all_objects(&mut self) {\n        #[cfg(feature = \"preserve_order\")]\n        {\n            match self {\n                Value::Object(map) => {\n                    map.sort_keys();\n                    map.values_mut().for_each(Value::sort_all_objects);\n                }\n                Value::Array(list) => {\n                    list.iter_mut().for_each(Value::sort_all_objects);\n                }\n                _ => {}\n            }\n        }\n    }\n}",
            "impl<'a> From<Cow<'a, str>> for Value {\n    /// Convert copy-on-write string to `Value::String`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    /// use std::borrow::Cow;\n    ///\n    /// let s: Cow<str> = Cow::Borrowed(\"lorem\");\n    /// let x: Value = s.into();\n    /// ```\n    ///\n    /// ```\n    /// use serde_json::Value;\n    /// use std::borrow::Cow;\n    ///\n    /// let s: Cow<str> = Cow::Owned(\"lorem\".to_owned());\n    /// let x: Value = s.into();\n    /// ```\n    fn from(f: Cow<'a, str>) -> Self {\n        Value::String(f.into_owned())\n    }\n}",
            "impl<'de> Deserialize<'de> for Value {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Value, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        struct ValueVisitor;\n\n        impl<'de> Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"any valid JSON value\")\n            }\n\n            #[inline]\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E> {\n                Ok(Value::Bool(value))\n            }\n\n            #[inline]\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            fn visit_i128<E>(self, value: i128) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                let de = serde::de::value::I128Deserializer::new(value);\n                Number::deserialize(de).map(Value::Number)\n            }\n\n            #[inline]\n            fn visit_u64<E>(self, value: u64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            fn visit_u128<E>(self, value: u128) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                let de = serde::de::value::U128Deserializer::new(value);\n                Number::deserialize(de).map(Value::Number)\n            }\n\n            #[inline]\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E> {\n                Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_str<E>(self, value: &str) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_string(String::from(value))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_string<E>(self, value: String) -> Result<Value, E> {\n                Ok(Value::String(value))\n            }\n\n            #[inline]\n            fn visit_none<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: serde::Deserializer<'de>,\n            {\n                Deserialize::deserialize(deserializer)\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n\n                while let Some(elem) = tri!(visitor.next_element()) {\n                    vec.push(elem);\n                }\n\n                Ok(Value::Array(vec))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: MapAccess<'de>,\n            {\n                match tri!(visitor.next_key_seed(KeyClassifier)) {\n                    #[cfg(feature = \"arbitrary_precision\")]\n                    Some(KeyClass::Number) => {\n                        let number: NumberFromString = tri!(visitor.next_value());\n                        Ok(Value::Number(number.value))\n                    }\n                    #[cfg(feature = \"raw_value\")]\n                    Some(KeyClass::RawValue) => {\n                        let value = tri!(visitor.next_value_seed(crate::raw::BoxedFromString));\n                        crate::from_str(value.get()).map_err(de::Error::custom)\n                    }\n                    Some(KeyClass::Map(first_key)) => {\n                        let mut values = Map::new();\n\n                        values.insert(first_key, tri!(visitor.next_value()));\n                        while let Some((key, value)) = tri!(visitor.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(Value::Object(values))\n                    }\n                    None => Ok(Value::Object(Map::new())),\n                }\n            }\n        }\n\n        deserializer.deserialize_any(ValueVisitor)\n    }\n}",
            "impl<'de> IntoDeserializer<'de, Error> for Value {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }\n}",
            "impl<'de> serde::Deserializer<'de> for Value {\n    type Error = Error;\n\n    #[inline]\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Null => visitor.visit_unit(),\n            Value::Bool(v) => visitor.visit_bool(v),\n            Value::Number(n) => n.deserialize_any(visitor),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n            Value::String(_) => unreachable!(),\n            Value::Array(v) => visit_array(v, visitor),\n            Value::Object(v) => v.deserialize_any(visitor),\n        }\n    }\n\n    deserialize_number!(deserialize_i8);\n    deserialize_number!(deserialize_i16);\n    deserialize_number!(deserialize_i32);\n    deserialize_number!(deserialize_i64);\n    deserialize_number!(deserialize_i128);\n    deserialize_number!(deserialize_u8);\n    deserialize_number!(deserialize_u16);\n    deserialize_number!(deserialize_u32);\n    deserialize_number!(deserialize_u64);\n    deserialize_number!(deserialize_u128);\n    deserialize_number!(deserialize_f32);\n    deserialize_number!(deserialize_f64);\n\n    #[inline]\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Null => visitor.visit_none(),\n            _ => visitor.visit_some(self),\n        }\n    }\n\n    #[inline]\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Object(value) => value.deserialize_enum(name, variants, visitor),\n            Value::String(variant) => visitor.visit_enum(EnumDeserializer {\n                variant,\n                value: None,\n            }),\n            other => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"string or map\",\n            )),\n        }\n    }\n\n    #[inline]\n    fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return visitor.visit_map(crate::raw::OwnedRawDeserializer {\n                    raw_value: Some(self.to_string()),\n                });\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Bool(v) => visitor.visit_bool(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_string(visitor)\n    }\n\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_string(visitor)\n    }\n\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_byte_buf(visitor)\n    }\n\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            Value::Array(v) => visit_array(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Null => visitor.visit_unit(),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_unit(visitor)\n    }\n\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Array(v) => visit_array(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Object(v) => v.deserialize_any(visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Array(v) => visit_array(v, visitor),\n            Value::Object(v) => v.deserialize_any(visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_string(visitor)\n    }\n\n    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        drop(self);\n        visitor.visit_unit()\n    }\n}",
            "impl<I> ops::Index<I> for Value\nwhere\n    I: Index,\n{\n    type Output = Value;\n\n    /// Index into a `serde_json::Value` using the syntax `value[0]` or\n    /// `value[\"k\"]`.\n    ///\n    /// Returns `Value::Null` if the type of `self` does not match the type of\n    /// the index, for example if the index is a string and `self` is an array\n    /// or a number. Also returns `Value::Null` if the given key does not exist\n    /// in the map or the given index is not within the bounds of the array.\n    ///\n    /// For retrieving deeply nested values, you should have a look at the\n    /// `Value::pointer` method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let data = json!({\n    ///     \"x\": {\n    ///         \"y\": [\"z\", \"zz\"]\n    ///     }\n    /// });\n    ///\n    /// assert_eq!(data[\"x\"][\"y\"], json!([\"z\", \"zz\"]));\n    /// assert_eq!(data[\"x\"][\"y\"][0], json!(\"z\"));\n    ///\n    /// assert_eq!(data[\"a\"], json!(null)); // returns null for undefined values\n    /// assert_eq!(data[\"a\"][\"b\"], json!(null)); // does not panic\n    /// ```\n    fn index(&self, index: I) -> &Value {\n        static NULL: Value = Value::Null;\n        index.index_into(self).unwrap_or(&NULL)\n    }\n}",
            "impl<I> ops::IndexMut<I> for Value\nwhere\n    I: Index,\n{\n    /// Write into a `serde_json::Value` using the syntax `value[0] = ...` or\n    /// `value[\"k\"] = ...`.\n    ///\n    /// If the index is a number, the value must be an array of length bigger\n    /// than the index. Indexing into a value that is not an array or an array\n    /// that is too small will panic.\n    ///\n    /// If the index is a string, the value must be an object or null which is\n    /// treated like an empty object. If the key is not already present in the\n    /// object, it will be inserted with a value of null. Indexing into a value\n    /// that is neither an object nor null will panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut data = json!({ \"x\": 0 });\n    ///\n    /// // replace an existing key\n    /// data[\"x\"] = json!(1);\n    ///\n    /// // insert a new key\n    /// data[\"y\"] = json!([false, false, false]);\n    ///\n    /// // replace an array value\n    /// data[\"y\"][0] = json!(true);\n    ///\n    /// // inserted a deeply nested key\n    /// data[\"a\"][\"b\"][\"c\"][\"d\"] = json!(true);\n    ///\n    /// println!(\"{}\", data);\n    /// ```\n    fn index_mut(&mut self, index: I) -> &mut Value {\n        index.index_or_insert(self)\n    }\n}",
            "impl<K: Into<String>, V: Into<Value>> FromIterator<(K, V)> for Value {\n    /// Create a `Value::Object` by collecting an iterator of key-value pairs.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let v: Vec<_> = vec![(\"lorem\", 40), (\"ipsum\", 2)];\n    /// let x: Value = v.into_iter().collect();\n    /// ```\n    fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {\n        Value::Object(\n            iter.into_iter()\n                .map(|(k, v)| (k.into(), v.into()))\n                .collect(),\n        )\n    }\n}",
            "impl<T: Clone + Into<Value>> From<&[T]> for Value {\n    /// Convert a slice to `Value::Array`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let v: &[&str] = &[\"lorem\", \"ipsum\", \"dolor\"];\n    /// let x: Value = v.into();\n    /// ```\n    fn from(f: &[T]) -> Self {\n        Value::Array(f.iter().cloned().map(Into::into).collect())\n    }\n}",
            "impl<T: Into<Value>, const N: usize> From<[T; N]> for Value {\n    fn from(array: [T; N]) -> Self {\n        Value::Array(array.into_iter().map(Into::into).collect())\n    }\n}",
            "impl<T: Into<Value>> From<Vec<T>> for Value {\n    /// Convert a `Vec` to `Value::Array`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let v = vec![\"lorem\", \"ipsum\", \"dolor\"];\n    /// let x: Value = v.into();\n    /// ```\n    fn from(f: Vec<T>) -> Self {\n        Value::Array(f.into_iter().map(Into::into).collect())\n    }\n}",
            "impl<T: Into<Value>> FromIterator<T> for Value {\n    /// Create a `Value::Array` by collecting an iterator of array elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let v = std::iter::repeat(42).take(5);\n    /// let x: Value = v.collect();\n    /// ```\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let v: Vec<_> = vec![\"lorem\", \"ipsum\", \"dolor\"];\n    /// let x: Value = v.into_iter().collect();\n    /// ```\n    ///\n    /// ```\n    /// use std::iter::FromIterator;\n    /// use serde_json::Value;\n    ///\n    /// let x: Value = Value::from_iter(vec![\"lorem\", \"ipsum\", \"dolor\"]);\n    /// ```\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n        Value::Array(iter.into_iter().map(Into::into).collect())\n    }\n}",
            "impl<T> From<Option<T>> for Value\nwhere\n    T: Into<Value>,\n{\n    fn from(opt: Option<T>) -> Self {\n        match opt {\n            None => Value::Null,\n            Some(value) => Into::into(value),\n        }\n    }\n}"
        ],
        "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor": [
            "impl<'de> Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"any valid JSON value\")\n            }\n\n            #[inline]\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E> {\n                Ok(Value::Bool(value))\n            }\n\n            #[inline]\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            fn visit_i128<E>(self, value: i128) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                let de = serde::de::value::I128Deserializer::new(value);\n                Number::deserialize(de).map(Value::Number)\n            }\n\n            #[inline]\n            fn visit_u64<E>(self, value: u64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            fn visit_u128<E>(self, value: u128) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                let de = serde::de::value::U128Deserializer::new(value);\n                Number::deserialize(de).map(Value::Number)\n            }\n\n            #[inline]\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E> {\n                Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_str<E>(self, value: &str) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_string(String::from(value))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_string<E>(self, value: String) -> Result<Value, E> {\n                Ok(Value::String(value))\n            }\n\n            #[inline]\n            fn visit_none<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: serde::Deserializer<'de>,\n            {\n                Deserialize::deserialize(deserializer)\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n\n                while let Some(elem) = tri!(visitor.next_element()) {\n                    vec.push(elem);\n                }\n\n                Ok(Value::Array(vec))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: MapAccess<'de>,\n            {\n                match tri!(visitor.next_key_seed(KeyClassifier)) {\n                    #[cfg(feature = \"arbitrary_precision\")]\n                    Some(KeyClass::Number) => {\n                        let number: NumberFromString = tri!(visitor.next_value());\n                        Ok(Value::Number(number.value))\n                    }\n                    #[cfg(feature = \"raw_value\")]\n                    Some(KeyClass::RawValue) => {\n                        let value = tri!(visitor.next_value_seed(crate::raw::BoxedFromString));\n                        crate::from_str(value.get()).map_err(de::Error::custom)\n                    }\n                    Some(KeyClass::Map(first_key)) => {\n                        let mut values = Map::new();\n\n                        values.insert(first_key, tri!(visitor.next_value()));\n                        while let Some((key, value)) = tri!(visitor.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(Value::Object(values))\n                    }\n                    None => Ok(Value::Object(Map::new())),\n                }\n            }\n        }"
        ],
        "value::de::BorrowedCowStrDeserializer": [
            "impl<'de> BorrowedCowStrDeserializer<'de> {\n    fn new(value: Cow<'de, str>) -> Self {\n        BorrowedCowStrDeserializer { value }\n    }\n}",
            "impl<'de> de::Deserializer<'de> for BorrowedCowStrDeserializer<'de> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self.value {\n            Cow::Borrowed(string) => visitor.visit_borrowed_str(string),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Cow::Owned(string) => visitor.visit_string(string),\n            #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n            Cow::Owned(_) => unreachable!(),\n        }\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}",
            "impl<'de> de::EnumAccess<'de> for BorrowedCowStrDeserializer<'de> {\n    type Error = Error;\n    type Variant = UnitOnly;\n\n    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        let value = tri!(seed.deserialize(self));\n        Ok((value, UnitOnly))\n    }\n}"
        ],
        "value::de::EnumDeserializer": [
            "impl<'de> EnumAccess<'de> for EnumDeserializer {\n    type Error = Error;\n    type Variant = VariantDeserializer;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, VariantDeserializer), Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        let variant = self.variant.into_deserializer();\n        let visitor = VariantDeserializer { value: self.value };\n        seed.deserialize(variant).map(|v| (v, visitor))\n    }\n}"
        ],
        "value::de::EnumRefDeserializer": [
            "impl<'de> EnumAccess<'de> for EnumRefDeserializer<'de> {\n    type Error = Error;\n    type Variant = VariantRefDeserializer<'de>;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        let variant = self.variant.into_deserializer();\n        let visitor = VariantRefDeserializer { value: self.value };\n        seed.deserialize(variant).map(|v| (v, visitor))\n    }\n}"
        ],
        "value::de::KeyClassifier": [
            "impl<'de> DeserializeSeed<'de> for KeyClassifier {\n    type Value = KeyClass;\n\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        deserializer.deserialize_str(self)\n    }\n}",
            "impl<'de> Visitor<'de> for KeyClassifier {\n    type Value = KeyClass;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a string key\")\n    }\n\n    fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n        match s {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(KeyClass::Number),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(KeyClass::RawValue),\n            _ => Ok(KeyClass::Map(s.to_owned())),\n        }\n    }\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn visit_string<E>(self, s: String) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n        match s.as_str() {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(KeyClass::Number),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(KeyClass::RawValue),\n            _ => Ok(KeyClass::Map(s)),\n        }\n    }\n}"
        ],
        "value::de::MapDeserializer": [
            "impl MapDeserializer {\n    fn new(map: Map<String, Value>) -> Self {\n        MapDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }\n}",
            "impl<'de> MapAccess<'de> for MapDeserializer {\n    type Error = Error;\n\n    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some(value);\n                let key_de = MapKeyDeserializer {\n                    key: Cow::Owned(key),\n                };\n                seed.deserialize(key_de).map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.value.take() {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::custom(\"value is missing\")),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}"
        ],
        "value::de::MapKeyDeserializer": [
            "impl<'de> serde::Deserializer<'de> for MapKeyDeserializer<'de> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        BorrowedCowStrDeserializer::new(self.key).deserialize_any(visitor)\n    }\n\n    deserialize_numeric_key!(deserialize_i8);\n    deserialize_numeric_key!(deserialize_i16);\n    deserialize_numeric_key!(deserialize_i32);\n    deserialize_numeric_key!(deserialize_i64);\n    deserialize_numeric_key!(deserialize_u8);\n    deserialize_numeric_key!(deserialize_u16);\n    deserialize_numeric_key!(deserialize_u32);\n    deserialize_numeric_key!(deserialize_u64);\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    deserialize_numeric_key!(deserialize_f32);\n    deserialize_numeric_key!(deserialize_f64);\n\n    #[cfg(feature = \"float_roundtrip\")]\n    deserialize_numeric_key!(deserialize_f32, do_deserialize_f32);\n    deserialize_numeric_key!(deserialize_i128, do_deserialize_i128);\n    deserialize_numeric_key!(deserialize_u128, do_deserialize_u128);\n\n    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        if self.key == \"true\" {\n            visitor.visit_bool(true)\n        } else if self.key == \"false\" {\n            visitor.visit_bool(false)\n        } else {\n            Err(serde::de::Error::invalid_type(\n                Unexpected::Str(&self.key),\n                &visitor,\n            ))\n        }\n    }\n\n    #[inline]\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        // Map keys cannot be null.\n        visitor.visit_some(self)\n    }\n\n    #[inline]\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.key\n            .into_deserializer()\n            .deserialize_enum(name, variants, visitor)\n    }\n\n    forward_to_deserialize_any! {\n        char str string bytes byte_buf unit unit_struct seq tuple tuple_struct\n        map struct identifier ignored_any\n    }\n}"
        ],
        "value::de::MapRefDeserializer": [
            "impl<'de> MapAccess<'de> for MapRefDeserializer<'de> {\n    type Error = Error;\n\n    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some(value);\n                let key_de = MapKeyDeserializer {\n                    key: Cow::Borrowed(&**key),\n                };\n                seed.deserialize(key_de).map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.value.take() {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::custom(\"value is missing\")),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}",
            "impl<'de> MapRefDeserializer<'de> {\n    fn new(map: &'de Map<String, Value>) -> Self {\n        MapRefDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }\n}"
        ],
        "value::de::SeqDeserializer": [
            "impl SeqDeserializer {\n    fn new(vec: Vec<Value>) -> Self {\n        SeqDeserializer {\n            iter: vec.into_iter(),\n        }\n    }\n}",
            "impl<'de> SeqAccess<'de> for SeqDeserializer {\n    type Error = Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}"
        ],
        "value::de::SeqRefDeserializer": [
            "impl<'de> SeqAccess<'de> for SeqRefDeserializer<'de> {\n    type Error = Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}",
            "impl<'de> SeqRefDeserializer<'de> {\n    fn new(slice: &'de [Value]) -> Self {\n        SeqRefDeserializer { iter: slice.iter() }\n    }\n}"
        ],
        "value::de::UnitOnly": [
            "impl<'de> de::VariantAccess<'de> for UnitOnly {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Error> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"newtype variant\",\n        ))\n    }\n\n    fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"tuple variant\",\n        ))\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"struct variant\",\n        ))\n    }\n}"
        ],
        "value::de::VariantDeserializer": [
            "impl<'de> VariantAccess<'de> for VariantDeserializer {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Error> {\n        match self.value {\n            Some(value) => Deserialize::deserialize(value),\n            None => Ok(()),\n        }\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.value {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"newtype variant\",\n            )),\n        }\n    }\n\n    fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.value {\n            Some(Value::Array(v)) => {\n                if v.is_empty() {\n                    visitor.visit_unit()\n                } else {\n                    visit_array(v, visitor)\n                }\n            }\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"tuple variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"tuple variant\",\n            )),\n        }\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.value {\n            Some(Value::Object(v)) => v.deserialize_any(visitor),\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"struct variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"struct variant\",\n            )),\n        }\n    }\n}"
        ],
        "value::de::VariantRefDeserializer": [
            "impl<'de> VariantAccess<'de> for VariantRefDeserializer<'de> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Error> {\n        match self.value {\n            Some(value) => Deserialize::deserialize(value),\n            None => Ok(()),\n        }\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.value {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"newtype variant\",\n            )),\n        }\n    }\n\n    fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.value {\n            Some(Value::Array(v)) => {\n                if v.is_empty() {\n                    visitor.visit_unit()\n                } else {\n                    visit_array_ref(v, visitor)\n                }\n            }\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"tuple variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"tuple variant\",\n            )),\n        }\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.value {\n            Some(Value::Object(v)) => v.deserialize_any(visitor),\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"struct variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"struct variant\",\n            )),\n        }\n    }\n}"
        ],
        "value::index::Type": [
            "impl<'a> Display for Type<'a> {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match *self.0 {\n            Value::Null => formatter.write_str(\"null\"),\n            Value::Bool(_) => formatter.write_str(\"boolean\"),\n            Value::Number(_) => formatter.write_str(\"number\"),\n            Value::String(_) => formatter.write_str(\"string\"),\n            Value::Array(_) => formatter.write_str(\"array\"),\n            Value::Object(_) => formatter.write_str(\"object\"),\n        }\n    }\n}"
        ],
        "value::ser::MapKeySerializer": [
            "impl serde::Serializer for MapKeySerializer {\n    type Ok = String;\n    type Error = Error;\n\n    type SerializeSeq = Impossible<String, Error>;\n    type SerializeTuple = Impossible<String, Error>;\n    type SerializeTupleStruct = Impossible<String, Error>;\n    type SerializeTupleVariant = Impossible<String, Error>;\n    type SerializeMap = Impossible<String, Error>;\n    type SerializeStruct = Impossible<String, Error>;\n    type SerializeStructVariant = Impossible<String, Error>;\n\n    #[inline]\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<String> {\n        Ok(variant.to_owned())\n    }\n\n    #[inline]\n    fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<String>\n    where\n        T: ?Sized + Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_bool(self, value: bool) -> Result<String> {\n        Ok(if value { \"true\" } else { \"false\" }.to_owned())\n    }\n\n    fn serialize_i8(self, value: i8) -> Result<String> {\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }\n\n    fn serialize_i16(self, value: i16) -> Result<String> {\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }\n\n    fn serialize_i32(self, value: i32) -> Result<String> {\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }\n\n    fn serialize_i64(self, value: i64) -> Result<String> {\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }\n\n    fn serialize_i128(self, value: i128) -> Result<String> {\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }\n\n    fn serialize_u8(self, value: u8) -> Result<String> {\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }\n\n    fn serialize_u16(self, value: u16) -> Result<String> {\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }\n\n    fn serialize_u32(self, value: u32) -> Result<String> {\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }\n\n    fn serialize_u64(self, value: u64) -> Result<String> {\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }\n\n    fn serialize_u128(self, value: u128) -> Result<String> {\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }\n\n    fn serialize_f32(self, value: f32) -> Result<String> {\n        if value.is_finite() {\n            Ok(ryu::Buffer::new().format_finite(value).to_owned())\n        } else {\n            Err(float_key_must_be_finite())\n        }\n    }\n\n    fn serialize_f64(self, value: f64) -> Result<String> {\n        if value.is_finite() {\n            Ok(ryu::Buffer::new().format_finite(value).to_owned())\n        } else {\n            Err(float_key_must_be_finite())\n        }\n    }\n\n    #[inline]\n    fn serialize_char(self, value: char) -> Result<String> {\n        Ok({\n            let mut s = String::new();\n            s.push(value);\n            s\n        })\n    }\n\n    #[inline]\n    fn serialize_str(self, value: &str) -> Result<String> {\n        Ok(value.to_owned())\n    }\n\n    fn serialize_bytes(self, _value: &[u8]) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_unit(self) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<String>\n    where\n        T: ?Sized + Serialize,\n    {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_none(self) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_some<T>(self, _value: &T) -> Result<String>\n    where\n        T: ?Sized + Serialize,\n    {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant> {\n        Err(key_must_be_a_string())\n    }\n\n    fn collect_str<T>(self, value: &T) -> Result<String>\n    where\n        T: ?Sized + Display,\n    {\n        Ok(value.to_string())\n    }\n}"
        ],
        "value::ser::SerializeMap": [
            "impl serde::ser::SerializeMap for SerializeMap {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_key<T>(&mut self, key: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            SerializeMap::Map { next_key, .. } => {\n                *next_key = Some(tri!(key.serialize(MapKeySerializer)));\n                Ok(())\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    fn serialize_value<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            SerializeMap::Map { map, next_key } => {\n                let key = next_key.take();\n                // Panic because this indicates a bug in the program rather than an\n                // expected failure.\n                let key = key.expect(\"serialize_value called before serialize_key\");\n                map.insert(key, tri!(to_value(value)));\n                Ok(())\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    fn end(self) -> Result<Value> {\n        match self {\n            SerializeMap::Map { map, .. } => Ok(Value::Object(map)),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }\n}",
            "impl serde::ser::SerializeStruct for SerializeMap {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            SerializeMap::Map { .. } => serde::ser::SerializeMap::serialize_entry(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { out_value } => {\n                if key == crate::number::TOKEN {\n                    *out_value = Some(tri!(value.serialize(NumberValueEmitter)));\n                    Ok(())\n                } else {\n                    Err(invalid_number())\n                }\n            }\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { out_value } => {\n                if key == crate::raw::TOKEN {\n                    *out_value = Some(tri!(value.serialize(RawValueEmitter)));\n                    Ok(())\n                } else {\n                    Err(invalid_raw_value())\n                }\n            }\n        }\n    }\n\n    fn end(self) -> Result<Value> {\n        match self {\n            SerializeMap::Map { .. } => serde::ser::SerializeMap::end(self),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { out_value, .. } => {\n                Ok(out_value.expect(\"number value was not emitted\"))\n            }\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { out_value, .. } => {\n                Ok(out_value.expect(\"raw value was not emitted\"))\n            }\n        }\n    }\n}"
        ],
        "value::ser::SerializeStructVariant": [
            "impl serde::ser::SerializeStructVariant for SerializeStructVariant {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        self.map.insert(String::from(key), tri!(to_value(value)));\n        Ok(())\n    }\n\n    fn end(self) -> Result<Value> {\n        let mut object = Map::new();\n\n        object.insert(self.name, Value::Object(self.map));\n\n        Ok(Value::Object(object))\n    }\n}"
        ],
        "value::ser::SerializeTupleVariant": [
            "impl serde::ser::SerializeTupleVariant for SerializeTupleVariant {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        self.vec.push(tri!(to_value(value)));\n        Ok(())\n    }\n\n    fn end(self) -> Result<Value> {\n        let mut object = Map::new();\n\n        object.insert(self.name, Value::Array(self.vec));\n\n        Ok(Value::Object(object))\n    }\n}"
        ],
        "value::ser::SerializeVec": [
            "impl serde::ser::SerializeSeq for SerializeVec {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        self.vec.push(tri!(to_value(value)));\n        Ok(())\n    }\n\n    fn end(self) -> Result<Value> {\n        Ok(Value::Array(self.vec))\n    }\n}",
            "impl serde::ser::SerializeTuple for SerializeVec {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        serde::ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Value> {\n        serde::ser::SerializeSeq::end(self)\n    }\n}",
            "impl serde::ser::SerializeTupleStruct for SerializeVec {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        serde::ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Value> {\n        serde::ser::SerializeSeq::end(self)\n    }\n}"
        ],
        "value::ser::Serializer": [
            "impl serde::Serializer for Serializer {\n    type Ok = Value;\n    type Error = Error;\n\n    type SerializeSeq = SerializeVec;\n    type SerializeTuple = SerializeVec;\n    type SerializeTupleStruct = SerializeVec;\n    type SerializeTupleVariant = SerializeTupleVariant;\n    type SerializeMap = SerializeMap;\n    type SerializeStruct = SerializeMap;\n    type SerializeStructVariant = SerializeStructVariant;\n\n    #[inline]\n    fn serialize_bool(self, value: bool) -> Result<Value> {\n        Ok(Value::Bool(value))\n    }\n\n    #[inline]\n    fn serialize_i8(self, value: i8) -> Result<Value> {\n        self.serialize_i64(value as i64)\n    }\n\n    #[inline]\n    fn serialize_i16(self, value: i16) -> Result<Value> {\n        self.serialize_i64(value as i64)\n    }\n\n    #[inline]\n    fn serialize_i32(self, value: i32) -> Result<Value> {\n        self.serialize_i64(value as i64)\n    }\n\n    fn serialize_i64(self, value: i64) -> Result<Value> {\n        Ok(Value::Number(value.into()))\n    }\n\n    fn serialize_i128(self, value: i128) -> Result<Value> {\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            Ok(Value::Number(value.into()))\n        }\n\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        {\n            if let Ok(value) = u64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else if let Ok(value) = i64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else {\n                Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))\n            }\n        }\n    }\n\n    #[inline]\n    fn serialize_u8(self, value: u8) -> Result<Value> {\n        self.serialize_u64(value as u64)\n    }\n\n    #[inline]\n    fn serialize_u16(self, value: u16) -> Result<Value> {\n        self.serialize_u64(value as u64)\n    }\n\n    #[inline]\n    fn serialize_u32(self, value: u32) -> Result<Value> {\n        self.serialize_u64(value as u64)\n    }\n\n    #[inline]\n    fn serialize_u64(self, value: u64) -> Result<Value> {\n        Ok(Value::Number(value.into()))\n    }\n\n    fn serialize_u128(self, value: u128) -> Result<Value> {\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            Ok(Value::Number(value.into()))\n        }\n\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        {\n            if let Ok(value) = u64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else {\n                Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))\n            }\n        }\n    }\n\n    #[inline]\n    fn serialize_f32(self, float: f32) -> Result<Value> {\n        Ok(Value::from(float))\n    }\n\n    #[inline]\n    fn serialize_f64(self, float: f64) -> Result<Value> {\n        Ok(Value::from(float))\n    }\n\n    #[inline]\n    fn serialize_char(self, value: char) -> Result<Value> {\n        let mut s = String::new();\n        s.push(value);\n        Ok(Value::String(s))\n    }\n\n    #[inline]\n    fn serialize_str(self, value: &str) -> Result<Value> {\n        Ok(Value::String(value.to_owned()))\n    }\n\n    fn serialize_bytes(self, value: &[u8]) -> Result<Value> {\n        let vec = value.iter().map(|&b| Value::Number(b.into())).collect();\n        Ok(Value::Array(vec))\n    }\n\n    #[inline]\n    fn serialize_unit(self) -> Result<Value> {\n        Ok(Value::Null)\n    }\n\n    #[inline]\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<Value> {\n        self.serialize_unit()\n    }\n\n    #[inline]\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Value> {\n        self.serialize_str(variant)\n    }\n\n    #[inline]\n    fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Value>\n    where\n        T: ?Sized + Serialize,\n    {\n        let mut values = Map::new();\n        values.insert(String::from(variant), tri!(to_value(value)));\n        Ok(Value::Object(values))\n    }\n\n    #[inline]\n    fn serialize_none(self) -> Result<Value> {\n        self.serialize_unit()\n    }\n\n    #[inline]\n    fn serialize_some<T>(self, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq> {\n        Ok(SerializeVec {\n            vec: Vec::with_capacity(len.unwrap_or(0)),\n        })\n    }\n\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant> {\n        Ok(SerializeTupleVariant {\n            name: String::from(variant),\n            vec: Vec::with_capacity(len),\n        })\n    }\n\n    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap> {\n        Ok(SerializeMap::Map {\n            map: Map::with_capacity(len.unwrap_or(0)),\n            next_key: None,\n        })\n    }\n\n    fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct> {\n        match name {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(SerializeMap::Number { out_value: None }),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(SerializeMap::RawValue { out_value: None }),\n            _ => self.serialize_map(Some(len)),\n        }\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant> {\n        Ok(SerializeStructVariant {\n            name: String::from(variant),\n            map: Map::new(),\n        })\n    }\n\n    fn collect_str<T>(self, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Display,\n    {\n        Ok(Value::String(value.to_string()))\n    }\n}"
        ]
    },
    "single_path_import": {
        "alloc::vec": "__private::vec",
        "de::Deserializer": "Deserializer",
        "de::StreamDeserializer": "StreamDeserializer",
        "de::from_reader": "from_reader",
        "de::from_slice": "from_slice",
        "de::from_str": "from_str",
        "error::Error": "Error",
        "error::Result": "Result",
        "map::Map": "value::Map",
        "number::Number": "value::Number",
        "read::IoRead": "de::IoRead",
        "read::Read": "de::Read",
        "read::SliceRead": "de::SliceRead",
        "read::StrRead": "de::StrRead",
        "ser::Serializer": "Serializer",
        "ser::to_string": "to_string",
        "ser::to_string_pretty": "to_string_pretty",
        "ser::to_vec": "to_vec",
        "ser::to_vec_pretty": "to_vec_pretty",
        "ser::to_writer": "to_writer",
        "ser::to_writer_pretty": "to_writer_pretty",
        "std::io::Bytes": "io::Bytes",
        "std::io::Error": "io::Error",
        "std::io::ErrorKind": "io::ErrorKind",
        "std::io::Read": "io::Read",
        "std::io::Result": "io::Result",
        "std::io::Write": "io::Write",
        "value::Value": "Value",
        "value::from_value": "from_value",
        "value::index::Index": "value::Index",
        "value::ser::Serializer": "value::Serializer",
        "value::to_value": "to_value"
    },
    "srcs": {
        "<&'a map::Map<alloc::string::String, value::Value> as core::iter::IntoIterator>::into_iter": [
            "#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        Iter {\n            iter: self.map.iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<&'a mut map::Map<alloc::string::String, value::Value> as core::iter::IntoIterator>::into_iter": [
            "#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str": [
            "fn collect_str<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Display,{\n        use self::fmt::Write;\n\n        struct Adapter<'ser, W: 'ser, F: 'ser> {\n            writer: &'ser mut W,\n            formatter: &'ser mut F,\n            error: Option<io::Error>,\n        }\n\n        impl<'ser, W, F> Write for Adapter<'ser, W, F>\n        where\n            W: io::Write,\n            F: Formatter,\n        {\n            fn write_str(&mut self, s: &str) -> fmt::Result {\n                debug_assert!(self.error.is_none());\n                match format_escaped_str_contents(self.writer, self.formatter, s) {\n                    Ok(()) => Ok(()),\n                    Err(err) => {\n                        self.error = Some(err);\n                        Err(fmt::Error)\n                    }\n                }\n            }\n        }\n\n        tri!(self\n            .formatter\n            .begin_string(&mut self.writer)\n            .map_err(Error::io));\n        let mut adapter = Adapter {\n            writer: &mut self.writer,\n            formatter: &mut self.formatter,\n            error: None,\n        };\n        match write!(adapter, \"{}\", value) {\n            Ok(()) => debug_assert!(adapter.error.is_none()),\n            Err(fmt::Error) => {\n                return Err(Error::io(adapter.error.expect(\"there should be an error\")));\n            }\n        }\n        self.formatter\n            .end_string(&mut self.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter": [
            "struct Adapter<'ser, W: 'ser, F: 'ser> {\n            writer: &'ser mut W,\n            formatter: &'ser mut F,\n            error: Option<io::Error>,\n        }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool": [
            "#[inline]\nfn serialize_bool(self, value: bool) -> Result<()>{\n        self.formatter\n            .write_bool(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes": [
            "#[inline]\nfn serialize_bytes(self, value: &[u8]) -> Result<()>{\n        self.formatter\n            .write_byte_array(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char": [
            "#[inline]\nfn serialize_char(self, value: char) -> Result<()>{\n        // A char encoded as UTF-8 takes 4 bytes at most.\n        let mut buf = [0; 4];\n        self.serialize_str(value.encode_utf8(&mut buf))\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32": [
            "#[inline]\nfn serialize_f32(self, value: f32) -> Result<()>{\n        match value.classify() {\n            FpCategory::Nan | FpCategory::Infinite => self\n                .formatter\n                .write_null(&mut self.writer)\n                .map_err(Error::io),\n            _ => self\n                .formatter\n                .write_f32(&mut self.writer, value)\n                .map_err(Error::io),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64": [
            "#[inline]\nfn serialize_f64(self, value: f64) -> Result<()>{\n        match value.classify() {\n            FpCategory::Nan | FpCategory::Infinite => self\n                .formatter\n                .write_null(&mut self.writer)\n                .map_err(Error::io),\n            _ => self\n                .formatter\n                .write_f64(&mut self.writer, value)\n                .map_err(Error::io),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128": [
            "fn serialize_i128(self, value: i128) -> Result<()>{\n        self.formatter\n            .write_i128(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16": [
            "#[inline]\nfn serialize_i16(self, value: i16) -> Result<()>{\n        self.formatter\n            .write_i16(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32": [
            "#[inline]\nfn serialize_i32(self, value: i32) -> Result<()>{\n        self.formatter\n            .write_i32(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64": [
            "#[inline]\nfn serialize_i64(self, value: i64) -> Result<()>{\n        self.formatter\n            .write_i64(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8": [
            "#[inline]\nfn serialize_i8(self, value: i8) -> Result<()>{\n        self.formatter\n            .write_i8(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map": [
            "#[inline]\nfn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap>{\n        tri!(self\n            .formatter\n            .begin_object(&mut self.writer)\n            .map_err(Error::io));\n        if len == Some(0) {\n            tri!(self\n                .formatter\n                .end_object(&mut self.writer)\n                .map_err(Error::io));\n            Ok(Compound::Map {\n                ser: self,\n                state: State::Empty,\n            })\n        } else {\n            Ok(Compound::Map {\n                ser: self,\n                state: State::First,\n            })\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct": [
            "/// Serialize newtypes without an object wrapper.\n#[inline]\nfn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant": [
            "#[inline]\nfn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        tri!(self\n            .formatter\n            .begin_object(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_key(&mut self.writer, true)\n            .map_err(Error::io));\n        tri!(self.serialize_str(variant));\n        tri!(self\n            .formatter\n            .end_object_key(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_value(&mut self.writer)\n            .map_err(Error::io));\n        tri!(value.serialize(&mut *self));\n        tri!(self\n            .formatter\n            .end_object_value(&mut self.writer)\n            .map_err(Error::io));\n        self.formatter\n            .end_object(&mut self.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none": [
            "#[inline]\nfn serialize_none(self) -> Result<()>{\n        self.serialize_unit()\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq": [
            "#[inline]\nfn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq>{\n        tri!(self\n            .formatter\n            .begin_array(&mut self.writer)\n            .map_err(Error::io));\n        if len == Some(0) {\n            tri!(self\n                .formatter\n                .end_array(&mut self.writer)\n                .map_err(Error::io));\n            Ok(Compound::Map {\n                ser: self,\n                state: State::Empty,\n            })\n        } else {\n            Ok(Compound::Map {\n                ser: self,\n                state: State::First,\n            })\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some": [
            "#[inline]\nfn serialize_some<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str": [
            "#[inline]\nfn serialize_str(self, value: &str) -> Result<()>{\n        format_escaped_str(&mut self.writer, &mut self.formatter, value).map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct": [
            "#[inline]\nfn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct>{\n        match name {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(Compound::Number { ser: self }),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(Compound::RawValue { ser: self }),\n            _ => self.serialize_map(Some(len)),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant": [
            "#[inline]\nfn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant>{\n        tri!(self\n            .formatter\n            .begin_object(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_key(&mut self.writer, true)\n            .map_err(Error::io));\n        tri!(self.serialize_str(variant));\n        tri!(self\n            .formatter\n            .end_object_key(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_value(&mut self.writer)\n            .map_err(Error::io));\n        self.serialize_map(Some(len))\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple": [
            "#[inline]\nfn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple>{\n        self.serialize_seq(Some(len))\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct": [
            "#[inline]\nfn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct>{\n        self.serialize_seq(Some(len))\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant": [
            "#[inline]\nfn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant>{\n        tri!(self\n            .formatter\n            .begin_object(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_key(&mut self.writer, true)\n            .map_err(Error::io));\n        tri!(self.serialize_str(variant));\n        tri!(self\n            .formatter\n            .end_object_key(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_value(&mut self.writer)\n            .map_err(Error::io));\n        self.serialize_seq(Some(len))\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128": [
            "fn serialize_u128(self, value: u128) -> Result<()>{\n        self.formatter\n            .write_u128(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16": [
            "#[inline]\nfn serialize_u16(self, value: u16) -> Result<()>{\n        self.formatter\n            .write_u16(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32": [
            "#[inline]\nfn serialize_u32(self, value: u32) -> Result<()>{\n        self.formatter\n            .write_u32(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64": [
            "#[inline]\nfn serialize_u64(self, value: u64) -> Result<()>{\n        self.formatter\n            .write_u64(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8": [
            "#[inline]\nfn serialize_u8(self, value: u8) -> Result<()>{\n        self.formatter\n            .write_u8(&mut self.writer, value)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit": [
            "#[inline]\nfn serialize_unit(self) -> Result<()>{\n        self.formatter\n            .write_null(&mut self.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct": [
            "#[inline]\nfn serialize_unit_struct(self, _name: &'static str) -> Result<()>{\n        self.serialize_unit()\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant": [
            "#[inline]\nfn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<()>{\n        self.serialize_str(variant)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<&'de map::Map<alloc::string::String, value::Value> as serde::de::IntoDeserializer<'de, error::Error>>::into_deserializer": [
            "fn into_deserializer(self) -> Self::Deserializer{\n        self\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<&T as value::index::Index>::index_into": [
            "fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>{\n        (**self).index_into(v)\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<&T as value::index::Index>::index_into_mut": [
            "fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>{\n        (**self).index_into_mut(v)\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<&T as value::index::Index>::index_or_insert": [
            "fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value{\n        (**self).index_or_insert(v)\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::byte_offset": [
            "fn byte_offset(&self) -> usize{\n        R::byte_offset(self)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::decode_hex_escape": [
            "fn decode_hex_escape(&mut self) -> Result<u16>{\n        R::decode_hex_escape(self)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::discard": [
            "fn discard(&mut self){\n        R::discard(self);\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::ignore_str": [
            "fn ignore_str(&mut self) -> Result<()>{\n        R::ignore_str(self)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::next": [
            "fn next(&mut self) -> Result<Option<u8>>{\n        R::next(self)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::parse_str": [
            "fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>>{\n        R::parse_str(self, scratch)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::parse_str_raw": [
            "fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>>{\n        R::parse_str_raw(self, scratch)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::peek": [
            "fn peek(&mut self) -> Result<Option<u8>>{\n        R::peek(self)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::peek_position": [
            "fn peek_position(&self) -> Position{\n        R::peek_position(self)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::position": [
            "fn position(&self) -> Position{\n        R::position(self)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut R as read::Read<'de>>::set_failed": [
            "fn set_failed(&mut self, failed: &mut bool){\n        R::set_failed(self, failed);\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any": [
            "#[inline]\nfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'n' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"ull\"));\n                visitor.visit_unit()\n            }\n            b't' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"rue\"));\n                visitor.visit_bool(true)\n            }\n            b'f' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"alse\"));\n                visitor.visit_bool(false)\n            }\n            b'-' => {\n                self.eat_char();\n                tri!(self.parse_any_number(false)).visit(visitor)\n            }\n            b'0'..=b'9' => tri!(self.parse_any_number(true)).visit(visitor),\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match tri!(self.read.parse_str(&mut self.scratch)) {\n                    Reference::Borrowed(s) => visitor.visit_borrowed_str(s),\n                    Reference::Copied(s) => visitor.visit_str(s),\n                }\n            }\n            b'[' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_seq(SeqAccess::new(self));\n                }\n\n                match (ret, self.end_seq()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            b'{' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_map(MapAccess::new(self));\n                }\n\n                match (ret, self.end_map()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            _ => Err(self.peek_error(ErrorCode::ExpectedSomeValue)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            // The de::Error impl creates errors with unknown line and column.\n            // Fill in the position here by looking at the current index in the\n            // input. There is no way to tell whether this should call `error`\n            // or `peek_error` so pick the one that seems correct more often.\n            // Worst case, the position is off by one character.\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool": [
            "fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b't' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"rue\"));\n                visitor.visit_bool(true)\n            }\n            b'f' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"alse\"));\n                visitor.visit_bool(false)\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "#[inline]\nfn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_bytes(visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes": [
            "/// Parses a JSON string as bytes. Note that this function does not check\n/// whether the bytes represent a valid UTF-8 string.\n///\n/// The relevant part of the JSON specification is Section 8.2 of [RFC\n/// 7159]:\n///\n/// > When all the strings represented in a JSON text are composed entirely\n/// > of Unicode characters (however escaped), then that JSON text is\n/// > interoperable in the sense that all software implementations that\n/// > parse it will agree on the contents of names and of string values in\n/// > objects and arrays.\n/// >\n/// > However, the ABNF in this specification allows member names and string\n/// > values to contain bit sequences that cannot encode Unicode characters;\n/// > for example, \"\\uDEAD\" (a single unpaired UTF-16 surrogate). Instances\n/// > of this have been observed, for example, when a library truncates a\n/// > UTF-16 string without checking whether the truncation split a\n/// > surrogate pair.  The behavior of software that receives JSON texts\n/// > containing such values is unpredictable; for example, implementations\n/// > might return different values for the length of a string value or even\n/// > suffer fatal runtime exceptions.\n///\n/// [RFC 7159]: https://tools.ietf.org/html/rfc7159\n///\n/// The behavior of serde_json is specified to fail on non-UTF-8 strings\n/// when deserializing into Rust UTF-8 string types such as String, and\n/// succeed with the bytes representing the [WTF-8] encoding of code points\n/// when deserializing using this method.\n///\n/// [WTF-8]: https://simonsapin.github.io/wtf-8\n///\n/// Escape sequences are processed as usual, and for `\\uXXXX` escapes it is\n/// still checked if the hex number represents a valid Unicode code point.\n///\n/// # Examples\n///\n/// You can use this to parse JSON strings containing invalid UTF-8 bytes,\n/// or unpaired surrogates.\n///\n/// ```\n/// use serde_bytes::ByteBuf;\n///\n/// fn look_at_bytes() -> Result<(), serde_json::Error> {\n///     let json_data = b\"\\\"some bytes: \\xe5\\x00\\xe5\\\"\";\n///     let bytes: ByteBuf = serde_json::from_slice(json_data)?;\n///\n///     assert_eq!(b'\\xe5', bytes[12]);\n///     assert_eq!(b'\\0', bytes[13]);\n///     assert_eq!(b'\\xe5', bytes[14]);\n///\n///     Ok(())\n/// }\n/// #\n/// # look_at_bytes().unwrap();\n/// ```\n///\n/// Backslash escape sequences like `\\n` are still interpreted and required\n/// to be valid. `\\u` escape sequences are required to represent a valid\n/// Unicode code point or lone surrogate.\n///\n/// ```\n/// use serde_bytes::ByteBuf;\n///\n/// fn look_at_bytes() -> Result<(), serde_json::Error> {\n///     let json_data = b\"\\\"lone surrogate: \\\\uD801\\\"\";\n///     let bytes: ByteBuf = serde_json::from_slice(json_data)?;\n///     let expected = b\"lone surrogate: \\xED\\xA0\\x81\";\n///     assert_eq!(expected, bytes.as_slice());\n///     Ok(())\n/// }\n/// #\n/// # look_at_bytes();\n/// ```\nfn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match tri!(self.read.parse_str_raw(&mut self.scratch)) {\n                    Reference::Borrowed(b) => visitor.visit_borrowed_bytes(b),\n                    Reference::Copied(b) => visitor.visit_bytes(b),\n                }\n            }\n            b'[' => self.deserialize_seq(visitor),\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char": [
            "fn deserialize_char<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum": [
            "/// Parses an enum as an object like `{\"$KEY\":$VALUE}`, where $VALUE is either a straight\n/// value, a `[..]`, or a `{..}`.\n#[inline]\nfn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        match tri!(self.parse_whitespace()) {\n            Some(b'{') => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_enum(VariantAccess::new(self));\n                }\n                let value = tri!(ret);\n\n                match tri!(self.parse_whitespace()) {\n                    Some(b'}') => {\n                        self.eat_char();\n                        Ok(value)\n                    }\n                    Some(_) => Err(self.error(ErrorCode::ExpectedSomeValue)),\n                    None => Err(self.error(ErrorCode::EofWhileParsingObject)),\n                }\n            }\n            Some(b'\"') => visitor.visit_enum(UnitVariantAccess::new(self)),\n            Some(_) => Err(self.peek_error(ErrorCode::ExpectedSomeValue)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingValue)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier": [
            "fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        tri!(self.ignore_value());\n        visitor.visit_unit()\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map": [
            "fn deserialize_map<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'{' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_map(MapAccess::new(self));\n                }\n\n                match (ret, self.end_map()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "/// Parses a newtype struct as the underlying value.\n#[inline]\nfn deserialize_newtype_struct<V>(self, name: &str, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return self.deserialize_raw_value(visitor);\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option": [
            "/// Parses a `null` as a None, and any other values as a `Some(...)`.\n#[inline]\nfn deserialize_option<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        match tri!(self.parse_whitespace()) {\n            Some(b'n') => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"ull\"));\n                visitor.visit_none()\n            }\n            _ => visitor.visit_some(self),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq": [
            "fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'[' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_seq(SeqAccess::new(self));\n                }\n\n                match (ret, self.end_seq()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str": [
            "fn deserialize_str<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match tri!(self.read.parse_str(&mut self.scratch)) {\n                    Reference::Borrowed(s) => visitor.visit_borrowed_str(s),\n                    Reference::Copied(s) => visitor.visit_str(s),\n                }\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string": [
            "fn deserialize_string<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct": [
            "fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'[' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_seq(SeqAccess::new(self));\n                }\n\n                match (ret, self.end_seq()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            b'{' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_map(MapAccess::new(self));\n                }\n\n                match (ret, self.end_map()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple": [
            "fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.$using(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit": [
            "fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'n' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"ull\"));\n                visitor.visit_unit()\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_unit(visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_any": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self.n {\n                N::PosInt(u) => visitor.visit_u64(u),\n                N::NegInt(i) => visitor.visit_i64(i),\n                N::Float(f) => visitor.visit_f64(f),\n            }\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_bool": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_bytes": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_char": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_enum": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_f32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_f64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i128": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i16": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i8": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_identifier": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_map": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_option": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_seq": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_str": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_string": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_tuple": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u128": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u16": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u8": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_unit": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as core::fmt::Write>::write_str": [
            "fn write_str(&mut self, s: &str) -> fmt::Result{\n                debug_assert!(self.error.is_none());\n                match format_escaped_str_contents(self.writer, self.formatter, s) {\n                    Ok(()) => Ok(()),\n                    Err(err) => {\n                        self.error = Some(err);\n                        Err(fmt::Error)\n                    }\n                }\n            }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting": [
            "fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n                formatter.write_str(\"a map\")\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map": [
            "#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[inline]\nfn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,{\n                let mut values = Map::new();\n\n                while let Some((key, value)) = tri!(visitor.next_entry()) {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit": [
            "#[inline]\nfn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,{\n                Ok(Map::new())\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::expecting": [
            "fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n                formatter.write_str(\"a JSON number\")\n            }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64": [
            "fn visit_f64<E>(self, value: f64) -> Result<Number, E>\n            where\n                E: de::Error,{\n                Number::from_f64(value).ok_or_else(|| de::Error::custom(\"not a JSON number\"))\n            }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i128": [
            "fn visit_i128<E>(self, value: i128) -> Result<Number, E>\n            where\n                E: de::Error,{\n                Number::from_i128(value)\n                    .ok_or_else(|| de::Error::custom(\"JSON number out of range\"))\n            }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64": [
            "fn visit_i64<E>(self, value: i64) -> Result<Number, E>{\n                Ok(value.into())\n            }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u128": [
            "fn visit_u128<E>(self, value: u128) -> Result<Number, E>\n            where\n                E: de::Error,{\n                Number::from_u128(value)\n                    .ok_or_else(|| de::Error::custom(\"JSON number out of range\"))\n            }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64": [
            "fn visit_u64<E>(self, value: u64) -> Result<Number, E>{\n                Ok(value.into())\n            }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<<value::Value as core::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::flush": [
            "fn flush(&mut self) -> io::Result<()>{\n                Ok(())\n            }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "<<value::Value as core::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::write": [
            "fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n                // Safety: the serializer below only emits valid utf8 when using\n                // the default formatter.\n                let s = unsafe { str::from_utf8_unchecked(buf) };\n                tri!(self.inner.write_str(s).map_err(io_error));\n                Ok(buf.len())\n            }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "<alloc::string::String as value::index::Index>::index_into": [
            "fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>{\n        self[..].index_into(v)\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<alloc::string::String as value::index::Index>::index_into_mut": [
            "fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>{\n        self[..].index_into_mut(v)\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<alloc::string::String as value::index::Index>::index_or_insert": [
            "fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value{\n        self[..].index_or_insert(v)\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed": [
            "fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>\n    where\n        K: de::DeserializeSeed<'de>,{\n        fn has_next_key<'de, 'a, R: Read<'de> + 'a>(map: &mut MapAccess<'a, R>) -> Result<bool> {\n            let peek = match tri!(map.de.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(map.de.peek_error(ErrorCode::EofWhileParsingObject));\n                }\n            };\n\n            if peek == b'}' {\n                Ok(false)\n            } else if map.first {\n                map.first = false;\n                if peek == b'\"' {\n                    Ok(true)\n                } else {\n                    Err(map.de.peek_error(ErrorCode::KeyMustBeAString))\n                }\n            } else if peek == b',' {\n                map.de.eat_char();\n                match tri!(map.de.parse_whitespace()) {\n                    Some(b'\"') => Ok(true),\n                    Some(b'}') => Err(map.de.peek_error(ErrorCode::TrailingComma)),\n                    Some(_) => Err(map.de.peek_error(ErrorCode::KeyMustBeAString)),\n                    None => Err(map.de.peek_error(ErrorCode::EofWhileParsingValue)),\n                }\n            } else {\n                Err(map.de.peek_error(ErrorCode::ExpectedObjectCommaOrEnd))\n            }\n        }\n\n        if tri!(has_next_key(self)) {\n            Ok(Some(tri!(seed.deserialize(MapKey { de: &mut *self.de }))))\n        } else {\n            Ok(None)\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed::has_next_key": [
            "fn has_next_key<'de, 'a, R: Read<'de> + 'a>(map: &mut MapAccess<'a, R>) -> Result<bool>{\n            let peek = match tri!(map.de.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(map.de.peek_error(ErrorCode::EofWhileParsingObject));\n                }\n            };\n\n            if peek == b'}' {\n                Ok(false)\n            } else if map.first {\n                map.first = false;\n                if peek == b'\"' {\n                    Ok(true)\n                } else {\n                    Err(map.de.peek_error(ErrorCode::KeyMustBeAString))\n                }\n            } else if peek == b',' {\n                map.de.eat_char();\n                match tri!(map.de.parse_whitespace()) {\n                    Some(b'\"') => Ok(true),\n                    Some(b'}') => Err(map.de.peek_error(ErrorCode::TrailingComma)),\n                    Some(_) => Err(map.de.peek_error(ErrorCode::KeyMustBeAString)),\n                    None => Err(map.de.peek_error(ErrorCode::EofWhileParsingValue)),\n                }\n            } else {\n                Err(map.de.peek_error(ErrorCode::ExpectedObjectCommaOrEnd))\n            }\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed": [
            "fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value>\n    where\n        V: de::DeserializeSeed<'de>,{\n        tri!(self.de.parse_object_colon());\n\n        seed.deserialize(&mut *self.de)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any": [
            "#[inline]\nfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.de.eat_char();\n        self.de.scratch.clear();\n        match tri!(self.de.read.parse_str(&mut self.de.scratch)) {\n            Reference::Borrowed(s) => visitor.visit_borrowed_str(s),\n            Reference::Copied(s) => visitor.visit_str(s),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool": [
            "fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.de.eat_char();\n\n        let peek = match tri!(self.de.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.de.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b't' => {\n                tri!(self.de.parse_ident(b\"rue\\\"\"));\n                visitor.visit_bool(true)\n            }\n            b'f' => {\n                tri!(self.de.parse_ident(b\"alse\\\"\"));\n                visitor.visit_bool(false)\n            }\n            _ => {\n                self.de.scratch.clear();\n                let s = tri!(self.de.read.parse_str(&mut self.de.scratch));\n                Err(de::Error::invalid_type(Unexpected::Str(&s), &visitor))\n            }\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.de.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "#[inline]\nfn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.de.deserialize_bytes(visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes": [
            "#[inline]\nfn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.de.deserialize_bytes(visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum": [
            "#[inline]\nfn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.de.deserialize_enum(name, variants, visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n\n            match tri!(self.de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(self.de.error(ErrorCode::ExpectedNumericKey)),\n            }\n\n            let value = tri!(self.de.$delegate(visitor));\n\n            match tri!(self.de.peek()) {\n                Some(b'\"') => self.de.eat_char(),\n                _ => return Err(self.de.peek_error(ErrorCode::ExpectedDoubleQuote)),\n            }\n\n            Ok(value)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "#[inline]\nfn deserialize_newtype_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return self.de.deserialize_raw_value(visitor);\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option": [
            "#[inline]\nfn deserialize_option<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        // Map keys cannot be null.\n        visitor.visit_some(self)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n\n            match tri!(self.de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(self.de.error(ErrorCode::ExpectedNumericKey)),\n            }\n\n            let value = tri!(self.de.$delegate(visitor));\n\n            match tri!(self.de.peek()) {\n                Some(b'\"') => self.de.eat_char(),\n                _ => return Err(self.de.peek_error(ErrorCode::ExpectedDoubleQuote)),\n            }\n\n            Ok(value)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed": [
            "fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n    where\n        T: de::DeserializeSeed<'de>,{\n        fn has_next_element<'de, 'a, R: Read<'de> + 'a>(\n            seq: &mut SeqAccess<'a, R>,\n        ) -> Result<bool> {\n            let peek = match tri!(seq.de.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(seq.de.peek_error(ErrorCode::EofWhileParsingList));\n                }\n            };\n\n            if peek == b']' {\n                Ok(false)\n            } else if seq.first {\n                seq.first = false;\n                Ok(true)\n            } else if peek == b',' {\n                seq.de.eat_char();\n                match tri!(seq.de.parse_whitespace()) {\n                    Some(b']') => Err(seq.de.peek_error(ErrorCode::TrailingComma)),\n                    Some(_) => Ok(true),\n                    None => Err(seq.de.peek_error(ErrorCode::EofWhileParsingValue)),\n                }\n            } else {\n                Err(seq.de.peek_error(ErrorCode::ExpectedListCommaOrEnd))\n            }\n        }\n\n        if tri!(has_next_element(self)) {\n            Ok(Some(tri!(seed.deserialize(&mut *self.de))))\n        } else {\n            Ok(None)\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed::has_next_element": [
            "fn has_next_element<'de, 'a, R: Read<'de> + 'a>(\n            seq: &mut SeqAccess<'a, R>,\n        ) -> Result<bool>{\n            let peek = match tri!(seq.de.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(seq.de.peek_error(ErrorCode::EofWhileParsingList));\n                }\n            };\n\n            if peek == b']' {\n                Ok(false)\n            } else if seq.first {\n                seq.first = false;\n                Ok(true)\n            } else if peek == b',' {\n                seq.de.eat_char();\n                match tri!(seq.de.parse_whitespace()) {\n                    Some(b']') => Err(seq.de.peek_error(ErrorCode::TrailingComma)),\n                    Some(_) => Ok(true),\n                    None => Err(seq.de.peek_error(ErrorCode::EofWhileParsingValue)),\n                }\n            } else {\n                Err(seq.de.peek_error(ErrorCode::ExpectedListCommaOrEnd))\n            }\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::StreamDeserializer<'de, R, T> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Result<T>>{\n        if R::should_early_return_if_failed && self.failed {\n            return None;\n        }\n\n        // skip whitespaces, if any\n        // this helps with trailing whitespaces, since whitespaces between\n        // values are handled for us.\n        match self.de.parse_whitespace() {\n            Ok(None) => {\n                self.offset = self.de.read.byte_offset();\n                None\n            }\n            Ok(Some(b)) => {\n                // If the value does not have a clear way to show the end of the value\n                // (like numbers, null, true etc.) we have to look for whitespace or\n                // the beginning of a self-delineated value.\n                let self_delineated_value = match b {\n                    b'[' | b'\"' | b'{' => true,\n                    _ => false,\n                };\n                self.offset = self.de.read.byte_offset();\n                let result = de::Deserialize::deserialize(&mut self.de);\n\n                Some(match result {\n                    Ok(value) => {\n                        self.offset = self.de.read.byte_offset();\n                        if self_delineated_value {\n                            Ok(value)\n                        } else {\n                            self.peek_end_of_value().map(|()| value)\n                        }\n                    }\n                    Err(e) => {\n                        self.de.read.set_failed(&mut self.failed);\n                        Err(e)\n                    }\n                })\n            }\n            Err(e) => {\n                self.de.read.set_failed(&mut self.failed);\n                Some(Err(e))\n            }\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed": [
            "fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>\n    where\n        V: de::DeserializeSeed<'de>,{\n        let variant = tri!(seed.deserialize(&mut *self.de));\n        Ok((variant, self))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value>\n    where\n        T: de::DeserializeSeed<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"newtype variant\",\n        ))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant": [
            "fn struct_variant<V>(self, _fields: &'static [&'static str], _visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"struct variant\",\n        ))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant": [
            "fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"tuple variant\",\n        ))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant": [
            "fn unit_variant(self) -> Result<()>{\n        Ok(())\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed": [
            "fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>\n    where\n        V: de::DeserializeSeed<'de>,{\n        let val = tri!(seed.deserialize(&mut *self.de));\n        tri!(self.de.parse_object_colon());\n        Ok((val, self))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value>\n    where\n        T: de::DeserializeSeed<'de>,{\n        seed.deserialize(self.de)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant": [
            "fn struct_variant<V>(self, fields: &'static [&'static str], visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        de::Deserializer::deserialize_struct(self.de, \"\", fields, visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant": [
            "fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        de::Deserializer::deserialize_seq(self.de, visitor)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant": [
            "fn unit_variant(self) -> Result<()>{\n        de::Deserialize::deserialize(self.de)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "<error::Error as core::error::Error>::source": [
            "#[cfg(feature = \"std\")]\nfn source(&self) -> Option<&(dyn error::Error + 'static)>{\n        match &self.err.code {\n            ErrorCode::Io(err) => err.source(),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(\n            f,\n            \"Error({:?}, line: {}, column: {})\",\n            self.err.code.to_string(),\n            self.err.line,\n            self.err.column\n        )\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as core::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Display::fmt(&*self.err, f)\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as serde::de::Error>::custom": [
            "#[cold]\nfn custom<T: Display>(msg: T) -> Error{\n        make_error(msg.to_string())\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as serde::de::Error>::invalid_type": [
            "#[cold]\nfn invalid_type(unexp: de::Unexpected, exp: &dyn de::Expected) -> Self{\n        Error::custom(format_args!(\n            \"invalid type: {}, expected {}\",\n            JsonUnexpected(unexp),\n            exp,\n        ))\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as serde::de::Error>::invalid_value": [
            "#[cold]\nfn invalid_value(unexp: de::Unexpected, exp: &dyn de::Expected) -> Self{\n        Error::custom(format_args!(\n            \"invalid value: {}, expected {}\",\n            JsonUnexpected(unexp),\n            exp,\n        ))\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as serde::ser::Error>::custom": [
            "#[cold]\nfn custom<T: Display>(msg: T) -> Error{\n        make_error(msg.to_string())\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::ErrorCode as core::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            ErrorCode::Message(msg) => f.write_str(msg),\n            ErrorCode::Io(err) => Display::fmt(err, f),\n            ErrorCode::EofWhileParsingList => f.write_str(\"EOF while parsing a list\"),\n            ErrorCode::EofWhileParsingObject => f.write_str(\"EOF while parsing an object\"),\n            ErrorCode::EofWhileParsingString => f.write_str(\"EOF while parsing a string\"),\n            ErrorCode::EofWhileParsingValue => f.write_str(\"EOF while parsing a value\"),\n            ErrorCode::ExpectedColon => f.write_str(\"expected `:`\"),\n            ErrorCode::ExpectedListCommaOrEnd => f.write_str(\"expected `,` or `]`\"),\n            ErrorCode::ExpectedObjectCommaOrEnd => f.write_str(\"expected `,` or `}`\"),\n            ErrorCode::ExpectedSomeIdent => f.write_str(\"expected ident\"),\n            ErrorCode::ExpectedSomeValue => f.write_str(\"expected value\"),\n            ErrorCode::ExpectedDoubleQuote => f.write_str(\"expected `\\\"`\"),\n            ErrorCode::InvalidEscape => f.write_str(\"invalid escape\"),\n            ErrorCode::InvalidNumber => f.write_str(\"invalid number\"),\n            ErrorCode::NumberOutOfRange => f.write_str(\"number out of range\"),\n            ErrorCode::InvalidUnicodeCodePoint => f.write_str(\"invalid unicode code point\"),\n            ErrorCode::ControlCharacterWhileParsingString => {\n                f.write_str(\"control character (\\\\u0000-\\\\u001F) found while parsing a string\")\n            }\n            ErrorCode::KeyMustBeAString => f.write_str(\"key must be a string\"),\n            ErrorCode::ExpectedNumericKey => {\n                f.write_str(\"invalid value: expected key to be a number in quotes\")\n            }\n            ErrorCode::FloatKeyMustBeFinite => {\n                f.write_str(\"float key must be finite (got NaN or +/-inf)\")\n            }\n            ErrorCode::LoneLeadingSurrogateInHexEscape => {\n                f.write_str(\"lone leading surrogate in hex escape\")\n            }\n            ErrorCode::TrailingComma => f.write_str(\"trailing comma\"),\n            ErrorCode::TrailingCharacters => f.write_str(\"trailing characters\"),\n            ErrorCode::UnexpectedEndOfHexEscape => f.write_str(\"unexpected end of hex escape\"),\n            ErrorCode::RecursionLimitExceeded => f.write_str(\"recursion limit exceeded\"),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::ErrorImpl as core::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if self.line == 0 {\n            Display::fmt(&self.code, f)\n        } else {\n            write!(\n                f,\n                \"{} at line {} column {}\",\n                self.code, self.line, self.column\n            )\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::JsonUnexpected<'a> as core::fmt::Display>::fmt": [
            "fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        match self.0 {\n            de::Unexpected::Unit => formatter.write_str(\"null\"),\n            de::Unexpected::Float(value) => write!(\n                formatter,\n                \"floating point `{}`\",\n                ryu::Buffer::new().format(value),\n            ),\n            unexp => Display::fmt(&unexp, formatter),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<iter::LineColIterator<I> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<io::Result<u8>>{\n        match self.iter.next() {\n            None => None,\n            Some(Ok(b'\\n')) => {\n                self.start_of_line += self.col + 1;\n                self.line += 1;\n                self.col = 0;\n                Some(Ok(b'\\n'))\n            }\n            Some(Ok(c)) => {\n                self.col += 1;\n                Some(Ok(c))\n            }\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }",
            "Real(LocalPath(\"src/iter.rs\"))"
        ],
        "<map::IntoIter as core::iter::DoubleEndedIterator>::next_back": [
            "#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IntoIter as core::iter::ExactSizeIterator>::len": [
            "#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IntoIter as core::iter::Iterator>::next": [
            "#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IntoIter as core::iter::Iterator>::size_hint": [
            "#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IntoValues as core::iter::DoubleEndedIterator>::next_back": [
            "#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IntoValues as core::iter::ExactSizeIterator>::len": [
            "#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IntoValues as core::iter::Iterator>::next": [
            "#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IntoValues as core::iter::Iterator>::size_hint": [
            "#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Iter<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Iter<'a> as core::iter::ExactSizeIterator>::len": [
            "#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Iter<'a> as core::iter::Iterator>::next": [
            "#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Iter<'a> as core::iter::Iterator>::size_hint": [
            "#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IterMut<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IterMut<'a> as core::iter::ExactSizeIterator>::len": [
            "#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IterMut<'a> as core::iter::Iterator>::next": [
            "#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IterMut<'a> as core::iter::Iterator>::size_hint": [
            "#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Keys<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Keys<'a> as core::iter::ExactSizeIterator>::len": [
            "#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Keys<'a> as core::iter::Iterator>::next": [
            "#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Keys<'a> as core::iter::Iterator>::size_hint": [
            "#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::clone::Clone>::clone": [
            "#[inline]\nfn clone(&self) -> Self{\n        Map {\n            map: self.map.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::clone::Clone>::clone_from": [
            "#[inline]\nfn clone_from(&mut self, source: &Self){\n        self.map.clone_from(&source.map);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::cmp::PartialEq>::eq": [
            "#[inline]\nfn eq(&self, other: &Self) -> bool{\n        self.map.eq(&other.map)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::default::Default>::default": [
            "#[inline]\nfn default() -> Self{\n        Map {\n            map: MapImpl::new(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::fmt::Debug>::fmt": [
            "#[inline]\nfn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error>{\n        self.map.fmt(formatter)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::hash::Hash>::hash": [
            "fn hash<H: Hasher>(&self, state: &mut H){\n        #[cfg(not(feature = \"preserve_order\"))]\n        {\n            self.map.hash(state);\n        }\n\n        #[cfg(feature = \"preserve_order\")]\n        {\n            let mut kv = Vec::from_iter(&self.map);\n            kv.sort_unstable_by(|a, b| a.0.cmp(b.0));\n            kv.hash(state);\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::iter::Extend<(alloc::string::String, value::Value)>>::extend": [
            "fn extend<T>(&mut self, iter: T)\n    where\n        T: IntoIterator<Item = (String, Value)>,{\n        self.map.extend(iter);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::iter::FromIterator<(alloc::string::String, value::Value)>>::from_iter": [
            "fn from_iter<T>(iter: T) -> Self\n    where\n        T: IntoIterator<Item = (String, Value)>,{\n        Map {\n            map: FromIterator::from_iter(iter),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::iter::IntoIterator>::into_iter": [
            "#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        IntoIter {\n            iter: self.map.into_iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::ops::Index<&Q>>::index": [
            "fn index(&self, index: &Q) -> &Value{\n        self.map.index(index)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::ops::IndexMut<&Q>>::index_mut": [
            "fn index_mut(&mut self, index: &Q) -> &mut Value{\n        self.map.get_mut(index).expect(\"no entry found for key\")\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize": [
            "#[inline]\nfn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,{\n        struct Visitor;\n\n        impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Map<String, Value>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                Ok(Map::new())\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut values = Map::new();\n\n                while let Some((key, value)) = tri!(visitor.next_entry()) {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        deserializer.deserialize_map(Visitor)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor": [
            "struct Visitor;",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::Serialize>::serialize": [
            "#[inline]\nfn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::ser::Serializer,{\n        use serde::ser::SerializeMap;\n        let mut map = tri!(serializer.serialize_map(Some(self.len())));\n        for (k, v) in self {\n            tri!(map.serialize_entry(k, v));\n        }\n        map.end()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::de::IntoDeserializer<'de, error::Error>>::into_deserializer": [
            "fn into_deserializer(self) -> Self::Deserializer{\n        self\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Values<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Values<'a> as core::iter::ExactSizeIterator>::len": [
            "#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Values<'a> as core::iter::Iterator>::next": [
            "#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::Values<'a> as core::iter::Iterator>::size_hint": [
            "#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::ValuesMut<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::ValuesMut<'a> as core::iter::ExactSizeIterator>::len": [
            "#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::ValuesMut<'a> as core::iter::Iterator>::next": [
            "#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::ValuesMut<'a> as core::iter::Iterator>::size_hint": [
            "#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<number::N as core::cmp::PartialEq>::eq": [
            "fn eq(&self, other: &Self) -> bool{\n        match (self, other) {\n            (N::PosInt(a), N::PosInt(b)) => a == b,\n            (N::NegInt(a), N::NegInt(b)) => a == b,\n            (N::Float(a), N::Float(b)) => a == b,\n            _ => false,\n        }\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::N as core::hash::Hash>::hash": [
            "fn hash<H: Hasher>(&self, h: &mut H){\n        match *self {\n            N::PosInt(i) => i.hash(h),\n            N::NegInt(i) => i.hash(h),\n            N::Float(f) => {\n                if f == 0.0f64 {\n                    // There are 2 zero representations, +0 and -0, which\n                    // compare equal but have different bits. We use the +0 hash\n                    // for both so that hash(+0) == hash(-0).\n                    0.0f64.to_bits().hash(h);\n                } else {\n                    f.to_bits().hash(h);\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<de::ParserNumber>>::from": [
            "fn from(value: ParserNumber) -> Self{\n        let n = match value {\n            ParserNumber::F64(f) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    ryu::Buffer::new().format_finite(f).to_owned()\n                }\n            }\n            ParserNumber::U64(u) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::PosInt(u)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    itoa::Buffer::new().format(u).to_owned()\n                }\n            }\n            ParserNumber::I64(i) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::NegInt(i)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    itoa::Buffer::new().format(i).to_owned()\n                }\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(s) => s,\n        };\n        Number { n }\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<i16>>::from": [
            "fn from(i: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<i32>>::from": [
            "fn from(i: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<i64>>::from": [
            "fn from(i: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<i8>>::from": [
            "fn from(i: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<isize>>::from": [
            "fn from(i: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<u16>>::from": [
            "fn from(u: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<u32>>::from": [
            "fn from(u: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<u64>>::from": [
            "fn from(u: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<u8>>::from": [
            "fn from(u: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::convert::From<usize>>::from": [
            "fn from(u: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::fmt::Debug>::fmt": [
            "fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        write!(formatter, \"Number({})\", self)\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as core::fmt::Display>::fmt": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        match self.n {\n            N::PosInt(u) => formatter.write_str(itoa::Buffer::new().format(u)),\n            N::NegInt(i) => formatter.write_str(itoa::Buffer::new().format(i)),\n            N::Float(f) => formatter.write_str(ryu::Buffer::new().format_finite(f)),\n        }\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserialize<'de>>::deserialize": [
            "#[inline]\nfn deserialize<D>(deserializer: D) -> Result<Number, D::Error>\n    where\n        D: Deserializer<'de>,{\n        struct NumberVisitor;\n\n        impl<'de> Visitor<'de> for NumberVisitor {\n            type Value = Number;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a JSON number\")\n            }\n\n            fn visit_i64<E>(self, value: i64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            fn visit_i128<E>(self, value: i128) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_i128(value)\n                    .ok_or_else(|| de::Error::custom(\"JSON number out of range\"))\n            }\n\n            fn visit_u64<E>(self, value: u64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            fn visit_u128<E>(self, value: u128) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_u128(value)\n                    .ok_or_else(|| de::Error::custom(\"JSON number out of range\"))\n            }\n\n            fn visit_f64<E>(self, value: f64) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_f64(value).ok_or_else(|| de::Error::custom(\"not a JSON number\"))\n            }\n\n            #[cfg(feature = \"arbitrary_precision\")]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Number, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let value = tri!(visitor.next_key::<NumberKey>());\n                if value.is_none() {\n                    return Err(de::Error::invalid_type(Unexpected::Map, &self));\n                }\n                let v: NumberFromString = tri!(visitor.next_value());\n                Ok(v.value)\n            }\n        }\n\n        deserializer.deserialize_any(NumberVisitor)\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor": [
            "struct NumberVisitor;",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_any": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self.n {\n                N::PosInt(u) => visitor.visit_u64(u),\n                N::NegInt(i) => visitor.visit_i64(i),\n                N::Float(f) => visitor.visit_f64(f),\n            }\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_bool": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_bytes": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_char": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_enum": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_f32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_f64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i128": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i16": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i8": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_identifier": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_map": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_option": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_seq": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_str": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_string": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_tuple": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u128": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u16": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u8": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_unit": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<number::Number as serde::Serialize>::serialize": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,{\n        match self.n {\n            N::PosInt(u) => serializer.serialize_u64(u),\n            N::NegInt(i) => serializer.serialize_i64(i),\n            N::Float(f) => serializer.serialize_f64(f),\n        }\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::byte_offset": [
            "fn byte_offset(&self) -> usize{\n        match self.ch {\n            Some(_) => self.iter.byte_offset() - 1,\n            None => self.iter.byte_offset(),\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::decode_hex_escape": [
            "fn decode_hex_escape(&mut self) -> Result<u16>{\n        let a = tri!(next_or_eof(self));\n        let b = tri!(next_or_eof(self));\n        let c = tri!(next_or_eof(self));\n        let d = tri!(next_or_eof(self));\n        match decode_four_hex_digits(a, b, c, d) {\n            Some(val) => Ok(val),\n            None => error(self, ErrorCode::InvalidEscape),\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::discard": [
            "#[cfg(not(feature = \"raw_value\"))]\n#[inline]\nfn discard(&mut self){\n        self.ch = None;\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::ignore_str": [
            "fn ignore_str(&mut self) -> Result<()>{\n        loop {\n            let ch = tri!(next_or_eof(self));\n            if !is_escape(ch, true) {\n                continue;\n            }\n            match ch {\n                b'\"' => {\n                    return Ok(());\n                }\n                b'\\\\' => {\n                    tri!(ignore_escape(self));\n                }\n                _ => {\n                    return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::next": [
            "#[inline]\nfn next(&mut self) -> Result<Option<u8>>{\n        match self.ch.take() {\n            Some(ch) => {\n                #[cfg(feature = \"raw_value\")]\n                {\n                    if let Some(buf) = &mut self.raw_buffer {\n                        buf.push(ch);\n                    }\n                }\n                Ok(Some(ch))\n            }\n            None => match self.iter.next() {\n                Some(Err(err)) => Err(Error::io(err)),\n                Some(Ok(ch)) => {\n                    #[cfg(feature = \"raw_value\")]\n                    {\n                        if let Some(buf) = &mut self.raw_buffer {\n                            buf.push(ch);\n                        }\n                    }\n                    Ok(Some(ch))\n                }\n                None => Ok(None),\n            },\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::parse_str": [
            "fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>>{\n        self.parse_str_bytes(scratch, true, as_str)\n            .map(Reference::Copied)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::parse_str_raw": [
            "fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>>{\n        self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))\n            .map(Reference::Copied)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::peek": [
            "#[inline]\nfn peek(&mut self) -> Result<Option<u8>>{\n        match self.ch {\n            Some(ch) => Ok(Some(ch)),\n            None => match self.iter.next() {\n                Some(Err(err)) => Err(Error::io(err)),\n                Some(Ok(ch)) => {\n                    self.ch = Some(ch);\n                    Ok(self.ch)\n                }\n                None => Ok(None),\n            },\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::peek_position": [
            "fn peek_position(&self) -> Position{\n        // The LineColIterator updates its position during peek() so it has the\n        // right one here.\n        self.position()\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::position": [
            "fn position(&self) -> Position{\n        Position {\n            line: self.iter.line(),\n            column: self.iter.col(),\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::IoRead<R> as read::Read<'de>>::set_failed": [
            "#[inline]\n#[cold]\nfn set_failed(&mut self, failed: &mut bool){\n        *failed = true;\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::Reference<'b, 'c, T> as core::ops::Deref>::deref": [
            "fn deref(&self) -> &Self::Target{\n        match *self {\n            Reference::Borrowed(b) => b,\n            Reference::Copied(c) => c,\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::byte_offset": [
            "fn byte_offset(&self) -> usize{\n        self.index\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::decode_hex_escape": [
            "#[inline]\nfn decode_hex_escape(&mut self) -> Result<u16>{\n        match self.slice[self.index..] {\n            [a, b, c, d, ..] => {\n                self.index += 4;\n                match decode_four_hex_digits(a, b, c, d) {\n                    Some(val) => Ok(val),\n                    None => error(self, ErrorCode::InvalidEscape),\n                }\n            }\n            _ => {\n                self.index = self.slice.len();\n                error(self, ErrorCode::EofWhileParsingString)\n            }\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::discard": [
            "#[inline]\nfn discard(&mut self){\n        self.index += 1;\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::ignore_str": [
            "fn ignore_str(&mut self) -> Result<()>{\n        loop {\n            self.skip_to_escape(true);\n            if self.index == self.slice.len() {\n                return error(self, ErrorCode::EofWhileParsingString);\n            }\n            match self.slice[self.index] {\n                b'\"' => {\n                    self.index += 1;\n                    return Ok(());\n                }\n                b'\\\\' => {\n                    self.index += 1;\n                    tri!(ignore_escape(self));\n                }\n                _ => {\n                    return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::next": [
            "#[inline]\nfn next(&mut self) -> Result<Option<u8>>{\n        // `Ok(self.slice.get(self.index).map(|ch| { self.index += 1; *ch }))`\n        // is about 10% slower.\n        Ok(if self.index < self.slice.len() {\n            let ch = self.slice[self.index];\n            self.index += 1;\n            Some(ch)\n        } else {\n            None\n        })\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::parse_str": [
            "fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>>{\n        self.parse_str_bytes(scratch, true, as_str)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::parse_str_raw": [
            "fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'a, 's, [u8]>>{\n        self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::peek": [
            "#[inline]\nfn peek(&mut self) -> Result<Option<u8>>{\n        // `Ok(self.slice.get(self.index).map(|ch| *ch))` is about 10% slower\n        // for some reason.\n        Ok(if self.index < self.slice.len() {\n            Some(self.slice[self.index])\n        } else {\n            None\n        })\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::peek_position": [
            "fn peek_position(&self) -> Position{\n        // Cap it at slice.len() just in case the most recent call was next()\n        // and it returned the last byte.\n        self.position_of_index(cmp::min(self.slice.len(), self.index + 1))\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::position": [
            "fn position(&self) -> Position{\n        self.position_of_index(self.index)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::set_failed": [
            "#[inline]\n#[cold]\nfn set_failed(&mut self, _failed: &mut bool){\n        self.slice = &self.slice[..self.index];\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::byte_offset": [
            "fn byte_offset(&self) -> usize{\n        self.delegate.byte_offset()\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::decode_hex_escape": [
            "fn decode_hex_escape(&mut self) -> Result<u16>{\n        self.delegate.decode_hex_escape()\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::discard": [
            "#[inline]\nfn discard(&mut self){\n        self.delegate.discard();\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::ignore_str": [
            "fn ignore_str(&mut self) -> Result<()>{\n        self.delegate.ignore_str()\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::next": [
            "#[inline]\nfn next(&mut self) -> Result<Option<u8>>{\n        self.delegate.next()\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::parse_str": [
            "fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>>{\n        self.delegate.parse_str_bytes(scratch, true, |_, bytes| {\n            // The deserialization input came in as &str with a UTF-8 guarantee,\n            // and the \\u-escapes are checked along the way, so don't need to\n            // check here.\n            Ok(unsafe { str::from_utf8_unchecked(bytes) })\n        })\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::parse_str_raw": [
            "fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'a, 's, [u8]>>{\n        self.delegate.parse_str_raw(scratch)\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::peek": [
            "#[inline]\nfn peek(&mut self) -> Result<Option<u8>>{\n        self.delegate.peek()\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::peek_position": [
            "fn peek_position(&self) -> Position{\n        self.delegate.peek_position()\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::position": [
            "fn position(&self) -> Position{\n        self.delegate.position()\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::set_failed": [
            "#[inline]\n#[cold]\nfn set_failed(&mut self, failed: &mut bool){\n        self.delegate.set_failed(failed);\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end": [
            "#[inline]\nfn end(self) -> Result<()>{\n        match self {\n            Compound::Map { ser, state } => match state {\n                State::Empty => Ok(()),\n                _ => ser.formatter.end_object(&mut ser.writer).map_err(Error::io),\n            },\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key": [
            "#[inline]\nfn serialize_key<T>(&mut self, key: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            Compound::Map { ser, state } => {\n                tri!(ser\n                    .formatter\n                    .begin_object_key(&mut ser.writer, *state == State::First)\n                    .map_err(Error::io));\n                *state = State::Rest;\n\n                tri!(key.serialize(MapKeySerializer { ser: *ser }));\n\n                ser.formatter\n                    .end_object_key(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value": [
            "#[inline]\nfn serialize_value<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            Compound::Map { ser, .. } => {\n                tri!(ser\n                    .formatter\n                    .begin_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                tri!(value.serialize(&mut **ser));\n                ser.formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end": [
            "#[inline]\nfn end(self) -> Result<()>{\n        match self {\n            Compound::Map { ser, state } => match state {\n                State::Empty => Ok(()),\n                _ => ser.formatter.end_array(&mut ser.writer).map_err(Error::io),\n            },\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element": [
            "#[inline]\nfn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            Compound::Map { ser, state } => {\n                tri!(ser\n                    .formatter\n                    .begin_array_value(&mut ser.writer, *state == State::First)\n                    .map_err(Error::io));\n                *state = State::Rest;\n                tri!(value.serialize(&mut **ser));\n                ser.formatter\n                    .end_array_value(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end": [
            "#[inline]\nfn end(self) -> Result<()>{\n        match self {\n            Compound::Map { .. } => ser::SerializeMap::end(self),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => Ok(()),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => Ok(()),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field": [
            "#[inline]\nfn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            Compound::Map { .. } => ser::SerializeMap::serialize_entry(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { ser, .. } => {\n                if key == crate::number::TOKEN {\n                    value.serialize(NumberStrEmitter(ser))\n                } else {\n                    Err(invalid_number())\n                }\n            }\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { ser, .. } => {\n                if key == crate::raw::TOKEN {\n                    value.serialize(RawValueStrEmitter(ser))\n                } else {\n                    Err(invalid_raw_value())\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end": [
            "#[inline]\nfn end(self) -> Result<()>{\n        match self {\n            Compound::Map { ser, state } => {\n                match state {\n                    State::Empty => {}\n                    _ => tri!(ser.formatter.end_object(&mut ser.writer).map_err(Error::io)),\n                }\n                tri!(ser\n                    .formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                ser.formatter.end_object(&mut ser.writer).map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field": [
            "#[inline]\nfn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match *self {\n            Compound::Map { .. } => ser::SerializeStruct::serialize_field(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end": [
            "#[inline]\nfn end(self) -> Result<()>{\n        ser::SerializeSeq::end(self)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element": [
            "#[inline]\nfn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        ser::SerializeSeq::serialize_element(self, value)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end": [
            "#[inline]\nfn end(self) -> Result<()>{\n        ser::SerializeSeq::end(self)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field": [
            "#[inline]\nfn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        ser::SerializeSeq::serialize_element(self, value)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end": [
            "#[inline]\nfn end(self) -> Result<()>{\n        match self {\n            Compound::Map { ser, state } => {\n                match state {\n                    State::Empty => {}\n                    _ => tri!(ser.formatter.end_array(&mut ser.writer).map_err(Error::io)),\n                }\n                tri!(ser\n                    .formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                ser.formatter.end_object(&mut ser.writer).map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field": [
            "#[inline]\nfn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        ser::SerializeSeq::serialize_element(self, value)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str": [
            "fn collect_str<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Display,{\n        self.ser.collect_str(value)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool": [
            "fn serialize_bool(self, value: bool) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_bool(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes": [
            "fn serialize_bytes(self, _value: &[u8]) -> Result<()>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char": [
            "fn serialize_char(self, value: char) -> Result<()>{\n        self.ser.serialize_str(value.encode_utf8(&mut [0u8; 4]))\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32": [
            "fn serialize_f32(self, value: f32) -> Result<()>{\n        if !value.is_finite() {\n            return Err(float_key_must_be_finite());\n        }\n\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_f32(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64": [
            "fn serialize_f64(self, value: f64) -> Result<()>{\n        if !value.is_finite() {\n            return Err(float_key_must_be_finite());\n        }\n\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_f64(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128": [
            "fn serialize_i128(self, value: i128) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i128(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16": [
            "fn serialize_i16(self, value: i16) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i16(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32": [
            "fn serialize_i32(self, value: i32) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i32(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64": [
            "fn serialize_i64(self, value: i64) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i64(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8": [
            "fn serialize_i8(self, value: i8) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i8(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map": [
            "fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct": [
            "#[inline]\nfn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant": [
            "fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none": [
            "fn serialize_none(self) -> Result<()>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq": [
            "fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some": [
            "fn serialize_some<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str": [
            "#[inline]\nfn serialize_str(self, value: &str) -> Result<()>{\n        self.ser.serialize_str(value)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct": [
            "fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant": [
            "fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple": [
            "fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct": [
            "fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant": [
            "fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128": [
            "fn serialize_u128(self, value: u128) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u128(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16": [
            "fn serialize_u16(self, value: u16) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u16(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32": [
            "fn serialize_u32(self, value: u32) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u32(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64": [
            "fn serialize_u64(self, value: u64) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u64(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8": [
            "fn serialize_u8(self, value: u8) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u8(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit": [
            "fn serialize_unit(self) -> Result<()>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct": [
            "fn serialize_unit_struct(self, _name: &'static str) -> Result<()>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant": [
            "#[inline]\nfn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<()>{\n        self.ser.serialize_str(variant)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::PrettyFormatter<'a> as core::default::Default>::default": [
            "fn default() -> Self{\n        PrettyFormatter::new()\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array": [
            "#[inline]\nfn begin_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.current_indent += 1;\n        self.has_value = false;\n        writer.write_all(b\"[\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value": [
            "#[inline]\nfn begin_array_value<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        tri!(writer.write_all(if first { b\"\\n\" } else { b\",\\n\" }));\n        indent(writer, self.current_indent, self.indent)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object": [
            "#[inline]\nfn begin_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.current_indent += 1;\n        self.has_value = false;\n        writer.write_all(b\"{\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key": [
            "#[inline]\nfn begin_object_key<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        tri!(writer.write_all(if first { b\"\\n\" } else { b\",\\n\" }));\n        indent(writer, self.current_indent, self.indent)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value": [
            "#[inline]\nfn begin_object_value<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\": \")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_array": [
            "#[inline]\nfn end_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.current_indent -= 1;\n\n        if self.has_value {\n            tri!(writer.write_all(b\"\\n\"));\n            tri!(indent(writer, self.current_indent, self.indent));\n        }\n\n        writer.write_all(b\"]\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value": [
            "#[inline]\nfn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.has_value = true;\n        Ok(())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_object": [
            "#[inline]\nfn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.current_indent -= 1;\n\n        if self.has_value {\n            tri!(writer.write_all(b\"\\n\"));\n            tri!(indent(writer, self.current_indent, self.indent));\n        }\n\n        writer.write_all(b\"}\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value": [
            "#[inline]\nfn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.has_value = true;\n        Ok(())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "<str as value::index::Index>::index_into": [
            "fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>{\n        match v {\n            Value::Object(map) => map.get(self),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<str as value::index::Index>::index_into_mut": [
            "fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>{\n        match v {\n            Value::Object(map) => map.get_mut(self),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<str as value::index::Index>::index_or_insert": [
            "fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value{\n        if let Value::Null = v {\n            *v = Value::Object(Map::new());\n        }\n        match v {\n            Value::Object(map) => map.entry(self.to_owned()).or_insert(Value::Null),\n            _ => panic!(\"cannot access key {:?} in JSON {}\", self, Type(v)),\n        }\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<usize as value::index::Index>::index_into": [
            "fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>{\n        match v {\n            Value::Array(vec) => vec.get(*self),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<usize as value::index::Index>::index_into_mut": [
            "fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>{\n        match v {\n            Value::Array(vec) => vec.get_mut(*self),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<usize as value::index::Index>::index_or_insert": [
            "fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value{\n        match v {\n            Value::Array(vec) => {\n                let len = vec.len();\n                vec.get_mut(*self).unwrap_or_else(|| {\n                    panic!(\n                        \"cannot access index {} of JSON array of length {}\",\n                        self, len\n                    )\n                })\n            }\n            _ => panic!(\"cannot access index {} of JSON {}\", self, Type(v)),\n        }\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<value::Value as core::default::Default>::default": [
            "fn default() -> Value{\n        Value::Null\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "<value::Value as core::fmt::Debug>::fmt": [
            "fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            Value::Null => formatter.write_str(\"Null\"),\n            Value::Bool(boolean) => write!(formatter, \"Bool({})\", boolean),\n            Value::Number(number) => Debug::fmt(number, formatter),\n            Value::String(string) => write!(formatter, \"String({:?})\", string),\n            Value::Array(vec) => {\n                tri!(formatter.write_str(\"Array \"));\n                Debug::fmt(vec, formatter)\n            }\n            Value::Object(map) => {\n                tri!(formatter.write_str(\"Object \"));\n                Debug::fmt(map, formatter)\n            }\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "<value::Value as core::fmt::Display>::fmt": [
            "/// Display a JSON value as a string.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let json = json!({ \"city\": \"London\", \"street\": \"10 Downing Street\" });\n///\n/// // Compact format:\n/// //\n/// // {\"city\":\"London\",\"street\":\"10 Downing Street\"}\n/// let compact = format!(\"{}\", json);\n/// assert_eq!(compact,\n///     \"{\\\"city\\\":\\\"London\\\",\\\"street\\\":\\\"10 Downing Street\\\"}\");\n///\n/// // Pretty format:\n/// //\n/// // {\n/// //   \"city\": \"London\",\n/// //   \"street\": \"10 Downing Street\"\n/// // }\n/// let pretty = format!(\"{:#}\", json);\n/// assert_eq!(pretty,\n///     \"{\\n  \\\"city\\\": \\\"London\\\",\\n  \\\"street\\\": \\\"10 Downing Street\\\"\\n}\");\n/// ```\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        struct WriterFormatter<'a, 'b: 'a> {\n            inner: &'a mut fmt::Formatter<'b>,\n        }\n\n        impl<'a, 'b> io::Write for WriterFormatter<'a, 'b> {\n            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n                // Safety: the serializer below only emits valid utf8 when using\n                // the default formatter.\n                let s = unsafe { str::from_utf8_unchecked(buf) };\n                tri!(self.inner.write_str(s).map_err(io_error));\n                Ok(buf.len())\n            }\n\n            fn flush(&mut self) -> io::Result<()> {\n                Ok(())\n            }\n        }\n\n        fn io_error(_: fmt::Error) -> io::Error {\n            // Error value does not matter because Display impl just maps it\n            // back to fmt::Error.\n            io::Error::new(io::ErrorKind::Other, \"fmt error\")\n        }\n\n        let alternate = f.alternate();\n        let mut wr = WriterFormatter { inner: f };\n        if alternate {\n            // {:#}\n            super::ser::to_writer_pretty(&mut wr, self).map_err(|_| fmt::Error)\n        } else {\n            // {}\n            super::ser::to_writer(&mut wr, self).map_err(|_| fmt::Error)\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "<value::Value as core::fmt::Display>::fmt::WriterFormatter": [
            "struct WriterFormatter<'a, 'b: 'a> {\n            inner: &'a mut fmt::Formatter<'b>,\n        }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "<value::Value as core::fmt::Display>::fmt::io_error": [
            "fn io_error(_: fmt::Error) -> io::Error{\n            // Error value does not matter because Display impl just maps it\n            // back to fmt::Error.\n            io::Error::new(io::ErrorKind::Other, \"fmt error\")\n        }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting": [
            "fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n                formatter.write_str(\"any valid JSON value\")\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool": [
            "#[inline]\nfn visit_bool<E>(self, value: bool) -> Result<Value, E>{\n                Ok(Value::Bool(value))\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64": [
            "#[inline]\nfn visit_f64<E>(self, value: f64) -> Result<Value, E>{\n                Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i128": [
            "fn visit_i128<E>(self, value: i128) -> Result<Value, E>\n            where\n                E: serde::de::Error,{\n                let de = serde::de::value::I128Deserializer::new(value);\n                Number::deserialize(de).map(Value::Number)\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64": [
            "#[inline]\nfn visit_i64<E>(self, value: i64) -> Result<Value, E>{\n                Ok(Value::Number(value.into()))\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map": [
            "#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nfn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: MapAccess<'de>,{\n                match tri!(visitor.next_key_seed(KeyClassifier)) {\n                    #[cfg(feature = \"arbitrary_precision\")]\n                    Some(KeyClass::Number) => {\n                        let number: NumberFromString = tri!(visitor.next_value());\n                        Ok(Value::Number(number.value))\n                    }\n                    #[cfg(feature = \"raw_value\")]\n                    Some(KeyClass::RawValue) => {\n                        let value = tri!(visitor.next_value_seed(crate::raw::BoxedFromString));\n                        crate::from_str(value.get()).map_err(de::Error::custom)\n                    }\n                    Some(KeyClass::Map(first_key)) => {\n                        let mut values = Map::new();\n\n                        values.insert(first_key, tri!(visitor.next_value()));\n                        while let Some((key, value)) = tri!(visitor.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(Value::Object(values))\n                    }\n                    None => Ok(Value::Object(Map::new())),\n                }\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none": [
            "#[inline]\nfn visit_none<E>(self) -> Result<Value, E>{\n                Ok(Value::Null)\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq": [
            "#[inline]\nfn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: SeqAccess<'de>,{\n                let mut vec = Vec::new();\n\n                while let Some(elem) = tri!(visitor.next_element()) {\n                    vec.push(elem);\n                }\n\n                Ok(Value::Array(vec))\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some": [
            "#[inline]\nfn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: serde::Deserializer<'de>,{\n                Deserialize::deserialize(deserializer)\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str": [
            "#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[inline]\nfn visit_str<E>(self, value: &str) -> Result<Value, E>\n            where\n                E: serde::de::Error,{\n                self.visit_string(String::from(value))\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string": [
            "#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[inline]\nfn visit_string<E>(self, value: String) -> Result<Value, E>{\n                Ok(Value::String(value))\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u128": [
            "fn visit_u128<E>(self, value: u128) -> Result<Value, E>\n            where\n                E: serde::de::Error,{\n                let de = serde::de::value::U128Deserializer::new(value);\n                Number::deserialize(de).map(Value::Number)\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64": [
            "#[inline]\nfn visit_u64<E>(self, value: u64) -> Result<Value, E>{\n                Ok(Value::Number(value.into()))\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit": [
            "#[inline]\nfn visit_unit<E>(self) -> Result<Value, E>{\n                Ok(Value::Null)\n            }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any": [
            "fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,{\n        match self.value {\n            Cow::Borrowed(string) => visitor.visit_borrowed_str(string),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Cow::Owned(string) => visitor.visit_string(string),\n            #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n            Cow::Owned(_) => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum": [
            "fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,{\n        visitor.visit_enum(self)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed": [
            "fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Error>\n    where\n        T: de::DeserializeSeed<'de>,{\n        let value = tri!(seed.deserialize(self));\n        Ok((value, UnitOnly))\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed": [
            "fn variant_seed<V>(self, seed: V) -> Result<(V::Value, VariantDeserializer), Error>\n    where\n        V: DeserializeSeed<'de>,{\n        let variant = self.variant.into_deserializer();\n        let visitor = VariantDeserializer { value: self.value };\n        seed.deserialize(variant).map(|v| (v, visitor))\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed": [
            "fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Error>\n    where\n        V: DeserializeSeed<'de>,{\n        let variant = self.variant.into_deserializer();\n        let visitor = VariantRefDeserializer { value: self.value };\n        seed.deserialize(variant).map(|v| (v, visitor))\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize": [
            "fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: serde::Deserializer<'de>,{\n        deserializer.deserialize_str(self)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::KeyClassifier as serde::de::Visitor<'de>>::expecting": [
            "fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        formatter.write_str(\"a string key\")\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str": [
            "fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,{\n        match s {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(KeyClass::Number),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(KeyClass::RawValue),\n            _ => Ok(KeyClass::Map(s.to_owned())),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string": [
            "#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nfn visit_string<E>(self, s: String) -> Result<Self::Value, E>\n    where\n        E: de::Error,{\n        match s.as_str() {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(KeyClass::Number),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(KeyClass::RawValue),\n            _ => Ok(KeyClass::Map(s)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed": [
            "fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some(value);\n                let key_de = MapKeyDeserializer {\n                    key: Cow::Owned(key),\n                };\n                seed.deserialize(key_de).map(Some)\n            }\n            None => Ok(None),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed": [
            "fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.value.take() {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::custom(\"value is missing\")),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapDeserializer as serde::de::MapAccess<'de>>::size_hint": [
            "fn size_hint(&self) -> Option<usize>{\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any": [
            "fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        BorrowedCowStrDeserializer::new(self.key).deserialize_any(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool": [
            "fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        if self.key == \"true\" {\n            visitor.visit_bool(true)\n        } else if self.key == \"false\" {\n            visitor.visit_bool(false)\n        } else {\n            Err(serde::de::Error::invalid_type(\n                Unexpected::Str(&self.key),\n                &visitor,\n            ))\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum": [
            "fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.key\n            .into_deserializer()\n            .deserialize_enum(name, variants, visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "#[inline]\nfn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        visitor.visit_newtype_struct(self)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option": [
            "#[inline]\nfn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        // Map keys cannot be null.\n        visitor.visit_some(self)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            let mut de = crate::Deserializer::from_str(&self.key);\n\n            match tri!(de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),\n            }\n\n            let number = tri!(de.$using(visitor));\n\n            if tri!(de.peek()).is_some() {\n                return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));\n            }\n\n            Ok(number)\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed": [
            "fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some(value);\n                let key_de = MapKeyDeserializer {\n                    key: Cow::Borrowed(&**key),\n                };\n                seed.deserialize(key_de).map(Some)\n            }\n            None => Ok(None),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed": [
            "fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.value.take() {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::custom(\"value is missing\")),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::size_hint": [
            "fn size_hint(&self) -> Option<usize>{\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed": [
            "fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint": [
            "fn size_hint(&self) -> Option<usize>{\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed": [
            "fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::size_hint": [
            "fn size_hint(&self) -> Option<usize>{\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Error>\n    where\n        T: de::DeserializeSeed<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"newtype variant\",\n        ))\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant": [
            "fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"struct variant\",\n        ))\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant": [
            "fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"tuple variant\",\n        ))\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::unit_variant": [
            "fn unit_variant(self) -> Result<(), Error>{\n        Ok(())\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.value {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"newtype variant\",\n            )),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant": [
            "fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self.value {\n            Some(Value::Object(v)) => v.deserialize_any(visitor),\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"struct variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"struct variant\",\n            )),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant": [
            "fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self.value {\n            Some(Value::Array(v)) => {\n                if v.is_empty() {\n                    visitor.visit_unit()\n                } else {\n                    visit_array(v, visitor)\n                }\n            }\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"tuple variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"tuple variant\",\n            )),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::unit_variant": [
            "fn unit_variant(self) -> Result<(), Error>{\n        match self.value {\n            Some(value) => Deserialize::deserialize(value),\n            None => Ok(()),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.value {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"newtype variant\",\n            )),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant": [
            "fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self.value {\n            Some(Value::Object(v)) => v.deserialize_any(visitor),\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"struct variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"struct variant\",\n            )),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant": [
            "fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self.value {\n            Some(Value::Array(v)) => {\n                if v.is_empty() {\n                    visitor.visit_unit()\n                } else {\n                    visit_array_ref(v, visitor)\n                }\n            }\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"tuple variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"tuple variant\",\n            )),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::unit_variant": [
            "fn unit_variant(self) -> Result<(), Error>{\n        match self.value {\n            Some(value) => Deserialize::deserialize(value),\n            None => Ok(()),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "<value::index::Type<'a> as core::fmt::Display>::fmt": [
            "fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        match *self.0 {\n            Value::Null => formatter.write_str(\"null\"),\n            Value::Bool(_) => formatter.write_str(\"boolean\"),\n            Value::Number(_) => formatter.write_str(\"number\"),\n            Value::String(_) => formatter.write_str(\"string\"),\n            Value::Array(_) => formatter.write_str(\"array\"),\n            Value::Object(_) => formatter.write_str(\"object\"),\n        }\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::collect_str": [
            "fn collect_str<T>(self, value: &T) -> Result<String>\n    where\n        T: ?Sized + Display,{\n        Ok(value.to_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_bool": [
            "fn serialize_bool(self, value: bool) -> Result<String>{\n        Ok(if value { \"true\" } else { \"false\" }.to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_bytes": [
            "fn serialize_bytes(self, _value: &[u8]) -> Result<String>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_char": [
            "#[inline]\nfn serialize_char(self, value: char) -> Result<String>{\n        Ok({\n            let mut s = String::new();\n            s.push(value);\n            s\n        })\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_f32": [
            "fn serialize_f32(self, value: f32) -> Result<String>{\n        if value.is_finite() {\n            Ok(ryu::Buffer::new().format_finite(value).to_owned())\n        } else {\n            Err(float_key_must_be_finite())\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_f64": [
            "fn serialize_f64(self, value: f64) -> Result<String>{\n        if value.is_finite() {\n            Ok(ryu::Buffer::new().format_finite(value).to_owned())\n        } else {\n            Err(float_key_must_be_finite())\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i128": [
            "fn serialize_i128(self, value: i128) -> Result<String>{\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i16": [
            "fn serialize_i16(self, value: i16) -> Result<String>{\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i32": [
            "fn serialize_i32(self, value: i32) -> Result<String>{\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i64": [
            "fn serialize_i64(self, value: i64) -> Result<String>{\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i8": [
            "fn serialize_i8(self, value: i8) -> Result<String>{\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_map": [
            "fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct": [
            "#[inline]\nfn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<String>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant": [
            "fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<String>\n    where\n        T: ?Sized + Serialize,{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_none": [
            "fn serialize_none(self) -> Result<String>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_seq": [
            "fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_some": [
            "fn serialize_some<T>(self, _value: &T) -> Result<String>\n    where\n        T: ?Sized + Serialize,{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_str": [
            "#[inline]\nfn serialize_str(self, value: &str) -> Result<String>{\n        Ok(value.to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct": [
            "fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct_variant": [
            "fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple": [
            "fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_struct": [
            "fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_variant": [
            "fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u128": [
            "fn serialize_u128(self, value: u128) -> Result<String>{\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u16": [
            "fn serialize_u16(self, value: u16) -> Result<String>{\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u32": [
            "fn serialize_u32(self, value: u32) -> Result<String>{\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u64": [
            "fn serialize_u64(self, value: u64) -> Result<String>{\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u8": [
            "fn serialize_u8(self, value: u8) -> Result<String>{\n        Ok(itoa::Buffer::new().format(value).to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit": [
            "fn serialize_unit(self) -> Result<String>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_struct": [
            "fn serialize_unit_struct(self, _name: &'static str) -> Result<String>{\n        Err(key_must_be_a_string())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_variant": [
            "#[inline]\nfn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<String>{\n        Ok(variant.to_owned())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeMap>::end": [
            "fn end(self) -> Result<Value>{\n        match self {\n            SerializeMap::Map { map, .. } => Ok(Value::Object(map)),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key": [
            "fn serialize_key<T>(&mut self, key: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            SerializeMap::Map { next_key, .. } => {\n                *next_key = Some(tri!(key.serialize(MapKeySerializer)));\n                Ok(())\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value": [
            "fn serialize_value<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            SerializeMap::Map { map, next_key } => {\n                let key = next_key.take();\n                // Panic because this indicates a bug in the program rather than an\n                // expected failure.\n                let key = key.expect(\"serialize_value called before serialize_key\");\n                map.insert(key, tri!(to_value(value)));\n                Ok(())\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeStruct>::end": [
            "fn end(self) -> Result<Value>{\n        match self {\n            SerializeMap::Map { .. } => serde::ser::SerializeMap::end(self),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { out_value, .. } => {\n                Ok(out_value.expect(\"number value was not emitted\"))\n            }\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { out_value, .. } => {\n                Ok(out_value.expect(\"raw value was not emitted\"))\n            }\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field": [
            "fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            SerializeMap::Map { .. } => serde::ser::SerializeMap::serialize_entry(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { out_value } => {\n                if key == crate::number::TOKEN {\n                    *out_value = Some(tri!(value.serialize(NumberValueEmitter)));\n                    Ok(())\n                } else {\n                    Err(invalid_number())\n                }\n            }\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { out_value } => {\n                if key == crate::raw::TOKEN {\n                    *out_value = Some(tri!(value.serialize(RawValueEmitter)));\n                    Ok(())\n                } else {\n                    Err(invalid_raw_value())\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::end": [
            "fn end(self) -> Result<Value>{\n        let mut object = Map::new();\n\n        object.insert(self.name, Value::Object(self.map));\n\n        Ok(Value::Object(object))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field": [
            "fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        self.map.insert(String::from(key), tri!(to_value(value)));\n        Ok(())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::end": [
            "fn end(self) -> Result<Value>{\n        let mut object = Map::new();\n\n        object.insert(self.name, Value::Array(self.vec));\n\n        Ok(Value::Object(object))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field": [
            "fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        self.vec.push(tri!(to_value(value)));\n        Ok(())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeSeq>::end": [
            "fn end(self) -> Result<Value>{\n        Ok(Value::Array(self.vec))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element": [
            "fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        self.vec.push(tri!(to_value(value)));\n        Ok(())\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTuple>::end": [
            "fn end(self) -> Result<Value>{\n        serde::ser::SerializeSeq::end(self)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element": [
            "fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        serde::ser::SerializeSeq::serialize_element(self, value)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::end": [
            "fn end(self) -> Result<Value>{\n        serde::ser::SerializeSeq::end(self)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field": [
            "fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        serde::ser::SerializeSeq::serialize_element(self, value)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::collect_str": [
            "fn collect_str<T>(self, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Display,{\n        Ok(Value::String(value.to_string()))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_bool": [
            "#[inline]\nfn serialize_bool(self, value: bool) -> Result<Value>{\n        Ok(Value::Bool(value))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_bytes": [
            "fn serialize_bytes(self, value: &[u8]) -> Result<Value>{\n        let vec = value.iter().map(|&b| Value::Number(b.into())).collect();\n        Ok(Value::Array(vec))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_char": [
            "#[inline]\nfn serialize_char(self, value: char) -> Result<Value>{\n        let mut s = String::new();\n        s.push(value);\n        Ok(Value::String(s))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_f32": [
            "#[inline]\nfn serialize_f32(self, float: f32) -> Result<Value>{\n        Ok(Value::from(float))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_f64": [
            "#[inline]\nfn serialize_f64(self, float: f64) -> Result<Value>{\n        Ok(Value::from(float))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i128": [
            "fn serialize_i128(self, value: i128) -> Result<Value>{\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            Ok(Value::Number(value.into()))\n        }\n\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        {\n            if let Ok(value) = u64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else if let Ok(value) = i64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else {\n                Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))\n            }\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i16": [
            "#[inline]\nfn serialize_i16(self, value: i16) -> Result<Value>{\n        self.serialize_i64(value as i64)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i32": [
            "#[inline]\nfn serialize_i32(self, value: i32) -> Result<Value>{\n        self.serialize_i64(value as i64)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i64": [
            "fn serialize_i64(self, value: i64) -> Result<Value>{\n        Ok(Value::Number(value.into()))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i8": [
            "#[inline]\nfn serialize_i8(self, value: i8) -> Result<Value>{\n        self.serialize_i64(value as i64)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_map": [
            "fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap>{\n        Ok(SerializeMap::Map {\n            map: Map::with_capacity(len.unwrap_or(0)),\n            next_key: None,\n        })\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_newtype_struct": [
            "#[inline]\nfn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_newtype_variant": [
            "fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Value>\n    where\n        T: ?Sized + Serialize,{\n        let mut values = Map::new();\n        values.insert(String::from(variant), tri!(to_value(value)));\n        Ok(Value::Object(values))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_none": [
            "#[inline]\nfn serialize_none(self) -> Result<Value>{\n        self.serialize_unit()\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_seq": [
            "fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq>{\n        Ok(SerializeVec {\n            vec: Vec::with_capacity(len.unwrap_or(0)),\n        })\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_some": [
            "#[inline]\nfn serialize_some<T>(self, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_str": [
            "#[inline]\nfn serialize_str(self, value: &str) -> Result<Value>{\n        Ok(Value::String(value.to_owned()))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_struct": [
            "fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct>{\n        match name {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(SerializeMap::Number { out_value: None }),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(SerializeMap::RawValue { out_value: None }),\n            _ => self.serialize_map(Some(len)),\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_struct_variant": [
            "fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant>{\n        Ok(SerializeStructVariant {\n            name: String::from(variant),\n            map: Map::new(),\n        })\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_tuple": [
            "fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple>{\n        self.serialize_seq(Some(len))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_tuple_struct": [
            "fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct>{\n        self.serialize_seq(Some(len))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_tuple_variant": [
            "fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant>{\n        Ok(SerializeTupleVariant {\n            name: String::from(variant),\n            vec: Vec::with_capacity(len),\n        })\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u128": [
            "fn serialize_u128(self, value: u128) -> Result<Value>{\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            Ok(Value::Number(value.into()))\n        }\n\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        {\n            if let Ok(value) = u64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else {\n                Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))\n            }\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u16": [
            "#[inline]\nfn serialize_u16(self, value: u16) -> Result<Value>{\n        self.serialize_u64(value as u64)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u32": [
            "#[inline]\nfn serialize_u32(self, value: u32) -> Result<Value>{\n        self.serialize_u64(value as u64)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u64": [
            "#[inline]\nfn serialize_u64(self, value: u64) -> Result<Value>{\n        Ok(Value::Number(value.into()))\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u8": [
            "#[inline]\nfn serialize_u8(self, value: u8) -> Result<Value>{\n        self.serialize_u64(value as u64)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_unit": [
            "#[inline]\nfn serialize_unit(self) -> Result<Value>{\n        Ok(Value::Null)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_unit_struct": [
            "#[inline]\nfn serialize_unit_struct(self, _name: &'static str) -> Result<Value>{\n        self.serialize_unit()\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_unit_variant": [
            "#[inline]\nfn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Value>{\n        self.serialize_str(variant)\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "de::<impl core::str::FromStr for number::Number>::from_str": [
            "fn from_str(s: &str) -> result::Result<Self, Self::Err>{\n        Deserializer::from_str(s)\n            .parse_any_signed_number()\n            .map(Into::into)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer": [
            "/// A structure that deserializes JSON into Rust values.\npub struct Deserializer<R> {\n    read: R,\n    scratch: Vec<u8>,\n    remaining_depth: u8,\n    #[cfg(feature = \"float_roundtrip\")]\n    single_precision: bool,\n    #[cfg(feature = \"unbounded_depth\")]\n    disable_recursion_limit: bool,\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::deserialize_number": [
            "pub(crate) fn deserialize_number<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'-' => {\n                self.eat_char();\n                tri!(self.parse_integer(false)).visit(visitor)\n            }\n            b'0'..=b'9' => tri!(self.parse_integer(true)).visit(visitor),\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::do_deserialize_i128": [
            "pub(crate) fn do_deserialize_i128<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,{\n        let mut buf = String::new();\n\n        match tri!(self.parse_whitespace()) {\n            Some(b'-') => {\n                self.eat_char();\n                buf.push('-');\n            }\n            Some(_) => {}\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        }\n\n        tri!(self.scan_integer128(&mut buf));\n\n        let value = match buf.parse() {\n            Ok(int) => visitor.visit_i128(int),\n            Err(_) => {\n                return Err(self.error(ErrorCode::NumberOutOfRange));\n            }\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::do_deserialize_u128": [
            "pub(crate) fn do_deserialize_u128<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,{\n        match tri!(self.parse_whitespace()) {\n            Some(b'-') => {\n                return Err(self.peek_error(ErrorCode::NumberOutOfRange));\n            }\n            Some(_) => {}\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        }\n\n        let mut buf = String::new();\n        tri!(self.scan_integer128(&mut buf));\n\n        let value = match buf.parse() {\n            Ok(int) => visitor.visit_u128(int),\n            Err(_) => {\n                return Err(self.error(ErrorCode::NumberOutOfRange));\n            }\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::eat_char": [
            "fn eat_char(&mut self){\n        self.read.discard();\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::end": [
            "/// The `Deserializer::end` method should be called after a value has been fully deserialized.\n/// This allows the `Deserializer` to validate that the input stream is at the end or that it\n/// only has trailing whitespace.\npub fn end(&mut self) -> Result<()>{\n        match tri!(self.parse_whitespace()) {\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Ok(()),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::end_map": [
            "fn end_map(&mut self) -> Result<()>{\n        match tri!(self.parse_whitespace()) {\n            Some(b'}') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(b',') => Err(self.peek_error(ErrorCode::TrailingComma)),\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::end_seq": [
            "fn end_seq(&mut self) -> Result<()>{\n        match tri!(self.parse_whitespace()) {\n            Some(b']') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(b',') => {\n                self.eat_char();\n                match self.parse_whitespace() {\n                    Ok(Some(b']')) => Err(self.peek_error(ErrorCode::TrailingComma)),\n                    _ => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n                }\n            }\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingList)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::error": [
            "/// Error caused by a byte from next_char().\n#[cold]\nfn error(&self, reason: ErrorCode) -> Error{\n        let position = self.read.position();\n        Error::syntax(reason, position.line, position.column)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::f64_from_parts": [
            "#[cfg(not(feature = \"float_roundtrip\"))]\nfn f64_from_parts(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        mut exponent: i32,\n    ) -> Result<f64>{\n        let mut f = significand as f64;\n        loop {\n            match POW10.get(exponent.wrapping_abs() as usize) {\n                Some(&pow) => {\n                    if exponent >= 0 {\n                        f *= pow;\n                        if f.is_infinite() {\n                            return Err(self.error(ErrorCode::NumberOutOfRange));\n                        }\n                    } else {\n                        f /= pow;\n                    }\n                    break;\n                }\n                None => {\n                    if f == 0.0 {\n                        break;\n                    }\n                    if exponent >= 0 {\n                        return Err(self.error(ErrorCode::NumberOutOfRange));\n                    }\n                    f /= 1e308;\n                    exponent += 308;\n                }\n            }\n        }\n        Ok(if positive { f } else { -f })\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::fix_position": [
            "#[cold]\nfn fix_position(&self, err: Error) -> Error{\n        err.fix_position(move |code| self.error(code))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::ignore_decimal": [
            "fn ignore_decimal(&mut self) -> Result<()>{\n        self.eat_char();\n\n        let mut at_least_one_digit = false;\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            at_least_one_digit = true;\n        }\n\n        if !at_least_one_digit {\n            return Err(self.peek_error(ErrorCode::InvalidNumber));\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.ignore_exponent(),\n            _ => Ok(()),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::ignore_exponent": [
            "fn ignore_exponent(&mut self) -> Result<()>{\n        self.eat_char();\n\n        match tri!(self.peek_or_null()) {\n            b'+' | b'-' => self.eat_char(),\n            _ => {}\n        }\n\n        // Make sure a digit follows the exponent place.\n        match tri!(self.next_char_or_null()) {\n            b'0'..=b'9' => {}\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        }\n\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n\n        Ok(())\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::ignore_integer": [
            "fn ignore_integer(&mut self) -> Result<()>{\n        match tri!(self.next_char_or_null()) {\n            b'0' => {\n                // There can be only one leading '0'.\n                if let b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    return Err(self.peek_error(ErrorCode::InvalidNumber));\n                }\n            }\n            b'1'..=b'9' => {\n                while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    self.eat_char();\n                }\n            }\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'.' => self.ignore_decimal(),\n            b'e' | b'E' => self.ignore_exponent(),\n            _ => Ok(()),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::ignore_value": [
            "fn ignore_value(&mut self) -> Result<()>{\n        self.scratch.clear();\n        let mut enclosing = None;\n\n        loop {\n            let peek = match tri!(self.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n                }\n            };\n\n            let frame = match peek {\n                b'n' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"ull\"));\n                    None\n                }\n                b't' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"rue\"));\n                    None\n                }\n                b'f' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"alse\"));\n                    None\n                }\n                b'-' => {\n                    self.eat_char();\n                    tri!(self.ignore_integer());\n                    None\n                }\n                b'0'..=b'9' => {\n                    tri!(self.ignore_integer());\n                    None\n                }\n                b'\"' => {\n                    self.eat_char();\n                    tri!(self.read.ignore_str());\n                    None\n                }\n                frame @ (b'[' | b'{') => {\n                    self.scratch.extend(enclosing.take());\n                    self.eat_char();\n                    Some(frame)\n                }\n                _ => return Err(self.peek_error(ErrorCode::ExpectedSomeValue)),\n            };\n\n            let (mut accept_comma, mut frame) = match frame {\n                Some(frame) => (false, frame),\n                None => match enclosing.take() {\n                    Some(frame) => (true, frame),\n                    None => match self.scratch.pop() {\n                        Some(frame) => (true, frame),\n                        None => return Ok(()),\n                    },\n                },\n            };\n\n            loop {\n                match tri!(self.parse_whitespace()) {\n                    Some(b',') if accept_comma => {\n                        self.eat_char();\n                        break;\n                    }\n                    Some(b']') if frame == b'[' => {}\n                    Some(b'}') if frame == b'{' => {}\n                    Some(_) => {\n                        if accept_comma {\n                            return Err(self.peek_error(match frame {\n                                b'[' => ErrorCode::ExpectedListCommaOrEnd,\n                                b'{' => ErrorCode::ExpectedObjectCommaOrEnd,\n                                _ => unreachable!(),\n                            }));\n                        } else {\n                            break;\n                        }\n                    }\n                    None => {\n                        return Err(self.peek_error(match frame {\n                            b'[' => ErrorCode::EofWhileParsingList,\n                            b'{' => ErrorCode::EofWhileParsingObject,\n                            _ => unreachable!(),\n                        }));\n                    }\n                }\n\n                self.eat_char();\n                frame = match self.scratch.pop() {\n                    Some(frame) => frame,\n                    None => return Ok(()),\n                };\n                accept_comma = true;\n            }\n\n            if frame == b'{' {\n                match tri!(self.parse_whitespace()) {\n                    Some(b'\"') => self.eat_char(),\n                    Some(_) => return Err(self.peek_error(ErrorCode::KeyMustBeAString)),\n                    None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n                }\n                tri!(self.read.ignore_str());\n                match tri!(self.parse_whitespace()) {\n                    Some(b':') => self.eat_char(),\n                    Some(_) => return Err(self.peek_error(ErrorCode::ExpectedColon)),\n                    None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n                }\n            }\n\n            enclosing = Some(frame);\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::into_iter": [
            "/// Turn a JSON deserializer into an iterator over values of type T.\npub fn into_iter<T>(self) -> StreamDeserializer<'de, R, T>\n    where\n        T: de::Deserialize<'de>,{\n        // This cannot be an implementation of std::iter::IntoIterator because\n        // we need the caller to choose what T is.\n        let offset = self.read.byte_offset();\n        StreamDeserializer {\n            de: self,\n            offset,\n            failed: false,\n            output: PhantomData,\n            lifetime: PhantomData,\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::new": [
            "/// Create a JSON deserializer from one of the possible serde_json input\n/// sources.\n///\n/// When reading from a source against which short reads are not efficient, such\n/// as a [`File`], you will want to apply your own buffering because serde_json\n/// will not buffer the input. See [`std::io::BufReader`].\n///\n/// Typically it is more convenient to use one of these methods instead:\n///\n///   - Deserializer::from_str\n///   - Deserializer::from_slice\n///   - Deserializer::from_reader\n///\n/// [`File`]: std::fs::File\npub fn new(read: R) -> Self{\n        Deserializer {\n            read,\n            scratch: Vec::new(),\n            remaining_depth: 128,\n            #[cfg(feature = \"float_roundtrip\")]\n            single_precision: false,\n            #[cfg(feature = \"unbounded_depth\")]\n            disable_recursion_limit: false,\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::next_char": [
            "fn next_char(&mut self) -> Result<Option<u8>>{\n        self.read.next()\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::next_char_or_null": [
            "fn next_char_or_null(&mut self) -> Result<u8>{\n        Ok(tri!(self.next_char()).unwrap_or(b'\\x00'))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_any_number": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn parse_any_number(&mut self, positive: bool) -> Result<ParserNumber>{\n        self.parse_integer(positive)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_any_signed_number": [
            "fn parse_any_signed_number(&mut self) -> Result<ParserNumber>{\n        let peek = match tri!(self.peek()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'-' => {\n                self.eat_char();\n                self.parse_any_number(false)\n            }\n            b'0'..=b'9' => self.parse_any_number(true),\n            _ => Err(self.peek_error(ErrorCode::InvalidNumber)),\n        };\n\n        let value = match tri!(self.peek()) {\n            Some(_) => Err(self.peek_error(ErrorCode::InvalidNumber)),\n            None => value,\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            // The de::Error impl creates errors with unknown line and column.\n            // Fill in the position here by looking at the current index in the\n            // input. There is no way to tell whether this should call `error`\n            // or `peek_error` so pick the one that seems correct more often.\n            // Worst case, the position is off by one character.\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_decimal": [
            "fn parse_decimal(\n        &mut self,\n        positive: bool,\n        mut significand: u64,\n        exponent_before_decimal_point: i32,\n    ) -> Result<f64>{\n        self.eat_char();\n\n        let mut exponent_after_decimal_point = 0;\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            let digit = (c - b'0') as u64;\n\n            if overflow!(significand * 10 + digit, u64::MAX) {\n                let exponent = exponent_before_decimal_point + exponent_after_decimal_point;\n                return self.parse_decimal_overflow(positive, significand, exponent);\n            }\n\n            self.eat_char();\n            significand = significand * 10 + digit;\n            exponent_after_decimal_point -= 1;\n        }\n\n        // Error if there is not at least one digit after the decimal point.\n        if exponent_after_decimal_point == 0 {\n            match tri!(self.peek()) {\n                Some(_) => return Err(self.peek_error(ErrorCode::InvalidNumber)),\n                None => return Err(self.peek_error(ErrorCode::EofWhileParsingValue)),\n            }\n        }\n\n        let exponent = exponent_before_decimal_point + exponent_after_decimal_point;\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.parse_exponent(positive, significand, exponent),\n            _ => self.f64_from_parts(positive, significand, exponent),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_decimal_overflow": [
            "#[cfg(not(feature = \"float_roundtrip\"))]\n#[cold]\n#[inline(never)]\nfn parse_decimal_overflow(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        exponent: i32,\n    ) -> Result<f64>{\n        // The next multiply/add would overflow, so just ignore all further\n        // digits.\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.parse_exponent(positive, significand, exponent),\n            _ => self.f64_from_parts(positive, significand, exponent),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_exponent": [
            "fn parse_exponent(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        starting_exp: i32,\n    ) -> Result<f64>{\n        self.eat_char();\n\n        let positive_exp = match tri!(self.peek_or_null()) {\n            b'+' => {\n                self.eat_char();\n                true\n            }\n            b'-' => {\n                self.eat_char();\n                false\n            }\n            _ => true,\n        };\n\n        let next = match tri!(self.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        // Make sure a digit follows the exponent place.\n        let mut exp = match next {\n            c @ b'0'..=b'9' => (c - b'0') as i32,\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        };\n\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            let digit = (c - b'0') as i32;\n\n            if overflow!(exp * 10 + digit, i32::MAX) {\n                let zero_significand = significand == 0;\n                return self.parse_exponent_overflow(positive, zero_significand, positive_exp);\n            }\n\n            exp = exp * 10 + digit;\n        }\n\n        let final_exp = if positive_exp {\n            starting_exp.saturating_add(exp)\n        } else {\n            starting_exp.saturating_sub(exp)\n        };\n\n        self.f64_from_parts(positive, significand, final_exp)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_exponent_overflow": [
            "#[cold]\n#[inline(never)]\nfn parse_exponent_overflow(\n        &mut self,\n        positive: bool,\n        zero_significand: bool,\n        positive_exp: bool,\n    ) -> Result<f64>{\n        // Error instead of +/- infinity.\n        if !zero_significand && positive_exp {\n            return Err(self.error(ErrorCode::NumberOutOfRange));\n        }\n\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n        Ok(if positive { 0.0 } else { -0.0 })\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_ident": [
            "fn parse_ident(&mut self, ident: &[u8]) -> Result<()>{\n        for expected in ident {\n            match tri!(self.next_char()) {\n                None => {\n                    return Err(self.error(ErrorCode::EofWhileParsingValue));\n                }\n                Some(next) => {\n                    if next != *expected {\n                        return Err(self.error(ErrorCode::ExpectedSomeIdent));\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_integer": [
            "fn parse_integer(&mut self, positive: bool) -> Result<ParserNumber>{\n        let next = match tri!(self.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        match next {\n            b'0' => {\n                // There can be only one leading '0'.\n                match tri!(self.peek_or_null()) {\n                    b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),\n                    _ => self.parse_number(positive, 0),\n                }\n            }\n            c @ b'1'..=b'9' => {\n                let mut significand = (c - b'0') as u64;\n\n                loop {\n                    match tri!(self.peek_or_null()) {\n                        c @ b'0'..=b'9' => {\n                            let digit = (c - b'0') as u64;\n\n                            // We need to be careful with overflow. If we can,\n                            // try to keep the number as a `u64` until we grow\n                            // too large. At that point, switch to parsing the\n                            // value as a `f64`.\n                            if overflow!(significand * 10 + digit, u64::MAX) {\n                                return Ok(ParserNumber::F64(tri!(\n                                    self.parse_long_integer(positive, significand),\n                                )));\n                            }\n\n                            self.eat_char();\n                            significand = significand * 10 + digit;\n                        }\n                        _ => {\n                            return self.parse_number(positive, significand);\n                        }\n                    }\n                }\n            }\n            _ => Err(self.error(ErrorCode::InvalidNumber)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_long_integer": [
            "#[cfg(not(feature = \"float_roundtrip\"))]\n#[cold]\n#[inline(never)]\nfn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64>{\n        let mut exponent = 0;\n        loop {\n            match tri!(self.peek_or_null()) {\n                b'0'..=b'9' => {\n                    self.eat_char();\n                    // This could overflow... if your integer is gigabytes long.\n                    // Ignore that possibility.\n                    exponent += 1;\n                }\n                b'.' => {\n                    return self.parse_decimal(positive, significand, exponent);\n                }\n                b'e' | b'E' => {\n                    return self.parse_exponent(positive, significand, exponent);\n                }\n                _ => {\n                    return self.f64_from_parts(positive, significand, exponent);\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_number": [
            "fn parse_number(&mut self, positive: bool, significand: u64) -> Result<ParserNumber>{\n        Ok(match tri!(self.peek_or_null()) {\n            b'.' => ParserNumber::F64(tri!(self.parse_decimal(positive, significand, 0))),\n            b'e' | b'E' => ParserNumber::F64(tri!(self.parse_exponent(positive, significand, 0))),\n            _ => {\n                if positive {\n                    ParserNumber::U64(significand)\n                } else {\n                    let neg = (significand as i64).wrapping_neg();\n\n                    // Convert into a float if we underflow, or on `-0`.\n                    if neg >= 0 {\n                        ParserNumber::F64(-(significand as f64))\n                    } else {\n                        ParserNumber::I64(neg)\n                    }\n                }\n            }\n        })\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_object_colon": [
            "fn parse_object_colon(&mut self) -> Result<()>{\n        match tri!(self.parse_whitespace()) {\n            Some(b':') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(_) => Err(self.peek_error(ErrorCode::ExpectedColon)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::parse_whitespace": [
            "/// Returns the first non-whitespace byte without consuming it, or `None` if\n/// EOF is encountered.\nfn parse_whitespace(&mut self) -> Result<Option<u8>>{\n        loop {\n            match tri!(self.peek()) {\n                Some(b' ' | b'\\n' | b'\\t' | b'\\r') => {\n                    self.eat_char();\n                }\n                other => {\n                    return Ok(other);\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::peek": [
            "pub(crate) fn peek(&mut self) -> Result<Option<u8>>{\n        self.read.peek()\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::peek_error": [
            "/// Error caused by a byte from peek().\n#[cold]\nfn peek_error(&self, reason: ErrorCode) -> Error{\n        let position = self.read.peek_position();\n        Error::syntax(reason, position.line, position.column)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::peek_invalid_type": [
            "#[cold]\nfn peek_invalid_type(&mut self, exp: &dyn Expected) -> Error{\n        let err = match self.peek_or_null().unwrap_or(b'\\x00') {\n            b'n' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"ull\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Unit, exp)\n            }\n            b't' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"rue\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Bool(true), exp)\n            }\n            b'f' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"alse\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Bool(false), exp)\n            }\n            b'-' => {\n                self.eat_char();\n                match self.parse_any_number(false) {\n                    Ok(n) => n.invalid_type(exp),\n                    Err(err) => return err,\n                }\n            }\n            b'0'..=b'9' => match self.parse_any_number(true) {\n                Ok(n) => n.invalid_type(exp),\n                Err(err) => return err,\n            },\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match self.read.parse_str(&mut self.scratch) {\n                    Ok(s) => de::Error::invalid_type(Unexpected::Str(&s), exp),\n                    Err(err) => return err,\n                }\n            }\n            b'[' => de::Error::invalid_type(Unexpected::Seq, exp),\n            b'{' => de::Error::invalid_type(Unexpected::Map, exp),\n            _ => self.peek_error(ErrorCode::ExpectedSomeValue),\n        };\n\n        self.fix_position(err)\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::peek_or_null": [
            "fn peek_or_null(&mut self) -> Result<u8>{\n        Ok(tri!(self.peek()).unwrap_or(b'\\x00'))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<R>::scan_integer128": [
            "fn scan_integer128(&mut self, buf: &mut String) -> Result<()>{\n        match tri!(self.next_char_or_null()) {\n            b'0' => {\n                buf.push('0');\n                // There can be only one leading '0'.\n                match tri!(self.peek_or_null()) {\n                    b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),\n                    _ => Ok(()),\n                }\n            }\n            c @ b'1'..=b'9' => {\n                buf.push(c as char);\n                while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    self.eat_char();\n                    buf.push(c as char);\n                }\n                Ok(())\n            }\n            _ => Err(self.error(ErrorCode::InvalidNumber)),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<read::IoRead<R>>::from_reader": [
            "/// Creates a JSON deserializer from an `io::Read`.\n///\n/// Reader-based deserializers do not support deserializing borrowed types\n/// like `&str`, since the `std::io::Read` trait has no non-copying methods\n/// -- everything it does involves copying bytes out of the data source.\npub fn from_reader(reader: R) -> Self{\n        Deserializer::new(read::IoRead::new(reader))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<read::SliceRead<'a>>::from_slice": [
            "/// Creates a JSON deserializer from a `&[u8]`.\npub fn from_slice(bytes: &'a [u8]) -> Self{\n        Deserializer::new(read::SliceRead::new(bytes))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::Deserializer::<read::StrRead<'a>>::from_str": [
            "/// Creates a JSON deserializer from a `&str`.\npub fn from_str(s: &'a str) -> Self{\n        Deserializer::new(read::StrRead::new(s))\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::MapAccess": [
            "struct MapAccess<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n    first: bool,\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::MapAccess::<'a, R>::new": [
            "fn new(de: &'a mut Deserializer<R>) -> Self{\n        MapAccess { de, first: true }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::MapKey": [
            "/// Only deserialize from this after peeking a '\"' byte! Otherwise it may\n/// deserialize invalid JSON successfully.\nstruct MapKey<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::MapKey::<'a, R>::deserialize_number": [
            "fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n\n            match tri!(self.de.peek()) {\n                Some(b'0'..=b'9' | b'-') => {}\n                _ => return Err(self.de.error(ErrorCode::ExpectedNumericKey)),\n            }\n\n            let value = tri!(self.de.$delegate(visitor));\n\n            match tri!(self.de.peek()) {\n                Some(b'\"') => self.de.eat_char(),\n                _ => return Err(self.de.peek_error(ErrorCode::ExpectedDoubleQuote)),\n            }\n\n            Ok(value)\n        }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::ParserNumber": [
            "pub(crate) enum ParserNumber {\n    F64(f64),\n    U64(u64),\n    I64(i64),\n    #[cfg(feature = \"arbitrary_precision\")]\n    String(String),\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::ParserNumber::invalid_type": [
            "fn invalid_type(self, exp: &dyn Expected) -> Error{\n        match self {\n            ParserNumber::F64(x) => de::Error::invalid_type(Unexpected::Float(x), exp),\n            ParserNumber::U64(x) => de::Error::invalid_type(Unexpected::Unsigned(x), exp),\n            ParserNumber::I64(x) => de::Error::invalid_type(Unexpected::Signed(x), exp),\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(_) => de::Error::invalid_type(Unexpected::Other(\"number\"), exp),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::ParserNumber::visit": [
            "fn visit<'de, V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        match self {\n            ParserNumber::F64(x) => visitor.visit_f64(x),\n            ParserNumber::U64(x) => visitor.visit_u64(x),\n            ParserNumber::I64(x) => visitor.visit_i64(x),\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(x) => visitor.visit_map(NumberDeserializer { number: x.into() }),\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::SeqAccess": [
            "struct SeqAccess<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n    first: bool,\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::SeqAccess::<'a, R>::new": [
            "fn new(de: &'a mut Deserializer<R>) -> Self{\n        SeqAccess { de, first: true }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::StreamDeserializer": [
            "/// Iterator that deserializes a stream into multiple JSON values.\n///\n/// A stream deserializer can be created from any JSON deserializer using the\n/// `Deserializer::into_iter` method.\n///\n/// The data can consist of any JSON value. Values need to be a self-delineating value e.g.\n/// arrays, objects, or strings, or be followed by whitespace or a self-delineating value.\n///\n/// ```\n/// use serde_json::{Deserializer, Value};\n///\n/// fn main() {\n///     let data = \"{\\\"k\\\": 3}1\\\"cool\\\"\\\"stuff\\\" 3{}  [0, 1, 2]\";\n///\n///     let stream = Deserializer::from_str(data).into_iter::<Value>();\n///\n///     for value in stream {\n///         println!(\"{}\", value.unwrap());\n///     }\n/// }\n/// ```\npub struct StreamDeserializer<'de, R, T> {\n    de: Deserializer<R>,\n    offset: usize,\n    failed: bool,\n    output: PhantomData<T>,\n    lifetime: PhantomData<&'de ()>,\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::StreamDeserializer::<'de, R, T>::byte_offset": [
            "/// Returns the number of bytes so far deserialized into a successful `T`.\n///\n/// If a stream deserializer returns an EOF error, new data can be joined to\n/// `old_data[stream.byte_offset()..]` to try again.\n///\n/// ```\n/// let data = b\"[0] [1] [\";\n///\n/// let de = serde_json::Deserializer::from_slice(data);\n/// let mut stream = de.into_iter::<Vec<i32>>();\n/// assert_eq!(0, stream.byte_offset());\n///\n/// println!(\"{:?}\", stream.next()); // [0]\n/// assert_eq!(3, stream.byte_offset());\n///\n/// println!(\"{:?}\", stream.next()); // [1]\n/// assert_eq!(7, stream.byte_offset());\n///\n/// println!(\"{:?}\", stream.next()); // error\n/// assert_eq!(8, stream.byte_offset());\n///\n/// // If err.is_eof(), can join the remaining data to new data and continue.\n/// let remaining = &data[stream.byte_offset()..];\n/// ```\n///\n/// *Note:* In the future this method may be changed to return the number of\n/// bytes so far deserialized into a successful T *or* syntactically valid\n/// JSON skipped over due to a type error. See [serde-rs/json#70] for an\n/// example illustrating this.\n///\n/// [serde-rs/json#70]: https://github.com/serde-rs/json/issues/70\npub fn byte_offset(&self) -> usize{\n        self.offset\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::StreamDeserializer::<'de, R, T>::new": [
            "/// Create a JSON stream deserializer from one of the possible serde_json\n/// input sources.\n///\n/// Typically it is more convenient to use one of these methods instead:\n///\n///   - Deserializer::from_str(...).into_iter()\n///   - Deserializer::from_slice(...).into_iter()\n///   - Deserializer::from_reader(...).into_iter()\npub fn new(read: R) -> Self{\n        let offset = read.byte_offset();\n        StreamDeserializer {\n            de: Deserializer::new(read),\n            offset,\n            failed: false,\n            output: PhantomData,\n            lifetime: PhantomData,\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::StreamDeserializer::<'de, R, T>::peek_end_of_value": [
            "fn peek_end_of_value(&mut self) -> Result<()>{\n        match tri!(self.de.peek()) {\n            Some(b' ' | b'\\n' | b'\\t' | b'\\r' | b'\"' | b'[' | b']' | b'{' | b'}' | b',' | b':')\n            | None => Ok(()),\n            Some(_) => {\n                let position = self.de.read.peek_position();\n                Err(Error::syntax(\n                    ErrorCode::TrailingCharacters,\n                    position.line,\n                    position.column,\n                ))\n            }\n        }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::UnitVariantAccess": [
            "struct UnitVariantAccess<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::UnitVariantAccess::<'a, R>::new": [
            "fn new(de: &'a mut Deserializer<R>) -> Self{\n        UnitVariantAccess { de }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::VariantAccess": [
            "struct VariantAccess<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::VariantAccess::<'a, R>::new": [
            "fn new(de: &'a mut Deserializer<R>) -> Self{\n        VariantAccess { de }\n    }",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::from_reader": [
            "/// Deserialize an instance of type `T` from an I/O stream of JSON.\n///\n/// The content of the I/O stream is deserialized directly from the stream\n/// without being buffered in memory by serde_json.\n///\n/// When reading from a source against which short reads are not efficient, such\n/// as a [`File`], you will want to apply your own buffering because serde_json\n/// will not buffer the input. See [`std::io::BufReader`].\n///\n/// It is expected that the input stream ends after the deserialized object.\n/// If the stream does not end, such as in the case of a persistent socket connection,\n/// this function will not return. It is possible instead to deserialize from a prefix of an input\n/// stream without looking for EOF by managing your own [`Deserializer`].\n///\n/// Note that counter to intuition, this function is usually slower than\n/// reading a file completely into memory and then applying [`from_str`]\n/// or [`from_slice`] on it. See [issue #160].\n///\n/// [`File`]: std::fs::File\n/// [issue #160]: https://github.com/serde-rs/json/issues/160\n///\n/// # Example\n///\n/// Reading the contents of a file.\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// use std::error::Error;\n/// use std::fs::File;\n/// use std::io::BufReader;\n/// use std::path::Path;\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn read_user_from_file<P: AsRef<Path>>(path: P) -> Result<User, Box<dyn Error>> {\n///     // Open the file in read-only mode with buffer.\n///     let file = File::open(path)?;\n///     let reader = BufReader::new(file);\n///\n///     // Read the JSON contents of the file as an instance of `User`.\n///     let u = serde_json::from_reader(reader)?;\n///\n///     // Return the `User`.\n///     Ok(u)\n/// }\n///\n/// fn main() {\n/// # }\n/// # fn fake_main() {\n///     let u = read_user_from_file(\"test.json\").unwrap();\n///     println!(\"{:#?}\", u);\n/// }\n/// ```\n///\n/// Reading from a persistent socket connection.\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// use std::error::Error;\n/// use std::io::BufReader;\n/// use std::net::{TcpListener, TcpStream};\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn read_user_from_stream(stream: &mut BufReader<TcpStream>) -> Result<User, Box<dyn Error>> {\n///     let mut de = serde_json::Deserializer::from_reader(stream);\n///     let u = User::deserialize(&mut de)?;\n///\n///     Ok(u)\n/// }\n///\n/// fn main() {\n/// # }\n/// # fn fake_main() {\n///     let listener = TcpListener::bind(\"127.0.0.1:4000\").unwrap();\n///\n///     for tcp_stream in listener.incoming() {\n///         let mut buffered = BufReader::new(tcp_stream.unwrap());\n///         println!(\"{:#?}\", read_user_from_stream(&mut buffered));\n///     }\n/// }\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the input does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the input\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\n#[cfg(feature = \"std\")]\npub fn from_reader<R, T>(rdr: R) -> Result<T>\nwhere\n    R: crate::io::Read,\n    T: de::DeserializeOwned,{\n    from_trait(read::IoRead::new(rdr))\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::from_slice": [
            "/// Deserialize an instance of type `T` from bytes of JSON text.\n///\n/// # Example\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn main() {\n///     // The type of `j` is `&[u8]`\n///     let j = b\"\n///         {\n///             \\\"fingerprint\\\": \\\"0xF9BA143B95FF6D82\\\",\n///             \\\"location\\\": \\\"Menlo Park, CA\\\"\n///         }\";\n///\n///     let u: User = serde_json::from_slice(j).unwrap();\n///     println!(\"{:#?}\", u);\n/// }\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the input does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the input\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\npub fn from_slice<'a, T>(v: &'a [u8]) -> Result<T>\nwhere\n    T: de::Deserialize<'a>,{\n    from_trait(read::SliceRead::new(v))\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::from_str": [
            "/// Deserialize an instance of type `T` from a string of JSON text.\n///\n/// # Example\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn main() {\n///     // The type of `j` is `&str`\n///     let j = \"\n///         {\n///             \\\"fingerprint\\\": \\\"0xF9BA143B95FF6D82\\\",\n///             \\\"location\\\": \\\"Menlo Park, CA\\\"\n///         }\";\n///\n///     let u: User = serde_json::from_str(j).unwrap();\n///     println!(\"{:#?}\", u);\n/// }\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the input does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the input\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\npub fn from_str<'a, T>(s: &'a str) -> Result<T>\nwhere\n    T: de::Deserialize<'a>,{\n    from_trait(read::StrRead::new(s))\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "de::from_trait": [
            "fn from_trait<'de, R, T>(read: R) -> Result<T>\nwhere\n    R: Read<'de>,\n    T: de::Deserialize<'de>,{\n    let mut de = Deserializer::new(read);\n    let value = tri!(de::Deserialize::deserialize(&mut de));\n\n    // Make sure the whole stream has been consumed.\n    tri!(de.end());\n    Ok(value)\n}",
            "Real(LocalPath(\"src/de.rs\"))"
        ],
        "error::<impl core::convert::From<error::Error> for std::io::Error>::from": [
            "/// Convert a `serde_json::Error` into an `io::Error`.\n///\n/// JSON syntax and data errors are turned into `InvalidData` I/O errors.\n/// EOF errors are turned into `UnexpectedEof` I/O errors.\n///\n/// ```\n/// use std::io;\n///\n/// enum MyError {\n///     Io(io::Error),\n///     Json(serde_json::Error),\n/// }\n///\n/// impl From<serde_json::Error> for MyError {\n///     fn from(err: serde_json::Error) -> MyError {\n///         use serde_json::error::Category;\n///         match err.classify() {\n///             Category::Io => {\n///                 MyError::Io(err.into())\n///             }\n///             Category::Syntax | Category::Data | Category::Eof => {\n///                 MyError::Json(err)\n///             }\n///         }\n///     }\n/// }\n/// ```\nfn from(j: Error) -> Self{\n        if let ErrorCode::Io(err) = j.err.code {\n            err\n        } else {\n            match j.classify() {\n                Category::Io => unreachable!(),\n                Category::Syntax | Category::Data => io::Error::new(ErrorKind::InvalidData, j),\n                Category::Eof => io::Error::new(ErrorKind::UnexpectedEof, j),\n            }\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Category": [
            "/// Categorizes the cause of a `serde_json::Error`.\npub enum Category {\n    /// The error was caused by a failure to read or write bytes on an I/O\n    /// stream.\n    Io,\n\n    /// The error was caused by input that was not syntactically valid JSON.\n    Syntax,\n\n    /// The error was caused by input data that was semantically incorrect.\n    ///\n    /// For example, JSON containing a number is semantically incorrect when the\n    /// type being deserialized into holds a String.\n    Data,\n\n    /// The error was caused by prematurely reaching the end of the input data.\n    ///\n    /// Callers that process streaming input may be interested in retrying the\n    /// deserialization once more data is available.\n    Eof,\n}",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error": [
            "/// This type represents all possible errors that can occur when serializing or\n/// deserializing JSON data.\npub struct Error {\n    /// This `Box` allows us to keep the size of `Error` as small as possible. A\n    /// larger `Error` type was substantially slower due to all the functions\n    /// that pass around `Result<T, Error>`.\n    err: Box<ErrorImpl>,\n}",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::classify": [
            "/// Categorizes the cause of this error.\n///\n/// - `Category::Io` - failure to read or write bytes on an I/O stream\n/// - `Category::Syntax` - input that is not syntactically valid JSON\n/// - `Category::Data` - input data that is semantically incorrect\n/// - `Category::Eof` - unexpected end of the input data\npub fn classify(&self) -> Category{\n        match self.err.code {\n            ErrorCode::Message(_) => Category::Data,\n            ErrorCode::Io(_) => Category::Io,\n            ErrorCode::EofWhileParsingList\n            | ErrorCode::EofWhileParsingObject\n            | ErrorCode::EofWhileParsingString\n            | ErrorCode::EofWhileParsingValue => Category::Eof,\n            ErrorCode::ExpectedColon\n            | ErrorCode::ExpectedListCommaOrEnd\n            | ErrorCode::ExpectedObjectCommaOrEnd\n            | ErrorCode::ExpectedSomeIdent\n            | ErrorCode::ExpectedSomeValue\n            | ErrorCode::ExpectedDoubleQuote\n            | ErrorCode::InvalidEscape\n            | ErrorCode::InvalidNumber\n            | ErrorCode::NumberOutOfRange\n            | ErrorCode::InvalidUnicodeCodePoint\n            | ErrorCode::ControlCharacterWhileParsingString\n            | ErrorCode::KeyMustBeAString\n            | ErrorCode::ExpectedNumericKey\n            | ErrorCode::FloatKeyMustBeFinite\n            | ErrorCode::LoneLeadingSurrogateInHexEscape\n            | ErrorCode::TrailingComma\n            | ErrorCode::TrailingCharacters\n            | ErrorCode::UnexpectedEndOfHexEscape\n            | ErrorCode::RecursionLimitExceeded => Category::Syntax,\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::column": [
            "/// One-based column number at which the error was detected.\n///\n/// The first character in the input and any characters immediately\n/// following a newline character are in column 1.\n///\n/// Note that errors may occur in column 0, for example if a read from an\n/// I/O stream fails immediately following a previously read newline\n/// character.\npub fn column(&self) -> usize{\n        self.err.column\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::fix_position": [
            "#[cold]\npub(crate) fn fix_position<F>(self, f: F) -> Self\n    where\n        F: FnOnce(ErrorCode) -> Error,{\n        if self.err.line == 0 {\n            f(self.err.code)\n        } else {\n            self\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::io": [
            "#[doc(hidden)]\n#[cold]\npub fn io(error: io::Error) -> Self{\n        Error {\n            err: Box::new(ErrorImpl {\n                code: ErrorCode::Io(error),\n                line: 0,\n                column: 0,\n            }),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::io_error_kind": [
            "/// The kind reported by the underlying standard library I/O error, if this\n/// error was caused by a failure to read or write bytes on an I/O stream.\n///\n/// # Example\n///\n/// ```\n/// use serde_json::Value;\n/// use std::io::{self, ErrorKind, Read};\n/// use std::process;\n///\n/// struct ReaderThatWillTimeOut<'a>(&'a [u8]);\n///\n/// impl<'a> Read for ReaderThatWillTimeOut<'a> {\n///     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n///         if self.0.is_empty() {\n///             Err(io::Error::new(ErrorKind::TimedOut, \"timed out\"))\n///         } else {\n///             self.0.read(buf)\n///         }\n///     }\n/// }\n///\n/// fn main() {\n///     let reader = ReaderThatWillTimeOut(br#\" {\"k\": \"#);\n///\n///     let _: Value = match serde_json::from_reader(reader) {\n///         Ok(value) => value,\n///         Err(error) => {\n///             if error.io_error_kind() == Some(ErrorKind::TimedOut) {\n///                 // Maybe this application needs to retry certain kinds of errors.\n///\n///                 # return;\n///             } else {\n///                 eprintln!(\"error: {}\", error);\n///                 process::exit(1);\n///             }\n///         }\n///     };\n/// }\n/// ```\n#[cfg(feature = \"std\")]\npub fn io_error_kind(&self) -> Option<ErrorKind>{\n        if let ErrorCode::Io(io_error) = &self.err.code {\n            Some(io_error.kind())\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::is_data": [
            "/// Returns true if this error was caused by input data that was\n/// semantically incorrect.\n///\n/// For example, JSON containing a number is semantically incorrect when the\n/// type being deserialized into holds a String.\npub fn is_data(&self) -> bool{\n        self.classify() == Category::Data\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::is_eof": [
            "/// Returns true if this error was caused by prematurely reaching the end of\n/// the input data.\n///\n/// Callers that process streaming input may be interested in retrying the\n/// deserialization once more data is available.\npub fn is_eof(&self) -> bool{\n        self.classify() == Category::Eof\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::is_io": [
            "/// Returns true if this error was caused by a failure to read or write\n/// bytes on an I/O stream.\npub fn is_io(&self) -> bool{\n        self.classify() == Category::Io\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::is_syntax": [
            "/// Returns true if this error was caused by input that was not\n/// syntactically valid JSON.\npub fn is_syntax(&self) -> bool{\n        self.classify() == Category::Syntax\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::line": [
            "/// One-based line number at which the error was detected.\n///\n/// Characters in the first line of the input (before the first newline\n/// character) are in line 1.\npub fn line(&self) -> usize{\n        self.err.line\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::syntax": [
            "#[cold]\npub(crate) fn syntax(code: ErrorCode, line: usize, column: usize) -> Self{\n        Error {\n            err: Box::new(ErrorImpl { code, line, column }),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::ErrorCode": [
            "pub(crate) enum ErrorCode {\n    /// Catchall for syntax error messages\n    Message(Box<str>),\n\n    /// Some I/O error occurred while serializing or deserializing.\n    Io(io::Error),\n\n    /// EOF while parsing a list.\n    EofWhileParsingList,\n\n    /// EOF while parsing an object.\n    EofWhileParsingObject,\n\n    /// EOF while parsing a string.\n    EofWhileParsingString,\n\n    /// EOF while parsing a JSON value.\n    EofWhileParsingValue,\n\n    /// Expected this character to be a `':'`.\n    ExpectedColon,\n\n    /// Expected this character to be either a `','` or a `']'`.\n    ExpectedListCommaOrEnd,\n\n    /// Expected this character to be either a `','` or a `'}'`.\n    ExpectedObjectCommaOrEnd,\n\n    /// Expected to parse either a `true`, `false`, or a `null`.\n    ExpectedSomeIdent,\n\n    /// Expected this character to start a JSON value.\n    ExpectedSomeValue,\n\n    /// Expected this character to be a `\"`.\n    ExpectedDoubleQuote,\n\n    /// Invalid hex escape code.\n    InvalidEscape,\n\n    /// Invalid number.\n    InvalidNumber,\n\n    /// Number is bigger than the maximum value of its type.\n    NumberOutOfRange,\n\n    /// Invalid unicode code point.\n    InvalidUnicodeCodePoint,\n\n    /// Control character found while parsing a string.\n    ControlCharacterWhileParsingString,\n\n    /// Object key is not a string.\n    KeyMustBeAString,\n\n    /// Contents of key were supposed to be a number.\n    ExpectedNumericKey,\n\n    /// Object key is a non-finite float value.\n    FloatKeyMustBeFinite,\n\n    /// Lone leading surrogate in hex escape.\n    LoneLeadingSurrogateInHexEscape,\n\n    /// JSON has a comma after the last value in an array or map.\n    TrailingComma,\n\n    /// JSON has non-whitespace trailing characters after the value.\n    TrailingCharacters,\n\n    /// Unexpected end of hex escape.\n    UnexpectedEndOfHexEscape,\n\n    /// Encountered nesting of JSON maps and arrays more than 128 layers deep.\n    RecursionLimitExceeded,\n}",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::ErrorImpl": [
            "struct ErrorImpl {\n    code: ErrorCode,\n    line: usize,\n    column: usize,\n}",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::JsonUnexpected": [
            "struct JsonUnexpected<'a>(de::Unexpected<'a>);",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::make_error": [
            "fn make_error(mut msg: String) -> Error{\n    let (line, column) = parse_line_col(&mut msg).unwrap_or((0, 0));\n    Error {\n        err: Box::new(ErrorImpl {\n            code: ErrorCode::Message(msg.into_boxed_str()),\n            line,\n            column,\n        }),\n    }\n}",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::parse_line_col": [
            "fn parse_line_col(msg: &mut String) -> Option<(usize, usize)>{\n    let start_of_suffix = match msg.rfind(\" at line \") {\n        Some(index) => index,\n        None => return None,\n    };\n\n    // Find start and end of line number.\n    let start_of_line = start_of_suffix + \" at line \".len();\n    let mut end_of_line = start_of_line;\n    while starts_with_digit(&msg[end_of_line..]) {\n        end_of_line += 1;\n    }\n\n    if !msg[end_of_line..].starts_with(\" column \") {\n        return None;\n    }\n\n    // Find start and end of column number.\n    let start_of_column = end_of_line + \" column \".len();\n    let mut end_of_column = start_of_column;\n    while starts_with_digit(&msg[end_of_column..]) {\n        end_of_column += 1;\n    }\n\n    if end_of_column < msg.len() {\n        return None;\n    }\n\n    // Parse numbers.\n    let line = match usize::from_str(&msg[start_of_line..end_of_line]) {\n        Ok(line) => line,\n        Err(_) => return None,\n    };\n    let column = match usize::from_str(&msg[start_of_column..end_of_column]) {\n        Ok(column) => column,\n        Err(_) => return None,\n    };\n\n    msg.truncate(start_of_suffix);\n    Some((line, column))\n}",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::starts_with_digit": [
            "fn starts_with_digit(slice: &str) -> bool{\n    match slice.as_bytes().first() {\n        None => false,\n        Some(&byte) => byte >= b'0' && byte <= b'9',\n    }\n}",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "iter::LineColIterator": [
            "pub struct LineColIterator<I> {\n    iter: I,\n\n    /// Index of the current line. Characters in the first line of the input\n    /// (before the first newline character) are in line 1.\n    line: usize,\n\n    /// Index of the current column. The first character in the input and any\n    /// characters immediately following a newline character are in column 1.\n    /// The column is 0 immediately after a newline character has been read.\n    col: usize,\n\n    /// Byte offset of the start of the current line. This is the sum of lengths\n    /// of all previous lines. Keeping track of things this way allows efficient\n    /// computation of the current line, column, and byte offset while only\n    /// updating one of the counters in `next()` in the common case.\n    start_of_line: usize,\n}",
            "Real(LocalPath(\"src/iter.rs\"))"
        ],
        "iter::LineColIterator::<I>::byte_offset": [
            "pub fn byte_offset(&self) -> usize{\n        self.start_of_line + self.col\n    }",
            "Real(LocalPath(\"src/iter.rs\"))"
        ],
        "iter::LineColIterator::<I>::col": [
            "pub fn col(&self) -> usize{\n        self.col\n    }",
            "Real(LocalPath(\"src/iter.rs\"))"
        ],
        "iter::LineColIterator::<I>::line": [
            "pub fn line(&self) -> usize{\n        self.line\n    }",
            "Real(LocalPath(\"src/iter.rs\"))"
        ],
        "iter::LineColIterator::<I>::new": [
            "pub fn new(iter: I) -> LineColIterator<I>{\n        LineColIterator {\n            iter,\n            line: 1,\n            col: 0,\n            start_of_line: 0,\n        }\n    }",
            "Real(LocalPath(\"src/iter.rs\"))"
        ],
        "map::Entry": [
            "/// A view into a single entry in a map, which may either be vacant or occupied.\n/// This enum is constructed from the [`entry`] method on [`Map`].\n///\n/// [`entry`]: Map::entry\npub enum Entry<'a> {\n    /// A vacant Entry.\n    Vacant(VacantEntry<'a>),\n    /// An occupied Entry.\n    Occupied(OccupiedEntry<'a>),\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Entry::<'a>::and_modify": [
            "/// Provides in-place mutable access to an occupied entry before any\n/// potential inserts into the map.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut map = serde_json::Map::new();\n/// map.entry(\"serde\")\n///     .and_modify(|e| *e = json!(\"rust\"))\n///     .or_insert(json!(\"cpp\"));\n///\n/// assert_eq!(map[\"serde\"], \"cpp\");\n///\n/// map.entry(\"serde\")\n///     .and_modify(|e| *e = json!(\"rust\"))\n///     .or_insert(json!(\"cpp\"));\n///\n/// assert_eq!(map[\"serde\"], \"rust\");\n/// ```\npub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut Value),{\n        match self {\n            Entry::Occupied(mut entry) => {\n                f(entry.get_mut());\n                Entry::Occupied(entry)\n            }\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Entry::<'a>::key": [
            "/// Returns a reference to this entry's key.\n///\n/// # Examples\n///\n/// ```\n/// let mut map = serde_json::Map::new();\n/// assert_eq!(map.entry(\"serde\").key(), &\"serde\");\n/// ```\npub fn key(&self) -> &String{\n        match self {\n            Entry::Vacant(e) => e.key(),\n            Entry::Occupied(e) => e.key(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Entry::<'a>::or_insert": [
            "/// Ensures a value is in the entry by inserting the default if empty, and\n/// returns a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut map = serde_json::Map::new();\n/// map.entry(\"serde\").or_insert(json!(12));\n///\n/// assert_eq!(map[\"serde\"], 12);\n/// ```\npub fn or_insert(self, default: Value) -> &'a mut Value{\n        match self {\n            Entry::Vacant(entry) => entry.insert(default),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Entry::<'a>::or_insert_with": [
            "/// Ensures a value is in the entry by inserting the result of the default\n/// function if empty, and returns a mutable reference to the value in the\n/// entry.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut map = serde_json::Map::new();\n/// map.entry(\"serde\").or_insert_with(|| json!(\"hoho\"));\n///\n/// assert_eq!(map[\"serde\"], \"hoho\".to_owned());\n/// ```\npub fn or_insert_with<F>(self, default: F) -> &'a mut Value\n    where\n        F: FnOnce() -> Value,{\n        match self {\n            Entry::Vacant(entry) => entry.insert(default()),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IntoIter": [
            "/// An owning iterator over a serde_json::Map's entries.\npub struct IntoIter {\n    iter: IntoIterImpl,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IntoValues": [
            "/// An owning iterator over a serde_json::Map's values.\npub struct IntoValues {\n    iter: IntoValuesImpl,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Iter": [
            "/// An iterator over a serde_json::Map's entries.\npub struct Iter<'a> {\n    iter: IterImpl<'a>,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IterMut": [
            "/// A mutable iterator over a serde_json::Map's entries.\npub struct IterMut<'a> {\n    iter: IterMutImpl<'a>,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Keys": [
            "/// An iterator over a serde_json::Map's keys.\npub struct Keys<'a> {\n    iter: KeysImpl<'a>,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map": [
            "/// Represents a JSON key/value type.\npub struct Map<K, V> {\n    map: MapImpl<K, V>,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::append": [
            "/// Moves all elements from other into self, leaving other empty.\n#[inline]\npub fn append(&mut self, other: &mut Self){\n        #[cfg(feature = \"preserve_order\")]\n        self.map\n            .extend(mem::replace(&mut other.map, MapImpl::default()));\n        #[cfg(not(feature = \"preserve_order\"))]\n        self.map.append(&mut other.map);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::clear": [
            "/// Clears the map, removing all values.\n#[inline]\npub fn clear(&mut self){\n        self.map.clear();\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::contains_key": [
            "/// Returns true if the map contains a value for the specified key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        self.map.contains_key(key)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::entry": [
            "/// Gets the given key's corresponding entry in the map for in-place\n/// manipulation.\npub fn entry<S>(&mut self, key: S) -> Entry\n    where\n        S: Into<String>,{\n        #[cfg(not(feature = \"preserve_order\"))]\n        use alloc::collections::btree_map::Entry as EntryImpl;\n        #[cfg(feature = \"preserve_order\")]\n        use indexmap::map::Entry as EntryImpl;\n\n        match self.map.entry(key.into()) {\n            EntryImpl::Vacant(vacant) => Entry::Vacant(VacantEntry { vacant }),\n            EntryImpl::Occupied(occupied) => Entry::Occupied(OccupiedEntry { occupied }),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::get": [
            "/// Returns a reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        self.map.get(key)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::get_key_value": [
            "/// Returns the key-value pair matching the given key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn get_key_value<Q>(&self, key: &Q) -> Option<(&String, &Value)>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        self.map.get_key_value(key)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::get_mut": [
            "/// Returns a mutable reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        self.map.get_mut(key)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::insert": [
            "/// Inserts a key-value pair into the map.\n///\n/// If the map did not have this key present, `None` is returned.\n///\n/// If the map did have this key present, the value is updated, and the old\n/// value is returned.\n#[inline]\npub fn insert(&mut self, k: String, v: Value) -> Option<Value>{\n        self.map.insert(k, v)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::into_values": [
            "/// Gets an iterator over the values of the map.\n#[inline]\npub fn into_values(self) -> IntoValues{\n        IntoValues {\n            iter: self.map.into_values(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::is_empty": [
            "/// Returns true if the map contains no elements.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.map.is_empty()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::iter": [
            "/// Gets an iterator over the entries of the map.\n#[inline]\npub fn iter(&self) -> Iter{\n        Iter {\n            iter: self.map.iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::iter_mut": [
            "/// Gets a mutable iterator over the entries of the map.\n#[inline]\npub fn iter_mut(&mut self) -> IterMut{\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::keys": [
            "/// Gets an iterator over the keys of the map.\n#[inline]\npub fn keys(&self) -> Keys{\n        Keys {\n            iter: self.map.keys(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::len": [
            "/// Returns the number of elements in the map.\n#[inline]\npub fn len(&self) -> usize{\n        self.map.len()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::new": [
            "/// Makes a new empty Map.\n#[inline]\npub fn new() -> Self{\n        Map {\n            map: MapImpl::new(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::remove": [
            "/// Removes a key from the map, returning the value at the key if the key\n/// was previously in the map.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n///\n/// If serde_json's \"preserve_order\" is enabled, `.remove(key)` is\n/// equivalent to [`.swap_remove(key)`][Self::swap_remove], replacing this\n/// entry's position with the last element. If you need to preserve the\n/// relative order of the keys in the map, use\n/// [`.shift_remove(key)`][Self::shift_remove] instead.\n#[inline]\npub fn remove<Q>(&mut self, key: &Q) -> Option<Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        #[cfg(feature = \"preserve_order\")]\n        return self.swap_remove(key);\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.map.remove(key);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::remove_entry": [
            "/// Removes a key from the map, returning the stored key and value if the\n/// key was previously in the map.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n///\n/// If serde_json's \"preserve_order\" is enabled, `.remove_entry(key)` is\n/// equivalent to [`.swap_remove_entry(key)`][Self::swap_remove_entry],\n/// replacing this entry's position with the last element. If you need to\n/// preserve the relative order of the keys in the map, use\n/// [`.shift_remove_entry(key)`][Self::shift_remove_entry] instead.\n#[inline]\npub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(String, Value)>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        #[cfg(feature = \"preserve_order\")]\n        return self.swap_remove_entry(key);\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.map.remove_entry(key);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::retain": [
            "/// Retains only the elements specified by the predicate.\n///\n/// In other words, remove all pairs `(k, v)` such that `f(&k, &mut v)`\n/// returns `false`.\n#[inline]\npub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&String, &mut Value) -> bool,{\n        self.map.retain(f);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::sort_keys": [
            "/// Sorts this map's entries in-place using `str`'s usual ordering.\n///\n/// If serde_json's \"preserve_order\" feature is not enabled, this method\n/// does no work because all JSON maps are always kept in a sorted state.\n///\n/// If serde_json's \"preserve_order\" feature is enabled, this method\n/// destroys the original source order or insertion order of this map in\n/// favor of an alphanumerical order that matches how a BTreeMap with the\n/// same contents would be ordered. This takes **O(n log n + c)** time where\n/// _n_ is the length of the map and _c_ is the capacity.\n///\n/// Other maps nested within the values of this map are not sorted. If you\n/// need the entire data structure to be sorted at all levels, you must also\n/// call\n/// <code>map.[values_mut]\\().for_each([Value::sort_all_objects])</code>.\n///\n/// [values_mut]: Map::values_mut\n#[inline]\npub fn sort_keys(&mut self){\n        #[cfg(feature = \"preserve_order\")]\n        self.map.sort_unstable_keys();\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::values": [
            "/// Gets an iterator over the values of the map.\n#[inline]\npub fn values(&self) -> Values{\n        Values {\n            iter: self.map.values(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::values_mut": [
            "/// Gets an iterator over mutable values of the map.\n#[inline]\npub fn values_mut(&mut self) -> ValuesMut{\n        ValuesMut {\n            iter: self.map.values_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Map::<alloc::string::String, value::Value>::with_capacity": [
            "/// Makes a new empty Map with the given initial capacity.\n#[inline]\npub fn with_capacity(capacity: usize) -> Self{\n        Map {\n            #[cfg(not(feature = \"preserve_order\"))]\n            map: {\n                // does not support with_capacity\n                let _ = capacity;\n                BTreeMap::new()\n            },\n            #[cfg(feature = \"preserve_order\")]\n            map: IndexMap::with_capacity(capacity),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::OccupiedEntry": [
            "/// An occupied Entry. It is part of the [`Entry`] enum.\npub struct OccupiedEntry<'a> {\n    occupied: OccupiedEntryImpl<'a>,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::OccupiedEntry::<'a>::get": [
            "/// Gets a reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!(12));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(occupied) => {\n///         assert_eq!(occupied.get(), 12);\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn get(&self) -> &Value{\n        self.occupied.get()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::OccupiedEntry::<'a>::get_mut": [
            "/// Gets a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!([1, 2, 3]));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(mut occupied) => {\n///         occupied.get_mut().as_array_mut().unwrap().push(json!(4));\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n///\n/// assert_eq!(map[\"serde\"].as_array().unwrap().len(), 4);\n/// ```\n#[inline]\npub fn get_mut(&mut self) -> &mut Value{\n        self.occupied.get_mut()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::OccupiedEntry::<'a>::insert": [
            "/// Sets the value of the entry with the `OccupiedEntry`'s key, and returns\n/// the entry's old value.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!(12));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(mut occupied) => {\n///         assert_eq!(occupied.insert(json!(13)), 12);\n///         assert_eq!(occupied.get(), 13);\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn insert(&mut self, value: Value) -> Value{\n        self.occupied.insert(value)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::OccupiedEntry::<'a>::into_mut": [
            "/// Converts the entry into a mutable reference to its value.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!([1, 2, 3]));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(mut occupied) => {\n///         occupied.into_mut().as_array_mut().unwrap().push(json!(4));\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n///\n/// assert_eq!(map[\"serde\"].as_array().unwrap().len(), 4);\n/// ```\n#[inline]\npub fn into_mut(self) -> &'a mut Value{\n        self.occupied.into_mut()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::OccupiedEntry::<'a>::key": [
            "/// Gets a reference to the key in the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!(12));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(occupied) => {\n///         assert_eq!(occupied.key(), &\"serde\");\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn key(&self) -> &String{\n        self.occupied.key()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::OccupiedEntry::<'a>::remove": [
            "/// Takes the value of the entry out of the map, and returns it.\n///\n/// If serde_json's \"preserve_order\" is enabled, `.remove()` is\n/// equivalent to [`.swap_remove()`][Self::swap_remove], replacing this\n/// entry's position with the last element. If you need to preserve the\n/// relative order of the keys in the map, use\n/// [`.shift_remove()`][Self::shift_remove] instead.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!(12));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(occupied) => {\n///         assert_eq!(occupied.remove(), 12);\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn remove(self) -> Value{\n        #[cfg(feature = \"preserve_order\")]\n        return self.swap_remove();\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.occupied.remove();\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::OccupiedEntry::<'a>::remove_entry": [
            "/// Removes the entry from the map, returning the stored key and value.\n///\n/// If serde_json's \"preserve_order\" is enabled, `.remove_entry()` is\n/// equivalent to [`.swap_remove_entry()`][Self::swap_remove_entry],\n/// replacing this entry's position with the last element. If you need to\n/// preserve the relative order of the keys in the map, use\n/// [`.shift_remove_entry()`][Self::shift_remove_entry] instead.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!(12));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(occupied) => {\n///         let (key, value) = occupied.remove_entry();\n///         assert_eq!(key, \"serde\");\n///         assert_eq!(value, 12);\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn remove_entry(self) -> (String, Value){\n        #[cfg(feature = \"preserve_order\")]\n        return self.swap_remove_entry();\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.occupied.remove_entry();\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::VacantEntry": [
            "/// A vacant Entry. It is part of the [`Entry`] enum.\npub struct VacantEntry<'a> {\n    vacant: VacantEntryImpl<'a>,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::VacantEntry::<'a>::insert": [
            "/// Sets the value of the entry with the VacantEntry's key, and returns a\n/// mutable reference to it.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n///\n/// match map.entry(\"serde\") {\n///     Entry::Vacant(vacant) => {\n///         vacant.insert(json!(\"hoho\"));\n///     }\n///     Entry::Occupied(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn insert(self, value: Value) -> &'a mut Value{\n        self.vacant.insert(value)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::VacantEntry::<'a>::key": [
            "/// Gets a reference to the key that would be used when inserting a value\n/// through the VacantEntry.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n///\n/// match map.entry(\"serde\") {\n///     Entry::Vacant(vacant) => {\n///         assert_eq!(vacant.key(), &\"serde\");\n///     }\n///     Entry::Occupied(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn key(&self) -> &String{\n        self.vacant.key()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::Values": [
            "/// An iterator over a serde_json::Map's values.\npub struct Values<'a> {\n    iter: ValuesImpl<'a>,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::ValuesMut": [
            "/// A mutable iterator over a serde_json::Map's values.\npub struct ValuesMut<'a> {\n    iter: ValuesMutImpl<'a>,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "number::N": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nenum N {\n    PosInt(u64),\n    /// Always less than zero.\n    NegInt(i64),\n    /// Always finite.\n    Float(f64),\n}",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number": [
            "/// Represents a JSON number, whether integer or floating point.\npub struct Number {\n    n: N,\n}",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::as_f32": [
            "pub(crate) fn as_f32(&self) -> Option<f32>{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as f32),\n            N::NegInt(n) => Some(n as f32),\n            N::Float(n) => Some(n as f32),\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse::<f32>().ok().filter(|float| float.is_finite())\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::as_f64": [
            "/// Represents the number as f64 if possible. Returns None otherwise.\npub fn as_f64(&self) -> Option<f64>{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as f64),\n            N::NegInt(n) => Some(n as f64),\n            N::Float(n) => Some(n),\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse::<f64>().ok().filter(|float| float.is_finite())\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::as_i128": [
            "/// If the `Number` is an integer, represent it as i128 if possible. Returns\n/// None otherwise.\npub fn as_i128(&self) -> Option<i128>{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as i128),\n            N::NegInt(n) => Some(n as i128),\n            N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::as_i64": [
            "/// If the `Number` is an integer, represent it as i64 if possible. Returns\n/// None otherwise.\npub fn as_i64(&self) -> Option<i64>{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => {\n                if n <= i64::MAX as u64 {\n                    Some(n as i64)\n                } else {\n                    None\n                }\n            }\n            N::NegInt(n) => Some(n),\n            N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::as_u128": [
            "/// If the `Number` is an integer, represent it as u128 if possible. Returns\n/// None otherwise.\npub fn as_u128(&self) -> Option<u128>{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as u128),\n            N::NegInt(_) | N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::as_u64": [
            "/// If the `Number` is an integer, represent it as u64 if possible. Returns\n/// None otherwise.\npub fn as_u64(&self) -> Option<u64>{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n),\n            N::NegInt(_) | N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::from_f32": [
            "pub(crate) fn from_f32(f: f32) -> Option<Number>{\n        if f.is_finite() {\n            let n = {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f as f64)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    ryu::Buffer::new().format_finite(f).to_owned()\n                }\n            };\n            Some(Number { n })\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::from_f64": [
            "/// Converts a finite `f64` to a `Number`. Infinite or NaN values are not JSON\n/// numbers.\n///\n/// ```\n/// # use serde_json::Number;\n/// #\n/// assert!(Number::from_f64(256.0).is_some());\n///\n/// assert!(Number::from_f64(f64::NAN).is_none());\n/// ```\npub fn from_f64(f: f64) -> Option<Number>{\n        if f.is_finite() {\n            let n = {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    ryu::Buffer::new().format_finite(f).to_owned()\n                }\n            };\n            Some(Number { n })\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::from_i128": [
            "/// Converts an `i128` to a `Number`. Numbers smaller than i64::MIN or\n/// larger than u64::MAX can only be represented in `Number` if serde_json's\n/// \"arbitrary_precision\" feature is enabled.\n///\n/// ```\n/// # use serde_json::Number;\n/// #\n/// assert!(Number::from_i128(256).is_some());\n/// ```\npub fn from_i128(i: i128) -> Option<Number>{\n        let n = {\n            #[cfg(not(feature = \"arbitrary_precision\"))]\n            {\n                if let Ok(u) = u64::try_from(i) {\n                    N::PosInt(u)\n                } else if let Ok(i) = i64::try_from(i) {\n                    N::NegInt(i)\n                } else {\n                    return None;\n                }\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            {\n                i.to_string()\n            }\n        };\n        Some(Number { n })\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::from_u128": [
            "/// Converts a `u128` to a `Number`. Numbers greater than u64::MAX can only\n/// be represented in `Number` if serde_json's \"arbitrary_precision\" feature\n/// is enabled.\n///\n/// ```\n/// # use serde_json::Number;\n/// #\n/// assert!(Number::from_u128(256).is_some());\n/// ```\npub fn from_u128(i: u128) -> Option<Number>{\n        let n = {\n            #[cfg(not(feature = \"arbitrary_precision\"))]\n            {\n                if let Ok(u) = u64::try_from(i) {\n                    N::PosInt(u)\n                } else {\n                    return None;\n                }\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            {\n                i.to_string()\n            }\n        };\n        Some(Number { n })\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::is_f64": [
            "/// Returns true if the `Number` can be represented by f64.\n///\n/// For any Number on which `is_f64` returns true, `as_f64` is guaranteed to\n/// return the floating point value.\n///\n/// Currently this function returns true if and only if both `is_i64` and\n/// `is_u64` return false but this is not a guarantee in the future.\npub fn is_f64(&self) -> bool{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::Float(_) => true,\n            N::PosInt(_) | N::NegInt(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            for c in self.n.chars() {\n                if c == '.' || c == 'e' || c == 'E' {\n                    return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);\n                }\n            }\n            false\n        }\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::is_i64": [
            "/// Returns true if the `Number` is an integer between `i64::MIN` and\n/// `i64::MAX`.\n///\n/// For any Number on which `is_i64` returns true, `as_i64` is guaranteed to\n/// return the integer value.\npub fn is_i64(&self) -> bool{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(v) => v <= i64::MAX as u64,\n            N::NegInt(_) => true,\n            N::Float(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.as_i64().is_some()\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::is_u64": [
            "/// Returns true if the `Number` is an integer between zero and `u64::MAX`.\n///\n/// For any Number on which `is_u64` returns true, `as_u64` is guaranteed to\n/// return the integer value.\npub fn is_u64(&self) -> bool{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(_) => true,\n            N::NegInt(_) | N::Float(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.as_u64().is_some()\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "number::Number::unexpected": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\n#[cold]\npub(crate) fn unexpected(&self) -> Unexpected{\n        match self.n {\n            N::PosInt(u) => Unexpected::Unsigned(u),\n            N::NegInt(i) => Unexpected::Signed(i),\n            N::Float(f) => Unexpected::Float(f),\n        }\n    }",
            "Real(LocalPath(\"src/number.rs\"))"
        ],
        "read::Fused": [
            "/// Marker for whether StreamDeserializer can implement FusedIterator.\npub trait Fused: private::Sealed {}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::IoRead": [
            "/// JSON input source that reads from a std::io input stream.\n#[cfg(feature = \"std\")]\npub struct IoRead<R>\nwhere\n    R: io::Read,\n{\n    iter: LineColIterator<io::Bytes<R>>,\n    /// Temporary storage of peeked byte.\n    ch: Option<u8>,\n    #[cfg(feature = \"raw_value\")]\n    raw_buffer: Option<Vec<u8>>,\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::IoRead::<R>::new": [
            "/// Create a JSON input source to read from a std::io input stream.\n///\n/// When reading from a source against which short reads are not efficient, such\n/// as a [`File`], you will want to apply your own buffering because serde_json\n/// will not buffer the input. See [`std::io::BufReader`].\n///\n/// [`File`]: std::fs::File\npub fn new(reader: R) -> Self{\n        IoRead {\n            iter: LineColIterator::new(reader.bytes()),\n            ch: None,\n            #[cfg(feature = \"raw_value\")]\n            raw_buffer: None,\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::IoRead::<R>::parse_str_bytes": [
            "fn parse_str_bytes<'s, T, F>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n        validate: bool,\n        result: F,\n    ) -> Result<T>\n    where\n        T: 's,\n        F: FnOnce(&'s Self, &'s [u8]) -> Result<T>,{\n        loop {\n            let ch = tri!(next_or_eof(self));\n            if !is_escape(ch, true) {\n                scratch.push(ch);\n                continue;\n            }\n            match ch {\n                b'\"' => {\n                    return result(self, scratch);\n                }\n                b'\\\\' => {\n                    tri!(parse_escape(self, validate, scratch));\n                }\n                _ => {\n                    if validate {\n                        return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                    }\n                    scratch.push(ch);\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::Position": [
            "pub struct Position {\n    pub line: usize,\n    pub column: usize,\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::Read": [
            "/// Trait used by the deserializer for iterating over input. This is manually\n/// \"specialized\" for iterating over `&[u8]`. Once feature(specialization) is\n/// stable we can use actual specialization.\n///\n/// This trait is sealed and cannot be implemented for types outside of\n/// `serde_json`.\npub trait Read<'de>: private::Sealed {\n    #[doc(hidden)]\n    fn next(&mut self) -> Result<Option<u8>>;\n    #[doc(hidden)]\n    fn peek(&mut self) -> Result<Option<u8>>;\n\n    /// Only valid after a call to peek(). Discards the peeked byte.\n    #[doc(hidden)]\n    fn discard(&mut self);\n\n    /// Position of the most recent call to next().\n    ///\n    /// The most recent call was probably next() and not peek(), but this method\n    /// should try to return a sensible result if the most recent call was\n    /// actually peek() because we don't always know.\n    ///\n    /// Only called in case of an error, so performance is not important.\n    #[doc(hidden)]\n    fn position(&self) -> Position;\n\n    /// Position of the most recent call to peek().\n    ///\n    /// The most recent call was probably peek() and not next(), but this method\n    /// should try to return a sensible result if the most recent call was\n    /// actually next() because we don't always know.\n    ///\n    /// Only called in case of an error, so performance is not important.\n    #[doc(hidden)]\n    fn peek_position(&self) -> Position;\n\n    /// Offset from the beginning of the input to the next byte that would be\n    /// returned by next() or peek().\n    #[doc(hidden)]\n    fn byte_offset(&self) -> usize;\n\n    /// Assumes the previous byte was a quotation mark. Parses a JSON-escaped\n    /// string until the next quotation mark using the given scratch space if\n    /// necessary. The scratch space is initially empty.\n    #[doc(hidden)]\n    fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>>;\n\n    /// Assumes the previous byte was a quotation mark. Parses a JSON-escaped\n    /// string until the next quotation mark using the given scratch space if\n    /// necessary. The scratch space is initially empty.\n    ///\n    /// This function returns the raw bytes in the string with escape sequences\n    /// expanded but without performing unicode validation.\n    #[doc(hidden)]\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>>;\n\n    /// Assumes the previous byte was a quotation mark. Parses a JSON-escaped\n    /// string until the next quotation mark but discards the data.\n    #[doc(hidden)]\n    fn ignore_str(&mut self) -> Result<()>;\n\n    /// Assumes the previous byte was a hex escape sequence ('\\u') in a string.\n    /// Parses next hexadecimal sequence.\n    #[doc(hidden)]\n    fn decode_hex_escape(&mut self) -> Result<u16>;\n\n    /// Switch raw buffering mode on.\n    ///\n    /// This is used when deserializing `RawValue`.\n    #[cfg(feature = \"raw_value\")]\n    #[doc(hidden)]\n    fn begin_raw_buffering(&mut self);\n\n    /// Switch raw buffering mode off and provides the raw buffered data to the\n    /// given visitor.\n    #[cfg(feature = \"raw_value\")]\n    #[doc(hidden)]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'de>;\n\n    /// Whether StreamDeserializer::next needs to check the failed flag. True\n    /// for IoRead, false for StrRead and SliceRead which can track failure by\n    /// truncating their input slice to avoid the extra check on every next\n    /// call.\n    #[doc(hidden)]\n    const should_early_return_if_failed: bool;\n\n    /// Mark a persistent failure of StreamDeserializer, either by setting the\n    /// flag or by truncating the input data.\n    #[doc(hidden)]\n    fn set_failed(&mut self, failed: &mut bool);\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::Reference": [
            "pub enum Reference<'b, 'c, T>\nwhere\n    T: ?Sized + 'static,\n{\n    Borrowed(&'b T),\n    Copied(&'c T),\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::SliceRead": [
            "/// JSON input source that reads from a slice of bytes.\npub struct SliceRead<'a> {\n    slice: &'a [u8],\n    /// Index of the *next* byte that will be returned by next() or peek().\n    index: usize,\n    #[cfg(feature = \"raw_value\")]\n    raw_buffering_start_index: usize,\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::SliceRead::<'a>::new": [
            "/// Create a JSON input source to read from a slice of bytes.\npub fn new(slice: &'a [u8]) -> Self{\n        SliceRead {\n            slice,\n            index: 0,\n            #[cfg(feature = \"raw_value\")]\n            raw_buffering_start_index: 0,\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::SliceRead::<'a>::parse_str_bytes": [
            "/// The big optimization here over IoRead is that if the string contains no\n/// backslash escape sequences, the returned &str is a slice of the raw JSON\n/// data so we avoid copying into the scratch space.\nfn parse_str_bytes<'s, T, F>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n        validate: bool,\n        result: F,\n    ) -> Result<Reference<'a, 's, T>>\n    where\n        T: ?Sized + 's,\n        F: for<'f> FnOnce(&'s Self, &'f [u8]) -> Result<&'f T>,{\n        // Index of the first byte not yet copied into the scratch space.\n        let mut start = self.index;\n\n        loop {\n            self.skip_to_escape(validate);\n            if self.index == self.slice.len() {\n                return error(self, ErrorCode::EofWhileParsingString);\n            }\n            match self.slice[self.index] {\n                b'\"' => {\n                    if scratch.is_empty() {\n                        // Fast path: return a slice of the raw JSON without any\n                        // copying.\n                        let borrowed = &self.slice[start..self.index];\n                        self.index += 1;\n                        return result(self, borrowed).map(Reference::Borrowed);\n                    } else {\n                        scratch.extend_from_slice(&self.slice[start..self.index]);\n                        self.index += 1;\n                        return result(self, scratch).map(Reference::Copied);\n                    }\n                }\n                b'\\\\' => {\n                    scratch.extend_from_slice(&self.slice[start..self.index]);\n                    self.index += 1;\n                    tri!(parse_escape(self, validate, scratch));\n                    start = self.index;\n                }\n                _ => {\n                    self.index += 1;\n                    return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::SliceRead::<'a>::position_of_index": [
            "fn position_of_index(&self, i: usize) -> Position{\n        let start_of_line = match memchr::memrchr(b'\\n', &self.slice[..i]) {\n            Some(position) => position + 1,\n            None => 0,\n        };\n        Position {\n            line: 1 + memchr::memchr_iter(b'\\n', &self.slice[..start_of_line]).count(),\n            column: i - start_of_line,\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::SliceRead::<'a>::skip_to_escape": [
            "fn skip_to_escape(&mut self, forbid_control_characters: bool){\n        // Immediately bail-out on empty strings and consecutive escapes (e.g. \\u041b\\u0435)\n        if self.index == self.slice.len()\n            || is_escape(self.slice[self.index], forbid_control_characters)\n        {\n            return;\n        }\n        self.index += 1;\n\n        let rest = &self.slice[self.index..];\n\n        if !forbid_control_characters {\n            self.index += memchr::memchr2(b'\"', b'\\\\', rest).unwrap_or(rest.len());\n            return;\n        }\n\n        // We wish to find the first byte in range 0x00..=0x1F or \" or \\. Ideally, we'd use\n        // something akin to memchr3, but the memchr crate does not support this at the moment.\n        // Therefore, we use a variation on Mycroft's algorithm [1] to provide performance better\n        // than a naive loop. It runs faster than equivalent two-pass memchr2+SWAR code on\n        // benchmarks and it's cross-platform, so probably the right fit.\n        // [1]: https://groups.google.com/forum/#!original/comp.lang.c/2HtQXvg7iKc/xOJeipH6KLMJ\n\n        #[cfg(fast_arithmetic = \"64\")]\n        type Chunk = u64;\n        #[cfg(fast_arithmetic = \"32\")]\n        type Chunk = u32;\n\n        const STEP: usize = mem::size_of::<Chunk>();\n        const ONE_BYTES: Chunk = Chunk::MAX / 255; // 0x0101...01\n\n        for chunk in rest.chunks_exact(STEP) {\n            let chars = Chunk::from_le_bytes(chunk.try_into().unwrap());\n            let contains_ctrl = chars.wrapping_sub(ONE_BYTES * 0x20) & !chars;\n            let chars_quote = chars ^ (ONE_BYTES * Chunk::from(b'\"'));\n            let contains_quote = chars_quote.wrapping_sub(ONE_BYTES) & !chars_quote;\n            let chars_backslash = chars ^ (ONE_BYTES * Chunk::from(b'\\\\'));\n            let contains_backslash = chars_backslash.wrapping_sub(ONE_BYTES) & !chars_backslash;\n            let masked = (contains_ctrl | contains_quote | contains_backslash) & (ONE_BYTES << 7);\n            if masked != 0 {\n                // SAFETY: chunk is in-bounds for slice\n                self.index = unsafe { chunk.as_ptr().offset_from(self.slice.as_ptr()) } as usize\n                    + masked.trailing_zeros() as usize / 8;\n                return;\n            }\n        }\n\n        self.index += rest.len() / STEP * STEP;\n        self.skip_to_escape_slow();\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::SliceRead::<'a>::skip_to_escape_slow": [
            "#[cold]\n#[inline(never)]\nfn skip_to_escape_slow(&mut self){\n        while self.index < self.slice.len() && !is_escape(self.slice[self.index], true) {\n            self.index += 1;\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::StrRead": [
            "/// JSON input source that reads from a UTF-8 string.\npub struct StrRead<'a> {\n    delegate: SliceRead<'a>,\n    #[cfg(feature = \"raw_value\")]\n    data: &'a str,\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::StrRead::<'a>::new": [
            "/// Create a JSON input source to read from a UTF-8 string.\npub fn new(s: &'a str) -> Self{\n        StrRead {\n            delegate: SliceRead::new(s.as_bytes()),\n            #[cfg(feature = \"raw_value\")]\n            data: s,\n        }\n    }",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::as_str": [
            "fn as_str<'de, 's, R: Read<'de>>(read: &R, slice: &'s [u8]) -> Result<&'s str>{\n    str::from_utf8(slice).or_else(|_| error(read, ErrorCode::InvalidUnicodeCodePoint))\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::build_hex_table": [
            "const fn build_hex_table(shift: usize) -> [i16; 256]{\n    let mut table = [0; 256];\n    let mut ch = 0;\n    while ch < 256 {\n        table[ch] = match decode_hex_val_slow(ch as u8) {\n            Some(val) => (val as i16) << shift,\n            None => -1,\n        };\n        ch += 1;\n    }\n    table\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::decode_four_hex_digits": [
            "fn decode_four_hex_digits(a: u8, b: u8, c: u8, d: u8) -> Option<u16>{\n    let a = HEX1[a as usize] as i32;\n    let b = HEX0[b as usize] as i32;\n    let c = HEX1[c as usize] as i32;\n    let d = HEX0[d as usize] as i32;\n\n    let codepoint = ((a | b) << 8) | c | d;\n\n    // A single sign bit check.\n    if codepoint >= 0 {\n        Some(codepoint as u16)\n    } else {\n        None\n    }\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::decode_hex_val_slow": [
            "const fn decode_hex_val_slow(val: u8) -> Option<u8>{\n    match val {\n        b'0'..=b'9' => Some(val - b'0'),\n        b'A'..=b'F' => Some(val - b'A' + 10),\n        b'a'..=b'f' => Some(val - b'a' + 10),\n        _ => None,\n    }\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::error": [
            "fn error<'de, R, T>(read: &R, reason: ErrorCode) -> Result<T>\nwhere\n    R: ?Sized + Read<'de>,{\n    let position = read.position();\n    Err(Error::syntax(reason, position.line, position.column))\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::ignore_escape": [
            "/// Parses a JSON escape sequence and discards the value. Assumes the previous\n/// byte read was a backslash.\nfn ignore_escape<'de, R>(read: &mut R) -> Result<()>\nwhere\n    R: ?Sized + Read<'de>,{\n    let ch = tri!(next_or_eof(read));\n\n    match ch {\n        b'\"' | b'\\\\' | b'/' | b'b' | b'f' | b'n' | b'r' | b't' => {}\n        b'u' => {\n            // At this point we don't care if the codepoint is valid. We just\n            // want to consume it. We don't actually know what is valid or not\n            // at this point, because that depends on if this string will\n            // ultimately be parsed into a string or a byte buffer in the \"real\"\n            // parse.\n\n            tri!(read.decode_hex_escape());\n        }\n        _ => {\n            return error(read, ErrorCode::InvalidEscape);\n        }\n    }\n\n    Ok(())\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::is_escape": [
            "fn is_escape(ch: u8, including_control_characters: bool) -> bool{\n    ch == b'\"' || ch == b'\\\\' || (including_control_characters && ch < 0x20)\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::next_or_eof": [
            "fn next_or_eof<'de, R>(read: &mut R) -> Result<u8>\nwhere\n    R: ?Sized + Read<'de>,{\n    match tri!(read.next()) {\n        Some(b) => Ok(b),\n        None => error(read, ErrorCode::EofWhileParsingString),\n    }\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::parse_escape": [
            "/// Parses a JSON escape sequence and appends it into the scratch space. Assumes\n/// the previous byte read was a backslash.\nfn parse_escape<'de, R: Read<'de>>(\n    read: &mut R,\n    validate: bool,\n    scratch: &mut Vec<u8>,\n) -> Result<()>{\n    let ch = tri!(next_or_eof(read));\n\n    match ch {\n        b'\"' => scratch.push(b'\"'),\n        b'\\\\' => scratch.push(b'\\\\'),\n        b'/' => scratch.push(b'/'),\n        b'b' => scratch.push(b'\\x08'),\n        b'f' => scratch.push(b'\\x0c'),\n        b'n' => scratch.push(b'\\n'),\n        b'r' => scratch.push(b'\\r'),\n        b't' => scratch.push(b'\\t'),\n        b'u' => return parse_unicode_escape(read, validate, scratch),\n        _ => return error(read, ErrorCode::InvalidEscape),\n    }\n\n    Ok(())\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::parse_unicode_escape": [
            "/// Parses a JSON \\u escape and appends it into the scratch space. Assumes `\\u`\n/// has just been read.\n#[cold]\nfn parse_unicode_escape<'de, R: Read<'de>>(\n    read: &mut R,\n    validate: bool,\n    scratch: &mut Vec<u8>,\n) -> Result<()>{\n    let mut n = tri!(read.decode_hex_escape());\n\n    // Non-BMP characters are encoded as a sequence of two hex escapes,\n    // representing UTF-16 surrogates. If deserializing a utf-8 string the\n    // surrogates are required to be paired, whereas deserializing a byte string\n    // accepts lone surrogates.\n    if validate && n >= 0xDC00 && n <= 0xDFFF {\n        // XXX: This is actually a trailing surrogate.\n        return error(read, ErrorCode::LoneLeadingSurrogateInHexEscape);\n    }\n\n    loop {\n        if n < 0xD800 || n > 0xDBFF {\n            // Every u16 outside of the surrogate ranges is guaranteed to be a\n            // legal char.\n            push_wtf8_codepoint(n as u32, scratch);\n            return Ok(());\n        }\n\n        // n is a leading surrogate, we now expect a trailing surrogate.\n        let n1 = n;\n\n        if tri!(peek_or_eof(read)) == b'\\\\' {\n            read.discard();\n        } else {\n            return if validate {\n                read.discard();\n                error(read, ErrorCode::UnexpectedEndOfHexEscape)\n            } else {\n                push_wtf8_codepoint(n1 as u32, scratch);\n                Ok(())\n            };\n        }\n\n        if tri!(peek_or_eof(read)) == b'u' {\n            read.discard();\n        } else {\n            return if validate {\n                read.discard();\n                error(read, ErrorCode::UnexpectedEndOfHexEscape)\n            } else {\n                push_wtf8_codepoint(n1 as u32, scratch);\n                // The \\ prior to this byte started an escape sequence, so we\n                // need to parse that now. This recursive call does not blow the\n                // stack on malicious input because the escape is not \\u, so it\n                // will be handled by one of the easy nonrecursive cases.\n                parse_escape(read, validate, scratch)\n            };\n        }\n\n        let n2 = tri!(read.decode_hex_escape());\n\n        if n2 < 0xDC00 || n2 > 0xDFFF {\n            if validate {\n                return error(read, ErrorCode::LoneLeadingSurrogateInHexEscape);\n            }\n            push_wtf8_codepoint(n1 as u32, scratch);\n            // If n2 is a leading surrogate, we need to restart.\n            n = n2;\n            continue;\n        }\n\n        // This value is in range U+10000..=U+10FFFF, which is always a valid\n        // codepoint.\n        let n = ((((n1 - 0xD800) as u32) << 10) | (n2 - 0xDC00) as u32) + 0x1_0000;\n        push_wtf8_codepoint(n, scratch);\n        return Ok(());\n    }\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::peek_or_eof": [
            "fn peek_or_eof<'de, R>(read: &mut R) -> Result<u8>\nwhere\n    R: ?Sized + Read<'de>,{\n    match tri!(read.peek()) {\n        Some(b) => Ok(b),\n        None => error(read, ErrorCode::EofWhileParsingString),\n    }\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::private::Sealed": [
            "pub trait Sealed {}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "read::push_wtf8_codepoint": [
            "/// Adds a WTF-8 codepoint to the end of the buffer. This is a more efficient\n/// implementation of String::push. The codepoint may be a surrogate.\n#[inline]\nfn push_wtf8_codepoint(n: u32, scratch: &mut Vec<u8>){\n    if n < 0x80 {\n        scratch.push(n as u8);\n        return;\n    }\n\n    scratch.reserve(4);\n\n    // SAFETY: After the `reserve` call, `scratch` has at least 4 bytes of\n    // allocated but uninitialized memory after its last initialized byte, which\n    // is where `ptr` points. All reachable match arms write `encoded_len` bytes\n    // to that region and update the length accordingly, and `encoded_len` is\n    // always <= 4.\n    unsafe {\n        let ptr = scratch.as_mut_ptr().add(scratch.len());\n\n        let encoded_len = match n {\n            0..=0x7F => unreachable!(),\n            0x80..=0x7FF => {\n                ptr.write(((n >> 6) & 0b0001_1111) as u8 | 0b1100_0000);\n                2\n            }\n            0x800..=0xFFFF => {\n                ptr.write(((n >> 12) & 0b0000_1111) as u8 | 0b1110_0000);\n                ptr.add(1)\n                    .write(((n >> 6) & 0b0011_1111) as u8 | 0b1000_0000);\n                3\n            }\n            0x1_0000..=0x10_FFFF => {\n                ptr.write(((n >> 18) & 0b0000_0111) as u8 | 0b1111_0000);\n                ptr.add(1)\n                    .write(((n >> 12) & 0b0011_1111) as u8 | 0b1000_0000);\n                ptr.add(2)\n                    .write(((n >> 6) & 0b0011_1111) as u8 | 0b1000_0000);\n                4\n            }\n            0x11_0000.. => unreachable!(),\n        };\n        ptr.add(encoded_len - 1)\n            .write((n & 0b0011_1111) as u8 | 0b1000_0000);\n\n        scratch.set_len(scratch.len() + encoded_len);\n    }\n}",
            "Real(LocalPath(\"src/read.rs\"))"
        ],
        "ser::CharEscape": [
            "/// Represents a character escape code in a type-safe manner.\npub enum CharEscape {\n    /// An escaped quote `\"`\n    Quote,\n    /// An escaped reverse solidus `\\`\n    ReverseSolidus,\n    /// An escaped solidus `/`\n    Solidus,\n    /// An escaped backspace character (usually escaped as `\\b`)\n    Backspace,\n    /// An escaped form feed character (usually escaped as `\\f`)\n    FormFeed,\n    /// An escaped line feed character (usually escaped as `\\n`)\n    LineFeed,\n    /// An escaped carriage return character (usually escaped as `\\r`)\n    CarriageReturn,\n    /// An escaped tab character (usually escaped as `\\t`)\n    Tab,\n    /// An escaped ASCII plane control character (usually escaped as\n    /// `\\u00XX` where `XX` are two hex characters)\n    AsciiControl(u8),\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::CharEscape::from_escape_table": [
            "#[inline]\nfn from_escape_table(escape: u8, byte: u8) -> CharEscape{\n        match escape {\n            self::BB => CharEscape::Backspace,\n            self::TT => CharEscape::Tab,\n            self::NN => CharEscape::LineFeed,\n            self::FF => CharEscape::FormFeed,\n            self::RR => CharEscape::CarriageReturn,\n            self::QU => CharEscape::Quote,\n            self::BS => CharEscape::ReverseSolidus,\n            self::UU => CharEscape::AsciiControl(byte),\n            _ => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::CompactFormatter": [
            "/// This structure compacts a JSON value with no extra whitespace.\npub struct CompactFormatter;",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Compound": [
            "#[doc(hidden)]\npub enum Compound<'a, W: 'a, F: 'a> {\n    Map {\n        ser: &'a mut Serializer<W, F>,\n        state: State,\n    },\n    #[cfg(feature = \"arbitrary_precision\")]\n    Number { ser: &'a mut Serializer<W, F> },\n    #[cfg(feature = \"raw_value\")]\n    RawValue { ser: &'a mut Serializer<W, F> },\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter": [
            "/// This trait abstracts away serializing the JSON control characters, which allows the user to\n/// optionally pretty print the JSON output.\npub trait Formatter {\n    /// Writes a `null` value to the specified writer.\n    #[inline]\n    fn write_null<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"null\")\n    }\n\n    /// Writes a `true` or `false` value to the specified writer.\n    #[inline]\n    fn write_bool<W>(&mut self, writer: &mut W, value: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let s = if value {\n            b\"true\" as &[u8]\n        } else {\n            b\"false\" as &[u8]\n        };\n        writer.write_all(s)\n    }\n\n    /// Writes an integer value like `-123` to the specified writer.\n    #[inline]\n    fn write_i8<W>(&mut self, writer: &mut W, value: i8) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `-123` to the specified writer.\n    #[inline]\n    fn write_i16<W>(&mut self, writer: &mut W, value: i16) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `-123` to the specified writer.\n    #[inline]\n    fn write_i32<W>(&mut self, writer: &mut W, value: i32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `-123` to the specified writer.\n    #[inline]\n    fn write_i64<W>(&mut self, writer: &mut W, value: i64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `-123` to the specified writer.\n    #[inline]\n    fn write_i128<W>(&mut self, writer: &mut W, value: i128) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `123` to the specified writer.\n    #[inline]\n    fn write_u8<W>(&mut self, writer: &mut W, value: u8) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `123` to the specified writer.\n    #[inline]\n    fn write_u16<W>(&mut self, writer: &mut W, value: u16) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `123` to the specified writer.\n    #[inline]\n    fn write_u32<W>(&mut self, writer: &mut W, value: u32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `123` to the specified writer.\n    #[inline]\n    fn write_u64<W>(&mut self, writer: &mut W, value: u64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `123` to the specified writer.\n    #[inline]\n    fn write_u128<W>(&mut self, writer: &mut W, value: u128) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes a floating point value like `-31.26e+12` to the specified writer.\n    ///\n    /// # Special cases\n    ///\n    /// This function **does not** check for NaN or infinity. If the input\n    /// number is not a finite float, the printed representation will be some\n    /// correctly formatted but unspecified numerical value.\n    ///\n    /// Please check [`is_finite`] yourself before calling this function, or\n    /// check [`is_nan`] and [`is_infinite`] and handle those cases yourself\n    /// with a different `Formatter` method.\n    ///\n    /// [`is_finite`]: f32::is_finite\n    /// [`is_nan`]: f32::is_nan\n    /// [`is_infinite`]: f32::is_infinite\n    #[inline]\n    fn write_f32<W>(&mut self, writer: &mut W, value: f32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = ryu::Buffer::new();\n        let s = buffer.format_finite(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes a floating point value like `-31.26e+12` to the specified writer.\n    ///\n    /// # Special cases\n    ///\n    /// This function **does not** check for NaN or infinity. If the input\n    /// number is not a finite float, the printed representation will be some\n    /// correctly formatted but unspecified numerical value.\n    ///\n    /// Please check [`is_finite`] yourself before calling this function, or\n    /// check [`is_nan`] and [`is_infinite`] and handle those cases yourself\n    /// with a different `Formatter` method.\n    ///\n    /// [`is_finite`]: f64::is_finite\n    /// [`is_nan`]: f64::is_nan\n    /// [`is_infinite`]: f64::is_infinite\n    #[inline]\n    fn write_f64<W>(&mut self, writer: &mut W, value: f64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = ryu::Buffer::new();\n        let s = buffer.format_finite(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes a number that has already been rendered to a string.\n    #[inline]\n    fn write_number_str<W>(&mut self, writer: &mut W, value: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(value.as_bytes())\n    }\n\n    /// Called before each series of `write_string_fragment` and\n    /// `write_char_escape`.  Writes a `\"` to the specified writer.\n    #[inline]\n    fn begin_string<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"\\\"\")\n    }\n\n    /// Called after each series of `write_string_fragment` and\n    /// `write_char_escape`.  Writes a `\"` to the specified writer.\n    #[inline]\n    fn end_string<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"\\\"\")\n    }\n\n    /// Writes a string fragment that doesn't need any escaping to the\n    /// specified writer.\n    #[inline]\n    fn write_string_fragment<W>(&mut self, writer: &mut W, fragment: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(fragment.as_bytes())\n    }\n\n    /// Writes a character escape code to the specified writer.\n    #[inline]\n    fn write_char_escape<W>(&mut self, writer: &mut W, char_escape: CharEscape) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        use self::CharEscape::*;\n\n        let s = match char_escape {\n            Quote => b\"\\\\\\\"\",\n            ReverseSolidus => b\"\\\\\\\\\",\n            Solidus => b\"\\\\/\",\n            Backspace => b\"\\\\b\",\n            FormFeed => b\"\\\\f\",\n            LineFeed => b\"\\\\n\",\n            CarriageReturn => b\"\\\\r\",\n            Tab => b\"\\\\t\",\n            AsciiControl(byte) => {\n                static HEX_DIGITS: [u8; 16] = *b\"0123456789abcdef\";\n                let bytes = &[\n                    b'\\\\',\n                    b'u',\n                    b'0',\n                    b'0',\n                    HEX_DIGITS[(byte >> 4) as usize],\n                    HEX_DIGITS[(byte & 0xF) as usize],\n                ];\n                return writer.write_all(bytes);\n            }\n        };\n\n        writer.write_all(s)\n    }\n\n    /// Writes the representation of a byte array. Formatters can choose whether\n    /// to represent bytes as a JSON array of integers (the default), or some\n    /// JSON string encoding like hex or base64.\n    fn write_byte_array<W>(&mut self, writer: &mut W, value: &[u8]) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        tri!(self.begin_array(writer));\n        let mut first = true;\n        for byte in value {\n            tri!(self.begin_array_value(writer, first));\n            tri!(self.write_u8(writer, *byte));\n            tri!(self.end_array_value(writer));\n            first = false;\n        }\n        self.end_array(writer)\n    }\n\n    /// Called before every array.  Writes a `[` to the specified\n    /// writer.\n    #[inline]\n    fn begin_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"[\")\n    }\n\n    /// Called after every array.  Writes a `]` to the specified\n    /// writer.\n    #[inline]\n    fn end_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"]\")\n    }\n\n    /// Called before every array value.  Writes a `,` if needed to\n    /// the specified writer.\n    #[inline]\n    fn begin_array_value<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        if first {\n            Ok(())\n        } else {\n            writer.write_all(b\",\")\n        }\n    }\n\n    /// Called after every array value.\n    #[inline]\n    fn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        Ok(())\n    }\n\n    /// Called before every object.  Writes a `{` to the specified\n    /// writer.\n    #[inline]\n    fn begin_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"{\")\n    }\n\n    /// Called after every object.  Writes a `}` to the specified\n    /// writer.\n    #[inline]\n    fn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"}\")\n    }\n\n    /// Called before every object key.\n    #[inline]\n    fn begin_object_key<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        if first {\n            Ok(())\n        } else {\n            writer.write_all(b\",\")\n        }\n    }\n\n    /// Called after every object key.  A `:` should be written to the\n    /// specified writer by either this method or\n    /// `begin_object_value`.\n    #[inline]\n    fn end_object_key<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        Ok(())\n    }\n\n    /// Called before every object value.  A `:` should be written to\n    /// the specified writer by either this method or\n    /// `end_object_key`.\n    #[inline]\n    fn begin_object_value<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\":\")\n    }\n\n    /// Called after every object value.\n    #[inline]\n    fn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        Ok(())\n    }\n\n    /// Writes a raw JSON fragment that doesn't need any escaping to the\n    /// specified writer.\n    #[inline]\n    fn write_raw_fragment<W>(&mut self, writer: &mut W, fragment: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(fragment.as_bytes())\n    }\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::begin_array": [
            "/// Called before every array.  Writes a `[` to the specified\n/// writer.\n#[inline]\nfn begin_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"[\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::begin_array_value": [
            "/// Called before every array value.  Writes a `,` if needed to\n/// the specified writer.\n#[inline]\nfn begin_array_value<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        if first {\n            Ok(())\n        } else {\n            writer.write_all(b\",\")\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::begin_object": [
            "/// Called before every object.  Writes a `{` to the specified\n/// writer.\n#[inline]\nfn begin_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"{\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::begin_object_key": [
            "/// Called before every object key.\n#[inline]\nfn begin_object_key<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        if first {\n            Ok(())\n        } else {\n            writer.write_all(b\",\")\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::begin_object_value": [
            "/// Called before every object value.  A `:` should be written to\n/// the specified writer by either this method or\n/// `end_object_key`.\n#[inline]\nfn begin_object_value<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\":\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::begin_string": [
            "/// Called before each series of `write_string_fragment` and\n/// `write_char_escape`.  Writes a `\"` to the specified writer.\n#[inline]\nfn begin_string<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"\\\"\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::end_array": [
            "/// Called after every array.  Writes a `]` to the specified\n/// writer.\n#[inline]\nfn end_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"]\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::end_array_value": [
            "/// Called after every array value.\n#[inline]\nfn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        Ok(())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::end_object": [
            "/// Called after every object.  Writes a `}` to the specified\n/// writer.\n#[inline]\nfn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"}\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::end_object_key": [
            "/// Called after every object key.  A `:` should be written to the\n/// specified writer by either this method or\n/// `begin_object_value`.\n#[inline]\nfn end_object_key<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        Ok(())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::end_object_value": [
            "/// Called after every object value.\n#[inline]\nfn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        Ok(())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::end_string": [
            "/// Called after each series of `write_string_fragment` and\n/// `write_char_escape`.  Writes a `\"` to the specified writer.\n#[inline]\nfn end_string<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"\\\"\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_bool": [
            "/// Writes a `true` or `false` value to the specified writer.\n#[inline]\nfn write_bool<W>(&mut self, writer: &mut W, value: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let s = if value {\n            b\"true\" as &[u8]\n        } else {\n            b\"false\" as &[u8]\n        };\n        writer.write_all(s)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_byte_array": [
            "/// Writes the representation of a byte array. Formatters can choose whether\n/// to represent bytes as a JSON array of integers (the default), or some\n/// JSON string encoding like hex or base64.\nfn write_byte_array<W>(&mut self, writer: &mut W, value: &[u8]) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        tri!(self.begin_array(writer));\n        let mut first = true;\n        for byte in value {\n            tri!(self.begin_array_value(writer, first));\n            tri!(self.write_u8(writer, *byte));\n            tri!(self.end_array_value(writer));\n            first = false;\n        }\n        self.end_array(writer)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_char_escape": [
            "/// Writes a character escape code to the specified writer.\n#[inline]\nfn write_char_escape<W>(&mut self, writer: &mut W, char_escape: CharEscape) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        use self::CharEscape::*;\n\n        let s = match char_escape {\n            Quote => b\"\\\\\\\"\",\n            ReverseSolidus => b\"\\\\\\\\\",\n            Solidus => b\"\\\\/\",\n            Backspace => b\"\\\\b\",\n            FormFeed => b\"\\\\f\",\n            LineFeed => b\"\\\\n\",\n            CarriageReturn => b\"\\\\r\",\n            Tab => b\"\\\\t\",\n            AsciiControl(byte) => {\n                static HEX_DIGITS: [u8; 16] = *b\"0123456789abcdef\";\n                let bytes = &[\n                    b'\\\\',\n                    b'u',\n                    b'0',\n                    b'0',\n                    HEX_DIGITS[(byte >> 4) as usize],\n                    HEX_DIGITS[(byte & 0xF) as usize],\n                ];\n                return writer.write_all(bytes);\n            }\n        };\n\n        writer.write_all(s)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_f32": [
            "/// Writes a floating point value like `-31.26e+12` to the specified writer.\n///\n/// # Special cases\n///\n/// This function **does not** check for NaN or infinity. If the input\n/// number is not a finite float, the printed representation will be some\n/// correctly formatted but unspecified numerical value.\n///\n/// Please check [`is_finite`] yourself before calling this function, or\n/// check [`is_nan`] and [`is_infinite`] and handle those cases yourself\n/// with a different `Formatter` method.\n///\n/// [`is_finite`]: f32::is_finite\n/// [`is_nan`]: f32::is_nan\n/// [`is_infinite`]: f32::is_infinite\n#[inline]\nfn write_f32<W>(&mut self, writer: &mut W, value: f32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = ryu::Buffer::new();\n        let s = buffer.format_finite(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_f64": [
            "/// Writes a floating point value like `-31.26e+12` to the specified writer.\n///\n/// # Special cases\n///\n/// This function **does not** check for NaN or infinity. If the input\n/// number is not a finite float, the printed representation will be some\n/// correctly formatted but unspecified numerical value.\n///\n/// Please check [`is_finite`] yourself before calling this function, or\n/// check [`is_nan`] and [`is_infinite`] and handle those cases yourself\n/// with a different `Formatter` method.\n///\n/// [`is_finite`]: f64::is_finite\n/// [`is_nan`]: f64::is_nan\n/// [`is_infinite`]: f64::is_infinite\n#[inline]\nfn write_f64<W>(&mut self, writer: &mut W, value: f64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = ryu::Buffer::new();\n        let s = buffer.format_finite(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_i128": [
            "/// Writes an integer value like `-123` to the specified writer.\n#[inline]\nfn write_i128<W>(&mut self, writer: &mut W, value: i128) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_i16": [
            "/// Writes an integer value like `-123` to the specified writer.\n#[inline]\nfn write_i16<W>(&mut self, writer: &mut W, value: i16) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_i32": [
            "/// Writes an integer value like `-123` to the specified writer.\n#[inline]\nfn write_i32<W>(&mut self, writer: &mut W, value: i32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_i64": [
            "/// Writes an integer value like `-123` to the specified writer.\n#[inline]\nfn write_i64<W>(&mut self, writer: &mut W, value: i64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_i8": [
            "/// Writes an integer value like `-123` to the specified writer.\n#[inline]\nfn write_i8<W>(&mut self, writer: &mut W, value: i8) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_null": [
            "/// Writes a `null` value to the specified writer.\n#[inline]\nfn write_null<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"null\")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_number_str": [
            "/// Writes a number that has already been rendered to a string.\n#[inline]\nfn write_number_str<W>(&mut self, writer: &mut W, value: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(value.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_raw_fragment": [
            "/// Writes a raw JSON fragment that doesn't need any escaping to the\n/// specified writer.\n#[inline]\nfn write_raw_fragment<W>(&mut self, writer: &mut W, fragment: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(fragment.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_string_fragment": [
            "/// Writes a string fragment that doesn't need any escaping to the\n/// specified writer.\n#[inline]\nfn write_string_fragment<W>(&mut self, writer: &mut W, fragment: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(fragment.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_u128": [
            "/// Writes an integer value like `123` to the specified writer.\n#[inline]\nfn write_u128<W>(&mut self, writer: &mut W, value: u128) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_u16": [
            "/// Writes an integer value like `123` to the specified writer.\n#[inline]\nfn write_u16<W>(&mut self, writer: &mut W, value: u16) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_u32": [
            "/// Writes an integer value like `123` to the specified writer.\n#[inline]\nfn write_u32<W>(&mut self, writer: &mut W, value: u32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_u64": [
            "/// Writes an integer value like `123` to the specified writer.\n#[inline]\nfn write_u64<W>(&mut self, writer: &mut W, value: u64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Formatter::write_u8": [
            "/// Writes an integer value like `123` to the specified writer.\n#[inline]\nfn write_u8<W>(&mut self, writer: &mut W, value: u8) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::MapKeySerializer": [
            "struct MapKeySerializer<'a, W: 'a, F: 'a> {\n    ser: &'a mut Serializer<W, F>,\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::PrettyFormatter": [
            "/// This structure pretty prints a JSON value to make it human readable.\npub struct PrettyFormatter<'a> {\n    current_indent: usize,\n    has_value: bool,\n    indent: &'a [u8],\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::PrettyFormatter::<'a>::new": [
            "/// Construct a pretty printer formatter that defaults to using two spaces for indentation.\npub fn new() -> Self{\n        PrettyFormatter::with_indent(b\"  \")\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::PrettyFormatter::<'a>::with_indent": [
            "/// Construct a pretty printer formatter that uses the `indent` string for indentation.\npub fn with_indent(indent: &'a [u8]) -> Self{\n        PrettyFormatter {\n            current_indent: 0,\n            has_value: false,\n            indent,\n        }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Serializer": [
            "/// A structure for serializing Rust values into JSON.\npub struct Serializer<W, F = CompactFormatter> {\n    writer: W,\n    formatter: F,\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Serializer::<W, F>::into_inner": [
            "/// Unwrap the `Writer` from the `Serializer`.\n#[inline]\npub fn into_inner(self) -> W{\n        self.writer\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Serializer::<W, F>::with_formatter": [
            "/// Creates a new JSON visitor whose output will be written to the writer\n/// specified.\n#[inline]\npub fn with_formatter(writer: W, formatter: F) -> Self{\n        Serializer { writer, formatter }\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty": [
            "/// Creates a new JSON pretty print serializer.\n#[inline]\npub fn pretty(writer: W) -> Self{\n        Serializer::with_formatter(writer, PrettyFormatter::new())\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::Serializer::<W>::new": [
            "/// Creates a new JSON serializer.\n#[inline]\npub fn new(writer: W) -> Self{\n        Serializer::with_formatter(writer, CompactFormatter)\n    }",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::State": [
            "#[doc(hidden)]\npub enum State {\n    Empty,\n    First,\n    Rest,\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::float_key_must_be_finite": [
            "fn float_key_must_be_finite() -> Error{\n    Error::syntax(ErrorCode::FloatKeyMustBeFinite, 0, 0)\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::format_escaped_str": [
            "fn format_escaped_str<W, F>(writer: &mut W, formatter: &mut F, value: &str) -> io::Result<()>\nwhere\n    W: ?Sized + io::Write,\n    F: ?Sized + Formatter,{\n    tri!(formatter.begin_string(writer));\n    tri!(format_escaped_str_contents(writer, formatter, value));\n    formatter.end_string(writer)\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::format_escaped_str_contents": [
            "fn format_escaped_str_contents<W, F>(\n    writer: &mut W,\n    formatter: &mut F,\n    value: &str,\n) -> io::Result<()>\nwhere\n    W: ?Sized + io::Write,\n    F: ?Sized + Formatter,{\n    let bytes = value.as_bytes();\n\n    let mut start = 0;\n\n    for (i, &byte) in bytes.iter().enumerate() {\n        let escape = ESCAPE[byte as usize];\n        if escape == 0 {\n            continue;\n        }\n\n        if start < i {\n            tri!(formatter.write_string_fragment(writer, &value[start..i]));\n        }\n\n        let char_escape = CharEscape::from_escape_table(escape, byte);\n        tri!(formatter.write_char_escape(writer, char_escape));\n\n        start = i + 1;\n    }\n\n    if start == bytes.len() {\n        return Ok(());\n    }\n\n    formatter.write_string_fragment(writer, &value[start..])\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::indent": [
            "fn indent<W>(wr: &mut W, n: usize, s: &[u8]) -> io::Result<()>\nwhere\n    W: ?Sized + io::Write,{\n    for _ in 0..n {\n        tri!(wr.write_all(s));\n    }\n\n    Ok(())\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::key_must_be_a_string": [
            "fn key_must_be_a_string() -> Error{\n    Error::syntax(ErrorCode::KeyMustBeAString, 0, 0)\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::to_string": [
            "/// Serialize the given data structure as a String of JSON.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::to_string_pretty": [
            "/// Serialize the given data structure as a pretty-printed String of JSON.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_string_pretty<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,{\n    let vec = tri!(to_vec_pretty(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::to_vec": [
            "/// Serialize the given data structure as a JSON byte vector.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_vec<T>(value: &T) -> Result<Vec<u8>>\nwhere\n    T: ?Sized + Serialize,{\n    let mut writer = Vec::with_capacity(128);\n    tri!(to_writer(&mut writer, value));\n    Ok(writer)\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::to_vec_pretty": [
            "/// Serialize the given data structure as a pretty-printed JSON byte vector.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_vec_pretty<T>(value: &T) -> Result<Vec<u8>>\nwhere\n    T: ?Sized + Serialize,{\n    let mut writer = Vec::with_capacity(128);\n    tri!(to_writer_pretty(&mut writer, value));\n    Ok(writer)\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::to_writer": [
            "/// Serialize the given data structure as JSON into the I/O stream.\n///\n/// Serialization guarantees it only feeds valid UTF-8 sequences to the writer.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_writer<W, T>(writer: W, value: &T) -> Result<()>\nwhere\n    W: io::Write,\n    T: ?Sized + Serialize,{\n    let mut ser = Serializer::new(writer);\n    value.serialize(&mut ser)\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "ser::to_writer_pretty": [
            "/// Serialize the given data structure as pretty-printed JSON into the I/O\n/// stream.\n///\n/// Serialization guarantees it only feeds valid UTF-8 sequences to the writer.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_writer_pretty<W, T>(writer: W, value: &T) -> Result<()>\nwhere\n    W: io::Write,\n    T: ?Sized + Serialize,{\n    let mut ser = Serializer::pretty(writer);\n    value.serialize(&mut ser)\n}",
            "Real(LocalPath(\"src/ser.rs\"))"
        ],
        "value::Value": [
            "/// Represents any valid JSON value.\n///\n/// See the [`serde_json::value` module documentation](self) for usage examples.\npub enum Value {\n    /// Represents a JSON null value.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!(null);\n    /// ```\n    Null,\n\n    /// Represents a JSON boolean.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!(true);\n    /// ```\n    Bool(bool),\n\n    /// Represents a JSON number, whether integer or floating point.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!(12.5);\n    /// ```\n    Number(Number),\n\n    /// Represents a JSON string.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!(\"a string\");\n    /// ```\n    String(String),\n\n    /// Represents a JSON array.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!([\"an\", \"array\"]);\n    /// ```\n    Array(Vec<Value>),\n\n    /// Represents a JSON object.\n    ///\n    /// By default the map is backed by a BTreeMap. Enable the `preserve_order`\n    /// feature of serde_json to use IndexMap instead, which preserves\n    /// entries in the order they are inserted into the map. In particular, this\n    /// allows JSON data to be deserialized into a Value and serialized to a\n    /// string while retaining the order of map keys in the input.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"an\": \"object\" });\n    /// ```\n    Object(Map<String, Value>),\n}",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_array": [
            "/// If the `Value` is an Array, returns the associated vector. Returns None\n/// otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": [\"an\", \"array\"], \"b\": { \"an\": \"object\" } });\n///\n/// // The length of `[\"an\", \"array\"]` is 2 elements.\n/// assert_eq!(v[\"a\"].as_array().unwrap().len(), 2);\n///\n/// // The object `{\"an\": \"object\"}` is not an array.\n/// assert_eq!(v[\"b\"].as_array(), None);\n/// ```\npub fn as_array(&self) -> Option<&Vec<Value>>{\n        match self {\n            Value::Array(array) => Some(array),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_array_mut": [
            "/// If the `Value` is an Array, returns the associated mutable vector.\n/// Returns None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut v = json!({ \"a\": [\"an\", \"array\"] });\n///\n/// v[\"a\"].as_array_mut().unwrap().clear();\n/// assert_eq!(v, json!({ \"a\": [] }));\n/// ```\npub fn as_array_mut(&mut self) -> Option<&mut Vec<Value>>{\n        match self {\n            Value::Array(list) => Some(list),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_bool": [
            "/// If the `Value` is a Boolean, returns the associated bool. Returns None\n/// otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": false, \"b\": \"false\" });\n///\n/// assert_eq!(v[\"a\"].as_bool(), Some(false));\n///\n/// // The string `\"false\"` is a string, not a boolean.\n/// assert_eq!(v[\"b\"].as_bool(), None);\n/// ```\npub fn as_bool(&self) -> Option<bool>{\n        match *self {\n            Value::Bool(b) => Some(b),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_f64": [
            "/// If the `Value` is a number, represent it as f64 if possible. Returns\n/// None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n///\n/// assert_eq!(v[\"a\"].as_f64(), Some(256.0));\n/// assert_eq!(v[\"b\"].as_f64(), Some(64.0));\n/// assert_eq!(v[\"c\"].as_f64(), Some(-64.0));\n/// ```\npub fn as_f64(&self) -> Option<f64>{\n        match self {\n            Value::Number(n) => n.as_f64(),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_i64": [
            "/// If the `Value` is an integer, represent it as i64 if possible. Returns\n/// None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let big = i64::max_value() as u64 + 10;\n/// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n///\n/// assert_eq!(v[\"a\"].as_i64(), Some(64));\n/// assert_eq!(v[\"b\"].as_i64(), None);\n/// assert_eq!(v[\"c\"].as_i64(), None);\n/// ```\npub fn as_i64(&self) -> Option<i64>{\n        match self {\n            Value::Number(n) => n.as_i64(),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_null": [
            "/// If the `Value` is a Null, returns (). Returns None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": null, \"b\": false });\n///\n/// assert_eq!(v[\"a\"].as_null(), Some(()));\n///\n/// // The boolean `false` is not null.\n/// assert_eq!(v[\"b\"].as_null(), None);\n/// ```\npub fn as_null(&self) -> Option<()>{\n        match *self {\n            Value::Null => Some(()),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_number": [
            "/// If the `Value` is a Number, returns the associated [`Number`]. Returns\n/// None otherwise.\n///\n/// ```\n/// # use serde_json::{json, Number};\n/// #\n/// let v = json!({ \"a\": 1, \"b\": 2.2, \"c\": -3, \"d\": \"4\" });\n///\n/// assert_eq!(v[\"a\"].as_number(), Some(&Number::from(1u64)));\n/// assert_eq!(v[\"b\"].as_number(), Some(&Number::from_f64(2.2).unwrap()));\n/// assert_eq!(v[\"c\"].as_number(), Some(&Number::from(-3i64)));\n///\n/// // The string `\"4\"` is not a number.\n/// assert_eq!(v[\"d\"].as_number(), None);\n/// ```\npub fn as_number(&self) -> Option<&Number>{\n        match self {\n            Value::Number(number) => Some(number),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_object": [
            "/// If the `Value` is an Object, returns the associated Map. Returns None\n/// otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": { \"nested\": true }, \"b\": [\"an\", \"array\"] });\n///\n/// // The length of `{\"nested\": true}` is 1 entry.\n/// assert_eq!(v[\"a\"].as_object().unwrap().len(), 1);\n///\n/// // The array `[\"an\", \"array\"]` is not an object.\n/// assert_eq!(v[\"b\"].as_object(), None);\n/// ```\npub fn as_object(&self) -> Option<&Map<String, Value>>{\n        match self {\n            Value::Object(map) => Some(map),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_object_mut": [
            "/// If the `Value` is an Object, returns the associated mutable Map.\n/// Returns None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut v = json!({ \"a\": { \"nested\": true } });\n///\n/// v[\"a\"].as_object_mut().unwrap().clear();\n/// assert_eq!(v, json!({ \"a\": {} }));\n/// ```\npub fn as_object_mut(&mut self) -> Option<&mut Map<String, Value>>{\n        match self {\n            Value::Object(map) => Some(map),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_str": [
            "/// If the `Value` is a String, returns the associated str. Returns None\n/// otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": \"some string\", \"b\": false });\n///\n/// assert_eq!(v[\"a\"].as_str(), Some(\"some string\"));\n///\n/// // The boolean `false` is not a string.\n/// assert_eq!(v[\"b\"].as_str(), None);\n///\n/// // JSON values are printed in JSON representation, so strings are in quotes.\n/// //\n/// //    The value is: \"some string\"\n/// println!(\"The value is: {}\", v[\"a\"]);\n///\n/// // Rust strings are printed without quotes.\n/// //\n/// //    The value is: some string\n/// println!(\"The value is: {}\", v[\"a\"].as_str().unwrap());\n/// ```\npub fn as_str(&self) -> Option<&str>{\n        match self {\n            Value::String(s) => Some(s),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::as_u64": [
            "/// If the `Value` is an integer, represent it as u64 if possible. Returns\n/// None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n///\n/// assert_eq!(v[\"a\"].as_u64(), Some(64));\n/// assert_eq!(v[\"b\"].as_u64(), None);\n/// assert_eq!(v[\"c\"].as_u64(), None);\n/// ```\npub fn as_u64(&self) -> Option<u64>{\n        match self {\n            Value::Number(n) => n.as_u64(),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::get": [
            "/// Index into a JSON array or map. A string index can be used to access a\n/// value in a map, and a usize index can be used to access an element of an\n/// array.\n///\n/// Returns `None` if the type of `self` does not match the type of the\n/// index, for example if the index is a string and `self` is an array or a\n/// number. Also returns `None` if the given key does not exist in the map\n/// or the given index is not within the bounds of the array.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let object = json!({ \"A\": 65, \"B\": 66, \"C\": 67 });\n/// assert_eq!(*object.get(\"A\").unwrap(), json!(65));\n///\n/// let array = json!([ \"A\", \"B\", \"C\" ]);\n/// assert_eq!(*array.get(2).unwrap(), json!(\"C\"));\n///\n/// assert_eq!(array.get(\"A\"), None);\n/// ```\n///\n/// Square brackets can also be used to index into a value in a more concise\n/// way. This returns `Value::Null` in cases where `get` would have returned\n/// `None`.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let object = json!({\n///     \"A\": [\"a\", \"\", \"\"],\n///     \"B\": [\"b\", \"b\"],\n///     \"C\": [\"c\", \"\", \"\", \"\"],\n/// });\n/// assert_eq!(object[\"B\"][0], json!(\"b\"));\n///\n/// assert_eq!(object[\"D\"], json!(null));\n/// assert_eq!(object[0][\"x\"][\"y\"][\"z\"], json!(null));\n/// ```\npub fn get<I: Index>(&self, index: I) -> Option<&Value>{\n        index.index_into(self)\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::get_mut": [
            "/// Mutably index into a JSON array or map. A string index can be used to\n/// access a value in a map, and a usize index can be used to access an\n/// element of an array.\n///\n/// Returns `None` if the type of `self` does not match the type of the\n/// index, for example if the index is a string and `self` is an array or a\n/// number. Also returns `None` if the given key does not exist in the map\n/// or the given index is not within the bounds of the array.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut object = json!({ \"A\": 65, \"B\": 66, \"C\": 67 });\n/// *object.get_mut(\"A\").unwrap() = json!(69);\n///\n/// let mut array = json!([ \"A\", \"B\", \"C\" ]);\n/// *array.get_mut(2).unwrap() = json!(\"D\");\n/// ```\npub fn get_mut<I: Index>(&mut self, index: I) -> Option<&mut Value>{\n        index.index_into_mut(self)\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::is_array": [
            "/// Returns true if the `Value` is an Array. Returns false otherwise.\n///\n/// For any Value on which `is_array` returns true, `as_array` and\n/// `as_array_mut` are guaranteed to return the vector representing the\n/// array.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let obj = json!({ \"a\": [\"an\", \"array\"], \"b\": { \"an\": \"object\" } });\n///\n/// assert!(obj[\"a\"].is_array());\n///\n/// // an object, not an array\n/// assert!(!obj[\"b\"].is_array());\n/// ```\npub fn is_array(&self) -> bool{\n        self.as_array().is_some()\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::is_boolean": [
            "/// Returns true if the `Value` is a Boolean. Returns false otherwise.\n///\n/// For any Value on which `is_boolean` returns true, `as_bool` is\n/// guaranteed to return the boolean value.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": false, \"b\": \"false\" });\n///\n/// assert!(v[\"a\"].is_boolean());\n///\n/// // The string `\"false\"` is a string, not a boolean.\n/// assert!(!v[\"b\"].is_boolean());\n/// ```\npub fn is_boolean(&self) -> bool{\n        self.as_bool().is_some()\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::is_f64": [
            "/// Returns true if the `Value` is a number that can be represented by f64.\n///\n/// For any Value on which `is_f64` returns true, `as_f64` is guaranteed to\n/// return the floating point value.\n///\n/// Currently this function returns true if and only if both `is_i64` and\n/// `is_u64` return false but this is not a guarantee in the future.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n///\n/// assert!(v[\"a\"].is_f64());\n///\n/// // Integers.\n/// assert!(!v[\"b\"].is_f64());\n/// assert!(!v[\"c\"].is_f64());\n/// ```\npub fn is_f64(&self) -> bool{\n        match self {\n            Value::Number(n) => n.is_f64(),\n            _ => false,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::is_i64": [
            "/// Returns true if the `Value` is an integer between `i64::MIN` and\n/// `i64::MAX`.\n///\n/// For any Value on which `is_i64` returns true, `as_i64` is guaranteed to\n/// return the integer value.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let big = i64::max_value() as u64 + 10;\n/// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n///\n/// assert!(v[\"a\"].is_i64());\n///\n/// // Greater than i64::MAX.\n/// assert!(!v[\"b\"].is_i64());\n///\n/// // Numbers with a decimal point are not considered integers.\n/// assert!(!v[\"c\"].is_i64());\n/// ```\npub fn is_i64(&self) -> bool{\n        match self {\n            Value::Number(n) => n.is_i64(),\n            _ => false,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::is_null": [
            "/// Returns true if the `Value` is a Null. Returns false otherwise.\n///\n/// For any Value on which `is_null` returns true, `as_null` is guaranteed\n/// to return `Some(())`.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": null, \"b\": false });\n///\n/// assert!(v[\"a\"].is_null());\n///\n/// // The boolean `false` is not null.\n/// assert!(!v[\"b\"].is_null());\n/// ```\npub fn is_null(&self) -> bool{\n        self.as_null().is_some()\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::is_number": [
            "/// Returns true if the `Value` is a Number. Returns false otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 1, \"b\": \"2\" });\n///\n/// assert!(v[\"a\"].is_number());\n///\n/// // The string `\"2\"` is a string, not a number.\n/// assert!(!v[\"b\"].is_number());\n/// ```\npub fn is_number(&self) -> bool{\n        match *self {\n            Value::Number(_) => true,\n            _ => false,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::is_object": [
            "/// Returns true if the `Value` is an Object. Returns false otherwise.\n///\n/// For any Value on which `is_object` returns true, `as_object` and\n/// `as_object_mut` are guaranteed to return the map representation of the\n/// object.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let obj = json!({ \"a\": { \"nested\": true }, \"b\": [\"an\", \"array\"] });\n///\n/// assert!(obj.is_object());\n/// assert!(obj[\"a\"].is_object());\n///\n/// // array, not an object\n/// assert!(!obj[\"b\"].is_object());\n/// ```\npub fn is_object(&self) -> bool{\n        self.as_object().is_some()\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::is_string": [
            "/// Returns true if the `Value` is a String. Returns false otherwise.\n///\n/// For any Value on which `is_string` returns true, `as_str` is guaranteed\n/// to return the string slice.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": \"some string\", \"b\": false });\n///\n/// assert!(v[\"a\"].is_string());\n///\n/// // The boolean `false` is not a string.\n/// assert!(!v[\"b\"].is_string());\n/// ```\npub fn is_string(&self) -> bool{\n        self.as_str().is_some()\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::is_u64": [
            "/// Returns true if the `Value` is an integer between zero and `u64::MAX`.\n///\n/// For any Value on which `is_u64` returns true, `as_u64` is guaranteed to\n/// return the integer value.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n///\n/// assert!(v[\"a\"].is_u64());\n///\n/// // Negative integer.\n/// assert!(!v[\"b\"].is_u64());\n///\n/// // Numbers with a decimal point are not considered integers.\n/// assert!(!v[\"c\"].is_u64());\n/// ```\npub fn is_u64(&self) -> bool{\n        match self {\n            Value::Number(n) => n.is_u64(),\n            _ => false,\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::pointer": [
            "/// Looks up a value by a JSON Pointer.\n///\n/// JSON Pointer defines a string syntax for identifying a specific value\n/// within a JavaScript Object Notation (JSON) document.\n///\n/// A Pointer is a Unicode string with the reference tokens separated by `/`.\n/// Inside tokens `/` is replaced by `~1` and `~` is replaced by `~0`. The\n/// addressed value is returned and if there is no such value `None` is\n/// returned.\n///\n/// For more information read [RFC6901](https://tools.ietf.org/html/rfc6901).\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let data = json!({\n///     \"x\": {\n///         \"y\": [\"z\", \"zz\"]\n///     }\n/// });\n///\n/// assert_eq!(data.pointer(\"/x/y/1\").unwrap(), &json!(\"zz\"));\n/// assert_eq!(data.pointer(\"/a/b/c\"), None);\n/// ```\npub fn pointer(&self, pointer: &str) -> Option<&Value>{\n        if pointer.is_empty() {\n            return Some(self);\n        }\n        if !pointer.starts_with('/') {\n            return None;\n        }\n        pointer\n            .split('/')\n            .skip(1)\n            .map(|x| x.replace(\"~1\", \"/\").replace(\"~0\", \"~\"))\n            .try_fold(self, |target, token| match target {\n                Value::Object(map) => map.get(&token),\n                Value::Array(list) => parse_index(&token).and_then(|x| list.get(x)),\n                _ => None,\n            })\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::pointer_mut": [
            "/// Looks up a value by a JSON Pointer and returns a mutable reference to\n/// that value.\n///\n/// JSON Pointer defines a string syntax for identifying a specific value\n/// within a JavaScript Object Notation (JSON) document.\n///\n/// A Pointer is a Unicode string with the reference tokens separated by `/`.\n/// Inside tokens `/` is replaced by `~1` and `~` is replaced by `~0`. The\n/// addressed value is returned and if there is no such value `None` is\n/// returned.\n///\n/// For more information read [RFC6901](https://tools.ietf.org/html/rfc6901).\n///\n/// # Example of Use\n///\n/// ```\n/// use serde_json::Value;\n///\n/// fn main() {\n///     let s = r#\"{\"x\": 1.0, \"y\": 2.0}\"#;\n///     let mut value: Value = serde_json::from_str(s).unwrap();\n///\n///     // Check value using read-only pointer\n///     assert_eq!(value.pointer(\"/x\"), Some(&1.0.into()));\n///     // Change value with direct assignment\n///     *value.pointer_mut(\"/x\").unwrap() = 1.5.into();\n///     // Check that new value was written\n///     assert_eq!(value.pointer(\"/x\"), Some(&1.5.into()));\n///     // Or change the value only if it exists\n///     value.pointer_mut(\"/x\").map(|v| *v = 1.5.into());\n///\n///     // \"Steal\" ownership of a value. Can replace with any valid Value.\n///     let old_x = value.pointer_mut(\"/x\").map(Value::take).unwrap();\n///     assert_eq!(old_x, 1.5);\n///     assert_eq!(value.pointer(\"/x\").unwrap(), &Value::Null);\n/// }\n/// ```\npub fn pointer_mut(&mut self, pointer: &str) -> Option<&mut Value>{\n        if pointer.is_empty() {\n            return Some(self);\n        }\n        if !pointer.starts_with('/') {\n            return None;\n        }\n        pointer\n            .split('/')\n            .skip(1)\n            .map(|x| x.replace(\"~1\", \"/\").replace(\"~0\", \"~\"))\n            .try_fold(self, |target, token| match target {\n                Value::Object(map) => map.get_mut(&token),\n                Value::Array(list) => parse_index(&token).and_then(move |x| list.get_mut(x)),\n                _ => None,\n            })\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::sort_all_objects": [
            "/// Reorders the entries of all `Value::Object` nested within this JSON\n/// value according to `str`'s usual ordering.\n///\n/// If serde_json's \"preserve_order\" feature is not enabled, this method\n/// does no work because all JSON maps are always kept in a sorted state.\n///\n/// If serde_json's \"preserve_order\" feature is enabled, this method\n/// destroys the original source order or insertion order of the JSON\n/// objects in favor of an alphanumerical order that matches how a BTreeMap\n/// with the same contents would be ordered.\npub fn sort_all_objects(&mut self){\n        #[cfg(feature = \"preserve_order\")]\n        {\n            match self {\n                Value::Object(map) => {\n                    map.sort_keys();\n                    map.values_mut().for_each(Value::sort_all_objects);\n                }\n                Value::Array(list) => {\n                    list.iter_mut().for_each(Value::sort_all_objects);\n                }\n                _ => {}\n            }\n        }\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::Value::take": [
            "/// Takes the value out of the `Value`, leaving a `Null` in its place.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut v = json!({ \"x\": \"y\" });\n/// assert_eq!(v[\"x\"].take(), json!(\"y\"));\n/// assert_eq!(v, json!({ \"x\": null }));\n/// ```\npub fn take(&mut self) -> Value{\n        mem::replace(self, Value::Null)\n    }",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::de::<impl core::str::FromStr for value::Value>::from_str": [
            "fn from_str(s: &str) -> Result<Value, Error>{\n        super::super::de::from_str(s)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize": [
            "#[inline]\nfn deserialize<D>(deserializer: D) -> Result<Value, D::Error>\n    where\n        D: serde::Deserializer<'de>,{\n        struct ValueVisitor;\n\n        impl<'de> Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"any valid JSON value\")\n            }\n\n            #[inline]\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E> {\n                Ok(Value::Bool(value))\n            }\n\n            #[inline]\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            fn visit_i128<E>(self, value: i128) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                let de = serde::de::value::I128Deserializer::new(value);\n                Number::deserialize(de).map(Value::Number)\n            }\n\n            #[inline]\n            fn visit_u64<E>(self, value: u64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            fn visit_u128<E>(self, value: u128) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                let de = serde::de::value::U128Deserializer::new(value);\n                Number::deserialize(de).map(Value::Number)\n            }\n\n            #[inline]\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E> {\n                Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_str<E>(self, value: &str) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_string(String::from(value))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_string<E>(self, value: String) -> Result<Value, E> {\n                Ok(Value::String(value))\n            }\n\n            #[inline]\n            fn visit_none<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: serde::Deserializer<'de>,\n            {\n                Deserialize::deserialize(deserializer)\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n\n                while let Some(elem) = tri!(visitor.next_element()) {\n                    vec.push(elem);\n                }\n\n                Ok(Value::Array(vec))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: MapAccess<'de>,\n            {\n                match tri!(visitor.next_key_seed(KeyClassifier)) {\n                    #[cfg(feature = \"arbitrary_precision\")]\n                    Some(KeyClass::Number) => {\n                        let number: NumberFromString = tri!(visitor.next_value());\n                        Ok(Value::Number(number.value))\n                    }\n                    #[cfg(feature = \"raw_value\")]\n                    Some(KeyClass::RawValue) => {\n                        let value = tri!(visitor.next_value_seed(crate::raw::BoxedFromString));\n                        crate::from_str(value.get()).map_err(de::Error::custom)\n                    }\n                    Some(KeyClass::Map(first_key)) => {\n                        let mut values = Map::new();\n\n                        values.insert(first_key, tri!(visitor.next_value()));\n                        while let Some((key, value)) = tri!(visitor.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(Value::Object(values))\n                    }\n                    None => Ok(Value::Object(Map::new())),\n                }\n            }\n        }\n\n        deserializer.deserialize_any(ValueVisitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor": [
            "struct ValueVisitor;",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_any": [
            "fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,{\n        let len = self.len();\n        let mut deserializer = MapRefDeserializer::new(self);\n        let map = tri!(visitor.visit_map(&mut deserializer));\n        let remaining = deserializer.iter.len();\n        if remaining == 0 {\n            Ok(map)\n        } else {\n            Err(serde::de::Error::invalid_length(\n                len,\n                &\"fewer elements in map\",\n            ))\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_bool": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_byte_buf": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_bytes": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_char": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_enum": [
            "fn deserialize_enum<V>(\n        self,\n        _name: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,{\n        let mut iter = self.into_iter();\n        let (variant, value) = match iter.next() {\n            Some(v) => v,\n            None => {\n                return Err(serde::de::Error::invalid_value(\n                    Unexpected::Map,\n                    &\"map with a single key\",\n                ));\n            }\n        };\n        // enums are encoded in json as maps with a single key:value pair\n        if iter.next().is_some() {\n            return Err(serde::de::Error::invalid_value(\n                Unexpected::Map,\n                &\"map with a single key\",\n            ));\n        }\n\n        visitor.visit_enum(EnumRefDeserializer {\n            variant,\n            value: Some(value),\n        })\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_f32": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_f64": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i128": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i16": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i32": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i64": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i8": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_identifier": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_ignored_any": [
            "fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        visitor.visit_unit()\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_map": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_newtype_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_option": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_seq": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_str": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_string": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_tuple": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_tuple_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u128": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u16": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u32": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u64": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u8": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_unit": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_unit_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any": [
            "fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Null => visitor.visit_unit(),\n            Value::Bool(v) => visitor.visit_bool(*v),\n            Value::Number(n) => n.deserialize_any(visitor),\n            Value::String(v) => visitor.visit_borrowed_str(v),\n            Value::Array(v) => visit_array_ref(v, visitor),\n            Value::Object(v) => v.deserialize_any(visitor),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool": [
            "fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match *self {\n            Value::Bool(v) => visitor.visit_bool(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf": [
            "fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_bytes(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes": [
            "fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::String(v) => visitor.visit_borrowed_str(v),\n            Value::Array(v) => visit_array_ref(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char": [
            "fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum": [
            "fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Object(value) => value.deserialize_enum(name, variants, visitor),\n            Value::String(variant) => visitor.visit_enum(EnumRefDeserializer {\n                variant,\n                value: None,\n            }),\n            other => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"string or map\",\n            )),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier": [
            "fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any": [
            "fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        visitor.visit_unit()\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map": [
            "fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Object(v) => v.deserialize_any(visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct": [
            "#[inline]\nfn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return visitor.visit_map(crate::raw::OwnedRawDeserializer {\n                    raw_value: Some(self.to_string()),\n                });\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option": [
            "fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match *self {\n            Value::Null => visitor.visit_none(),\n            _ => visitor.visit_some(self),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq": [
            "fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Array(v) => visit_array_ref(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str": [
            "fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::String(v) => visitor.visit_borrowed_str(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string": [
            "fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct": [
            "fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Array(v) => visit_array_ref(v, visitor),\n            Value::Object(v) => v.deserialize_any(visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple": [
            "fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct": [
            "fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit": [
            "fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match *self {\n            Value::Null => visitor.visit_unit(),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct": [
            "fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_unit(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_any": [
            "fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,{\n        let len = self.len();\n        let mut deserializer = MapDeserializer::new(self);\n        let map = tri!(visitor.visit_map(&mut deserializer));\n        let remaining = deserializer.iter.len();\n        if remaining == 0 {\n            Ok(map)\n        } else {\n            Err(serde::de::Error::invalid_length(\n                len,\n                &\"fewer elements in map\",\n            ))\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_bool": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_byte_buf": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_bytes": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_char": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_enum": [
            "fn deserialize_enum<V>(\n        self,\n        _name: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,{\n        let mut iter = self.into_iter();\n        let (variant, value) = match iter.next() {\n            Some(v) => v,\n            None => {\n                return Err(serde::de::Error::invalid_value(\n                    Unexpected::Map,\n                    &\"map with a single key\",\n                ));\n            }\n        };\n        // enums are encoded in json as maps with a single key:value pair\n        if iter.next().is_some() {\n            return Err(serde::de::Error::invalid_value(\n                Unexpected::Map,\n                &\"map with a single key\",\n            ));\n        }\n\n        visitor.visit_enum(EnumDeserializer {\n            variant,\n            value: Some(value),\n        })\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_f32": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_f64": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i128": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i16": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i32": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i64": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i8": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_identifier": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_ignored_any": [
            "fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,{\n        drop(self);\n        visitor.visit_unit()\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_map": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_newtype_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_option": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_seq": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_str": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_string": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_tuple": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_tuple_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u128": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u16": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u32": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u64": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u8": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_unit": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_unit_struct": [
            "#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any": [
            "#[inline]\nfn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Null => visitor.visit_unit(),\n            Value::Bool(v) => visitor.visit_bool(v),\n            Value::Number(n) => n.deserialize_any(visitor),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n            Value::String(_) => unreachable!(),\n            Value::Array(v) => visit_array(v, visitor),\n            Value::Object(v) => v.deserialize_any(visitor),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool": [
            "fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Bool(v) => visitor.visit_bool(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf": [
            "fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            Value::Array(v) => visit_array(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes": [
            "fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_byte_buf(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char": [
            "fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_string(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum": [
            "#[inline]\nfn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Object(value) => value.deserialize_enum(name, variants, visitor),\n            Value::String(variant) => visitor.visit_enum(EnumDeserializer {\n                variant,\n                value: None,\n            }),\n            other => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"string or map\",\n            )),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier": [
            "fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_string(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any": [
            "fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        drop(self);\n        visitor.visit_unit()\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map": [
            "fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Object(v) => v.deserialize_any(visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct": [
            "#[inline]\nfn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return visitor.visit_map(crate::raw::OwnedRawDeserializer {\n                    raw_value: Some(self.to_string()),\n                });\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option": [
            "#[inline]\nfn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Null => visitor.visit_none(),\n            _ => visitor.visit_some(self),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq": [
            "fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Array(v) => visit_array(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str": [
            "fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_string(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string": [
            "fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct": [
            "fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Array(v) => visit_array(v, visitor),\n            Value::Object(v) => v.deserialize_any(visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple": [
            "fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct": [
            "fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8": [
            "#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit": [
            "fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Null => visitor.visit_unit(),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct": [
            "fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_unit(visitor)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for &'de value::Value>::into_deserializer": [
            "fn into_deserializer(self) -> Self::Deserializer{\n        self\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for value::Value>::into_deserializer": [
            "fn into_deserializer(self) -> Self::Deserializer{\n        self\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl value::Value>::invalid_type": [
            "#[cold]\nfn invalid_type<E>(&self, exp: &dyn Expected) -> E\n    where\n        E: serde::de::Error,{\n        serde::de::Error::invalid_type(self.unexpected(), exp)\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::<impl value::Value>::unexpected": [
            "#[cold]\nfn unexpected(&self) -> Unexpected{\n        match self {\n            Value::Null => Unexpected::Unit,\n            Value::Bool(b) => Unexpected::Bool(*b),\n            Value::Number(n) => n.unexpected(),\n            Value::String(s) => Unexpected::Str(s),\n            Value::Array(_) => Unexpected::Seq,\n            Value::Object(_) => Unexpected::Map,\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::BorrowedCowStrDeserializer": [
            "struct BorrowedCowStrDeserializer<'de> {\n    value: Cow<'de, str>,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::BorrowedCowStrDeserializer::<'de>::new": [
            "fn new(value: Cow<'de, str>) -> Self{\n        BorrowedCowStrDeserializer { value }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::EnumDeserializer": [
            "struct EnumDeserializer {\n    variant: String,\n    value: Option<Value>,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::EnumRefDeserializer": [
            "struct EnumRefDeserializer<'de> {\n    variant: &'de str,\n    value: Option<&'de Value>,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::KeyClass": [
            "enum KeyClass {\n    Map(String),\n    #[cfg(feature = \"arbitrary_precision\")]\n    Number,\n    #[cfg(feature = \"raw_value\")]\n    RawValue,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::KeyClassifier": [
            "struct KeyClassifier;",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::MapDeserializer": [
            "struct MapDeserializer {\n    iter: <Map<String, Value> as IntoIterator>::IntoIter,\n    value: Option<Value>,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::MapDeserializer::new": [
            "fn new(map: Map<String, Value>) -> Self{\n        MapDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::MapKeyDeserializer": [
            "struct MapKeyDeserializer<'de> {\n    key: Cow<'de, str>,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::MapRefDeserializer": [
            "struct MapRefDeserializer<'de> {\n    iter: <&'de Map<String, Value> as IntoIterator>::IntoIter,\n    value: Option<&'de Value>,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::MapRefDeserializer::<'de>::new": [
            "fn new(map: &'de Map<String, Value>) -> Self{\n        MapRefDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::SeqDeserializer": [
            "struct SeqDeserializer {\n    iter: vec::IntoIter<Value>,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::SeqDeserializer::new": [
            "fn new(vec: Vec<Value>) -> Self{\n        SeqDeserializer {\n            iter: vec.into_iter(),\n        }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::SeqRefDeserializer": [
            "struct SeqRefDeserializer<'de> {\n    iter: slice::Iter<'de, Value>,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::SeqRefDeserializer::<'de>::new": [
            "fn new(slice: &'de [Value]) -> Self{\n        SeqRefDeserializer { iter: slice.iter() }\n    }",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::UnitOnly": [
            "struct UnitOnly;",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::VariantDeserializer": [
            "struct VariantDeserializer {\n    value: Option<Value>,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::VariantRefDeserializer": [
            "struct VariantRefDeserializer<'de> {\n    value: Option<&'de Value>,\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::visit_array": [
            "fn visit_array<'de, V>(array: Vec<Value>, visitor: V) -> Result<V::Value, Error>\nwhere\n    V: Visitor<'de>,{\n    let len = array.len();\n    let mut deserializer = SeqDeserializer::new(array);\n    let seq = tri!(visitor.visit_seq(&mut deserializer));\n    let remaining = deserializer.iter.len();\n    if remaining == 0 {\n        Ok(seq)\n    } else {\n        Err(serde::de::Error::invalid_length(\n            len,\n            &\"fewer elements in array\",\n        ))\n    }\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::de::visit_array_ref": [
            "fn visit_array_ref<'de, V>(array: &'de [Value], visitor: V) -> Result<V::Value, Error>\nwhere\n    V: Visitor<'de>,{\n    let len = array.len();\n    let mut deserializer = SeqRefDeserializer::new(array);\n    let seq = tri!(visitor.visit_seq(&mut deserializer));\n    let remaining = deserializer.iter.len();\n    if remaining == 0 {\n        Ok(seq)\n    } else {\n        Err(serde::de::Error::invalid_length(\n            len,\n            &\"fewer elements in array\",\n        ))\n    }\n}",
            "Real(LocalPath(\"src/value/de.rs\"))"
        ],
        "value::from::<impl core::convert::From<&[T]> for value::Value>::from": [
            "/// Convert a slice to `Value::Array`.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let v: &[&str] = &[\"lorem\", \"ipsum\", \"dolor\"];\n/// let x: Value = v.into();\n/// ```\nfn from(f: &[T]) -> Self{\n        Value::Array(f.iter().cloned().map(Into::into).collect())\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<&str> for value::Value>::from": [
            "/// Convert string slice to `Value::String`.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let s: &str = \"lorem\";\n/// let x: Value = s.into();\n/// ```\nfn from(f: &str) -> Self{\n        Value::String(f.to_owned())\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<()> for value::Value>::from": [
            "/// Convert `()` to `Value::Null`.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let u = ();\n/// let x: Value = u.into();\n/// ```\nfn from((): ()) -> Self{\n        Value::Null\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<[T; N]> for value::Value>::from": [
            "fn from(array: [T; N]) -> Self{\n        Value::Array(array.into_iter().map(Into::into).collect())\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<alloc::borrow::Cow<'a, str>> for value::Value>::from": [
            "/// Convert copy-on-write string to `Value::String`.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n/// use std::borrow::Cow;\n///\n/// let s: Cow<str> = Cow::Borrowed(\"lorem\");\n/// let x: Value = s.into();\n/// ```\n///\n/// ```\n/// use serde_json::Value;\n/// use std::borrow::Cow;\n///\n/// let s: Cow<str> = Cow::Owned(\"lorem\".to_owned());\n/// let x: Value = s.into();\n/// ```\nfn from(f: Cow<'a, str>) -> Self{\n        Value::String(f.into_owned())\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<alloc::string::String> for value::Value>::from": [
            "/// Convert `String` to `Value::String`.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let s: String = \"lorem\".to_owned();\n/// let x: Value = s.into();\n/// ```\nfn from(f: String) -> Self{\n        Value::String(f)\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<alloc::vec::Vec<T>> for value::Value>::from": [
            "/// Convert a `Vec` to `Value::Array`.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let v = vec![\"lorem\", \"ipsum\", \"dolor\"];\n/// let x: Value = v.into();\n/// ```\nfn from(f: Vec<T>) -> Self{\n        Value::Array(f.into_iter().map(Into::into).collect())\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<bool> for value::Value>::from": [
            "/// Convert boolean to `Value::Bool`.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let b = false;\n/// let x: Value = b.into();\n/// ```\nfn from(f: bool) -> Self{\n        Value::Bool(f)\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<core::option::Option<T>> for value::Value>::from": [
            "fn from(opt: Option<T>) -> Self{\n        match opt {\n            None => Value::Null,\n            Some(value) => Into::into(value),\n        }\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<f32> for value::Value>::from": [
            "/// Convert 32-bit floating point number to `Value::Number`, or\n/// `Value::Null` if infinite or NaN.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let f: f32 = 13.37;\n/// let x: Value = f.into();\n/// ```\nfn from(f: f32) -> Self{\n        Number::from_f32(f).map_or(Value::Null, Value::Number)\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<f64> for value::Value>::from": [
            "/// Convert 64-bit floating point number to `Value::Number`, or\n/// `Value::Null` if infinite or NaN.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let f: f64 = 13.37;\n/// let x: Value = f.into();\n/// ```\nfn from(f: f64) -> Self{\n        Number::from_f64(f).map_or(Value::Null, Value::Number)\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<i16> for value::Value>::from": [
            "fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<i32> for value::Value>::from": [
            "fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<i64> for value::Value>::from": [
            "fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<i8> for value::Value>::from": [
            "fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<isize> for value::Value>::from": [
            "fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<map::Map<alloc::string::String, value::Value>> for value::Value>::from": [
            "/// Convert map (with string keys) to `Value::Object`.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::{Map, Value};\n///\n/// let mut m = Map::new();\n/// m.insert(\"Lorem\".to_owned(), \"ipsum\".into());\n/// let x: Value = m.into();\n/// ```\nfn from(f: Map<String, Value>) -> Self{\n        Value::Object(f)\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<number::Number> for value::Value>::from": [
            "/// Convert `Number` to `Value::Number`.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::{Number, Value};\n///\n/// let n = Number::from(7);\n/// let x: Value = n.into();\n/// ```\nfn from(f: Number) -> Self{\n        Value::Number(f)\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<u16> for value::Value>::from": [
            "fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<u32> for value::Value>::from": [
            "fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<u64> for value::Value>::from": [
            "fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<u8> for value::Value>::from": [
            "fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::convert::From<usize> for value::Value>::from": [
            "fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::iter::FromIterator<(K, V)> for value::Value>::from_iter": [
            "/// Create a `Value::Object` by collecting an iterator of key-value pairs.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let v: Vec<_> = vec![(\"lorem\", 40), (\"ipsum\", 2)];\n/// let x: Value = v.into_iter().collect();\n/// ```\nfn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self{\n        Value::Object(\n            iter.into_iter()\n                .map(|(k, v)| (k.into(), v.into()))\n                .collect(),\n        )\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from::<impl core::iter::FromIterator<T> for value::Value>::from_iter": [
            "/// Create a `Value::Array` by collecting an iterator of array elements.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let v = std::iter::repeat(42).take(5);\n/// let x: Value = v.collect();\n/// ```\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let v: Vec<_> = vec![\"lorem\", \"ipsum\", \"dolor\"];\n/// let x: Value = v.into_iter().collect();\n/// ```\n///\n/// ```\n/// use std::iter::FromIterator;\n/// use serde_json::Value;\n///\n/// let x: Value = Value::from_iter(vec![\"lorem\", \"ipsum\", \"dolor\"]);\n/// ```\nfn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self{\n        Value::Array(iter.into_iter().map(Into::into).collect())\n    }",
            "Real(LocalPath(\"src/value/from.rs\"))"
        ],
        "value::from_value": [
            "/// Interpret a `serde_json::Value` as an instance of type `T`.\n///\n/// # Example\n///\n/// ```\n/// use serde::Deserialize;\n/// use serde_json::json;\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn main() {\n///     // The type of `j` is `serde_json::Value`\n///     let j = json!({\n///         \"fingerprint\": \"0xF9BA143B95FF6D82\",\n///         \"location\": \"Menlo Park, CA\"\n///     });\n///\n///     let u: User = serde_json::from_value(j).unwrap();\n///     println!(\"{:#?}\", u);\n/// }\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the Value does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the Value\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\npub fn from_value<T>(value: Value) -> Result<T, Error>\nwhere\n    T: DeserializeOwned,{\n    T::deserialize(value)\n}",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::index::<impl core::ops::Index<I> for value::Value>::index": [
            "/// Index into a `serde_json::Value` using the syntax `value[0]` or\n/// `value[\"k\"]`.\n///\n/// Returns `Value::Null` if the type of `self` does not match the type of\n/// the index, for example if the index is a string and `self` is an array\n/// or a number. Also returns `Value::Null` if the given key does not exist\n/// in the map or the given index is not within the bounds of the array.\n///\n/// For retrieving deeply nested values, you should have a look at the\n/// `Value::pointer` method.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let data = json!({\n///     \"x\": {\n///         \"y\": [\"z\", \"zz\"]\n///     }\n/// });\n///\n/// assert_eq!(data[\"x\"][\"y\"], json!([\"z\", \"zz\"]));\n/// assert_eq!(data[\"x\"][\"y\"][0], json!(\"z\"));\n///\n/// assert_eq!(data[\"a\"], json!(null)); // returns null for undefined values\n/// assert_eq!(data[\"a\"][\"b\"], json!(null)); // does not panic\n/// ```\nfn index(&self, index: I) -> &Value{\n        static NULL: Value = Value::Null;\n        index.index_into(self).unwrap_or(&NULL)\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "value::index::<impl core::ops::IndexMut<I> for value::Value>::index_mut": [
            "/// Write into a `serde_json::Value` using the syntax `value[0] = ...` or\n/// `value[\"k\"] = ...`.\n///\n/// If the index is a number, the value must be an array of length bigger\n/// than the index. Indexing into a value that is not an array or an array\n/// that is too small will panic.\n///\n/// If the index is a string, the value must be an object or null which is\n/// treated like an empty object. If the key is not already present in the\n/// object, it will be inserted with a value of null. Indexing into a value\n/// that is neither an object nor null will panic.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut data = json!({ \"x\": 0 });\n///\n/// // replace an existing key\n/// data[\"x\"] = json!(1);\n///\n/// // insert a new key\n/// data[\"y\"] = json!([false, false, false]);\n///\n/// // replace an array value\n/// data[\"y\"][0] = json!(true);\n///\n/// // inserted a deeply nested key\n/// data[\"a\"][\"b\"][\"c\"][\"d\"] = json!(true);\n///\n/// println!(\"{}\", data);\n/// ```\nfn index_mut(&mut self, index: I) -> &mut Value{\n        index.index_or_insert(self)\n    }",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "value::index::Index": [
            "/// A type that can be used to index into a `serde_json::Value`.\n///\n/// The [`get`] and [`get_mut`] methods of `Value` accept any type that\n/// implements `Index`, as does the [square-bracket indexing operator]. This\n/// trait is implemented for strings which are used as the index into a JSON\n/// map, and for `usize` which is used as the index into a JSON array.\n///\n/// [`get`]: Value::get\n/// [`get_mut`]: Value::get_mut\n/// [square-bracket indexing operator]: Value#impl-Index%3CI%3E-for-Value\n///\n/// This trait is sealed and cannot be implemented for types outside of\n/// `serde_json`.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let data = json!({ \"inner\": [1, 2, 3] });\n///\n/// // Data is a JSON map so it can be indexed with a string.\n/// let inner = &data[\"inner\"];\n///\n/// // Inner is a JSON array so it can be indexed with an integer.\n/// let first = &inner[0];\n///\n/// assert_eq!(first, 1);\n/// ```\npub trait Index: private::Sealed {\n    /// Return None if the key is not already in the array or object.\n    #[doc(hidden)]\n    fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>;\n\n    /// Return None if the key is not already in the array or object.\n    #[doc(hidden)]\n    fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>;\n\n    /// Panic if array index out of bounds. If key is not already in the object,\n    /// insert it with a value of null. Panic if Value is a type that cannot be\n    /// indexed into, except if Value is null then it can be treated as an empty\n    /// object.\n    #[doc(hidden)]\n    fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value;\n}",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "value::index::Type": [
            "/// Used in panic messages.\nstruct Type<'a>(&'a Value);",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "value::index::private::Sealed": [
            "pub trait Sealed {}",
            "Real(LocalPath(\"src/value/index.rs\"))"
        ],
        "value::parse_index": [
            "fn parse_index(s: &str) -> Option<usize>{\n    if s.starts_with('+') || (s.starts_with('0') && s.len() != 1) {\n        return None;\n    }\n    s.parse().ok()\n}",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<&str> for value::Value>::eq": [
            "fn eq(&self, other: &&str) -> bool{\n        eq_str(self, *other)\n    }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<alloc::string::String> for value::Value>::eq": [
            "fn eq(&self, other: &String) -> bool{\n        eq_str(self, other.as_str())\n    }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<bool> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<bool> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<bool> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f32> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f32> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f32> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f64> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f64> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f64> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i16> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i16> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i16> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i32> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i32> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i32> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i64> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i64> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i64> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i8> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i8> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i8> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<isize> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<isize> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<isize> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<str> for value::Value>::eq": [
            "fn eq(&self, other: &str) -> bool{\n        eq_str(self, other)\n    }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u16> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u16> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u16> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u32> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u32> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u32> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u64> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u64> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u64> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u8> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u8> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u8> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<usize> for &'a mut value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<usize> for &'a value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<usize> for value::Value>::eq": [
            "fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for &str>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n        eq_str(other, *self)\n    }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for alloc::string::String>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n        eq_str(other, self.as_str())\n    }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for bool>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for f32>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for f64>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i16>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i32>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i64>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i8>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for isize>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for str>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n        eq_str(other, self)\n    }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u16>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u32>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u64>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u8>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for usize>::eq": [
            "fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::eq_bool": [
            "fn eq_bool(value: &Value, other: bool) -> bool{\n    value.as_bool() == Some(other)\n}",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::eq_f32": [
            "fn eq_f32(value: &Value, other: f32) -> bool{\n    match value {\n        Value::Number(n) => n.as_f32() == Some(other),\n        _ => false,\n    }\n}",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::eq_f64": [
            "fn eq_f64(value: &Value, other: f64) -> bool{\n    value.as_f64() == Some(other)\n}",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::eq_i64": [
            "fn eq_i64(value: &Value, other: i64) -> bool{\n    value.as_i64() == Some(other)\n}",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::eq_str": [
            "fn eq_str(value: &Value, other: &str) -> bool{\n    value.as_str() == Some(other)\n}",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::partial_eq::eq_u64": [
            "fn eq_u64(value: &Value, other: u64) -> bool{\n    value.as_u64() == Some(other)\n}",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))"
        ],
        "value::ser::<impl serde::Serialize for value::Value>::serialize": [
            "#[inline]\nfn serialize<S>(&self, serializer: S) -> result::Result<S::Ok, S::Error>\n    where\n        S: ::serde::Serializer,{\n        match self {\n            Value::Null => serializer.serialize_unit(),\n            Value::Bool(b) => serializer.serialize_bool(*b),\n            Value::Number(n) => n.serialize(serializer),\n            Value::String(s) => serializer.serialize_str(s),\n            Value::Array(v) => v.serialize(serializer),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::Object(m) => {\n                use serde::ser::SerializeMap;\n                let mut map = tri!(serializer.serialize_map(Some(m.len())));\n                for (k, v) in m {\n                    tri!(map.serialize_entry(k, v));\n                }\n                map.end()\n            }\n            #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n            Value::Object(_) => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "value::ser::MapKeySerializer": [
            "struct MapKeySerializer;",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "value::ser::SerializeMap": [
            "pub enum SerializeMap {\n    Map {\n        map: Map<String, Value>,\n        next_key: Option<String>,\n    },\n    #[cfg(feature = \"arbitrary_precision\")]\n    Number { out_value: Option<Value> },\n    #[cfg(feature = \"raw_value\")]\n    RawValue { out_value: Option<Value> },\n}",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "value::ser::SerializeStructVariant": [
            "pub struct SerializeStructVariant {\n    name: String,\n    map: Map<String, Value>,\n}",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "value::ser::SerializeTupleVariant": [
            "pub struct SerializeTupleVariant {\n    name: String,\n    vec: Vec<Value>,\n}",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "value::ser::SerializeVec": [
            "pub struct SerializeVec {\n    vec: Vec<Value>,\n}",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "value::ser::Serializer": [
            "/// Serializer whose output is a `Value`.\n///\n/// This is the serializer that backs [`serde_json::to_value`][crate::to_value].\n/// Unlike the main serde_json serializer which goes from some serializable\n/// value of type `T` to JSON text, this one goes from `T` to\n/// `serde_json::Value`.\n///\n/// The `to_value` function is implementable as:\n///\n/// ```\n/// use serde::Serialize;\n/// use serde_json::{Error, Value};\n///\n/// pub fn to_value<T>(input: T) -> Result<Value, Error>\n/// where\n///     T: Serialize,\n/// {\n///     input.serialize(serde_json::value::Serializer)\n/// }\n/// ```\npub struct Serializer;",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "value::ser::float_key_must_be_finite": [
            "fn float_key_must_be_finite() -> Error{\n    Error::syntax(ErrorCode::FloatKeyMustBeFinite, 0, 0)\n}",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "value::ser::key_must_be_a_string": [
            "fn key_must_be_a_string() -> Error{\n    Error::syntax(ErrorCode::KeyMustBeAString, 0, 0)\n}",
            "Real(LocalPath(\"src/value/ser.rs\"))"
        ],
        "value::to_value": [
            "/// Convert a `T` into `serde_json::Value` which is an enum that can represent\n/// any valid JSON data.\n///\n/// # Example\n///\n/// ```\n/// use serde::Serialize;\n/// use serde_json::json;\n/// use std::error::Error;\n///\n/// #[derive(Serialize)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn compare_json_values() -> Result<(), Box<dyn Error>> {\n///     let u = User {\n///         fingerprint: \"0xF9BA143B95FF6D82\".to_owned(),\n///         location: \"Menlo Park, CA\".to_owned(),\n///     };\n///\n///     // The type of `expected` is `serde_json::Value`\n///     let expected = json!({\n///         \"fingerprint\": \"0xF9BA143B95FF6D82\",\n///         \"location\": \"Menlo Park, CA\",\n///     });\n///\n///     let v = serde_json::to_value(u).unwrap();\n///     assert_eq!(v, expected);\n///\n///     Ok(())\n/// }\n/// #\n/// # compare_json_values().unwrap();\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n///\n/// ```\n/// use std::collections::BTreeMap;\n///\n/// fn main() {\n///     // The keys in this map are vectors, not strings.\n///     let mut map = BTreeMap::new();\n///     map.insert(vec![32, 64], \"x86\");\n///\n///     println!(\"{}\", serde_json::to_value(map).unwrap_err());\n/// }\n/// ```\npub fn to_value<T>(value: T) -> Result<Value, Error>\nwhere\n    T: Serialize,{\n    value.serialize(Serializer)\n}",
            "Real(LocalPath(\"src/value/mod.rs\"))"
        ]
    },
    "struct_constructor": {
        "&'^0.Named(DefId(0:3046 ~ serde_json[b530]::map::{impl#6}::index::'_), \"'_\") value::Value": [
            "index"
        ],
        "&'^0.Named(DefId(0:3049 ~ serde_json[b530]::map::{impl#7}::index_mut::'_), \"'_\") mut value::Value": [
            "index_mut"
        ],
        "&'^0.Named(DefId(0:3059 ~ serde_json[b530]::map::{impl#15}::key::'_), \"'_\") alloc::string::String": [
            "key"
        ],
        "&'^0.Named(DefId(0:3061 ~ serde_json[b530]::map::{impl#16}::key::'_), \"'_\") alloc::string::String": [
            "key"
        ],
        "&'^0.Named(DefId(0:3062 ~ serde_json[b530]::map::{impl#17}::key::'_), \"'_\") alloc::string::String": [
            "key"
        ],
        "&'^0.Named(DefId(0:3063 ~ serde_json[b530]::map::{impl#17}::get::'_), \"'_\") value::Value": [
            "get"
        ],
        "&'^0.Named(DefId(0:3064 ~ serde_json[b530]::map::{impl#17}::get_mut::'_), \"'_\") mut value::Value": [
            "get_mut"
        ],
        "&'^0.Named(DefId(0:3371 ~ serde_json[b530]::read::{impl#0}::deref::'_), \"'_\") Alias(Projection, AliasTy { args: [read::Reference<'b/#0, 'c/#1, T/#2>], def_id: DefId(1:3552 ~ core[a245]::ops::deref::Deref::Target) })": [
            "deref"
        ],
        "&'a/#0 mut value::Value": [
            "insert",
            "into_mut",
            "or_insert",
            "or_insert_with"
        ],
        "(alloc::string::String, value::Value)": [
            "remove_entry"
        ],
        "(usize, core::option::Option<usize>)": [
            "size_hint"
        ],
        "Alias(Projection, AliasTy { args: [&'a/#0 map::Map<alloc::string::String, value::Value>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [&'a/#0 mut map::Map<alloc::string::String, value::Value>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [&'de/#0 map::Map<alloc::string::String, value::Value>, 'de/#0, error::Error], def_id: DefId(20:1685 ~ serde[5b86]::de::IntoDeserializer::Deserializer) })": [
            "into_deserializer"
        ],
        "Alias(Projection, AliasTy { args: [&'de/#0 value::Value, 'de/#0, error::Error], def_id: DefId(20:1685 ~ serde[5b86]::de::IntoDeserializer::Deserializer) })": [
            "into_deserializer"
        ],
        "Alias(Projection, AliasTy { args: [map::Map<alloc::string::String, value::Value>, 'de/#0, error::Error], def_id: DefId(20:1685 ~ serde[5b86]::de::IntoDeserializer::Deserializer) })": [
            "into_deserializer"
        ],
        "Alias(Projection, AliasTy { args: [map::Map<alloc::string::String, value::Value>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [value::Value, 'de/#0, error::Error], def_id: DefId(20:1685 ~ serde[5b86]::de::IntoDeserializer::Deserializer) })": [
            "into_deserializer"
        ],
        "[i16; 256_usize]": [
            "build_hex_table"
        ],
        "bool": [
            "contains_key",
            "eq",
            "eq_f32",
            "eq_f64",
            "eq_i64",
            "eq_str",
            "eq_u64",
            "is_array",
            "is_boolean",
            "is_data",
            "is_empty",
            "is_eof",
            "is_f64",
            "is_i64",
            "is_io",
            "is_null",
            "is_number",
            "is_object",
            "is_string",
            "is_syntax",
            "is_u64",
            "starts_with_digit"
        ],
        "core::option::Option": [
            "as_array",
            "as_array_mut",
            "as_bool",
            "as_f32",
            "as_f64",
            "as_i128",
            "as_i64",
            "as_null",
            "as_number",
            "as_object",
            "as_object_mut",
            "as_str",
            "as_u128",
            "as_u64",
            "decode_four_hex_digits",
            "decode_hex_val_slow",
            "from_f32",
            "from_f64",
            "from_i128",
            "from_u128",
            "get",
            "get_key_value",
            "get_mut",
            "index_into",
            "index_into_mut",
            "insert",
            "io_error_kind",
            "next",
            "next_back",
            "parse_index",
            "parse_line_col",
            "pointer",
            "pointer_mut",
            "remove",
            "remove_entry",
            "size_hint",
            "source"
        ],
        "core::result::Result": [
            "as_str",
            "begin_array",
            "begin_array_value",
            "begin_object",
            "begin_object_key",
            "begin_object_value",
            "begin_string",
            "collect_str",
            "decode_hex_escape",
            "deserialize",
            "deserialize_any",
            "deserialize_bool",
            "deserialize_byte_buf",
            "deserialize_bytes",
            "deserialize_char",
            "deserialize_enum",
            "deserialize_f32",
            "deserialize_f64",
            "deserialize_i128",
            "deserialize_i16",
            "deserialize_i32",
            "deserialize_i64",
            "deserialize_i8",
            "deserialize_identifier",
            "deserialize_ignored_any",
            "deserialize_map",
            "deserialize_newtype_struct",
            "deserialize_number",
            "deserialize_option",
            "deserialize_seq",
            "deserialize_str",
            "deserialize_string",
            "deserialize_struct",
            "deserialize_tuple",
            "deserialize_tuple_struct",
            "deserialize_u128",
            "deserialize_u16",
            "deserialize_u32",
            "deserialize_u64",
            "deserialize_u8",
            "deserialize_unit",
            "deserialize_unit_struct",
            "do_deserialize_i128",
            "do_deserialize_u128",
            "end",
            "end_array",
            "end_array_value",
            "end_map",
            "end_object",
            "end_object_key",
            "end_object_value",
            "end_seq",
            "end_string",
            "error",
            "expecting",
            "f64_from_parts",
            "flush",
            "fmt",
            "format_escaped_str",
            "format_escaped_str_contents",
            "from_reader",
            "from_slice",
            "from_str",
            "from_trait",
            "from_value",
            "has_next_element",
            "has_next_key",
            "ignore_decimal",
            "ignore_escape",
            "ignore_exponent",
            "ignore_integer",
            "ignore_str",
            "ignore_value",
            "indent",
            "newtype_variant_seed",
            "next",
            "next_char",
            "next_char_or_null",
            "next_element_seed",
            "next_key_seed",
            "next_or_eof",
            "next_value_seed",
            "parse_any_number",
            "parse_any_signed_number",
            "parse_decimal",
            "parse_decimal_overflow",
            "parse_escape",
            "parse_exponent",
            "parse_exponent_overflow",
            "parse_ident",
            "parse_integer",
            "parse_long_integer",
            "parse_number",
            "parse_object_colon",
            "parse_str",
            "parse_str_bytes",
            "parse_str_raw",
            "parse_unicode_escape",
            "parse_whitespace",
            "peek",
            "peek_end_of_value",
            "peek_or_eof",
            "peek_or_null",
            "scan_integer128",
            "serialize",
            "serialize_bool",
            "serialize_bytes",
            "serialize_char",
            "serialize_element",
            "serialize_f32",
            "serialize_f64",
            "serialize_field",
            "serialize_i128",
            "serialize_i16",
            "serialize_i32",
            "serialize_i64",
            "serialize_i8",
            "serialize_key",
            "serialize_map",
            "serialize_newtype_struct",
            "serialize_newtype_variant",
            "serialize_none",
            "serialize_seq",
            "serialize_some",
            "serialize_str",
            "serialize_struct",
            "serialize_struct_variant",
            "serialize_tuple",
            "serialize_tuple_struct",
            "serialize_tuple_variant",
            "serialize_u128",
            "serialize_u16",
            "serialize_u32",
            "serialize_u64",
            "serialize_u8",
            "serialize_unit",
            "serialize_unit_struct",
            "serialize_unit_variant",
            "serialize_value",
            "struct_variant",
            "to_string",
            "to_string_pretty",
            "to_value",
            "to_vec",
            "to_vec_pretty",
            "to_writer",
            "to_writer_pretty",
            "tuple_variant",
            "unit_variant",
            "variant_seed",
            "visit",
            "visit_array",
            "visit_array_ref",
            "visit_bool",
            "visit_f64",
            "visit_i128",
            "visit_i64",
            "visit_map",
            "visit_none",
            "visit_seq",
            "visit_some",
            "visit_str",
            "visit_string",
            "visit_u128",
            "visit_u64",
            "visit_unit",
            "write",
            "write_bool",
            "write_byte_array",
            "write_char_escape",
            "write_f32",
            "write_f64",
            "write_i128",
            "write_i16",
            "write_i32",
            "write_i64",
            "write_i8",
            "write_null",
            "write_number_str",
            "write_raw_fragment",
            "write_str",
            "write_string_fragment",
            "write_u128",
            "write_u16",
            "write_u32",
            "write_u64",
            "write_u8"
        ],
        "de::Deserializer": [
            "from_reader",
            "from_slice",
            "from_str",
            "new"
        ],
        "de::MapAccess": [
            "new"
        ],
        "de::SeqAccess": [
            "new"
        ],
        "de::StreamDeserializer": [
            "into_iter",
            "new"
        ],
        "de::UnitVariantAccess": [
            "new"
        ],
        "de::VariantAccess": [
            "new"
        ],
        "error::Category": [
            "classify",
            "clone"
        ],
        "error::Error": [
            "custom",
            "error",
            "float_key_must_be_finite",
            "invalid_type",
            "invalid_value",
            "io",
            "key_must_be_a_string",
            "make_error",
            "peek_error",
            "peek_invalid_type",
            "syntax"
        ],
        "iter::LineColIterator": [
            "new"
        ],
        "map::Entry": [
            "entry"
        ],
        "map::IntoValues": [
            "into_values"
        ],
        "map::Iter": [
            "iter"
        ],
        "map::IterMut": [
            "iter_mut"
        ],
        "map::Keys": [
            "keys"
        ],
        "map::Map": [
            "clone",
            "default",
            "from_iter",
            "new",
            "with_capacity"
        ],
        "map::Values": [
            "values"
        ],
        "map::ValuesMut": [
            "values_mut"
        ],
        "number::N": [
            "clone"
        ],
        "number::Number": [
            "clone",
            "from"
        ],
        "read::IoRead": [
            "new"
        ],
        "read::Position": [
            "peek_position",
            "position",
            "position_of_index"
        ],
        "read::SliceRead": [
            "new"
        ],
        "read::StrRead": [
            "new"
        ],
        "ser::CharEscape": [
            "from_escape_table"
        ],
        "ser::CompactFormatter": [
            "clone"
        ],
        "ser::PrettyFormatter": [
            "clone",
            "default",
            "new",
            "with_indent"
        ],
        "ser::Serializer": [
            "new",
            "pretty",
            "with_formatter"
        ],
        "serde::de::Unexpected": [
            "unexpected"
        ],
        "std::io::Error": [
            "from",
            "io_error"
        ],
        "usize": [
            "byte_offset",
            "col",
            "column",
            "len",
            "line"
        ],
        "value::Value": [
            "clone",
            "default",
            "from",
            "from_iter",
            "remove",
            "take"
        ],
        "value::de::BorrowedCowStrDeserializer": [
            "new"
        ],
        "value::de::MapDeserializer": [
            "new"
        ],
        "value::de::MapRefDeserializer": [
            "new"
        ],
        "value::de::SeqDeserializer": [
            "new"
        ],
        "value::de::SeqRefDeserializer": [
            "new"
        ]
    },
    "struct_to_trait": {
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter": [
            "core::fmt::Write"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor": [
            "serde::de::Visitor"
        ],
        "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor": [
            "serde::de::Visitor"
        ],
        "<value::Value as core::fmt::Display>::fmt::WriterFormatter": [
            "std::io::Write"
        ],
        "alloc::string::String": [
            "core::cmp::PartialEq",
            "value::index::Index",
            "value::index::private::Sealed"
        ],
        "de::MapAccess": [
            "serde::de::MapAccess"
        ],
        "de::MapKey": [
            "serde::Deserializer"
        ],
        "de::SeqAccess": [
            "serde::de::SeqAccess"
        ],
        "de::StreamDeserializer": [
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "de::UnitVariantAccess": [
            "serde::de::EnumAccess",
            "serde::de::VariantAccess"
        ],
        "de::VariantAccess": [
            "serde::de::EnumAccess",
            "serde::de::VariantAccess"
        ],
        "error::Category": [
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::fmt::Debug",
            "core::marker::Copy",
            "core::marker::StructuralPartialEq"
        ],
        "error::Error": [
            "core::error::Error",
            "core::fmt::Debug",
            "core::fmt::Display",
            "serde::de::Error",
            "serde::ser::Error"
        ],
        "error::ErrorCode": [
            "core::fmt::Display"
        ],
        "error::ErrorImpl": [
            "core::fmt::Display"
        ],
        "error::JsonUnexpected": [
            "core::fmt::Display"
        ],
        "iter::LineColIterator": [
            "core::iter::Iterator"
        ],
        "map::IntoIter": [
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::IntoValues": [
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::Iter": [
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::IterMut": [
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::Keys": [
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::Map": [
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::default::Default",
            "core::fmt::Debug",
            "core::hash::Hash",
            "core::iter::Extend",
            "core::iter::FromIterator",
            "core::iter::IntoIterator",
            "core::ops::Index",
            "core::ops::IndexMut",
            "serde::Deserialize",
            "serde::Deserializer",
            "serde::Serialize",
            "serde::de::IntoDeserializer"
        ],
        "map::Values": [
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::ValuesMut": [
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "number::N": [
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::hash::Hash",
            "core::marker::Copy"
        ],
        "number::Number": [
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::convert::From",
            "core::fmt::Debug",
            "core::fmt::Display",
            "core::hash::Hash",
            "core::marker::StructuralPartialEq",
            "core::str::FromStr",
            "serde::Deserialize",
            "serde::Deserializer",
            "serde::Serialize"
        ],
        "read::IoRead": [
            "read::Read",
            "read::private::Sealed"
        ],
        "read::Reference": [
            "core::ops::Deref"
        ],
        "read::SliceRead": [
            "read::Fused",
            "read::Read",
            "read::private::Sealed"
        ],
        "read::StrRead": [
            "read::Fused",
            "read::Read",
            "read::private::Sealed"
        ],
        "ser::CompactFormatter": [
            "core::clone::Clone",
            "core::fmt::Debug",
            "ser::Formatter"
        ],
        "ser::Compound": [
            "serde::ser::SerializeMap",
            "serde::ser::SerializeSeq",
            "serde::ser::SerializeStruct",
            "serde::ser::SerializeStructVariant",
            "serde::ser::SerializeTuple",
            "serde::ser::SerializeTupleStruct",
            "serde::ser::SerializeTupleVariant"
        ],
        "ser::MapKeySerializer": [
            "serde::Serializer"
        ],
        "ser::PrettyFormatter": [
            "core::clone::Clone",
            "core::default::Default",
            "core::fmt::Debug",
            "ser::Formatter"
        ],
        "ser::State": [
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::marker::StructuralPartialEq"
        ],
        "std::io::Error": [
            "core::convert::From"
        ],
        "value::Value": [
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::convert::From",
            "core::default::Default",
            "core::fmt::Debug",
            "core::fmt::Display",
            "core::hash::Hash",
            "core::iter::FromIterator",
            "core::marker::StructuralPartialEq",
            "core::ops::Index",
            "core::ops::IndexMut",
            "core::str::FromStr",
            "serde::Deserialize",
            "serde::Deserializer",
            "serde::Serialize",
            "serde::de::IntoDeserializer"
        ],
        "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor": [
            "serde::de::Visitor"
        ],
        "value::de::BorrowedCowStrDeserializer": [
            "serde::Deserializer",
            "serde::de::EnumAccess"
        ],
        "value::de::EnumDeserializer": [
            "serde::de::EnumAccess"
        ],
        "value::de::EnumRefDeserializer": [
            "serde::de::EnumAccess"
        ],
        "value::de::KeyClassifier": [
            "serde::de::DeserializeSeed",
            "serde::de::Visitor"
        ],
        "value::de::MapDeserializer": [
            "serde::de::MapAccess"
        ],
        "value::de::MapKeyDeserializer": [
            "serde::Deserializer"
        ],
        "value::de::MapRefDeserializer": [
            "serde::de::MapAccess"
        ],
        "value::de::SeqDeserializer": [
            "serde::de::SeqAccess"
        ],
        "value::de::SeqRefDeserializer": [
            "serde::de::SeqAccess"
        ],
        "value::de::UnitOnly": [
            "serde::de::VariantAccess"
        ],
        "value::de::VariantDeserializer": [
            "serde::de::VariantAccess"
        ],
        "value::de::VariantRefDeserializer": [
            "serde::de::VariantAccess"
        ],
        "value::index::Type": [
            "core::fmt::Display"
        ],
        "value::ser::MapKeySerializer": [
            "serde::Serializer"
        ],
        "value::ser::SerializeMap": [
            "serde::ser::SerializeMap",
            "serde::ser::SerializeStruct"
        ],
        "value::ser::SerializeStructVariant": [
            "serde::ser::SerializeStructVariant"
        ],
        "value::ser::SerializeTupleVariant": [
            "serde::ser::SerializeTupleVariant"
        ],
        "value::ser::SerializeVec": [
            "serde::ser::SerializeSeq",
            "serde::ser::SerializeTuple",
            "serde::ser::SerializeTupleStruct"
        ],
        "value::ser::Serializer": [
            "serde::Serializer"
        ]
    },
    "targets": {
        "<&'a map::Map<alloc::string::String, value::Value> as core::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::IntoIterator"
        ],
        "<&'a mut map::Map<alloc::string::String, value::Value> as core::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::IntoIterator"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str": [
            "collect_str",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool": [
            "serialize_bool",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes": [
            "serialize_bytes",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char": [
            "serialize_char",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32": [
            "serialize_f32",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64": [
            "serialize_f64",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128": [
            "serialize_i128",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16": [
            "serialize_i16",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32": [
            "serialize_i32",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64": [
            "serialize_i64",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8": [
            "serialize_i8",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map": [
            "serialize_map",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct": [
            "serialize_newtype_struct",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant": [
            "serialize_newtype_variant",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none": [
            "serialize_none",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq": [
            "serialize_seq",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some": [
            "serialize_some",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str": [
            "serialize_str",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct": [
            "serialize_struct",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant": [
            "serialize_struct_variant",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple": [
            "serialize_tuple",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct": [
            "serialize_tuple_struct",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant": [
            "serialize_tuple_variant",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128": [
            "serialize_u128",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16": [
            "serialize_u16",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32": [
            "serialize_u32",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64": [
            "serialize_u64",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8": [
            "serialize_u8",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit": [
            "serialize_unit",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct": [
            "serialize_unit_struct",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant": [
            "serialize_unit_variant",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<&'de map::Map<alloc::string::String, value::Value> as serde::de::IntoDeserializer<'de, error::Error>>::into_deserializer": [
            "into_deserializer",
            "Real(LocalPath(\"src/map.rs\"))",
            "serde::de::IntoDeserializer"
        ],
        "<&T as value::index::Index>::index_into": [
            "index_into",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<&T as value::index::Index>::index_into_mut": [
            "index_into_mut",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<&T as value::index::Index>::index_or_insert": [
            "index_or_insert",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<&mut R as read::Read<'de>>::byte_offset": [
            "byte_offset",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut R as read::Read<'de>>::decode_hex_escape": [
            "decode_hex_escape",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut R as read::Read<'de>>::discard": [
            "discard",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut R as read::Read<'de>>::ignore_str": [
            "ignore_str",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut R as read::Read<'de>>::next": [
            "next",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut R as read::Read<'de>>::parse_str": [
            "parse_str",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut R as read::Read<'de>>::parse_str_raw": [
            "parse_str_raw",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut R as read::Read<'de>>::peek": [
            "peek",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut R as read::Read<'de>>::peek_position": [
            "peek_position",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut R as read::Read<'de>>::position": [
            "position",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut R as read::Read<'de>>::set_failed": [
            "set_failed",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any": [
            "deserialize_any",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool": [
            "deserialize_bool",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "deserialize_byte_buf",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes": [
            "deserialize_bytes",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char": [
            "deserialize_char",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum": [
            "deserialize_enum",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32": [
            "deserialize_f32",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64": [
            "deserialize_f64",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128": [
            "deserialize_i128",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16": [
            "deserialize_i16",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32": [
            "deserialize_i32",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64": [
            "deserialize_i64",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8": [
            "deserialize_i8",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier": [
            "deserialize_identifier",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "deserialize_ignored_any",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map": [
            "deserialize_map",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "deserialize_newtype_struct",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option": [
            "deserialize_option",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq": [
            "deserialize_seq",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str": [
            "deserialize_str",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string": [
            "deserialize_string",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct": [
            "deserialize_struct",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple": [
            "deserialize_tuple",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "deserialize_tuple_struct",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128": [
            "deserialize_u128",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16": [
            "deserialize_u16",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32": [
            "deserialize_u32",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64": [
            "deserialize_u64",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8": [
            "deserialize_u8",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit": [
            "deserialize_unit",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "deserialize_unit_struct",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_any": [
            "deserialize_any",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_bool": [
            "deserialize_bool",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "deserialize_byte_buf",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_bytes": [
            "deserialize_bytes",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_char": [
            "deserialize_char",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_enum": [
            "deserialize_enum",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_f32": [
            "deserialize_f32",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_f64": [
            "deserialize_f64",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i128": [
            "deserialize_i128",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i16": [
            "deserialize_i16",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i32": [
            "deserialize_i32",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i64": [
            "deserialize_i64",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_i8": [
            "deserialize_i8",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_identifier": [
            "deserialize_identifier",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "deserialize_ignored_any",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_map": [
            "deserialize_map",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "deserialize_newtype_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_option": [
            "deserialize_option",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_seq": [
            "deserialize_seq",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_str": [
            "deserialize_str",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_string": [
            "deserialize_string",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_struct": [
            "deserialize_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_tuple": [
            "deserialize_tuple",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "deserialize_tuple_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u128": [
            "deserialize_u128",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u16": [
            "deserialize_u16",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u32": [
            "deserialize_u32",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u64": [
            "deserialize_u64",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_u8": [
            "deserialize_u8",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_unit": [
            "deserialize_unit",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<&number::Number as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "deserialize_unit_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as core::fmt::Write>::write_str": [
            "write_str",
            "Real(LocalPath(\"src/ser.rs\"))",
            "core::fmt::Write"
        ],
        "<<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting": [
            "expecting",
            "Real(LocalPath(\"src/map.rs\"))",
            "serde::de::Visitor"
        ],
        "<<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map": [
            "visit_map",
            "Real(LocalPath(\"src/map.rs\"))",
            "serde::de::Visitor"
        ],
        "<<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit": [
            "visit_unit",
            "Real(LocalPath(\"src/map.rs\"))",
            "serde::de::Visitor"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::expecting": [
            "expecting",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::de::Visitor"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64": [
            "visit_f64",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::de::Visitor"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i128": [
            "visit_i128",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::de::Visitor"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64": [
            "visit_i64",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::de::Visitor"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u128": [
            "visit_u128",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::de::Visitor"
        ],
        "<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64": [
            "visit_u64",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::de::Visitor"
        ],
        "<<value::Value as core::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::flush": [
            "flush",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            "std::io::Write"
        ],
        "<<value::Value as core::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::write": [
            "write",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            "std::io::Write"
        ],
        "<alloc::string::String as value::index::Index>::index_into": [
            "index_into",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<alloc::string::String as value::index::Index>::index_into_mut": [
            "index_into_mut",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<alloc::string::String as value::index::Index>::index_or_insert": [
            "index_or_insert",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed": [
            "next_key_seed",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::MapAccess"
        ],
        "<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed::has_next_key": [
            "has_next_key",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed": [
            "next_value_seed",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::MapAccess"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any": [
            "deserialize_any",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool": [
            "deserialize_bool",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "deserialize_byte_buf",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes": [
            "deserialize_bytes",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char": [
            "deserialize_char",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum": [
            "deserialize_enum",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32": [
            "deserialize_f32",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64": [
            "deserialize_f64",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128": [
            "deserialize_i128",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16": [
            "deserialize_i16",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32": [
            "deserialize_i32",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64": [
            "deserialize_i64",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8": [
            "deserialize_i8",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier": [
            "deserialize_identifier",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "deserialize_ignored_any",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map": [
            "deserialize_map",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "deserialize_newtype_struct",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option": [
            "deserialize_option",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq": [
            "deserialize_seq",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str": [
            "deserialize_str",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string": [
            "deserialize_string",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct": [
            "deserialize_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple": [
            "deserialize_tuple",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "deserialize_tuple_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128": [
            "deserialize_u128",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16": [
            "deserialize_u16",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32": [
            "deserialize_u32",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64": [
            "deserialize_u64",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8": [
            "deserialize_u8",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit": [
            "deserialize_unit",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "deserialize_unit_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed": [
            "next_element_seed",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::SeqAccess"
        ],
        "<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed::has_next_element": [
            "has_next_element",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "<de::StreamDeserializer<'de, R, T> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/de.rs\"))",
            "core::iter::Iterator"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed": [
            "variant_seed",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::EnumAccess"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "newtype_variant_seed",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant": [
            "struct_variant",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant": [
            "tuple_variant",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant": [
            "unit_variant",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed": [
            "variant_seed",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::EnumAccess"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "newtype_variant_seed",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant": [
            "struct_variant",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant": [
            "tuple_variant",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant": [
            "unit_variant",
            "Real(LocalPath(\"src/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<error::Error as core::error::Error>::source": [
            "source",
            "Real(LocalPath(\"src/error.rs\"))",
            "core::error::Error"
        ],
        "<error::Error as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/error.rs\"))",
            "core::fmt::Debug"
        ],
        "<error::Error as core::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/error.rs\"))",
            "core::fmt::Display"
        ],
        "<error::Error as serde::de::Error>::custom": [
            "custom",
            "Real(LocalPath(\"src/error.rs\"))",
            "serde::de::Error"
        ],
        "<error::Error as serde::de::Error>::invalid_type": [
            "invalid_type",
            "Real(LocalPath(\"src/error.rs\"))",
            "serde::de::Error"
        ],
        "<error::Error as serde::de::Error>::invalid_value": [
            "invalid_value",
            "Real(LocalPath(\"src/error.rs\"))",
            "serde::de::Error"
        ],
        "<error::Error as serde::ser::Error>::custom": [
            "custom",
            "Real(LocalPath(\"src/error.rs\"))",
            "serde::ser::Error"
        ],
        "<error::ErrorCode as core::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/error.rs\"))",
            "core::fmt::Display"
        ],
        "<error::ErrorImpl as core::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/error.rs\"))",
            "core::fmt::Display"
        ],
        "<error::JsonUnexpected<'a> as core::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/error.rs\"))",
            "core::fmt::Display"
        ],
        "<iter::LineColIterator<I> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::IntoIter as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::IntoIter as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::IntoIter as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::IntoIter as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::IntoValues as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::IntoValues as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::IntoValues as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::IntoValues as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::Iter<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::Iter<'a> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::Iter<'a> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::Iter<'a> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::IterMut<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::IterMut<'a> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::IterMut<'a> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::IterMut<'a> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::Keys<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::Keys<'a> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::Keys<'a> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::Keys<'a> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::clone::Clone"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::clone::Clone>::clone_from": [
            "clone_from",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::clone::Clone"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::cmp::PartialEq>::eq": [
            "eq",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::cmp::PartialEq"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::default::Default"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::hash::Hash"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::iter::Extend<(alloc::string::String, value::Value)>>::extend": [
            "extend",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Extend"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::iter::FromIterator<(alloc::string::String, value::Value)>>::from_iter": [
            "from_iter",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::FromIterator"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::IntoIterator"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::ops::Index<&Q>>::index": [
            "index",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::ops::Index"
        ],
        "<map::Map<alloc::string::String, value::Value> as core::ops::IndexMut<&Q>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::ops::IndexMut"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize": [
            "deserialize",
            "Real(LocalPath(\"src/map.rs\"))",
            "serde::Deserialize"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::Serialize>::serialize": [
            "serialize",
            "Real(LocalPath(\"src/map.rs\"))",
            "serde::Serialize"
        ],
        "<map::Map<alloc::string::String, value::Value> as serde::de::IntoDeserializer<'de, error::Error>>::into_deserializer": [
            "into_deserializer",
            "Real(LocalPath(\"src/map.rs\"))",
            "serde::de::IntoDeserializer"
        ],
        "<map::Values<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::Values<'a> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::Values<'a> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::Values<'a> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::ValuesMut<'a> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::ValuesMut<'a> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::ValuesMut<'a> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::ValuesMut<'a> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Iterator"
        ],
        "<number::N as core::cmp::PartialEq>::eq": [
            "eq",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::cmp::PartialEq"
        ],
        "<number::N as core::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::hash::Hash"
        ],
        "<number::Number as core::convert::From<de::ParserNumber>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::convert::From<i16>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::convert::From<i32>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::convert::From<i64>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::convert::From<i8>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::convert::From<isize>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::convert::From<u16>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::convert::From<u32>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::convert::From<u64>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::convert::From<u8>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::convert::From<usize>>::from": [
            "from",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::convert::From"
        ],
        "<number::Number as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::fmt::Debug"
        ],
        "<number::Number as core::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/number.rs\"))",
            "core::fmt::Display"
        ],
        "<number::Number as serde::Deserialize<'de>>::deserialize": [
            "deserialize",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserialize"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_any": [
            "deserialize_any",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_bool": [
            "deserialize_bool",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "deserialize_byte_buf",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_bytes": [
            "deserialize_bytes",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_char": [
            "deserialize_char",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_enum": [
            "deserialize_enum",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_f32": [
            "deserialize_f32",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_f64": [
            "deserialize_f64",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i128": [
            "deserialize_i128",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i16": [
            "deserialize_i16",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i32": [
            "deserialize_i32",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i64": [
            "deserialize_i64",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_i8": [
            "deserialize_i8",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_identifier": [
            "deserialize_identifier",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "deserialize_ignored_any",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_map": [
            "deserialize_map",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "deserialize_newtype_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_option": [
            "deserialize_option",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_seq": [
            "deserialize_seq",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_str": [
            "deserialize_str",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_string": [
            "deserialize_string",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_struct": [
            "deserialize_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_tuple": [
            "deserialize_tuple",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "deserialize_tuple_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u128": [
            "deserialize_u128",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u16": [
            "deserialize_u16",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u32": [
            "deserialize_u32",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u64": [
            "deserialize_u64",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_u8": [
            "deserialize_u8",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_unit": [
            "deserialize_unit",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "deserialize_unit_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<number::Number as serde::Serialize>::serialize": [
            "serialize",
            "Real(LocalPath(\"src/number.rs\"))",
            "serde::Serialize"
        ],
        "<read::IoRead<R> as read::Read<'de>>::byte_offset": [
            "byte_offset",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::decode_hex_escape": [
            "decode_hex_escape",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::discard": [
            "discard",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::ignore_str": [
            "ignore_str",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::next": [
            "next",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::parse_str": [
            "parse_str",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::parse_str_raw": [
            "parse_str_raw",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::peek": [
            "peek",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::peek_position": [
            "peek_position",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::position": [
            "position",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::IoRead<R> as read::Read<'de>>::set_failed": [
            "set_failed",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::Reference<'b, 'c, T> as core::ops::Deref>::deref": [
            "deref",
            "Real(LocalPath(\"src/read.rs\"))",
            "core::ops::Deref"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::byte_offset": [
            "byte_offset",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::decode_hex_escape": [
            "decode_hex_escape",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::discard": [
            "discard",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::ignore_str": [
            "ignore_str",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::next": [
            "next",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::parse_str": [
            "parse_str",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::parse_str_raw": [
            "parse_str_raw",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::peek": [
            "peek",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::peek_position": [
            "peek_position",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::position": [
            "position",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::SliceRead<'a> as read::Read<'a>>::set_failed": [
            "set_failed",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::byte_offset": [
            "byte_offset",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::decode_hex_escape": [
            "decode_hex_escape",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::discard": [
            "discard",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::ignore_str": [
            "ignore_str",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::next": [
            "next",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::parse_str": [
            "parse_str",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::parse_str_raw": [
            "parse_str_raw",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::peek": [
            "peek",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::peek_position": [
            "peek_position",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::position": [
            "position",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<read::StrRead<'a> as read::Read<'a>>::set_failed": [
            "set_failed",
            "Real(LocalPath(\"src/read.rs\"))",
            "read::Read"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end": [
            "end",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeMap"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key": [
            "serialize_key",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeMap"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value": [
            "serialize_value",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeMap"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end": [
            "end",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeSeq"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element": [
            "serialize_element",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeSeq"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end": [
            "end",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeStruct"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field": [
            "serialize_field",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeStruct"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end": [
            "end",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeStructVariant"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field": [
            "serialize_field",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeStructVariant"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end": [
            "end",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeTuple"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element": [
            "serialize_element",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeTuple"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end": [
            "end",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeTupleStruct"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field": [
            "serialize_field",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeTupleStruct"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end": [
            "end",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeTupleVariant"
        ],
        "<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field": [
            "serialize_field",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::ser::SerializeTupleVariant"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str": [
            "collect_str",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool": [
            "serialize_bool",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes": [
            "serialize_bytes",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char": [
            "serialize_char",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32": [
            "serialize_f32",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64": [
            "serialize_f64",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128": [
            "serialize_i128",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16": [
            "serialize_i16",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32": [
            "serialize_i32",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64": [
            "serialize_i64",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8": [
            "serialize_i8",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map": [
            "serialize_map",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct": [
            "serialize_newtype_struct",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant": [
            "serialize_newtype_variant",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none": [
            "serialize_none",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq": [
            "serialize_seq",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some": [
            "serialize_some",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str": [
            "serialize_str",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct": [
            "serialize_struct",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant": [
            "serialize_struct_variant",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple": [
            "serialize_tuple",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct": [
            "serialize_tuple_struct",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant": [
            "serialize_tuple_variant",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128": [
            "serialize_u128",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16": [
            "serialize_u16",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32": [
            "serialize_u32",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64": [
            "serialize_u64",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8": [
            "serialize_u8",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit": [
            "serialize_unit",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct": [
            "serialize_unit_struct",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant": [
            "serialize_unit_variant",
            "Real(LocalPath(\"src/ser.rs\"))",
            "serde::Serializer"
        ],
        "<ser::PrettyFormatter<'a> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/ser.rs\"))",
            "core::default::Default"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array": [
            "begin_array",
            "Real(LocalPath(\"src/ser.rs\"))",
            "ser::Formatter"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value": [
            "begin_array_value",
            "Real(LocalPath(\"src/ser.rs\"))",
            "ser::Formatter"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object": [
            "begin_object",
            "Real(LocalPath(\"src/ser.rs\"))",
            "ser::Formatter"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key": [
            "begin_object_key",
            "Real(LocalPath(\"src/ser.rs\"))",
            "ser::Formatter"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value": [
            "begin_object_value",
            "Real(LocalPath(\"src/ser.rs\"))",
            "ser::Formatter"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_array": [
            "end_array",
            "Real(LocalPath(\"src/ser.rs\"))",
            "ser::Formatter"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value": [
            "end_array_value",
            "Real(LocalPath(\"src/ser.rs\"))",
            "ser::Formatter"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_object": [
            "end_object",
            "Real(LocalPath(\"src/ser.rs\"))",
            "ser::Formatter"
        ],
        "<ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value": [
            "end_object_value",
            "Real(LocalPath(\"src/ser.rs\"))",
            "ser::Formatter"
        ],
        "<str as value::index::Index>::index_into": [
            "index_into",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<str as value::index::Index>::index_into_mut": [
            "index_into_mut",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<str as value::index::Index>::index_or_insert": [
            "index_or_insert",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<usize as value::index::Index>::index_into": [
            "index_into",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<usize as value::index::Index>::index_into_mut": [
            "index_into_mut",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<usize as value::index::Index>::index_or_insert": [
            "index_or_insert",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "value::index::Index"
        ],
        "<value::Value as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            "core::default::Default"
        ],
        "<value::Value as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            "core::fmt::Debug"
        ],
        "<value::Value as core::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            "core::fmt::Display"
        ],
        "<value::Value as core::fmt::Display>::fmt::io_error": [
            "io_error",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting": [
            "expecting",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool": [
            "visit_bool",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64": [
            "visit_f64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i128": [
            "visit_i128",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64": [
            "visit_i64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map": [
            "visit_map",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none": [
            "visit_none",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq": [
            "visit_seq",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some": [
            "visit_some",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str": [
            "visit_str",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string": [
            "visit_string",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u128": [
            "visit_u128",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64": [
            "visit_u64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit": [
            "visit_unit",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any": [
            "deserialize_any",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool": [
            "deserialize_bool",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "deserialize_byte_buf",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes": [
            "deserialize_bytes",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char": [
            "deserialize_char",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum": [
            "deserialize_enum",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32": [
            "deserialize_f32",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64": [
            "deserialize_f64",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128": [
            "deserialize_i128",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16": [
            "deserialize_i16",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32": [
            "deserialize_i32",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64": [
            "deserialize_i64",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8": [
            "deserialize_i8",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier": [
            "deserialize_identifier",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "deserialize_ignored_any",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map": [
            "deserialize_map",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "deserialize_newtype_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option": [
            "deserialize_option",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq": [
            "deserialize_seq",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str": [
            "deserialize_str",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string": [
            "deserialize_string",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct": [
            "deserialize_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple": [
            "deserialize_tuple",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "deserialize_tuple_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128": [
            "deserialize_u128",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16": [
            "deserialize_u16",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32": [
            "deserialize_u32",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64": [
            "deserialize_u64",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8": [
            "deserialize_u8",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit": [
            "deserialize_unit",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "deserialize_unit_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed": [
            "variant_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::EnumAccess"
        ],
        "<value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed": [
            "variant_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::EnumAccess"
        ],
        "<value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed": [
            "variant_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::EnumAccess"
        ],
        "<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize": [
            "deserialize",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::DeserializeSeed"
        ],
        "<value::de::KeyClassifier as serde::de::Visitor<'de>>::expecting": [
            "expecting",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str": [
            "visit_str",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string": [
            "visit_string",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::Visitor"
        ],
        "<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed": [
            "next_key_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::MapAccess"
        ],
        "<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed": [
            "next_value_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::MapAccess"
        ],
        "<value::de::MapDeserializer as serde::de::MapAccess<'de>>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::MapAccess"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any": [
            "deserialize_any",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool": [
            "deserialize_bool",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf": [
            "deserialize_byte_buf",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes": [
            "deserialize_bytes",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char": [
            "deserialize_char",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum": [
            "deserialize_enum",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32": [
            "deserialize_f32",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64": [
            "deserialize_f64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128": [
            "deserialize_i128",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16": [
            "deserialize_i16",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32": [
            "deserialize_i32",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64": [
            "deserialize_i64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8": [
            "deserialize_i8",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier": [
            "deserialize_identifier",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any": [
            "deserialize_ignored_any",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map": [
            "deserialize_map",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct": [
            "deserialize_newtype_struct",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option": [
            "deserialize_option",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq": [
            "deserialize_seq",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str": [
            "deserialize_str",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string": [
            "deserialize_string",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct": [
            "deserialize_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple": [
            "deserialize_tuple",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct": [
            "deserialize_tuple_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128": [
            "deserialize_u128",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16": [
            "deserialize_u16",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32": [
            "deserialize_u32",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64": [
            "deserialize_u64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8": [
            "deserialize_u8",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit": [
            "deserialize_unit",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct": [
            "deserialize_unit_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed": [
            "next_key_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::MapAccess"
        ],
        "<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed": [
            "next_value_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::MapAccess"
        ],
        "<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::MapAccess"
        ],
        "<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed": [
            "next_element_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::SeqAccess"
        ],
        "<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::SeqAccess"
        ],
        "<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed": [
            "next_element_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::SeqAccess"
        ],
        "<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::SeqAccess"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "newtype_variant_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant": [
            "struct_variant",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant": [
            "tuple_variant",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::UnitOnly as serde::de::VariantAccess<'de>>::unit_variant": [
            "unit_variant",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "newtype_variant_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant": [
            "struct_variant",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant": [
            "tuple_variant",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::unit_variant": [
            "unit_variant",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed": [
            "newtype_variant_seed",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant": [
            "struct_variant",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant": [
            "tuple_variant",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::unit_variant": [
            "unit_variant",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::VariantAccess"
        ],
        "<value::index::Type<'a> as core::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "core::fmt::Display"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::collect_str": [
            "collect_str",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_bool": [
            "serialize_bool",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_bytes": [
            "serialize_bytes",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_char": [
            "serialize_char",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_f32": [
            "serialize_f32",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_f64": [
            "serialize_f64",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i128": [
            "serialize_i128",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i16": [
            "serialize_i16",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i32": [
            "serialize_i32",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i64": [
            "serialize_i64",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_i8": [
            "serialize_i8",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_map": [
            "serialize_map",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct": [
            "serialize_newtype_struct",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant": [
            "serialize_newtype_variant",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_none": [
            "serialize_none",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_seq": [
            "serialize_seq",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_some": [
            "serialize_some",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_str": [
            "serialize_str",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct": [
            "serialize_struct",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct_variant": [
            "serialize_struct_variant",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple": [
            "serialize_tuple",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_struct": [
            "serialize_tuple_struct",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_variant": [
            "serialize_tuple_variant",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u128": [
            "serialize_u128",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u16": [
            "serialize_u16",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u32": [
            "serialize_u32",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u64": [
            "serialize_u64",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_u8": [
            "serialize_u8",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit": [
            "serialize_unit",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_struct": [
            "serialize_unit_struct",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_variant": [
            "serialize_unit_variant",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeMap>::end": [
            "end",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeMap"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key": [
            "serialize_key",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeMap"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value": [
            "serialize_value",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeMap"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeStruct>::end": [
            "end",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeStruct"
        ],
        "<value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field": [
            "serialize_field",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeStruct"
        ],
        "<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::end": [
            "end",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeStructVariant"
        ],
        "<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field": [
            "serialize_field",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeStructVariant"
        ],
        "<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::end": [
            "end",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeTupleVariant"
        ],
        "<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field": [
            "serialize_field",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeTupleVariant"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeSeq>::end": [
            "end",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeSeq"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element": [
            "serialize_element",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeSeq"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTuple>::end": [
            "end",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeTuple"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element": [
            "serialize_element",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeTuple"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::end": [
            "end",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeTupleStruct"
        ],
        "<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field": [
            "serialize_field",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::ser::SerializeTupleStruct"
        ],
        "<value::ser::Serializer as serde::Serializer>::collect_str": [
            "collect_str",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_bool": [
            "serialize_bool",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_bytes": [
            "serialize_bytes",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_char": [
            "serialize_char",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_f32": [
            "serialize_f32",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_f64": [
            "serialize_f64",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i128": [
            "serialize_i128",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i16": [
            "serialize_i16",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i32": [
            "serialize_i32",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i64": [
            "serialize_i64",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_i8": [
            "serialize_i8",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_map": [
            "serialize_map",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_newtype_struct": [
            "serialize_newtype_struct",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_newtype_variant": [
            "serialize_newtype_variant",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_none": [
            "serialize_none",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_seq": [
            "serialize_seq",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_some": [
            "serialize_some",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_str": [
            "serialize_str",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_struct": [
            "serialize_struct",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_struct_variant": [
            "serialize_struct_variant",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_tuple": [
            "serialize_tuple",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_tuple_struct": [
            "serialize_tuple_struct",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_tuple_variant": [
            "serialize_tuple_variant",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u128": [
            "serialize_u128",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u16": [
            "serialize_u16",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u32": [
            "serialize_u32",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u64": [
            "serialize_u64",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_u8": [
            "serialize_u8",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_unit": [
            "serialize_unit",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_unit_struct": [
            "serialize_unit_struct",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "<value::ser::Serializer as serde::Serializer>::serialize_unit_variant": [
            "serialize_unit_variant",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serializer"
        ],
        "de::<impl core::str::FromStr for number::Number>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/de.rs\"))",
            "core::str::FromStr"
        ],
        "de::Deserializer::<R>::deserialize_number": [
            "deserialize_number",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::do_deserialize_i128": [
            "do_deserialize_i128",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::do_deserialize_u128": [
            "do_deserialize_u128",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::eat_char": [
            "eat_char",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::end": [
            "end",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::end_map": [
            "end_map",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::end_seq": [
            "end_seq",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::error": [
            "error",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::f64_from_parts": [
            "f64_from_parts",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::fix_position": [
            "fix_position",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::ignore_decimal": [
            "ignore_decimal",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::ignore_exponent": [
            "ignore_exponent",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::ignore_integer": [
            "ignore_integer",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::ignore_value": [
            "ignore_value",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::new": [
            "new",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::next_char": [
            "next_char",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::next_char_or_null": [
            "next_char_or_null",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_any_number": [
            "parse_any_number",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_any_signed_number": [
            "parse_any_signed_number",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_decimal": [
            "parse_decimal",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_decimal_overflow": [
            "parse_decimal_overflow",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_exponent": [
            "parse_exponent",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_exponent_overflow": [
            "parse_exponent_overflow",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_ident": [
            "parse_ident",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_integer": [
            "parse_integer",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_long_integer": [
            "parse_long_integer",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_number": [
            "parse_number",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_object_colon": [
            "parse_object_colon",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::parse_whitespace": [
            "parse_whitespace",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::peek": [
            "peek",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::peek_error": [
            "peek_error",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::peek_invalid_type": [
            "peek_invalid_type",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::peek_or_null": [
            "peek_or_null",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<R>::scan_integer128": [
            "scan_integer128",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<read::IoRead<R>>::from_reader": [
            "from_reader",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<read::SliceRead<'a>>::from_slice": [
            "from_slice",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::Deserializer::<read::StrRead<'a>>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::MapAccess::<'a, R>::new": [
            "new",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::MapKey::<'a, R>::deserialize_number": [
            "deserialize_number",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::ParserNumber::invalid_type": [
            "invalid_type",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::ParserNumber::visit": [
            "visit",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::SeqAccess::<'a, R>::new": [
            "new",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::StreamDeserializer::<'de, R, T>::byte_offset": [
            "byte_offset",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::StreamDeserializer::<'de, R, T>::new": [
            "new",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::StreamDeserializer::<'de, R, T>::peek_end_of_value": [
            "peek_end_of_value",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::UnitVariantAccess::<'a, R>::new": [
            "new",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::VariantAccess::<'a, R>::new": [
            "new",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::from_reader": [
            "from_reader",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::from_slice": [
            "from_slice",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::from_str": [
            "from_str",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "de::from_trait": [
            "from_trait",
            "Real(LocalPath(\"src/de.rs\"))",
            ""
        ],
        "error::<impl core::convert::From<error::Error> for std::io::Error>::from": [
            "from",
            "Real(LocalPath(\"src/error.rs\"))",
            "core::convert::From"
        ],
        "error::Error::classify": [
            "classify",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::column": [
            "column",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::fix_position": [
            "fix_position",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::io": [
            "io",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::io_error_kind": [
            "io_error_kind",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::is_data": [
            "is_data",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::is_eof": [
            "is_eof",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::is_io": [
            "is_io",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::is_syntax": [
            "is_syntax",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::line": [
            "line",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::syntax": [
            "syntax",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::make_error": [
            "make_error",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::parse_line_col": [
            "parse_line_col",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::starts_with_digit": [
            "starts_with_digit",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "iter::LineColIterator::<I>::byte_offset": [
            "byte_offset",
            "Real(LocalPath(\"src/iter.rs\"))",
            ""
        ],
        "iter::LineColIterator::<I>::col": [
            "col",
            "Real(LocalPath(\"src/iter.rs\"))",
            ""
        ],
        "iter::LineColIterator::<I>::line": [
            "line",
            "Real(LocalPath(\"src/iter.rs\"))",
            ""
        ],
        "iter::LineColIterator::<I>::new": [
            "new",
            "Real(LocalPath(\"src/iter.rs\"))",
            ""
        ],
        "map::Entry::<'a>::and_modify": [
            "and_modify",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Entry::<'a>::key": [
            "key",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Entry::<'a>::or_insert": [
            "or_insert",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Entry::<'a>::or_insert_with": [
            "or_insert_with",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::append": [
            "append",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::clear": [
            "clear",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::contains_key": [
            "contains_key",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::entry": [
            "entry",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::get": [
            "get",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::get_key_value": [
            "get_key_value",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::insert": [
            "insert",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::into_values": [
            "into_values",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::is_empty": [
            "is_empty",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::iter": [
            "iter",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::iter_mut": [
            "iter_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::keys": [
            "keys",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::len": [
            "len",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::new": [
            "new",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::remove": [
            "remove",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::remove_entry": [
            "remove_entry",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::retain": [
            "retain",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::sort_keys": [
            "sort_keys",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::values": [
            "values",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::values_mut": [
            "values_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::Map::<alloc::string::String, value::Value>::with_capacity": [
            "with_capacity",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::OccupiedEntry::<'a>::get": [
            "get",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::OccupiedEntry::<'a>::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::OccupiedEntry::<'a>::insert": [
            "insert",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::OccupiedEntry::<'a>::into_mut": [
            "into_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::OccupiedEntry::<'a>::key": [
            "key",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::OccupiedEntry::<'a>::remove": [
            "remove",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::OccupiedEntry::<'a>::remove_entry": [
            "remove_entry",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::VacantEntry::<'a>::insert": [
            "insert",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::VacantEntry::<'a>::key": [
            "key",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "number::Number::as_f32": [
            "as_f32",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::as_f64": [
            "as_f64",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::as_i128": [
            "as_i128",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::as_i64": [
            "as_i64",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::as_u128": [
            "as_u128",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::as_u64": [
            "as_u64",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::from_f32": [
            "from_f32",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::from_f64": [
            "from_f64",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::from_i128": [
            "from_i128",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::from_u128": [
            "from_u128",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::is_f64": [
            "is_f64",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::is_i64": [
            "is_i64",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::is_u64": [
            "is_u64",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "number::Number::unexpected": [
            "unexpected",
            "Real(LocalPath(\"src/number.rs\"))",
            ""
        ],
        "read::IoRead::<R>::new": [
            "new",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::IoRead::<R>::parse_str_bytes": [
            "parse_str_bytes",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::SliceRead::<'a>::new": [
            "new",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::SliceRead::<'a>::parse_str_bytes": [
            "parse_str_bytes",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::SliceRead::<'a>::position_of_index": [
            "position_of_index",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::SliceRead::<'a>::skip_to_escape": [
            "skip_to_escape",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::SliceRead::<'a>::skip_to_escape_slow": [
            "skip_to_escape_slow",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::StrRead::<'a>::new": [
            "new",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::as_str": [
            "as_str",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::build_hex_table": [
            "build_hex_table",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::decode_four_hex_digits": [
            "decode_four_hex_digits",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::decode_hex_val_slow": [
            "decode_hex_val_slow",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::error": [
            "error",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::ignore_escape": [
            "ignore_escape",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::is_escape": [
            "is_escape",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::next_or_eof": [
            "next_or_eof",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::parse_escape": [
            "parse_escape",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::parse_unicode_escape": [
            "parse_unicode_escape",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::peek_or_eof": [
            "peek_or_eof",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "read::push_wtf8_codepoint": [
            "push_wtf8_codepoint",
            "Real(LocalPath(\"src/read.rs\"))",
            ""
        ],
        "ser::CharEscape::from_escape_table": [
            "from_escape_table",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::begin_array": [
            "begin_array",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::begin_array_value": [
            "begin_array_value",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::begin_object": [
            "begin_object",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::begin_object_key": [
            "begin_object_key",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::begin_object_value": [
            "begin_object_value",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::begin_string": [
            "begin_string",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::end_array": [
            "end_array",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::end_array_value": [
            "end_array_value",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::end_object": [
            "end_object",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::end_object_key": [
            "end_object_key",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::end_object_value": [
            "end_object_value",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::end_string": [
            "end_string",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_bool": [
            "write_bool",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_byte_array": [
            "write_byte_array",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_char_escape": [
            "write_char_escape",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_f32": [
            "write_f32",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_f64": [
            "write_f64",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_i128": [
            "write_i128",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_i16": [
            "write_i16",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_i32": [
            "write_i32",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_i64": [
            "write_i64",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_i8": [
            "write_i8",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_null": [
            "write_null",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_number_str": [
            "write_number_str",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_raw_fragment": [
            "write_raw_fragment",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_string_fragment": [
            "write_string_fragment",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_u128": [
            "write_u128",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_u16": [
            "write_u16",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_u32": [
            "write_u32",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_u64": [
            "write_u64",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Formatter::write_u8": [
            "write_u8",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::PrettyFormatter::<'a>::new": [
            "new",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::PrettyFormatter::<'a>::with_indent": [
            "with_indent",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Serializer::<W, F>::into_inner": [
            "into_inner",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Serializer::<W, F>::with_formatter": [
            "with_formatter",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty": [
            "pretty",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::Serializer::<W>::new": [
            "new",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::float_key_must_be_finite": [
            "float_key_must_be_finite",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::format_escaped_str": [
            "format_escaped_str",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::format_escaped_str_contents": [
            "format_escaped_str_contents",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::indent": [
            "indent",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::key_must_be_a_string": [
            "key_must_be_a_string",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::to_string": [
            "to_string",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::to_string_pretty": [
            "to_string_pretty",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::to_vec": [
            "to_vec",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::to_vec_pretty": [
            "to_vec_pretty",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::to_writer": [
            "to_writer",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "ser::to_writer_pretty": [
            "to_writer_pretty",
            "Real(LocalPath(\"src/ser.rs\"))",
            ""
        ],
        "value::Value::as_array": [
            "as_array",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::as_array_mut": [
            "as_array_mut",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::as_bool": [
            "as_bool",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::as_f64": [
            "as_f64",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::as_i64": [
            "as_i64",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::as_null": [
            "as_null",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::as_number": [
            "as_number",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::as_object": [
            "as_object",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::as_object_mut": [
            "as_object_mut",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::as_str": [
            "as_str",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::as_u64": [
            "as_u64",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::get": [
            "get",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::is_array": [
            "is_array",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::is_boolean": [
            "is_boolean",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::is_f64": [
            "is_f64",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::is_i64": [
            "is_i64",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::is_null": [
            "is_null",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::is_number": [
            "is_number",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::is_object": [
            "is_object",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::is_string": [
            "is_string",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::is_u64": [
            "is_u64",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::pointer": [
            "pointer",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::pointer_mut": [
            "pointer_mut",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::sort_all_objects": [
            "sort_all_objects",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::Value::take": [
            "take",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::de::<impl core::str::FromStr for value::Value>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "core::str::FromStr"
        ],
        "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize": [
            "deserialize",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserialize"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_any": [
            "deserialize_any",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_bool": [
            "deserialize_bool",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_byte_buf": [
            "deserialize_byte_buf",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_bytes": [
            "deserialize_bytes",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_char": [
            "deserialize_char",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_enum": [
            "deserialize_enum",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_f32": [
            "deserialize_f32",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_f64": [
            "deserialize_f64",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i128": [
            "deserialize_i128",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i16": [
            "deserialize_i16",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i32": [
            "deserialize_i32",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i64": [
            "deserialize_i64",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_i8": [
            "deserialize_i8",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_identifier": [
            "deserialize_identifier",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_ignored_any": [
            "deserialize_ignored_any",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_map": [
            "deserialize_map",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_newtype_struct": [
            "deserialize_newtype_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_option": [
            "deserialize_option",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_seq": [
            "deserialize_seq",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_str": [
            "deserialize_str",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_string": [
            "deserialize_string",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_struct": [
            "deserialize_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_tuple": [
            "deserialize_tuple",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_tuple_struct": [
            "deserialize_tuple_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u128": [
            "deserialize_u128",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u16": [
            "deserialize_u16",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u32": [
            "deserialize_u32",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u64": [
            "deserialize_u64",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_u8": [
            "deserialize_u8",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_unit": [
            "deserialize_unit",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de map::Map<alloc::string::String, value::Value>>::deserialize_unit_struct": [
            "deserialize_unit_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any": [
            "deserialize_any",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool": [
            "deserialize_bool",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf": [
            "deserialize_byte_buf",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes": [
            "deserialize_bytes",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char": [
            "deserialize_char",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum": [
            "deserialize_enum",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32": [
            "deserialize_f32",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64": [
            "deserialize_f64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128": [
            "deserialize_i128",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16": [
            "deserialize_i16",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32": [
            "deserialize_i32",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64": [
            "deserialize_i64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8": [
            "deserialize_i8",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier": [
            "deserialize_identifier",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any": [
            "deserialize_ignored_any",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map": [
            "deserialize_map",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct": [
            "deserialize_newtype_struct",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option": [
            "deserialize_option",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq": [
            "deserialize_seq",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str": [
            "deserialize_str",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string": [
            "deserialize_string",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct": [
            "deserialize_struct",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple": [
            "deserialize_tuple",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct": [
            "deserialize_tuple_struct",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128": [
            "deserialize_u128",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16": [
            "deserialize_u16",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32": [
            "deserialize_u32",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64": [
            "deserialize_u64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8": [
            "deserialize_u8",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit": [
            "deserialize_unit",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct": [
            "deserialize_unit_struct",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_any": [
            "deserialize_any",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_bool": [
            "deserialize_bool",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_byte_buf": [
            "deserialize_byte_buf",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_bytes": [
            "deserialize_bytes",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_char": [
            "deserialize_char",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_enum": [
            "deserialize_enum",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_f32": [
            "deserialize_f32",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_f64": [
            "deserialize_f64",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i128": [
            "deserialize_i128",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i16": [
            "deserialize_i16",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i32": [
            "deserialize_i32",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i64": [
            "deserialize_i64",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_i8": [
            "deserialize_i8",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_identifier": [
            "deserialize_identifier",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_ignored_any": [
            "deserialize_ignored_any",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_map": [
            "deserialize_map",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_newtype_struct": [
            "deserialize_newtype_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_option": [
            "deserialize_option",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_seq": [
            "deserialize_seq",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_str": [
            "deserialize_str",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_string": [
            "deserialize_string",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_struct": [
            "deserialize_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_tuple": [
            "deserialize_tuple",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_tuple_struct": [
            "deserialize_tuple_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u128": [
            "deserialize_u128",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u16": [
            "deserialize_u16",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u32": [
            "deserialize_u32",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u64": [
            "deserialize_u64",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_u8": [
            "deserialize_u8",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_unit": [
            "deserialize_unit",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for map::Map<alloc::string::String, value::Value>>::deserialize_unit_struct": [
            "deserialize_unit_struct",
            "Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.219/src/macros.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any": [
            "deserialize_any",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool": [
            "deserialize_bool",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf": [
            "deserialize_byte_buf",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes": [
            "deserialize_bytes",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char": [
            "deserialize_char",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum": [
            "deserialize_enum",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32": [
            "deserialize_f32",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64": [
            "deserialize_f64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128": [
            "deserialize_i128",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16": [
            "deserialize_i16",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32": [
            "deserialize_i32",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64": [
            "deserialize_i64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8": [
            "deserialize_i8",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier": [
            "deserialize_identifier",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any": [
            "deserialize_ignored_any",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map": [
            "deserialize_map",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct": [
            "deserialize_newtype_struct",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option": [
            "deserialize_option",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq": [
            "deserialize_seq",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str": [
            "deserialize_str",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string": [
            "deserialize_string",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct": [
            "deserialize_struct",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple": [
            "deserialize_tuple",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct": [
            "deserialize_tuple_struct",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128": [
            "deserialize_u128",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16": [
            "deserialize_u16",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32": [
            "deserialize_u32",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64": [
            "deserialize_u64",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8": [
            "deserialize_u8",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit": [
            "deserialize_unit",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct": [
            "deserialize_unit_struct",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::Deserializer"
        ],
        "value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for &'de value::Value>::into_deserializer": [
            "into_deserializer",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::IntoDeserializer"
        ],
        "value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for value::Value>::into_deserializer": [
            "into_deserializer",
            "Real(LocalPath(\"src/value/de.rs\"))",
            "serde::de::IntoDeserializer"
        ],
        "value::de::<impl value::Value>::invalid_type": [
            "invalid_type",
            "Real(LocalPath(\"src/value/de.rs\"))",
            ""
        ],
        "value::de::<impl value::Value>::unexpected": [
            "unexpected",
            "Real(LocalPath(\"src/value/de.rs\"))",
            ""
        ],
        "value::de::BorrowedCowStrDeserializer::<'de>::new": [
            "new",
            "Real(LocalPath(\"src/value/de.rs\"))",
            ""
        ],
        "value::de::MapDeserializer::new": [
            "new",
            "Real(LocalPath(\"src/value/de.rs\"))",
            ""
        ],
        "value::de::MapRefDeserializer::<'de>::new": [
            "new",
            "Real(LocalPath(\"src/value/de.rs\"))",
            ""
        ],
        "value::de::SeqDeserializer::new": [
            "new",
            "Real(LocalPath(\"src/value/de.rs\"))",
            ""
        ],
        "value::de::SeqRefDeserializer::<'de>::new": [
            "new",
            "Real(LocalPath(\"src/value/de.rs\"))",
            ""
        ],
        "value::de::visit_array": [
            "visit_array",
            "Real(LocalPath(\"src/value/de.rs\"))",
            ""
        ],
        "value::de::visit_array_ref": [
            "visit_array_ref",
            "Real(LocalPath(\"src/value/de.rs\"))",
            ""
        ],
        "value::from::<impl core::convert::From<&[T]> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<&str> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<()> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<[T; N]> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<alloc::borrow::Cow<'a, str>> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<alloc::string::String> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<alloc::vec::Vec<T>> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<bool> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<core::option::Option<T>> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<f32> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<f64> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<i16> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<i32> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<i64> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<i8> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<isize> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<map::Map<alloc::string::String, value::Value>> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<number::Number> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<u16> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<u32> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<u64> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<u8> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::convert::From<usize> for value::Value>::from": [
            "from",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::convert::From"
        ],
        "value::from::<impl core::iter::FromIterator<(K, V)> for value::Value>::from_iter": [
            "from_iter",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::iter::FromIterator"
        ],
        "value::from::<impl core::iter::FromIterator<T> for value::Value>::from_iter": [
            "from_iter",
            "Real(LocalPath(\"src/value/from.rs\"))",
            "core::iter::FromIterator"
        ],
        "value::from_value": [
            "from_value",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::index::<impl core::ops::Index<I> for value::Value>::index": [
            "index",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "core::ops::Index"
        ],
        "value::index::<impl core::ops::IndexMut<I> for value::Value>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/value/index.rs\"))",
            "core::ops::IndexMut"
        ],
        "value::parse_index": [
            "parse_index",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<&str> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<alloc::string::String> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<bool> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<bool> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<bool> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f32> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f32> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f32> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f64> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f64> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<f64> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i16> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i16> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i16> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i32> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i32> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i32> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i64> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i64> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i64> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i8> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i8> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<i8> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<isize> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<isize> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<isize> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<str> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u16> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u16> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u16> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u32> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u32> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u32> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u64> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u64> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u64> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u8> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u8> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<u8> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<usize> for &'a mut value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<usize> for &'a value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<usize> for value::Value>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for &str>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for alloc::string::String>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for bool>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for f32>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for f64>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i16>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i32>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i64>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for i8>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for isize>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for str>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u16>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u32>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u64>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for u8>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::<impl core::cmp::PartialEq<value::Value> for usize>::eq": [
            "eq",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            "core::cmp::PartialEq"
        ],
        "value::partial_eq::eq_bool": [
            "eq_bool",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            ""
        ],
        "value::partial_eq::eq_f32": [
            "eq_f32",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            ""
        ],
        "value::partial_eq::eq_f64": [
            "eq_f64",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            ""
        ],
        "value::partial_eq::eq_i64": [
            "eq_i64",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            ""
        ],
        "value::partial_eq::eq_str": [
            "eq_str",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            ""
        ],
        "value::partial_eq::eq_u64": [
            "eq_u64",
            "Real(LocalPath(\"src/value/partial_eq.rs\"))",
            ""
        ],
        "value::ser::<impl serde::Serialize for value::Value>::serialize": [
            "serialize",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            "serde::Serialize"
        ],
        "value::ser::float_key_must_be_finite": [
            "float_key_must_be_finite",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            ""
        ],
        "value::ser::key_must_be_a_string": [
            "key_must_be_a_string",
            "Real(LocalPath(\"src/value/ser.rs\"))",
            ""
        ],
        "value::to_value": [
            "to_value",
            "Real(LocalPath(\"src/value/mod.rs\"))",
            ""
        ]
    },
    "trait_to_struct": {
        "core::clone::Clone": [
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "ser::CompactFormatter",
            "ser::PrettyFormatter",
            "value::Value"
        ],
        "core::cmp::Eq": [
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "ser::State",
            "value::Value"
        ],
        "core::cmp::PartialEq": [
            "alloc::string::String",
            "error::Category",
            "map::Map",
            "number::N",
            "number::Number",
            "ser::State",
            "value::Value"
        ],
        "core::convert::From": [
            "number::Number",
            "std::io::Error",
            "value::Value"
        ],
        "core::default::Default": [
            "map::Map",
            "ser::PrettyFormatter",
            "value::Value"
        ],
        "core::error::Error": [
            "error::Error"
        ],
        "core::fmt::Debug": [
            "error::Category",
            "error::Error",
            "map::Map",
            "number::Number",
            "ser::CompactFormatter",
            "ser::PrettyFormatter",
            "value::Value"
        ],
        "core::fmt::Display": [
            "error::Error",
            "error::ErrorCode",
            "error::ErrorImpl",
            "error::JsonUnexpected",
            "number::Number",
            "value::Value",
            "value::index::Type"
        ],
        "core::fmt::Write": [
            "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter"
        ],
        "core::hash::Hash": [
            "map::Map",
            "number::N",
            "number::Number",
            "value::Value"
        ],
        "core::iter::DoubleEndedIterator": [
            "map::IntoIter",
            "map::IntoValues",
            "map::Iter",
            "map::IterMut",
            "map::Keys",
            "map::Values",
            "map::ValuesMut"
        ],
        "core::iter::ExactSizeIterator": [
            "map::IntoIter",
            "map::IntoValues",
            "map::Iter",
            "map::IterMut",
            "map::Keys",
            "map::Values",
            "map::ValuesMut"
        ],
        "core::iter::Extend": [
            "map::Map"
        ],
        "core::iter::FromIterator": [
            "map::Map",
            "value::Value"
        ],
        "core::iter::FusedIterator": [
            "de::StreamDeserializer",
            "map::IntoIter",
            "map::IntoValues",
            "map::Iter",
            "map::IterMut",
            "map::Keys",
            "map::Values",
            "map::ValuesMut"
        ],
        "core::iter::IntoIterator": [
            "map::Map"
        ],
        "core::iter::Iterator": [
            "de::StreamDeserializer",
            "iter::LineColIterator",
            "map::IntoIter",
            "map::IntoValues",
            "map::Iter",
            "map::IterMut",
            "map::Keys",
            "map::Values",
            "map::ValuesMut"
        ],
        "core::marker::Copy": [
            "error::Category",
            "number::N"
        ],
        "core::marker::StructuralPartialEq": [
            "error::Category",
            "number::Number",
            "ser::State",
            "value::Value"
        ],
        "core::ops::Deref": [
            "read::Reference"
        ],
        "core::ops::Index": [
            "map::Map",
            "value::Value"
        ],
        "core::ops::IndexMut": [
            "map::Map",
            "value::Value"
        ],
        "core::str::FromStr": [
            "number::Number",
            "value::Value"
        ],
        "read::Fused": [
            "read::SliceRead",
            "read::StrRead"
        ],
        "read::Read": [
            "read::IoRead",
            "read::SliceRead",
            "read::StrRead"
        ],
        "read::private::Sealed": [
            "read::IoRead",
            "read::SliceRead",
            "read::StrRead"
        ],
        "ser::Formatter": [
            "ser::CompactFormatter",
            "ser::PrettyFormatter"
        ],
        "serde::Deserialize": [
            "map::Map",
            "number::Number",
            "value::Value"
        ],
        "serde::Deserializer": [
            "de::MapKey",
            "map::Map",
            "number::Number",
            "value::Value",
            "value::de::BorrowedCowStrDeserializer",
            "value::de::MapKeyDeserializer"
        ],
        "serde::Serialize": [
            "map::Map",
            "number::Number",
            "value::Value"
        ],
        "serde::Serializer": [
            "ser::MapKeySerializer",
            "value::ser::MapKeySerializer",
            "value::ser::Serializer"
        ],
        "serde::de::DeserializeSeed": [
            "value::de::KeyClassifier"
        ],
        "serde::de::EnumAccess": [
            "de::UnitVariantAccess",
            "de::VariantAccess",
            "value::de::BorrowedCowStrDeserializer",
            "value::de::EnumDeserializer",
            "value::de::EnumRefDeserializer"
        ],
        "serde::de::Error": [
            "error::Error"
        ],
        "serde::de::IntoDeserializer": [
            "map::Map",
            "value::Value"
        ],
        "serde::de::MapAccess": [
            "de::MapAccess",
            "value::de::MapDeserializer",
            "value::de::MapRefDeserializer"
        ],
        "serde::de::SeqAccess": [
            "de::SeqAccess",
            "value::de::SeqDeserializer",
            "value::de::SeqRefDeserializer"
        ],
        "serde::de::VariantAccess": [
            "de::UnitVariantAccess",
            "de::VariantAccess",
            "value::de::UnitOnly",
            "value::de::VariantDeserializer",
            "value::de::VariantRefDeserializer"
        ],
        "serde::de::Visitor": [
            "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
            "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor",
            "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor",
            "value::de::KeyClassifier"
        ],
        "serde::ser::Error": [
            "error::Error"
        ],
        "serde::ser::SerializeMap": [
            "ser::Compound",
            "value::ser::SerializeMap"
        ],
        "serde::ser::SerializeSeq": [
            "ser::Compound",
            "value::ser::SerializeVec"
        ],
        "serde::ser::SerializeStruct": [
            "ser::Compound",
            "value::ser::SerializeMap"
        ],
        "serde::ser::SerializeStructVariant": [
            "ser::Compound",
            "value::ser::SerializeStructVariant"
        ],
        "serde::ser::SerializeTuple": [
            "ser::Compound",
            "value::ser::SerializeVec"
        ],
        "serde::ser::SerializeTupleStruct": [
            "ser::Compound",
            "value::ser::SerializeVec"
        ],
        "serde::ser::SerializeTupleVariant": [
            "ser::Compound",
            "value::ser::SerializeTupleVariant"
        ],
        "std::io::Write": [
            "<value::Value as core::fmt::Display>::fmt::WriterFormatter"
        ],
        "value::index::Index": [
            "alloc::string::String"
        ],
        "value::index::private::Sealed": [
            "alloc::string::String"
        ]
    },
    "type_to_def_path": {
        "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F>": "<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter",
        "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor": "<map::Map<alloc::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor",
        "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor": "<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor",
        "<value::Value as core::fmt::Display>::fmt::WriterFormatter<'a, 'b>": "<value::Value as core::fmt::Display>::fmt::WriterFormatter",
        "de::Deserializer<R>": "de::Deserializer",
        "de::MapAccess<'a, R>": "de::MapAccess",
        "de::MapKey<'a, R>": "de::MapKey",
        "de::ParserNumber": "de::ParserNumber",
        "de::SeqAccess<'a, R>": "de::SeqAccess",
        "de::StreamDeserializer<'de, R, T>": "de::StreamDeserializer",
        "de::UnitVariantAccess<'a, R>": "de::UnitVariantAccess",
        "de::VariantAccess<'a, R>": "de::VariantAccess",
        "error::Category": "error::Category",
        "error::Error": "error::Error",
        "error::ErrorCode": "error::ErrorCode",
        "error::ErrorImpl": "error::ErrorImpl",
        "error::JsonUnexpected<'a>": "error::JsonUnexpected",
        "iter::LineColIterator<I>": "iter::LineColIterator",
        "map::Entry<'a>": "map::Entry",
        "map::IntoIter": "map::IntoIter",
        "map::IntoValues": "map::IntoValues",
        "map::Iter<'a>": "map::Iter",
        "map::IterMut<'a>": "map::IterMut",
        "map::Keys<'a>": "map::Keys",
        "map::Map<K, V>": "map::Map",
        "map::OccupiedEntry<'a>": "map::OccupiedEntry",
        "map::VacantEntry<'a>": "map::VacantEntry",
        "map::Values<'a>": "map::Values",
        "map::ValuesMut<'a>": "map::ValuesMut",
        "number::N": "number::N",
        "number::Number": "number::Number",
        "read::IoRead<R>": "read::IoRead",
        "read::Position": "read::Position",
        "read::Reference<'b, 'c, T>": "read::Reference",
        "read::SliceRead<'a>": "read::SliceRead",
        "read::StrRead<'a>": "read::StrRead",
        "ser::CharEscape": "ser::CharEscape",
        "ser::CompactFormatter": "ser::CompactFormatter",
        "ser::Compound<'a, W, F>": "ser::Compound",
        "ser::MapKeySerializer<'a, W, F>": "ser::MapKeySerializer",
        "ser::PrettyFormatter<'a>": "ser::PrettyFormatter",
        "ser::Serializer<W, F>": "ser::Serializer",
        "ser::State": "ser::State",
        "value::Value": "value::Value",
        "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor": "value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor",
        "value::de::BorrowedCowStrDeserializer<'de>": "value::de::BorrowedCowStrDeserializer",
        "value::de::EnumDeserializer": "value::de::EnumDeserializer",
        "value::de::EnumRefDeserializer<'de>": "value::de::EnumRefDeserializer",
        "value::de::KeyClass": "value::de::KeyClass",
        "value::de::KeyClassifier": "value::de::KeyClassifier",
        "value::de::MapDeserializer": "value::de::MapDeserializer",
        "value::de::MapKeyDeserializer<'de>": "value::de::MapKeyDeserializer",
        "value::de::MapRefDeserializer<'de>": "value::de::MapRefDeserializer",
        "value::de::SeqDeserializer": "value::de::SeqDeserializer",
        "value::de::SeqRefDeserializer<'de>": "value::de::SeqRefDeserializer",
        "value::de::UnitOnly": "value::de::UnitOnly",
        "value::de::VariantDeserializer": "value::de::VariantDeserializer",
        "value::de::VariantRefDeserializer<'de>": "value::de::VariantRefDeserializer",
        "value::index::Type<'a>": "value::index::Type",
        "value::ser::MapKeySerializer": "value::ser::MapKeySerializer",
        "value::ser::SerializeMap": "value::ser::SerializeMap",
        "value::ser::SerializeStructVariant": "value::ser::SerializeStructVariant",
        "value::ser::SerializeTupleVariant": "value::ser::SerializeTupleVariant",
        "value::ser::SerializeVec": "value::ser::SerializeVec",
        "value::ser::Serializer": "value::ser::Serializer"
    }
}