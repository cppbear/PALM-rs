{"<defer::D<F> as std::ops::Drop>::drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::{Arc, Mutex};\n\n    #[test]\n    fn test_drop_calls_fn_once() {\n        let called = Arc::new(Mutex::new(false));\n        {\n            let called_clone = Arc::clone(&called);\n            let _d = D(Some(|| {\n                let mut c = called_clone.lock().unwrap();\n                *c = true;\n            }));\n        }\n        assert!(*called.lock().unwrap());\n    }\n\n    #[test]\n    fn test_drop_with_no_function() {\n        let called = Arc::new(Mutex::new(false));\n        {\n            let _d: D<Box<dyn FnOnce()>> = D(None);\n        }\n        assert!(!*called.lock().unwrap());\n    }\n}\n```", "defer": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_defer() {\n        let mut called = false;\n        {\n            let _d = defer(|| {\n                called = true;\n            });\n        }\n        assert!(called, \"The deferred function was not called\");\n    }\n}\n```", "main": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use xshell::{Shell, Result};\n\n    #[test]\n    fn test_main() -> Result<()> {\n        let sh = Shell::new()?;\n        let _e = push_toolchain(&sh, \"stable\")?;\n        let _e = sh.push_env(\"CARGO\", \"\");\n\n        {\n            let _s = section(\"BUILD\");\n            cmd!(sh, \"cargo test --workspace --no-run\").run()?;\n        }\n\n        {\n            let _s = section(\"TEST\");\n            cmd!(sh, \"cargo test --workspace\").run()?;\n            for &release in &[None, Some(\"--release\")] {\n                cmd!(sh, \"cargo test --features unstable {release...}\").run()?;\n                cmd!(sh, \"cargo test --no-default-features --features unstable,std,parking_lot {release...}\").run()?;\n            }\n            cmd!(sh, \"cargo test --no-default-features --features unstable --test it\").run()?;\n            cmd!(sh, \"cargo test --no-default-features --features unstable,alloc --test it\").run()?;\n            cmd!(sh, \"cargo test --no-default-features --features critical-section\").run()?;\n            cmd!(sh, \"cargo test --features critical-section\").run()?;\n        }\n\n        {\n            let _s = section(\"TEST_BETA\");\n            let _e = push_toolchain(&sh, \"beta\")?;\n            let _e = sh.push_env(\"RUSTFLAGS\", \"-A unreachable_patterns\");\n            cmd!(sh, \"cargo test --features unstable\").run()?;\n        }\n\n        {\n            let _s = section(\"TEST_MSRV\");\n            let msrv = {\n                let manifest = sh.read_file(\"Cargo.toml\")?;\n                let (_, suffix) = manifest.split_once(\"rust-version = \\\"\").unwrap();\n                let (version, _) = suffix.split_once(\"\\\"\").unwrap();\n                version.to_string()\n            };\n            let _e = push_toolchain(&sh, &msrv)?;\n            sh.copy_file(\"Cargo.lock.msrv\", \"Cargo.lock\")?;\n            if let err @ Err(_) = cmd!(sh, \"cargo update -w -v --locked\").run() {\n                println! {\"\\\n                    Error: `Cargo.lock.msrv` is out of date. \\\n                    Please run:\\n    \\\n                    (cp Cargo.lock{{.msrv,}} && cargo +{msrv} update -w -v && cp Cargo.lock{{.msrv,}})\\n\\\n                    \\n\\\n                    Alternatively, `git apply` the `.patch` below:\\\n                \"}\n                cmd!(sh, \"cargo update -q -w\").quiet().run()?;\n                sh.copy_file(\"Cargo.lock\", \"Cargo.lock.msrv\")?;\n                cmd!(sh, \"git --no-pager diff --color=always -- Cargo.lock.msrv\").quiet().run()?;\n                return err;\n            }\n            cmd!(sh, \"cargo build --locked\").run()?;\n        }\n\n        {\n            let _s = section(\"TEST_MIRI\");\n            let miri_nightly= cmd!(sh, \"curl -s https://rust-lang.github.io/rustup-components-history/x86_64-unknown-linux-gnu/miri\").read()?;\n            let _e = push_toolchain(&sh, &format!(\"nightly-{}\", miri_nightly))?;\n            sh.remove_path(\"./target\")?;\n            cmd!(sh, \"rustup component add miri\").run()?;\n            cmd!(sh, \"cargo miri setup\").run()?;\n            cmd!(sh, \"cargo miri test --features unstable\").run()?;\n        }\n\n        {\n            let _s = section(\"PUBLISH\");\n            let version = cmd!(sh, \"cargo pkgid\").read()?.rsplit_once('#').unwrap().1.to_string();\n            let tag = format!(\"v{version}\");\n            let current_branch = cmd!(sh, \"git branch --show-current\").read()?;\n            let has_tag = cmd!(sh, \"git tag --list\").read()?.lines().any(|it| it.trim() == tag);\n            let dry_run = sh.var(\"CI\").is_err() || has_tag || current_branch != \"master\";\n            eprintln!(\"Publishing{}!\", if dry_run { \" (dry run)\" } else { \"\" });\n            let dry_run_arg = if dry_run { Some(\"--dry-run\") } else { None };\n            cmd!(sh, \"cargo publish {dry_run_arg...}\").run()?;\n            if dry_run {\n                eprintln!(\"{}\", cmd!(sh, \"git tag {tag}\"));\n                eprintln!(\"{}\", cmd!(sh, \"git push --tags\"));\n            } else {\n                cmd!(sh, \"git tag {tag}\").run()?;\n                cmd!(sh, \"git push --tags\").run()?;\n            }\n        }\n\n        Ok(())\n    }\n}\n```", "push_toolchain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use xshell::{cmd, Shell};\n\n    #[test]\n    fn test_push_toolchain() {\n        let shell = Shell::new().unwrap();\n        let toolchain = \"stable\"; // Example toolchain, change as necessary\n\n        // Ensure the push_toolchain function runs without errors\n        let result = push_toolchain(&shell, toolchain);\n        assert!(result.is_ok());\n\n        // Verify that the correct environment variable is set\n        let push_env = result.unwrap();\n        assert_eq!(push_env.get(\"RUSTUP_TOOLCHAIN\").unwrap(), toolchain);\n    }\n\n    #[test]\n    fn test_push_toolchain_invalid() {\n        let shell = Shell::new().unwrap();\n        let toolchain = \"invalid-toolchain\"; // Example of an invalid toolchain\n\n        // Ensure the push_toolchain function returns an error\n        let result = push_toolchain(&shell, toolchain);\n        assert!(result.is_err());\n    }\n}\n```", "section": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_section() {\n        let section_name = \"test_section\";\n        \n        // Capture stdout and stderr to check outputs\n        let output = std::panic::catch_unwind(move || {\n            let _guard = section(section_name);\n            // Sleep for a short duration to simulate work being done\n            std::thread::sleep(std::time::Duration::from_millis(100));\n        });\n\n        assert!(output.is_ok());\n\n        // Check for expected output in stderr and stdout\n        // This is a simplified check to ensure the output contains expected values\n        // You might want to use a more robust method to capture output\n        let expected_stdout = format!(\"::group::{section_name}\\n::endgroup::\\n\");\n        let expected_stderr = format!(\"{}: \", section_name);\n        \n        // You would have to implement output capture to validate this part\n        assert!(output_stderr.contains(&expected_stderr));\n    }\n}\n```"}