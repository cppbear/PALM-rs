{"dependencies":{"<defer::D<F> as std::ops::Drop>::drop":["defer::D","std::marker::Sized","std::ops::FnOnce","std::option::Option"],"defer":["std::marker::Sized","std::ops::FnOnce"],"defer::D":["defer::D","std::marker::Sized","std::ops::FnOnce","std::option::Option"],"main":["std::marker::Sized","std::result::Result"],"push_toolchain":["std::marker::Sized","std::result::Result","xshell::Shell"],"section":[]},"glob_path_import":{},"self_to_fn":{"defer::D":["impl<F: FnOnce()> Drop for D<F> {\n        fn drop(&mut self) {\n            if let Some(f) = self.0.take() {\n                f()\n            }\n        }\n    }"]},"single_path_import":{},"srcs":{"<defer::D<F> as std::ops::Drop>::drop":["fn drop(&mut self){\n            if let Some(f) = self.0.take() {\n                f()\n            }\n        }","Real(LocalPath(\"xtask/src/main.rs\"))"],"defer":["fn defer<F: FnOnce()>(f: F) -> impl Drop{\n    struct D<F: FnOnce()>(Option<F>);\n    impl<F: FnOnce()> Drop for D<F> {\n        fn drop(&mut self) {\n            if let Some(f) = self.0.take() {\n                f()\n            }\n        }\n    }\n    D(Some(f))\n}","Real(LocalPath(\"xtask/src/main.rs\"))"],"defer::D":["struct D<F: FnOnce()>(Option<F>);","Real(LocalPath(\"xtask/src/main.rs\"))"],"main":["fn main() -> xshell::Result<()>{\n    let sh = Shell::new()?;\n\n    let _e = push_toolchain(&sh, \"stable\")?;\n    let _e = sh.push_env(\"CARGO\", \"\");\n\n    {\n        let _s = section(\"BUILD\");\n        cmd!(sh, \"cargo test --workspace --no-run\").run()?;\n    }\n\n    {\n        let _s = section(\"TEST\");\n\n        cmd!(sh, \"cargo test --workspace\").run()?;\n\n        for &release in &[None, Some(\"--release\")] {\n            cmd!(sh, \"cargo test --features unstable {release...}\").run()?;\n            cmd!(\n                sh,\n                \"cargo test --no-default-features --features unstable,std,parking_lot {release...}\"\n            )\n            .run()?;\n        }\n\n        // Skip doctests for no_std tests as those don't work\n        cmd!(sh, \"cargo test --no-default-features --features unstable --test it\").run()?;\n        cmd!(sh, \"cargo test --no-default-features --features unstable,alloc --test it\").run()?;\n\n        cmd!(sh, \"cargo test --no-default-features --features critical-section\").run()?;\n        cmd!(sh, \"cargo test --features critical-section\").run()?;\n    }\n\n    {\n        let _s = section(\"TEST_BETA\");\n        let _e = push_toolchain(&sh, \"beta\")?;\n        // TEMPORARY WORKAROUND for Rust compiler issue ref:\n        // - https://github.com/rust-lang/rust/issues/129352\n        // - https://github.com/matklad/once_cell/issues/261\n        let _e = sh.push_env(\"RUSTFLAGS\", \"-A unreachable_patterns\");\n\n        cmd!(sh, \"cargo test --features unstable\").run()?;\n    }\n\n    {\n        let _s = section(\"TEST_MSRV\");\n        let msrv = {\n            let manifest = sh.read_file(\"Cargo.toml\")?;\n            let (_, suffix) = manifest.split_once(\"rust-version = \\\"\").unwrap();\n            let (version, _) = suffix.split_once(\"\\\"\").unwrap();\n            version.to_string()\n        };\n\n        let _e = push_toolchain(&sh, &msrv)?;\n        sh.copy_file(\"Cargo.lock.msrv\", \"Cargo.lock\")?;\n        if let err @ Err(_) = cmd!(sh, \"cargo update -w -v --locked\").run() {\n            // `Cargo.lock.msrv` is out of date! Probably from having bumped our own version number.\n            println! {\"\\\n                Error: `Cargo.lock.msrv` is out of date. \\\n                Please run:\\n    \\\n                (cp Cargo.lock{{.msrv,}} && cargo +{msrv} update -w -v && cp Cargo.lock{{.msrv,}})\\n\\\n                \\n\\\n                Alternatively, `git apply` the `.patch` below:\\\n            \"}\n            cmd!(sh, \"cargo update -q -w\").quiet().run()?;\n            sh.copy_file(\"Cargo.lock\", \"Cargo.lock.msrv\")?;\n            cmd!(sh, \"git --no-pager diff --color=always -- Cargo.lock.msrv\").quiet().run()?;\n            return err;\n        }\n        cmd!(sh, \"cargo build --locked\").run()?;\n    }\n\n    {\n        let _s = section(\"TEST_MIRI\");\n        let miri_nightly= cmd!(sh, \"curl -s https://rust-lang.github.io/rustup-components-history/x86_64-unknown-linux-gnu/miri\").read()?;\n        let _e = push_toolchain(&sh, &format!(\"nightly-{}\", miri_nightly))?;\n\n        sh.remove_path(\"./target\")?;\n\n        cmd!(sh, \"rustup component add miri\").run()?;\n        cmd!(sh, \"cargo miri setup\").run()?;\n        cmd!(sh, \"cargo miri test --features unstable\").run()?;\n    }\n\n    {\n        let _s = section(\"PUBLISH\");\n\n        let version = cmd!(sh, \"cargo pkgid\").read()?.rsplit_once('#').unwrap().1.to_string();\n        let tag = format!(\"v{version}\");\n\n        let current_branch = cmd!(sh, \"git branch --show-current\").read()?;\n        let has_tag = cmd!(sh, \"git tag --list\").read()?.lines().any(|it| it.trim() == tag);\n        let dry_run = sh.var(\"CI\").is_err() || has_tag || current_branch != \"master\";\n        eprintln!(\"Publishing{}!\", if dry_run { \" (dry run)\" } else { \"\" });\n\n        let dry_run_arg = if dry_run { Some(\"--dry-run\") } else { None };\n        cmd!(sh, \"cargo publish {dry_run_arg...}\").run()?;\n        if dry_run {\n            eprintln!(\"{}\", cmd!(sh, \"git tag {tag}\"));\n            eprintln!(\"{}\", cmd!(sh, \"git push --tags\"));\n        } else {\n            cmd!(sh, \"git tag {tag}\").run()?;\n            cmd!(sh, \"git push --tags\").run()?;\n        }\n    }\n    Ok(())\n}","Real(LocalPath(\"xtask/src/main.rs\"))"],"push_toolchain":["fn push_toolchain<'a>(\n    sh: &'a xshell::Shell,\n    toolchain: &str,\n) -> xshell::Result<xshell::PushEnv<'a>>{\n    cmd!(sh, \"rustup toolchain install {toolchain} --no-self-update\").run()?;\n    let res = sh.push_env(\"RUSTUP_TOOLCHAIN\", toolchain);\n    cmd!(sh, \"rustc --version\").run()?;\n    Ok(res)\n}","Real(LocalPath(\"xtask/src/main.rs\"))"],"section":["fn section(name: &'static str) -> impl Drop{\n    println!(\"::group::{name}\");\n    let start = Instant::now();\n    defer(move || {\n        let elapsed = start.elapsed();\n        eprintln!(\"{name}: {elapsed:.2?}\");\n        println!(\"::endgroup::\");\n    })\n}","Real(LocalPath(\"xtask/src/main.rs\"))"]},"struct_constructor":{"Alias(Opaque, AliasTy { args: [F/#0], def_id: DefId(0:51 ~ xtask[7d89]::defer::{opaque#0}) })":["defer"],"Alias(Opaque, AliasTy { args: [], def_id: DefId(0:50 ~ xtask[7d89]::section::{opaque#0}) })":["section"],"xshell::PushEnv":["push_toolchain"]},"struct_to_trait":{"defer::D":["std::ops::Drop"]},"targets":{"<defer::D<F> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"xtask/src/main.rs\"))","std::ops::Drop"],"defer":["defer","Real(LocalPath(\"xtask/src/main.rs\"))",""],"main":["main","Real(LocalPath(\"xtask/src/main.rs\"))",""],"push_toolchain":["push_toolchain","Real(LocalPath(\"xtask/src/main.rs\"))",""],"section":["section","Real(LocalPath(\"xtask/src/main.rs\"))",""]},"trait_to_struct":{"std::ops::Drop":["defer::D"]},"type_to_def_path":{"defer::D<F>":"defer::D"}}