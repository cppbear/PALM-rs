{"dependencies":{"<internals::Derive as std::clone::Clone>::clone":["internals::Derive"],"<internals::ast::Style as std::clone::Clone>::clone":["internals::ast::Style"],"<internals::attr::Identifier as std::clone::Clone>::clone":["internals::attr::Identifier"],"<internals::attr::RenameAllRules as std::clone::Clone>::clone":["internals::attr::RenameAllRules","internals::case::RenameRule"],"<internals::case::ParseError<'a> as std::fmt::Display>::fmt":["internals::case::ParseError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<internals::case::RenameRule as std::clone::Clone>::clone":["internals::case::RenameRule"],"<internals::case::RenameRule as std::cmp::PartialEq>::eq":["internals::case::RenameRule"],"<internals::ctxt::Ctxt as std::default::Default>::default":["internals::ctxt::Ctxt","std::cell::RefCell"],"<internals::ctxt::Ctxt as std::ops::Drop>::drop":["internals::ctxt::Ctxt","std::cell::RefCell"],"<internals::name::Name as quote::ToTokens>::to_tokens":["internals::name::Name","proc_macro2::Span","proc_macro2::TokenStream","std::string::String"],"<internals::name::Name as std::clone::Clone>::clone":["internals::name::Name","proc_macro2::Span","std::string::String"],"<internals::name::Name as std::cmp::Ord>::cmp":["internals::name::Name","proc_macro2::Span","std::cmp::Ordering","std::string::String"],"<internals::name::Name as std::cmp::PartialEq>::eq":["internals::name::Name","proc_macro2::Span","std::string::String"],"<internals::name::Name as std::cmp::PartialOrd>::partial_cmp":["internals::name::Name","proc_macro2::Span","std::marker::Sized","std::option::Option","std::string::String"],"<internals::name::Name as std::convert::From<&proc_macro2::Ident>>::from":["internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::string::String"],"<internals::name::Name as std::convert::From<&syn::LitStr>>::from":["internals::name::Name","proc_macro2::Span","std::string::String","syn::LitStr"],"<internals::name::Name as std::fmt::Display>::fmt":["internals::name::Name","proc_macro2::Span","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<internals::symbol::Symbol as std::clone::Clone>::clone":["internals::symbol::Symbol"],"<internals::symbol::Symbol as std::fmt::Display>::fmt":["internals::symbol::Symbol","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"internals::Derive":["internals::Derive"],"internals::ast::Container":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::ast::Container::<'a>::from_ast":["internals::Derive","internals::ctxt::Ctxt","std::cell::RefCell","std::marker::Sized","std::option::Option","syn::DeriveInput"],"internals::ast::Data":["internals::ast::Data","internals::ast::Style","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"internals::ast::Data::<'a>::all_fields":["internals::ast::Data","internals::ast::Style","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"internals::ast::Data::<'a>::has_getter":["internals::ast::Data","internals::ast::Style","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"internals::ast::Field":["internals::Derive","internals::ast::Field","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath","syn::Field","syn::Member","syn::Type"],"internals::ast::Style":["internals::ast::Style"],"internals::ast::Variant":["internals::Derive","internals::ast::Style","internals::ast::Variant","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::Variant"],"internals::ast::enum_from_ast":["internals::attr::Default","internals::ctxt::Ctxt","std::alloc::Allocator","std::cell::RefCell","std::marker::Sized","std::vec::Vec","syn::ExprPath","syn::punctuated::Punctuated"],"internals::ast::fields_from_ast":["internals::attr::Default","internals::ctxt::Ctxt","std::alloc::Allocator","std::cell::RefCell","std::marker::Sized","std::option::Option","std::vec::Vec","syn::ExprPath","syn::punctuated::Punctuated"],"internals::ast::struct_from_ast":["internals::ast::Style","internals::attr::Default","internals::ctxt::Ctxt","std::alloc::Allocator","std::cell::RefCell","std::marker::Sized","std::option::Option","std::vec::Vec","syn::ExprPath","syn::Fields"],"internals::attr::Attr":["internals::attr::Attr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::cell::RefCell","std::marker::Sized","std::option::Option"],"internals::attr::Attr::<'c, T>::get":["internals::attr::Attr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::cell::RefCell","std::marker::Sized","std::option::Option"],"internals::attr::Attr::<'c, T>::get_with_tokens":["internals::attr::Attr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::cell::RefCell","std::marker::Sized","std::option::Option"],"internals::attr::Attr::<'c, T>::none":["internals::attr::Attr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::cell::RefCell","std::marker::Sized","std::option::Option"],"internals::attr::Attr::<'c, T>::set":["internals::attr::Attr","internals::ctxt::Ctxt","internals::name::Name","internals::symbol::Symbol","proc_macro2::Span","proc_macro2::TokenStream","quote::ToTokens","std::cell::RefCell","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Attr::<'c, T>::set_if_none":["internals::attr::Attr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::cell::RefCell","std::marker::Sized","std::option::Option"],"internals::attr::Attr::<'c, T>::set_opt":["internals::attr::Attr","internals::ctxt::Ctxt","internals::name::Name","internals::symbol::Symbol","proc_macro2::Span","proc_macro2::TokenStream","quote::ToTokens","std::cell::RefCell","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::BoolAttr":["internals::attr::Attr","internals::attr::BoolAttr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::cell::RefCell","std::marker::Sized","std::option::Option"],"internals::attr::BoolAttr::<'c>::get":["internals::attr::Attr","internals::attr::BoolAttr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::cell::RefCell","std::marker::Sized","std::option::Option"],"internals::attr::BoolAttr::<'c>::none":["internals::attr::Attr","internals::attr::BoolAttr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::cell::RefCell","std::marker::Sized","std::option::Option"],"internals::attr::BoolAttr::<'c>::set_true":["internals::attr::Attr","internals::attr::BoolAttr","internals::ctxt::Ctxt","internals::name::Name","internals::symbol::Symbol","proc_macro2::Span","proc_macro2::TokenStream","quote::ToTokens","std::cell::RefCell","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::BorrowAttribute":["internals::attr::BorrowAttribute","std::marker::Sized","std::option::Option","syn::Path"],"internals::attr::Container":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::custom_serde_path":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::de_bound":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::default":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::deny_unknown_fields":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::expecting":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::from_ast":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::DeriveInput","syn::ExprPath"],"internals::attr::Container::identifier":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::is_packed":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::name":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::non_exhaustive":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::remote":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::rename_all_fields_rules":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::rename_all_rules":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::ser_bound":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::serde_path":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::tag":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::transparent":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::type_from":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::type_into":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Container::type_try_from":["internals::Derive","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Default":["internals::attr::Default","syn::ExprPath"],"internals::attr::Default::is_none":["internals::attr::Default","syn::ExprPath"],"internals::attr::Field":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::aliases":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::borrowed_lifetimes":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::de_bound":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::default":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::deserialize_with":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::flatten":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::from_ast":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath","syn::Field"],"internals::attr::Field::getter":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::mark_transparent":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::name":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::rename_by_rules":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::attr::RenameAllRules","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::ser_bound":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::serialize_with":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::skip_deserializing":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::skip_serializing":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::skip_serializing_if":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Field::transparent":["internals::Derive","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath"],"internals::attr::Identifier":["internals::attr::Identifier"],"internals::attr::RenameAllRules":["internals::attr::RenameAllRules","internals::case::RenameRule"],"internals::attr::RenameAllRules::or":["internals::attr::RenameAllRules","internals::case::RenameRule"],"internals::attr::TagType":["internals::attr::TagType","std::string::String"],"internals::attr::Variant":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::aliases":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::de_bound":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::deserialize_with":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::from_ast":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::Variant"],"internals::attr::Variant::name":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::other":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::rename_all_rules":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::rename_by_rules":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::ser_bound":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::serialize_with":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::skip_deserializing":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::skip_serializing":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::Variant::untagged":["internals::Derive","internals::attr::RenameAllRules","internals::attr::Variant","internals::case::RenameRule","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::attr::VecAttr":["internals::attr::VecAttr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::alloc::Allocator","std::cell::RefCell","std::marker::Sized","std::vec::Vec"],"internals::attr::VecAttr::<'c, T>::at_most_one":["internals::attr::VecAttr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::alloc::Allocator","std::cell::RefCell","std::marker::Sized","std::option::Option","std::vec::Vec"],"internals::attr::VecAttr::<'c, T>::get":["internals::attr::VecAttr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::alloc::Allocator","std::cell::RefCell","std::marker::Sized","std::vec::Vec"],"internals::attr::VecAttr::<'c, T>::insert":["internals::attr::VecAttr","internals::ctxt::Ctxt","internals::name::Name","internals::symbol::Symbol","proc_macro2::Span","proc_macro2::TokenStream","quote::ToTokens","std::alloc::Allocator","std::cell::RefCell","std::marker::Sized","std::string::String","std::vec::Vec"],"internals::attr::VecAttr::<'c, T>::none":["internals::attr::VecAttr","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::alloc::Allocator","std::cell::RefCell","std::marker::Sized","std::vec::Vec"],"internals::attr::borrowable_lifetimes":["internals::ctxt::Ctxt","internals::name::Name","proc_macro2::Span","std::cell::RefCell","std::marker::Sized","std::result::Result","std::string::String","syn::Field"],"internals::attr::collect_lifetimes":["internals::Derive","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","syn::Type"],"internals::attr::collect_lifetimes_from_tokens":["internals::Derive","proc_macro2::TokenStream","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized"],"internals::attr::decide_identifier":["internals::attr::Attr","internals::attr::BoolAttr","internals::attr::Identifier","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::cell::RefCell","std::marker::Sized","std::option::Option","syn::DeriveInput"],"internals::attr::decide_tag":["internals::attr::Attr","internals::attr::BoolAttr","internals::attr::TagType","internals::ctxt::Ctxt","internals::symbol::Symbol","proc_macro2::TokenStream","std::cell::RefCell","std::marker::Sized","std::option::Option","std::string::String","syn::DeriveInput"],"internals::attr::get_lit_str":["internals::ctxt::Ctxt","internals::symbol::Symbol","std::cell::RefCell","std::marker::Sized","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::get_lit_str2":["internals::ctxt::Ctxt","internals::symbol::Symbol","std::cell::RefCell","std::marker::Sized","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::get_multiple_renames":["internals::ctxt::Ctxt","std::cell::RefCell","std::marker::Sized","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::get_renames":["internals::ctxt::Ctxt","internals::symbol::Symbol","std::cell::RefCell","std::marker::Sized","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::get_ser_and_de":["internals::Derive","internals::ctxt::Ctxt","internals::symbol::Symbol","std::cell::RefCell","std::clone::Clone","std::convert::Into","std::marker::Sized","std::ops::Fn","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::get_where_predicates":["internals::ctxt::Ctxt","std::cell::RefCell","std::marker::Sized","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::is_cow":["syn::Type"],"internals::attr::is_implicitly_borrowed":["syn::Type"],"internals::attr::is_implicitly_borrowed_reference":["syn::Type"],"internals::attr::is_option":["syn::Type"],"internals::attr::is_primitive_path":["syn::Path"],"internals::attr::is_primitive_type":["syn::Type"],"internals::attr::is_reference":["syn::Type"],"internals::attr::is_slice_u8":["syn::Type"],"internals::attr::is_str":["syn::Type"],"internals::attr::parse_lit_into_expr_path":["internals::ctxt::Ctxt","internals::symbol::Symbol","std::cell::RefCell","std::marker::Sized","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::parse_lit_into_lifetimes":["internals::ctxt::Ctxt","std::cell::RefCell","std::marker::Sized","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::parse_lit_into_path":["internals::ctxt::Ctxt","internals::symbol::Symbol","std::cell::RefCell","std::marker::Sized","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::parse_lit_into_ty":["internals::ctxt::Ctxt","internals::symbol::Symbol","std::cell::RefCell","std::marker::Sized","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::parse_lit_into_where":["internals::ctxt::Ctxt","internals::symbol::Symbol","std::cell::RefCell","std::marker::Sized","std::result::Result","syn::meta::ParseNestedMeta"],"internals::attr::unraw":["proc_macro2::Ident"],"internals::case::ParseError":["internals::case::ParseError"],"internals::case::RenameRule":["internals::case::RenameRule"],"internals::case::RenameRule::apply_to_field":["internals::case::RenameRule","std::string::String"],"internals::case::RenameRule::apply_to_variant":["internals::case::RenameRule","std::string::String"],"internals::case::RenameRule::from_str":["std::marker::Sized","std::result::Result"],"internals::case::RenameRule::or":["internals::case::RenameRule"],"internals::check::allow_transparent":["internals::Derive","internals::ast::Field","internals::attr::Default","internals::attr::Field","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath","syn::Field","syn::Member","syn::Type"],"internals::check::check":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::check_adjacent_tag_conflict":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::check_default_on_tuple":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::check_flatten":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::check_flatten_field":["internals::Derive","internals::ast::Field","internals::ast::Style","internals::attr::Default","internals::attr::Field","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","syn::ExprPath","syn::Field","syn::Member","syn::Type"],"internals::check::check_from_and_try_from":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::check_getter":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::check_identifier":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::check_internal_tag_field_name_conflict":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::check_remote_generic":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::check_transparent":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::check_variant_skip_attrs":["internals::Derive","internals::ast::Container","internals::ast::Data","internals::ast::Style","internals::attr::Container","internals::attr::Default","internals::attr::Identifier","internals::attr::RenameAllRules","internals::attr::TagType","internals::case::RenameRule","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","proc_macro2::Ident","proc_macro2::Span","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","syn::DeriveInput","syn::ExprPath","syn::Generics"],"internals::check::member_message":["std::string::String","syn::Member"],"internals::ctxt::Ctxt":["internals::ctxt::Ctxt","std::cell::RefCell"],"internals::ctxt::Ctxt::check":["internals::ctxt::Ctxt","std::cell::RefCell","std::marker::Sized","std::result::Result"],"internals::ctxt::Ctxt::error_spanned_by":["internals::case::ParseError","internals::ctxt::Ctxt","internals::name::Name","proc_macro2::Span","quote::ToTokens","std::cell::RefCell","std::fmt::Display","std::marker::Sized","std::string::String"],"internals::ctxt::Ctxt::new":["internals::ctxt::Ctxt","std::cell::RefCell"],"internals::ctxt::Ctxt::syn_error":["internals::ctxt::Ctxt","std::cell::RefCell","syn::Error"],"internals::name::MultiName":["internals::Derive","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::string::String"],"internals::name::MultiName::deserialize_aliases":["internals::Derive","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::string::String"],"internals::name::MultiName::deserialize_name":["internals::Derive","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::string::String"],"internals::name::MultiName::from_attrs":["internals::Derive","internals::attr::Attr","internals::ctxt::Ctxt","internals::name::MultiName","internals::name::Name","internals::symbol::Symbol","proc_macro2::Span","proc_macro2::TokenStream","std::alloc::Allocator","std::cell::RefCell","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::string::String"],"internals::name::MultiName::serialize_name":["internals::Derive","internals::name::MultiName","internals::name::Name","proc_macro2::Span","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::string::String"],"internals::name::Name":["internals::name::Name","proc_macro2::Span","std::string::String"],"internals::receiver::ReplaceReceiver":["internals::receiver::ReplaceReceiver","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::self_to_expr_path":["internals::receiver::ReplaceReceiver","syn::Path","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::self_to_qself":["internals::receiver::ReplaceReceiver","std::marker::Sized","std::option::Option","syn::Path","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::self_ty":["internals::receiver::ReplaceReceiver","proc_macro2::Span","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_data_mut":["internals::receiver::ReplaceReceiver","syn::Data","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_expr_mut":["internals::receiver::ReplaceReceiver","syn::Expr","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_expr_path_mut":["internals::receiver::ReplaceReceiver","syn::ExprPath","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_expr_path_mut_impl":["internals::receiver::ReplaceReceiver","syn::ExprPath","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_generics_mut":["internals::receiver::ReplaceReceiver","syn::Generics","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_macro_mut":["internals::receiver::ReplaceReceiver","syn::Macro","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_path_arguments_mut":["internals::receiver::ReplaceReceiver","syn::PathArguments","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_path_mut":["internals::receiver::ReplaceReceiver","syn::Path","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_return_type_mut":["internals::receiver::ReplaceReceiver","syn::ReturnType","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_type_mut":["internals::receiver::ReplaceReceiver","syn::Type","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_type_mut_impl":["internals::receiver::ReplaceReceiver","syn::Type","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_type_param_bound_mut":["internals::receiver::ReplaceReceiver","syn::TypeParamBound","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_type_path_mut":["internals::receiver::ReplaceReceiver","syn::TypePath"],"internals::receiver::ReplaceReceiver::<'_>::visit_type_path_mut_impl":["internals::receiver::ReplaceReceiver","syn::TypePath"],"internals::receiver::replace_receiver":["syn::DeriveInput"],"internals::respan::respan":["proc_macro2::Span","proc_macro2::TokenStream"],"internals::respan::respan_token":["proc_macro2::Span","proc_macro2::TokenTree"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for &proc_macro2::Ident>::eq":["internals::symbol::Symbol","proc_macro2::Ident"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for &syn::Path>::eq":["internals::symbol::Symbol","syn::Path"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for proc_macro2::Ident>::eq":["internals::symbol::Symbol","proc_macro2::Ident"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for syn::Path>::eq":["internals::symbol::Symbol","syn::Path"],"internals::symbol::Symbol":["internals::symbol::Symbol"],"internals::ungroup":["syn::Type"]},"glob_path_import":{"internals":""},"self_to_fn":{"internals::Derive":["Clone","Copy"],"internals::ast::Container":["impl<'a> Container<'a> {\n    /// Convert the raw Syn ast into a parsed container object, collecting errors in `cx`.\n    pub fn from_ast(\n        cx: &Ctxt,\n        item: &'a syn::DeriveInput,\n        derive: Derive,\n    ) -> Option<Container<'a>> {\n        let attrs = attr::Container::from_ast(cx, item);\n\n        let mut data = match &item.data {\n            syn::Data::Enum(data) => Data::Enum(enum_from_ast(cx, &data.variants, attrs.default())),\n            syn::Data::Struct(data) => {\n                let (style, fields) = struct_from_ast(cx, &data.fields, None, attrs.default());\n                Data::Struct(style, fields)\n            }\n            syn::Data::Union(_) => {\n                cx.error_spanned_by(item, \"Serde does not support derive for unions\");\n                return None;\n            }\n        };\n\n        match &mut data {\n            Data::Enum(variants) => {\n                for variant in variants {\n                    variant.attrs.rename_by_rules(attrs.rename_all_rules());\n                    for field in &mut variant.fields {\n                        field.attrs.rename_by_rules(\n                            variant\n                                .attrs\n                                .rename_all_rules()\n                                .or(attrs.rename_all_fields_rules()),\n                        );\n                    }\n                }\n            }\n            Data::Struct(_, fields) => {\n                for field in fields {\n                    field.attrs.rename_by_rules(attrs.rename_all_rules());\n                }\n            }\n        }\n\n        let mut item = Container {\n            ident: item.ident.clone(),\n            attrs,\n            data,\n            generics: &item.generics,\n            original: item,\n        };\n        check::check(cx, &mut item, derive);\n        Some(item)\n    }\n}"],"internals::ast::Data":["impl<'a> Data<'a> {\n    pub fn all_fields(&'a self) -> Box<dyn Iterator<Item = &'a Field<'a>> + 'a> {\n        match self {\n            Data::Enum(variants) => {\n                Box::new(variants.iter().flat_map(|variant| variant.fields.iter()))\n            }\n            Data::Struct(_, fields) => Box::new(fields.iter()),\n        }\n    }\n\n    pub fn has_getter(&self) -> bool {\n        self.all_fields().any(|f| f.attrs.getter().is_some())\n    }\n}"],"internals::ast::Style":["Clone","Copy"],"internals::attr::Attr":["impl<'c, T> Attr<'c, T> {\n    fn none(cx: &'c Ctxt, name: Symbol) -> Self {\n        Attr {\n            cx,\n            name,\n            tokens: TokenStream::new(),\n            value: None,\n        }\n    }\n\n    fn set<A: ToTokens>(&mut self, obj: A, value: T) {\n        let tokens = obj.into_token_stream();\n\n        if self.value.is_some() {\n            let msg = format!(\"duplicate serde attribute `{}`\", self.name);\n            self.cx.error_spanned_by(tokens, msg);\n        } else {\n            self.tokens = tokens;\n            self.value = Some(value);\n        }\n    }\n\n    fn set_opt<A: ToTokens>(&mut self, obj: A, value: Option<T>) {\n        if let Some(value) = value {\n            self.set(obj, value);\n        }\n    }\n\n    fn set_if_none(&mut self, value: T) {\n        if self.value.is_none() {\n            self.value = Some(value);\n        }\n    }\n\n    pub(crate) fn get(self) -> Option<T> {\n        self.value\n    }\n\n    fn get_with_tokens(self) -> Option<(TokenStream, T)> {\n        match self.value {\n            Some(v) => Some((self.tokens, v)),\n            None => None,\n        }\n    }\n}"],"internals::attr::BoolAttr":["impl<'c> BoolAttr<'c> {\n    fn none(cx: &'c Ctxt, name: Symbol) -> Self {\n        BoolAttr(Attr::none(cx, name))\n    }\n\n    fn set_true<A: ToTokens>(&mut self, obj: A) {\n        self.0.set(obj, ());\n    }\n\n    fn get(&self) -> bool {\n        self.0.value.is_some()\n    }\n}"],"internals::attr::Container":["impl Container {\n    /// Extract out the `#[serde(...)]` attributes from an item.\n    pub fn from_ast(cx: &Ctxt, item: &syn::DeriveInput) -> Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut transparent = BoolAttr::none(cx, TRANSPARENT);\n        let mut deny_unknown_fields = BoolAttr::none(cx, DENY_UNKNOWN_FIELDS);\n        let mut default = Attr::none(cx, DEFAULT);\n        let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_fields_ser_rule = Attr::none(cx, RENAME_ALL_FIELDS);\n        let mut rename_all_fields_de_rule = Attr::none(cx, RENAME_ALL_FIELDS);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut untagged = BoolAttr::none(cx, UNTAGGED);\n        let mut internal_tag = Attr::none(cx, TAG);\n        let mut content = Attr::none(cx, CONTENT);\n        let mut type_from = Attr::none(cx, FROM);\n        let mut type_try_from = Attr::none(cx, TRY_FROM);\n        let mut type_into = Attr::none(cx, INTO);\n        let mut remote = Attr::none(cx, REMOTE);\n        let mut field_identifier = BoolAttr::none(cx, FIELD_IDENTIFIER);\n        let mut variant_identifier = BoolAttr::none(cx, VARIANT_IDENTIFIER);\n        let mut serde_path = Attr::none(cx, CRATE);\n        let mut expecting = Attr::none(cx, EXPECTING);\n        let mut non_exhaustive = false;\n\n        for attr in &item.attrs {\n            if attr.path() != SERDE {\n                non_exhaustive |=\n                    matches!(&attr.meta, syn::Meta::Path(path) if path == NON_EXHAUSTIVE);\n                continue;\n            }\n\n            if let syn::Meta::List(meta) = &attr.meta {\n                if meta.tokens.is_empty() {\n                    continue;\n                }\n            }\n\n            if let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            }) {\n                cx.syn_error(err);\n            }\n        }\n\n        let mut is_packed = false;\n        for attr in &item.attrs {\n            if attr.path() == REPR {\n                let _ = attr.parse_args_with(|input: ParseStream| {\n                    while let Some(token) = input.parse()? {\n                        if let TokenTree::Ident(ident) = token {\n                            is_packed |= ident == \"packed\";\n                        }\n                    }\n                    Ok(())\n                });\n            }\n        }\n\n        Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }\n    }\n\n    pub fn name(&self) -> &MultiName {\n        &self.name\n    }\n\n    pub fn rename_all_rules(&self) -> RenameAllRules {\n        self.rename_all_rules\n    }\n\n    pub fn rename_all_fields_rules(&self) -> RenameAllRules {\n        self.rename_all_fields_rules\n    }\n\n    pub fn transparent(&self) -> bool {\n        self.transparent\n    }\n\n    pub fn deny_unknown_fields(&self) -> bool {\n        self.deny_unknown_fields\n    }\n\n    pub fn default(&self) -> &Default {\n        &self.default\n    }\n\n    pub fn ser_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.ser_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn de_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.de_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn tag(&self) -> &TagType {\n        &self.tag\n    }\n\n    pub fn type_from(&self) -> Option<&syn::Type> {\n        self.type_from.as_ref()\n    }\n\n    pub fn type_try_from(&self) -> Option<&syn::Type> {\n        self.type_try_from.as_ref()\n    }\n\n    pub fn type_into(&self) -> Option<&syn::Type> {\n        self.type_into.as_ref()\n    }\n\n    pub fn remote(&self) -> Option<&syn::Path> {\n        self.remote.as_ref()\n    }\n\n    pub fn is_packed(&self) -> bool {\n        self.is_packed\n    }\n\n    pub fn identifier(&self) -> Identifier {\n        self.identifier\n    }\n\n    pub fn custom_serde_path(&self) -> Option<&syn::Path> {\n        self.serde_path.as_ref()\n    }\n\n    pub fn serde_path(&self) -> Cow<syn::Path> {\n        self.custom_serde_path()\n            .map_or_else(|| Cow::Owned(parse_quote!(_serde)), Cow::Borrowed)\n    }\n\n    /// Error message generated when type can't be deserialized.\n    /// If `None`, default message will be used\n    pub fn expecting(&self) -> Option<&str> {\n        self.expecting.as_ref().map(String::as_ref)\n    }\n\n    pub fn non_exhaustive(&self) -> bool {\n        self.non_exhaustive\n    }\n}"],"internals::attr::Default":["impl Default {\n    pub fn is_none(&self) -> bool {\n        match self {\n            Default::None => true,\n            Default::Default | Default::Path(_) => false,\n        }\n    }\n}"],"internals::attr::Field":["impl Field {\n    /// Extract out the `#[serde(...)]` attributes from a struct field.\n    pub fn from_ast(\n        cx: &Ctxt,\n        index: usize,\n        field: &syn::Field,\n        attrs: Option<&Variant>,\n        container_default: &Default,\n    ) -> Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut de_aliases = VecAttr::none(cx, RENAME);\n        let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);\n        let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);\n        let mut skip_serializing_if = Attr::none(cx, SKIP_SERIALIZING_IF);\n        let mut default = Attr::none(cx, DEFAULT);\n        let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n        let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut borrowed_lifetimes = Attr::none(cx, BORROW);\n        let mut getter = Attr::none(cx, GETTER);\n        let mut flatten = BoolAttr::none(cx, FLATTEN);\n\n        let ident = match &field.ident {\n            Some(ident) => Name::from(&unraw(ident)),\n            None => Name {\n                value: index.to_string(),\n                span: Span::call_site(),\n            },\n        };\n\n        if let Some(borrow_attribute) = attrs.and_then(|variant| variant.borrow.as_ref()) {\n            if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field) {\n                if let Some(lifetimes) = &borrow_attribute.lifetimes {\n                    for lifetime in lifetimes {\n                        if !borrowable.contains(lifetime) {\n                            let msg =\n                                format!(\"field `{}` does not have lifetime {}\", ident, lifetime);\n                            cx.error_spanned_by(field, msg);\n                        }\n                    }\n                    borrowed_lifetimes.set(&borrow_attribute.path, lifetimes.clone());\n                } else {\n                    borrowed_lifetimes.set(&borrow_attribute.path, borrowable);\n                }\n            }\n        }\n\n        for attr in &field.attrs {\n            if attr.path() != SERDE {\n                continue;\n            }\n\n            if let syn::Meta::List(meta) = &attr.meta {\n                if meta.tokens.is_empty() {\n                    continue;\n                }\n            }\n\n            if let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_multiple_renames(cx, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    for de_value in de {\n                        de_name.set_if_none(Name::from(&de_value));\n                        de_aliases.insert(&meta.path, Name::from(&de_value));\n                    }\n                } else if meta.path == ALIAS {\n                    // #[serde(alias = \"foo\")]\n                    if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {\n                        de_aliases.insert(&meta.path, Name::from(&s));\n                    }\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            default.set(&meta.path, Default::Path(path));\n                        }\n                    } else {\n                        // #[serde(default)]\n                        default.set(&meta.path, Default::Default);\n                    }\n                } else if meta.path == SKIP_SERIALIZING {\n                    // #[serde(skip_serializing)]\n                    skip_serializing.set_true(&meta.path);\n                } else if meta.path == SKIP_DESERIALIZING {\n                    // #[serde(skip_deserializing)]\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP {\n                    // #[serde(skip)]\n                    skip_serializing.set_true(&meta.path);\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_SERIALIZING_IF {\n                    // #[serde(skip_serializing_if = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SKIP_SERIALIZING_IF, &meta)? {\n                        skip_serializing_if.set(&meta.path, path);\n                    }\n                } else if meta.path == SERIALIZE_WITH {\n                    // #[serde(serialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {\n                        serialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == DESERIALIZE_WITH {\n                    // #[serde(deserialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {\n                        deserialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == WITH {\n                    // #[serde(with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {\n                        let mut ser_path = path.clone();\n                        ser_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"serialize\", ser_path.span()).into());\n                        serialize_with.set(&meta.path, ser_path);\n                        let mut de_path = path;\n                        de_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"deserialize\", de_path.span()).into());\n                        deserialize_with.set(&meta.path, de_path);\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == BORROW {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(borrow = \"'a + 'b\")]\n                        let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;\n                        if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field) {\n                            for lifetime in &lifetimes {\n                                if !borrowable.contains(lifetime) {\n                                    let msg = format!(\n                                        \"field `{}` does not have lifetime {}\",\n                                        ident, lifetime,\n                                    );\n                                    cx.error_spanned_by(field, msg);\n                                }\n                            }\n                            borrowed_lifetimes.set(&meta.path, lifetimes);\n                        }\n                    } else {\n                        // #[serde(borrow)]\n                        if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field) {\n                            borrowed_lifetimes.set(&meta.path, borrowable);\n                        }\n                    }\n                } else if meta.path == GETTER {\n                    // #[serde(getter = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, GETTER, &meta)? {\n                        getter.set(&meta.path, path);\n                    }\n                } else if meta.path == FLATTEN {\n                    // #[serde(flatten)]\n                    flatten.set_true(&meta.path);\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde field attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            }) {\n                cx.syn_error(err);\n            }\n        }\n\n        // Is skip_deserializing, initialize the field to Default::default() unless a\n        // different default is specified by `#[serde(default = \"...\")]` on\n        // ourselves or our container (e.g. the struct we are in).\n        if let Default::None = *container_default {\n            if skip_deserializing.0.value.is_some() {\n                default.set_if_none(Default::Default);\n            }\n        }\n\n        let mut borrowed_lifetimes = borrowed_lifetimes.get().unwrap_or_default();\n        if !borrowed_lifetimes.is_empty() {\n            // Cow<str> and Cow<[u8]> never borrow by default:\n            //\n            //     impl<'de, 'a, T: ?Sized> Deserialize<'de> for Cow<'a, T>\n            //\n            // A #[serde(borrow)] attribute enables borrowing that corresponds\n            // roughly to these impls:\n            //\n            //     impl<'de: 'a, 'a> Deserialize<'de> for Cow<'a, str>\n            //     impl<'de: 'a, 'a> Deserialize<'de> for Cow<'a, [u8]>\n            if is_cow(&field.ty, is_str) {\n                let mut path = syn::Path {\n                    leading_colon: None,\n                    segments: Punctuated::new(),\n                };\n                let span = Span::call_site();\n                path.segments.push(Ident::new(\"_serde\", span).into());\n                path.segments.push(Ident::new(\"__private\", span).into());\n                path.segments.push(Ident::new(\"de\", span).into());\n                path.segments\n                    .push(Ident::new(\"borrow_cow_str\", span).into());\n                let expr = syn::ExprPath {\n                    attrs: Vec::new(),\n                    qself: None,\n                    path,\n                };\n                deserialize_with.set_if_none(expr);\n            } else if is_cow(&field.ty, is_slice_u8) {\n                let mut path = syn::Path {\n                    leading_colon: None,\n                    segments: Punctuated::new(),\n                };\n                let span = Span::call_site();\n                path.segments.push(Ident::new(\"_serde\", span).into());\n                path.segments.push(Ident::new(\"__private\", span).into());\n                path.segments.push(Ident::new(\"de\", span).into());\n                path.segments\n                    .push(Ident::new(\"borrow_cow_bytes\", span).into());\n                let expr = syn::ExprPath {\n                    attrs: Vec::new(),\n                    qself: None,\n                    path,\n                };\n                deserialize_with.set_if_none(expr);\n            }\n        } else if is_implicitly_borrowed(&field.ty) {\n            // Types &str and &[u8] are always implicitly borrowed. No need for\n            // a #[serde(borrow)].\n            collect_lifetimes(&field.ty, &mut borrowed_lifetimes);\n        }\n\n        Field {\n            name: MultiName::from_attrs(ident, ser_name, de_name, Some(de_aliases)),\n            skip_serializing: skip_serializing.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing_if: skip_serializing_if.get(),\n            default: default.get().unwrap_or(Default::None),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            borrowed_lifetimes,\n            getter: getter.get(),\n            flatten: flatten.get(),\n            transparent: false,\n        }\n    }\n\n    pub fn name(&self) -> &MultiName {\n        &self.name\n    }\n\n    pub fn aliases(&self) -> &BTreeSet<Name> {\n        self.name.deserialize_aliases()\n    }\n\n    pub fn rename_by_rules(&mut self, rules: RenameAllRules) {\n        if !self.name.serialize_renamed {\n            self.name.serialize.value = rules.serialize.apply_to_field(&self.name.serialize.value);\n        }\n        if !self.name.deserialize_renamed {\n            self.name.deserialize.value = rules\n                .deserialize\n                .apply_to_field(&self.name.deserialize.value);\n        }\n        self.name\n            .deserialize_aliases\n            .insert(self.name.deserialize.clone());\n    }\n\n    pub fn skip_serializing(&self) -> bool {\n        self.skip_serializing\n    }\n\n    pub fn skip_deserializing(&self) -> bool {\n        self.skip_deserializing\n    }\n\n    pub fn skip_serializing_if(&self) -> Option<&syn::ExprPath> {\n        self.skip_serializing_if.as_ref()\n    }\n\n    pub fn default(&self) -> &Default {\n        &self.default\n    }\n\n    pub fn serialize_with(&self) -> Option<&syn::ExprPath> {\n        self.serialize_with.as_ref()\n    }\n\n    pub fn deserialize_with(&self) -> Option<&syn::ExprPath> {\n        self.deserialize_with.as_ref()\n    }\n\n    pub fn ser_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.ser_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn de_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.de_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn borrowed_lifetimes(&self) -> &BTreeSet<syn::Lifetime> {\n        &self.borrowed_lifetimes\n    }\n\n    pub fn getter(&self) -> Option<&syn::ExprPath> {\n        self.getter.as_ref()\n    }\n\n    pub fn flatten(&self) -> bool {\n        self.flatten\n    }\n\n    pub fn transparent(&self) -> bool {\n        self.transparent\n    }\n\n    pub fn mark_transparent(&mut self) {\n        self.transparent = true;\n    }\n}"],"internals::attr::Identifier":["Clone","Copy","impl Identifier {\n    #[cfg(feature = \"deserialize_in_place\")]\n    pub fn is_some(self) -> bool {\n        match self {\n            Identifier::No => false,\n            Identifier::Field | Identifier::Variant => true,\n        }\n    }\n}"],"internals::attr::RenameAllRules":["Clone","Copy","impl RenameAllRules {\n    /// Returns a new `RenameAllRules` with the individual rules of `self` and\n    /// `other_rules` joined by `RenameRules::or`.\n    pub fn or(self, other_rules: Self) -> Self {\n        Self {\n            serialize: self.serialize.or(other_rules.serialize),\n            deserialize: self.deserialize.or(other_rules.deserialize),\n        }\n    }\n}"],"internals::attr::Variant":["impl Variant {\n    pub fn from_ast(cx: &Ctxt, variant: &syn::Variant) -> Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut de_aliases = VecAttr::none(cx, RENAME);\n        let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);\n        let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);\n        let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut other = BoolAttr::none(cx, OTHER);\n        let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n        let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n        let mut borrow = Attr::none(cx, BORROW);\n        let mut untagged = BoolAttr::none(cx, UNTAGGED);\n\n        for attr in &variant.attrs {\n            if attr.path() != SERDE {\n                continue;\n            }\n\n            if let syn::Meta::List(meta) = &attr.meta {\n                if meta.tokens.is_empty() {\n                    continue;\n                }\n            }\n\n            if let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_multiple_renames(cx, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    for de_value in de {\n                        de_name.set_if_none(Name::from(&de_value));\n                        de_aliases.insert(&meta.path, Name::from(&de_value));\n                    }\n                } else if meta.path == ALIAS {\n                    // #[serde(alias = \"foo\")]\n                    if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {\n                        de_aliases.insert(&meta.path, Name::from(&s));\n                    }\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == SKIP {\n                    // #[serde(skip)]\n                    skip_serializing.set_true(&meta.path);\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_DESERIALIZING {\n                    // #[serde(skip_deserializing)]\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_SERIALIZING {\n                    // #[serde(skip_serializing)]\n                    skip_serializing.set_true(&meta.path);\n                } else if meta.path == OTHER {\n                    // #[serde(other)]\n                    other.set_true(&meta.path);\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == WITH {\n                    // #[serde(with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {\n                        let mut ser_path = path.clone();\n                        ser_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"serialize\", ser_path.span()).into());\n                        serialize_with.set(&meta.path, ser_path);\n                        let mut de_path = path;\n                        de_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"deserialize\", de_path.span()).into());\n                        deserialize_with.set(&meta.path, de_path);\n                    }\n                } else if meta.path == SERIALIZE_WITH {\n                    // #[serde(serialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {\n                        serialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == DESERIALIZE_WITH {\n                    // #[serde(deserialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {\n                        deserialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == BORROW {\n                    let borrow_attribute = if meta.input.peek(Token![=]) {\n                        // #[serde(borrow = \"'a + 'b\")]\n                        let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: Some(lifetimes),\n                        }\n                    } else {\n                        // #[serde(borrow)]\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: None,\n                        }\n                    };\n                    match &variant.fields {\n                        syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {\n                            borrow.set(&meta.path, borrow_attribute);\n                        }\n                        _ => {\n                            let msg = \"#[serde(borrow)] may only be used on newtype variants\";\n                            cx.error_spanned_by(variant, msg);\n                        }\n                    }\n                } else if meta.path == UNTAGGED {\n                    untagged.set_true(&meta.path);\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde variant attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            }) {\n                cx.syn_error(err);\n            }\n        }\n\n        Variant {\n            name: MultiName::from_attrs(\n                Name::from(&unraw(&variant.ident)),\n                ser_name,\n                de_name,\n                Some(de_aliases),\n            ),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n            untagged: untagged.get(),\n        }\n    }\n\n    pub fn name(&self) -> &MultiName {\n        &self.name\n    }\n\n    pub fn aliases(&self) -> &BTreeSet<Name> {\n        self.name.deserialize_aliases()\n    }\n\n    pub fn rename_by_rules(&mut self, rules: RenameAllRules) {\n        if !self.name.serialize_renamed {\n            self.name.serialize.value =\n                rules.serialize.apply_to_variant(&self.name.serialize.value);\n        }\n        if !self.name.deserialize_renamed {\n            self.name.deserialize.value = rules\n                .deserialize\n                .apply_to_variant(&self.name.deserialize.value);\n        }\n        self.name\n            .deserialize_aliases\n            .insert(self.name.deserialize.clone());\n    }\n\n    pub fn rename_all_rules(&self) -> RenameAllRules {\n        self.rename_all_rules\n    }\n\n    pub fn ser_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.ser_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn de_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.de_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn skip_deserializing(&self) -> bool {\n        self.skip_deserializing\n    }\n\n    pub fn skip_serializing(&self) -> bool {\n        self.skip_serializing\n    }\n\n    pub fn other(&self) -> bool {\n        self.other\n    }\n\n    pub fn serialize_with(&self) -> Option<&syn::ExprPath> {\n        self.serialize_with.as_ref()\n    }\n\n    pub fn deserialize_with(&self) -> Option<&syn::ExprPath> {\n        self.deserialize_with.as_ref()\n    }\n\n    pub fn untagged(&self) -> bool {\n        self.untagged\n    }\n}"],"internals::attr::VecAttr":["impl<'c, T> VecAttr<'c, T> {\n    fn none(cx: &'c Ctxt, name: Symbol) -> Self {\n        VecAttr {\n            cx,\n            name,\n            first_dup_tokens: TokenStream::new(),\n            values: Vec::new(),\n        }\n    }\n\n    fn insert<A: ToTokens>(&mut self, obj: A, value: T) {\n        if self.values.len() == 1 {\n            self.first_dup_tokens = obj.into_token_stream();\n        }\n        self.values.push(value);\n    }\n\n    fn at_most_one(mut self) -> Option<T> {\n        if self.values.len() > 1 {\n            let dup_token = self.first_dup_tokens;\n            let msg = format!(\"duplicate serde attribute `{}`\", self.name);\n            self.cx.error_spanned_by(dup_token, msg);\n            None\n        } else {\n            self.values.pop()\n        }\n    }\n\n    pub(crate) fn get(self) -> Vec<T> {\n        self.values\n    }\n}"],"internals::case::ParseError":["impl<'a> Display for ParseError<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(\"unknown rename rule `rename_all = \")?;\n        Debug::fmt(self.unknown, f)?;\n        f.write_str(\"`, expected one of \")?;\n        for (i, (name, _rule)) in RENAME_RULES.iter().enumerate() {\n            if i > 0 {\n                f.write_str(\", \")?;\n            }\n            Debug::fmt(name, f)?;\n        }\n        Ok(())\n    }\n}"],"internals::case::RenameRule":["Clone","Copy","PartialEq","impl RenameRule {\n    pub fn from_str(rename_all_str: &str) -> Result<Self, ParseError> {\n        for (name, rule) in RENAME_RULES {\n            if rename_all_str == *name {\n                return Ok(*rule);\n            }\n        }\n        Err(ParseError {\n            unknown: rename_all_str,\n        })\n    }\n\n    /// Apply a renaming rule to an enum variant, returning the version expected in the source.\n    pub fn apply_to_variant(self, variant: &str) -> String {\n        match self {\n            None | PascalCase => variant.to_owned(),\n            LowerCase => variant.to_ascii_lowercase(),\n            UpperCase => variant.to_ascii_uppercase(),\n            CamelCase => variant[..1].to_ascii_lowercase() + &variant[1..],\n            SnakeCase => {\n                let mut snake = String::new();\n                for (i, ch) in variant.char_indices() {\n                    if i > 0 && ch.is_uppercase() {\n                        snake.push('_');\n                    }\n                    snake.push(ch.to_ascii_lowercase());\n                }\n                snake\n            }\n            ScreamingSnakeCase => SnakeCase.apply_to_variant(variant).to_ascii_uppercase(),\n            KebabCase => SnakeCase.apply_to_variant(variant).replace('_', \"-\"),\n            ScreamingKebabCase => ScreamingSnakeCase\n                .apply_to_variant(variant)\n                .replace('_', \"-\"),\n        }\n    }\n\n    /// Apply a renaming rule to a struct field, returning the version expected in the source.\n    pub fn apply_to_field(self, field: &str) -> String {\n        match self {\n            None | LowerCase | SnakeCase => field.to_owned(),\n            UpperCase => field.to_ascii_uppercase(),\n            PascalCase => {\n                let mut pascal = String::new();\n                let mut capitalize = true;\n                for ch in field.chars() {\n                    if ch == '_' {\n                        capitalize = true;\n                    } else if capitalize {\n                        pascal.push(ch.to_ascii_uppercase());\n                        capitalize = false;\n                    } else {\n                        pascal.push(ch);\n                    }\n                }\n                pascal\n            }\n            CamelCase => {\n                let pascal = PascalCase.apply_to_field(field);\n                pascal[..1].to_ascii_lowercase() + &pascal[1..]\n            }\n            ScreamingSnakeCase => field.to_ascii_uppercase(),\n            KebabCase => field.replace('_', \"-\"),\n            ScreamingKebabCase => ScreamingSnakeCase.apply_to_field(field).replace('_', \"-\"),\n        }\n    }\n\n    /// Returns the `RenameRule` if it is not `None`, `rule_b` otherwise.\n    pub fn or(self, rule_b: Self) -> Self {\n        match self {\n            None => rule_b,\n            _ => self,\n        }\n    }\n}"],"internals::ctxt::Ctxt":["Default","impl Ctxt {\n    /// Create a new context object.\n    ///\n    /// This object contains no errors, but will still trigger a panic if it is not `check`ed.\n    pub fn new() -> Self {\n        Ctxt {\n            errors: RefCell::new(Some(Vec::new())),\n        }\n    }\n\n    /// Add an error to the context object with a tokenenizable object.\n    ///\n    /// The object is used for spanning in error messages.\n    pub fn error_spanned_by<A: ToTokens, T: Display>(&self, obj: A, msg: T) {\n        self.errors\n            .borrow_mut()\n            .as_mut()\n            .unwrap()\n            // Curb monomorphization from generating too many identical methods.\n            .push(syn::Error::new_spanned(obj.into_token_stream(), msg));\n    }\n\n    /// Add one of Syn's parse errors.\n    pub fn syn_error(&self, err: syn::Error) {\n        self.errors.borrow_mut().as_mut().unwrap().push(err);\n    }\n\n    /// Consume this object, producing a formatted error string if there are errors.\n    pub fn check(self) -> syn::Result<()> {\n        let mut errors = self.errors.borrow_mut().take().unwrap().into_iter();\n\n        let mut combined = match errors.next() {\n            Some(first) => first,\n            None => return Ok(()),\n        };\n\n        for rest in errors {\n            combined.combine(rest);\n        }\n\n        Err(combined)\n    }\n}","impl Drop for Ctxt {\n    fn drop(&mut self) {\n        if !thread::panicking() && self.errors.borrow().is_some() {\n            panic!(\"forgot to check for errors\");\n        }\n    }\n}"],"internals::name::MultiName":["impl MultiName {\n    pub(crate) fn from_attrs(\n        source_name: Name,\n        ser_name: Attr<Name>,\n        de_name: Attr<Name>,\n        de_aliases: Option<VecAttr<Name>>,\n    ) -> Self {\n        let mut alias_set = BTreeSet::new();\n        if let Some(de_aliases) = de_aliases {\n            for alias_name in de_aliases.get() {\n                alias_set.insert(alias_name);\n            }\n        }\n\n        let ser_name = ser_name.get();\n        let ser_renamed = ser_name.is_some();\n        let de_name = de_name.get();\n        let de_renamed = de_name.is_some();\n        MultiName {\n            serialize: ser_name.unwrap_or_else(|| source_name.clone()),\n            serialize_renamed: ser_renamed,\n            deserialize: de_name.unwrap_or(source_name),\n            deserialize_renamed: de_renamed,\n            deserialize_aliases: alias_set,\n        }\n    }\n\n    /// Return the container name for the container when serializing.\n    pub fn serialize_name(&self) -> &Name {\n        &self.serialize\n    }\n\n    /// Return the container name for the container when deserializing.\n    pub fn deserialize_name(&self) -> &Name {\n        &self.deserialize\n    }\n\n    pub(crate) fn deserialize_aliases(&self) -> &BTreeSet<Name> {\n        &self.deserialize_aliases\n    }\n}"],"internals::name::Name":["Clone","impl Display for Name {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&self.value, formatter)\n    }\n}","impl Eq for Name {}","impl From<&Ident> for Name {\n    fn from(ident: &Ident) -> Self {\n        Name {\n            value: ident.to_string(),\n            span: ident.span(),\n        }\n    }\n}","impl From<&LitStr> for Name {\n    fn from(lit: &LitStr) -> Self {\n        Name {\n            value: lit.value(),\n            span: lit.span(),\n        }\n    }\n}","impl Ord for Name {\n    fn cmp(&self, other: &Self) -> Ordering {\n        Ord::cmp(&self.value, &other.value)\n    }\n}","impl PartialEq for Name {\n    fn eq(&self, other: &Self) -> bool {\n        self.value == other.value\n    }\n}","impl PartialOrd for Name {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(Ord::cmp(self, other))\n    }\n}","impl ToTokens for Name {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        LitStr::new(&self.value, self.span).to_tokens(tokens);\n    }\n}"],"internals::receiver::ReplaceReceiver":["impl ReplaceReceiver<'_> {\n    // `Self` -> `Receiver`\n    fn visit_type_mut(&mut self, ty: &mut Type) {\n        let span = if let Type::Path(node) = ty {\n            if node.qself.is_none() && node.path.is_ident(\"Self\") {\n                node.path.segments[0].ident.span()\n            } else {\n                self.visit_type_path_mut(node);\n                return;\n            }\n        } else {\n            self.visit_type_mut_impl(ty);\n            return;\n        };\n        *ty = Type::Path(self.self_ty(span));\n    }\n\n    // `Self::Assoc` -> `<Receiver>::Assoc`\n    fn visit_type_path_mut(&mut self, ty: &mut TypePath) {\n        if ty.qself.is_none() {\n            self.self_to_qself(&mut ty.qself, &mut ty.path);\n        }\n        self.visit_type_path_mut_impl(ty);\n    }\n\n    // `Self::method` -> `<Receiver>::method`\n    fn visit_expr_path_mut(&mut self, expr: &mut ExprPath) {\n        if expr.qself.is_none() {\n            self.self_to_qself(&mut expr.qself, &mut expr.path);\n        }\n        self.visit_expr_path_mut_impl(expr);\n    }\n\n    // Everything below is simply traversing the syntax tree.\n\n    fn visit_type_mut_impl(&mut self, ty: &mut Type) {\n        match ty {\n            #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]\n            Type::Array(ty) => {\n                self.visit_type_mut(&mut ty.elem);\n                self.visit_expr_mut(&mut ty.len);\n            }\n            Type::BareFn(ty) => {\n                for arg in &mut ty.inputs {\n                    self.visit_type_mut(&mut arg.ty);\n                }\n                self.visit_return_type_mut(&mut ty.output);\n            }\n            Type::Group(ty) => self.visit_type_mut(&mut ty.elem),\n            Type::ImplTrait(ty) => {\n                for bound in &mut ty.bounds {\n                    self.visit_type_param_bound_mut(bound);\n                }\n            }\n            Type::Macro(ty) => self.visit_macro_mut(&mut ty.mac),\n            Type::Paren(ty) => self.visit_type_mut(&mut ty.elem),\n            Type::Path(ty) => {\n                if let Some(qself) = &mut ty.qself {\n                    self.visit_type_mut(&mut qself.ty);\n                }\n                self.visit_path_mut(&mut ty.path);\n            }\n            Type::Ptr(ty) => self.visit_type_mut(&mut ty.elem),\n            Type::Reference(ty) => self.visit_type_mut(&mut ty.elem),\n            Type::Slice(ty) => self.visit_type_mut(&mut ty.elem),\n            Type::TraitObject(ty) => {\n                for bound in &mut ty.bounds {\n                    self.visit_type_param_bound_mut(bound);\n                }\n            }\n            Type::Tuple(ty) => {\n                for elem in &mut ty.elems {\n                    self.visit_type_mut(elem);\n                }\n            }\n\n            Type::Infer(_) | Type::Never(_) | Type::Verbatim(_) => {}\n\n            _ => {}\n        }\n    }\n\n    fn visit_type_path_mut_impl(&mut self, ty: &mut TypePath) {\n        if let Some(qself) = &mut ty.qself {\n            self.visit_type_mut(&mut qself.ty);\n        }\n        self.visit_path_mut(&mut ty.path);\n    }\n\n    fn visit_expr_path_mut_impl(&mut self, expr: &mut ExprPath) {\n        if let Some(qself) = &mut expr.qself {\n            self.visit_type_mut(&mut qself.ty);\n        }\n        self.visit_path_mut(&mut expr.path);\n    }\n\n    fn visit_path_mut(&mut self, path: &mut Path) {\n        for segment in &mut path.segments {\n            self.visit_path_arguments_mut(&mut segment.arguments);\n        }\n    }\n\n    fn visit_path_arguments_mut(&mut self, arguments: &mut PathArguments) {\n        match arguments {\n            PathArguments::None => {}\n            PathArguments::AngleBracketed(arguments) => {\n                for arg in &mut arguments.args {\n                    match arg {\n                        #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]\n                        GenericArgument::Type(arg) => self.visit_type_mut(arg),\n                        GenericArgument::AssocType(arg) => self.visit_type_mut(&mut arg.ty),\n                        GenericArgument::Lifetime(_)\n                        | GenericArgument::Const(_)\n                        | GenericArgument::AssocConst(_)\n                        | GenericArgument::Constraint(_) => {}\n                        _ => {}\n                    }\n                }\n            }\n            PathArguments::Parenthesized(arguments) => {\n                for argument in &mut arguments.inputs {\n                    self.visit_type_mut(argument);\n                }\n                self.visit_return_type_mut(&mut arguments.output);\n            }\n        }\n    }\n\n    fn visit_return_type_mut(&mut self, return_type: &mut ReturnType) {\n        match return_type {\n            ReturnType::Default => {}\n            ReturnType::Type(_, output) => self.visit_type_mut(output),\n        }\n    }\n\n    fn visit_type_param_bound_mut(&mut self, bound: &mut TypeParamBound) {\n        match bound {\n            #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]\n            TypeParamBound::Trait(bound) => self.visit_path_mut(&mut bound.path),\n            TypeParamBound::Lifetime(_)\n            | TypeParamBound::PreciseCapture(_)\n            | TypeParamBound::Verbatim(_) => {}\n            _ => {}\n        }\n    }\n\n    fn visit_generics_mut(&mut self, generics: &mut Generics) {\n        for param in &mut generics.params {\n            match param {\n                GenericParam::Type(param) => {\n                    for bound in &mut param.bounds {\n                        self.visit_type_param_bound_mut(bound);\n                    }\n                }\n                GenericParam::Lifetime(_) | GenericParam::Const(_) => {}\n            }\n        }\n        if let Some(where_clause) = &mut generics.where_clause {\n            for predicate in &mut where_clause.predicates {\n                match predicate {\n                    #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]\n                    WherePredicate::Type(predicate) => {\n                        self.visit_type_mut(&mut predicate.bounded_ty);\n                        for bound in &mut predicate.bounds {\n                            self.visit_type_param_bound_mut(bound);\n                        }\n                    }\n                    WherePredicate::Lifetime(_) => {}\n                    _ => {}\n                }\n            }\n        }\n    }\n\n    fn visit_data_mut(&mut self, data: &mut Data) {\n        match data {\n            Data::Struct(data) => {\n                for field in &mut data.fields {\n                    self.visit_type_mut(&mut field.ty);\n                }\n            }\n            Data::Enum(data) => {\n                for variant in &mut data.variants {\n                    for field in &mut variant.fields {\n                        self.visit_type_mut(&mut field.ty);\n                    }\n                }\n            }\n            Data::Union(_) => {}\n        }\n    }\n\n    fn visit_expr_mut(&mut self, expr: &mut Expr) {\n        match expr {\n            Expr::Binary(expr) => {\n                self.visit_expr_mut(&mut expr.left);\n                self.visit_expr_mut(&mut expr.right);\n            }\n            Expr::Call(expr) => {\n                self.visit_expr_mut(&mut expr.func);\n                for arg in &mut expr.args {\n                    self.visit_expr_mut(arg);\n                }\n            }\n            Expr::Cast(expr) => {\n                self.visit_expr_mut(&mut expr.expr);\n                self.visit_type_mut(&mut expr.ty);\n            }\n            Expr::Field(expr) => self.visit_expr_mut(&mut expr.base),\n            Expr::Index(expr) => {\n                self.visit_expr_mut(&mut expr.expr);\n                self.visit_expr_mut(&mut expr.index);\n            }\n            Expr::Paren(expr) => self.visit_expr_mut(&mut expr.expr),\n            Expr::Path(expr) => self.visit_expr_path_mut(expr),\n            Expr::Unary(expr) => self.visit_expr_mut(&mut expr.expr),\n            _ => {}\n        }\n    }\n\n    fn visit_macro_mut(&mut self, _mac: &mut Macro) {}\n}","impl ReplaceReceiver<'_> {\n    fn self_ty(&self, span: Span) -> TypePath {\n        let tokens = self.0.to_token_stream();\n        let respanned = respan(tokens, span);\n        syn::parse2(respanned).unwrap()\n    }\n\n    fn self_to_qself(&self, qself: &mut Option<QSelf>, path: &mut Path) {\n        if path.leading_colon.is_some() || path.segments[0].ident != \"Self\" {\n            return;\n        }\n\n        if path.segments.len() == 1 {\n            self.self_to_expr_path(path);\n            return;\n        }\n\n        let span = path.segments[0].ident.span();\n        *qself = Some(QSelf {\n            lt_token: Token![<](span),\n            ty: Box::new(Type::Path(self.self_ty(span))),\n            position: 0,\n            as_token: None,\n            gt_token: Token![>](span),\n        });\n\n        path.leading_colon = Some(**path.segments.pairs().next().unwrap().punct().unwrap());\n\n        let segments = mem::take(&mut path.segments);\n        path.segments = segments.into_pairs().skip(1).collect();\n    }\n\n    fn self_to_expr_path(&self, path: &mut Path) {\n        let self_ty = self.self_ty(path.segments[0].ident.span());\n        let variant = mem::replace(path, self_ty.path);\n        for segment in &mut path.segments {\n            if let PathArguments::AngleBracketed(bracketed) = &mut segment.arguments {\n                if bracketed.colon2_token.is_none() && !bracketed.args.is_empty() {\n                    bracketed.colon2_token = Some(<Token![::]>::default());\n                }\n            }\n        }\n        if variant.segments.len() > 1 {\n            path.segments.push_punct(<Token![::]>::default());\n            path.segments.extend(variant.segments.into_pairs().skip(1));\n        }\n    }\n}"],"internals::symbol::Symbol":["Clone","Copy","impl Display for Symbol {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(self.0)\n    }\n}"],"proc_macro2::Ident":["impl PartialEq<Symbol> for Ident {\n    fn eq(&self, word: &Symbol) -> bool {\n        self == word.0\n    }\n}"],"syn::Path":["impl PartialEq<Symbol> for Path {\n    fn eq(&self, word: &Symbol) -> bool {\n        self.is_ident(word.0)\n    }\n}"]},"single_path_import":{"internals::case::RenameRule":"internals::attr::RenameRule","internals::ctxt::Ctxt":"internals::Ctxt","internals::receiver::replace_receiver":"internals::replace_receiver"},"srcs":{"<internals::case::ParseError<'a> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_str(\"unknown rename rule `rename_all = \")?;\n        Debug::fmt(self.unknown, f)?;\n        f.write_str(\"`, expected one of \")?;\n        for (i, (name, _rule)) in RENAME_RULES.iter().enumerate() {\n            if i > 0 {\n                f.write_str(\", \")?;\n            }\n            Debug::fmt(name, f)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))"],"<internals::ctxt::Ctxt as std::ops::Drop>::drop":["fn drop(&mut self){\n        if !thread::panicking() && self.errors.borrow().is_some() {\n            panic!(\"forgot to check for errors\");\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))"],"<internals::name::Name as quote::ToTokens>::to_tokens":["fn to_tokens(&self, tokens: &mut TokenStream){\n        LitStr::new(&self.value, self.span).to_tokens(tokens);\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"<internals::name::Name as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> Ordering{\n        Ord::cmp(&self.value, &other.value)\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"<internals::name::Name as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        self.value == other.value\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"<internals::name::Name as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        Some(Ord::cmp(self, other))\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"<internals::name::Name as std::convert::From<&proc_macro2::Ident>>::from":["fn from(ident: &Ident) -> Self{\n        Name {\n            value: ident.to_string(),\n            span: ident.span(),\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"<internals::name::Name as std::convert::From<&syn::LitStr>>::from":["fn from(lit: &LitStr) -> Self{\n        Name {\n            value: lit.value(),\n            span: lit.span(),\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"<internals::name::Name as std::fmt::Display>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        Display::fmt(&self.value, formatter)\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"<internals::symbol::Symbol as std::fmt::Display>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        formatter.write_str(self.0)\n    }","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))"],"internals::Derive":["pub enum Derive {\n    Serialize,\n    Deserialize,\n}","Real(LocalPath(\"serde_derive_internals/src/mod.rs\"))"],"internals::ast::Container":["/// A source data structure annotated with `#[derive(Serialize)]` and/or `#[derive(Deserialize)]`,\n/// parsed into an internal representation.\npub struct Container<'a> {\n    /// The struct or enum name (without generics).\n    pub ident: syn::Ident,\n    /// Attributes on the structure, parsed for Serde.\n    pub attrs: attr::Container,\n    /// The contents of the struct or enum.\n    pub data: Data<'a>,\n    /// Any generics on the struct or enum.\n    pub generics: &'a syn::Generics,\n    /// Original input.\n    pub original: &'a syn::DeriveInput,\n}","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::ast::Container::<'a>::from_ast":["/// Convert the raw Syn ast into a parsed container object, collecting errors in `cx`.\npub fn from_ast(\n        cx: &Ctxt,\n        item: &'a syn::DeriveInput,\n        derive: Derive,\n    ) -> Option<Container<'a>>{\n        let attrs = attr::Container::from_ast(cx, item);\n\n        let mut data = match &item.data {\n            syn::Data::Enum(data) => Data::Enum(enum_from_ast(cx, &data.variants, attrs.default())),\n            syn::Data::Struct(data) => {\n                let (style, fields) = struct_from_ast(cx, &data.fields, None, attrs.default());\n                Data::Struct(style, fields)\n            }\n            syn::Data::Union(_) => {\n                cx.error_spanned_by(item, \"Serde does not support derive for unions\");\n                return None;\n            }\n        };\n\n        match &mut data {\n            Data::Enum(variants) => {\n                for variant in variants {\n                    variant.attrs.rename_by_rules(attrs.rename_all_rules());\n                    for field in &mut variant.fields {\n                        field.attrs.rename_by_rules(\n                            variant\n                                .attrs\n                                .rename_all_rules()\n                                .or(attrs.rename_all_fields_rules()),\n                        );\n                    }\n                }\n            }\n            Data::Struct(_, fields) => {\n                for field in fields {\n                    field.attrs.rename_by_rules(attrs.rename_all_rules());\n                }\n            }\n        }\n\n        let mut item = Container {\n            ident: item.ident.clone(),\n            attrs,\n            data,\n            generics: &item.generics,\n            original: item,\n        };\n        check::check(cx, &mut item, derive);\n        Some(item)\n    }","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::ast::Data":["/// The fields of a struct or enum.\n///\n/// Analogous to `syn::Data`.\npub enum Data<'a> {\n    Enum(Vec<Variant<'a>>),\n    Struct(Style, Vec<Field<'a>>),\n}","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::ast::Data::<'a>::all_fields":["pub fn all_fields(&'a self) -> Box<dyn Iterator<Item = &'a Field<'a>> + 'a>{\n        match self {\n            Data::Enum(variants) => {\n                Box::new(variants.iter().flat_map(|variant| variant.fields.iter()))\n            }\n            Data::Struct(_, fields) => Box::new(fields.iter()),\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::ast::Data::<'a>::has_getter":["pub fn has_getter(&self) -> bool{\n        self.all_fields().any(|f| f.attrs.getter().is_some())\n    }","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::ast::Field":["/// A field of a struct.\npub struct Field<'a> {\n    pub member: syn::Member,\n    pub attrs: attr::Field,\n    pub ty: &'a syn::Type,\n    pub original: &'a syn::Field,\n}","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::ast::Style":["pub enum Style {\n    /// Named fields.\n    Struct,\n    /// Many unnamed fields.\n    Tuple,\n    /// One unnamed field.\n    Newtype,\n    /// No fields.\n    Unit,\n}","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::ast::Variant":["/// A variant of an enum.\npub struct Variant<'a> {\n    pub ident: syn::Ident,\n    pub attrs: attr::Variant,\n    pub style: Style,\n    pub fields: Vec<Field<'a>>,\n    pub original: &'a syn::Variant,\n}","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::ast::enum_from_ast":["fn enum_from_ast<'a>(\n    cx: &Ctxt,\n    variants: &'a Punctuated<syn::Variant, Token![,]>,\n    container_default: &attr::Default,\n) -> Vec<Variant<'a>>{\n    let variants: Vec<Variant> = variants\n        .iter()\n        .map(|variant| {\n            let attrs = attr::Variant::from_ast(cx, variant);\n            let (style, fields) =\n                struct_from_ast(cx, &variant.fields, Some(&attrs), container_default);\n            Variant {\n                ident: variant.ident.clone(),\n                attrs,\n                style,\n                fields,\n                original: variant,\n            }\n        })\n        .collect();\n\n    let index_of_last_tagged_variant = variants\n        .iter()\n        .rposition(|variant| !variant.attrs.untagged());\n    if let Some(index_of_last_tagged_variant) = index_of_last_tagged_variant {\n        for variant in &variants[..index_of_last_tagged_variant] {\n            if variant.attrs.untagged() {\n                cx.error_spanned_by(&variant.ident, \"all variants with the #[serde(untagged)] attribute must be placed at the end of the enum\");\n            }\n        }\n    }\n\n    variants\n}","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::ast::fields_from_ast":["fn fields_from_ast<'a>(\n    cx: &Ctxt,\n    fields: &'a Punctuated<syn::Field, Token![,]>,\n    attrs: Option<&attr::Variant>,\n    container_default: &attr::Default,\n) -> Vec<Field<'a>>{\n    fields\n        .iter()\n        .enumerate()\n        .map(|(i, field)| Field {\n            member: match &field.ident {\n                Some(ident) => syn::Member::Named(ident.clone()),\n                None => syn::Member::Unnamed(i.into()),\n            },\n            attrs: attr::Field::from_ast(cx, i, field, attrs, container_default),\n            ty: &field.ty,\n            original: field,\n        })\n        .collect()\n}","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::ast::struct_from_ast":["fn struct_from_ast<'a>(\n    cx: &Ctxt,\n    fields: &'a syn::Fields,\n    attrs: Option<&attr::Variant>,\n    container_default: &attr::Default,\n) -> (Style, Vec<Field<'a>>){\n    match fields {\n        syn::Fields::Named(fields) => (\n            Style::Struct,\n            fields_from_ast(cx, &fields.named, attrs, container_default),\n        ),\n        syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => (\n            Style::Newtype,\n            fields_from_ast(cx, &fields.unnamed, attrs, container_default),\n        ),\n        syn::Fields::Unnamed(fields) => (\n            Style::Tuple,\n            fields_from_ast(cx, &fields.unnamed, attrs, container_default),\n        ),\n        syn::Fields::Unit => (Style::Unit, Vec::new()),\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))"],"internals::attr::Attr":["pub(crate) struct Attr<'c, T> {\n    cx: &'c Ctxt,\n    name: Symbol,\n    tokens: TokenStream,\n    value: Option<T>,\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Attr::<'c, T>::get":["pub(crate) fn get(self) -> Option<T>{\n        self.value\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Attr::<'c, T>::get_with_tokens":["fn get_with_tokens(self) -> Option<(TokenStream, T)>{\n        match self.value {\n            Some(v) => Some((self.tokens, v)),\n            None => None,\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Attr::<'c, T>::none":["fn none(cx: &'c Ctxt, name: Symbol) -> Self{\n        Attr {\n            cx,\n            name,\n            tokens: TokenStream::new(),\n            value: None,\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Attr::<'c, T>::set":["fn set<A: ToTokens>(&mut self, obj: A, value: T){\n        let tokens = obj.into_token_stream();\n\n        if self.value.is_some() {\n            let msg = format!(\"duplicate serde attribute `{}`\", self.name);\n            self.cx.error_spanned_by(tokens, msg);\n        } else {\n            self.tokens = tokens;\n            self.value = Some(value);\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Attr::<'c, T>::set_if_none":["fn set_if_none(&mut self, value: T){\n        if self.value.is_none() {\n            self.value = Some(value);\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Attr::<'c, T>::set_opt":["fn set_opt<A: ToTokens>(&mut self, obj: A, value: Option<T>){\n        if let Some(value) = value {\n            self.set(obj, value);\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::BoolAttr":["struct BoolAttr<'c>(Attr<'c, ()>);","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::BoolAttr::<'c>::get":["fn get(&self) -> bool{\n        self.0.value.is_some()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::BoolAttr::<'c>::none":["fn none(cx: &'c Ctxt, name: Symbol) -> Self{\n        BoolAttr(Attr::none(cx, name))\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::BoolAttr::<'c>::set_true":["fn set_true<A: ToTokens>(&mut self, obj: A){\n        self.0.set(obj, ());\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::BorrowAttribute":["struct BorrowAttribute {\n    path: syn::Path,\n    lifetimes: Option<BTreeSet<syn::Lifetime>>,\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container":["/// Represents struct or enum attribute information.\npub struct Container {\n    name: MultiName,\n    transparent: bool,\n    deny_unknown_fields: bool,\n    default: Default,\n    rename_all_rules: RenameAllRules,\n    rename_all_fields_rules: RenameAllRules,\n    ser_bound: Option<Vec<syn::WherePredicate>>,\n    de_bound: Option<Vec<syn::WherePredicate>>,\n    tag: TagType,\n    type_from: Option<syn::Type>,\n    type_try_from: Option<syn::Type>,\n    type_into: Option<syn::Type>,\n    remote: Option<syn::Path>,\n    identifier: Identifier,\n    serde_path: Option<syn::Path>,\n    is_packed: bool,\n    /// Error message generated when type can't be deserialized\n    expecting: Option<String>,\n    non_exhaustive: bool,\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::custom_serde_path":["pub fn custom_serde_path(&self) -> Option<&syn::Path>{\n        self.serde_path.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::de_bound":["pub fn de_bound(&self) -> Option<&[syn::WherePredicate]>{\n        self.de_bound.as_ref().map(|vec| &vec[..])\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::default":["pub fn default(&self) -> &Default{\n        &self.default\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::deny_unknown_fields":["pub fn deny_unknown_fields(&self) -> bool{\n        self.deny_unknown_fields\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::expecting":["/// Error message generated when type can't be deserialized.\n/// If `None`, default message will be used\npub fn expecting(&self) -> Option<&str>{\n        self.expecting.as_ref().map(String::as_ref)\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::from_ast":["/// Extract out the `#[serde(...)]` attributes from an item.\npub fn from_ast(cx: &Ctxt, item: &syn::DeriveInput) -> Self{\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut transparent = BoolAttr::none(cx, TRANSPARENT);\n        let mut deny_unknown_fields = BoolAttr::none(cx, DENY_UNKNOWN_FIELDS);\n        let mut default = Attr::none(cx, DEFAULT);\n        let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_fields_ser_rule = Attr::none(cx, RENAME_ALL_FIELDS);\n        let mut rename_all_fields_de_rule = Attr::none(cx, RENAME_ALL_FIELDS);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut untagged = BoolAttr::none(cx, UNTAGGED);\n        let mut internal_tag = Attr::none(cx, TAG);\n        let mut content = Attr::none(cx, CONTENT);\n        let mut type_from = Attr::none(cx, FROM);\n        let mut type_try_from = Attr::none(cx, TRY_FROM);\n        let mut type_into = Attr::none(cx, INTO);\n        let mut remote = Attr::none(cx, REMOTE);\n        let mut field_identifier = BoolAttr::none(cx, FIELD_IDENTIFIER);\n        let mut variant_identifier = BoolAttr::none(cx, VARIANT_IDENTIFIER);\n        let mut serde_path = Attr::none(cx, CRATE);\n        let mut expecting = Attr::none(cx, EXPECTING);\n        let mut non_exhaustive = false;\n\n        for attr in &item.attrs {\n            if attr.path() != SERDE {\n                non_exhaustive |=\n                    matches!(&attr.meta, syn::Meta::Path(path) if path == NON_EXHAUSTIVE);\n                continue;\n            }\n\n            if let syn::Meta::List(meta) = &attr.meta {\n                if meta.tokens.is_empty() {\n                    continue;\n                }\n            }\n\n            if let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            }) {\n                cx.syn_error(err);\n            }\n        }\n\n        let mut is_packed = false;\n        for attr in &item.attrs {\n            if attr.path() == REPR {\n                let _ = attr.parse_args_with(|input: ParseStream| {\n                    while let Some(token) = input.parse()? {\n                        if let TokenTree::Ident(ident) = token {\n                            is_packed |= ident == \"packed\";\n                        }\n                    }\n                    Ok(())\n                });\n            }\n        }\n\n        Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::identifier":["pub fn identifier(&self) -> Identifier{\n        self.identifier\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::is_packed":["pub fn is_packed(&self) -> bool{\n        self.is_packed\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::name":["pub fn name(&self) -> &MultiName{\n        &self.name\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::non_exhaustive":["pub fn non_exhaustive(&self) -> bool{\n        self.non_exhaustive\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::remote":["pub fn remote(&self) -> Option<&syn::Path>{\n        self.remote.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::rename_all_fields_rules":["pub fn rename_all_fields_rules(&self) -> RenameAllRules{\n        self.rename_all_fields_rules\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::rename_all_rules":["pub fn rename_all_rules(&self) -> RenameAllRules{\n        self.rename_all_rules\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::ser_bound":["pub fn ser_bound(&self) -> Option<&[syn::WherePredicate]>{\n        self.ser_bound.as_ref().map(|vec| &vec[..])\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::serde_path":["pub fn serde_path(&self) -> Cow<syn::Path>{\n        self.custom_serde_path()\n            .map_or_else(|| Cow::Owned(parse_quote!(_serde)), Cow::Borrowed)\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::tag":["pub fn tag(&self) -> &TagType{\n        &self.tag\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::transparent":["pub fn transparent(&self) -> bool{\n        self.transparent\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::type_from":["pub fn type_from(&self) -> Option<&syn::Type>{\n        self.type_from.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::type_into":["pub fn type_into(&self) -> Option<&syn::Type>{\n        self.type_into.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Container::type_try_from":["pub fn type_try_from(&self) -> Option<&syn::Type>{\n        self.type_try_from.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Default":["/// Represents the default to use for a field when deserializing.\npub enum Default {\n    /// Field must always be specified because it does not have a default.\n    None,\n    /// The default is given by `std::default::Default::default()`.\n    Default,\n    /// The default is given by this function.\n    Path(syn::ExprPath),\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Default::is_none":["pub fn is_none(&self) -> bool{\n        match self {\n            Default::None => true,\n            Default::Default | Default::Path(_) => false,\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field":["/// Represents field attribute information\npub struct Field {\n    name: MultiName,\n    skip_serializing: bool,\n    skip_deserializing: bool,\n    skip_serializing_if: Option<syn::ExprPath>,\n    default: Default,\n    serialize_with: Option<syn::ExprPath>,\n    deserialize_with: Option<syn::ExprPath>,\n    ser_bound: Option<Vec<syn::WherePredicate>>,\n    de_bound: Option<Vec<syn::WherePredicate>>,\n    borrowed_lifetimes: BTreeSet<syn::Lifetime>,\n    getter: Option<syn::ExprPath>,\n    flatten: bool,\n    transparent: bool,\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::aliases":["pub fn aliases(&self) -> &BTreeSet<Name>{\n        self.name.deserialize_aliases()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::borrowed_lifetimes":["pub fn borrowed_lifetimes(&self) -> &BTreeSet<syn::Lifetime>{\n        &self.borrowed_lifetimes\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::de_bound":["pub fn de_bound(&self) -> Option<&[syn::WherePredicate]>{\n        self.de_bound.as_ref().map(|vec| &vec[..])\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::default":["pub fn default(&self) -> &Default{\n        &self.default\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::deserialize_with":["pub fn deserialize_with(&self) -> Option<&syn::ExprPath>{\n        self.deserialize_with.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::flatten":["pub fn flatten(&self) -> bool{\n        self.flatten\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::from_ast":["/// Extract out the `#[serde(...)]` attributes from a struct field.\npub fn from_ast(\n        cx: &Ctxt,\n        index: usize,\n        field: &syn::Field,\n        attrs: Option<&Variant>,\n        container_default: &Default,\n    ) -> Self{\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut de_aliases = VecAttr::none(cx, RENAME);\n        let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);\n        let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);\n        let mut skip_serializing_if = Attr::none(cx, SKIP_SERIALIZING_IF);\n        let mut default = Attr::none(cx, DEFAULT);\n        let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n        let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut borrowed_lifetimes = Attr::none(cx, BORROW);\n        let mut getter = Attr::none(cx, GETTER);\n        let mut flatten = BoolAttr::none(cx, FLATTEN);\n\n        let ident = match &field.ident {\n            Some(ident) => Name::from(&unraw(ident)),\n            None => Name {\n                value: index.to_string(),\n                span: Span::call_site(),\n            },\n        };\n\n        if let Some(borrow_attribute) = attrs.and_then(|variant| variant.borrow.as_ref()) {\n            if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field) {\n                if let Some(lifetimes) = &borrow_attribute.lifetimes {\n                    for lifetime in lifetimes {\n                        if !borrowable.contains(lifetime) {\n                            let msg =\n                                format!(\"field `{}` does not have lifetime {}\", ident, lifetime);\n                            cx.error_spanned_by(field, msg);\n                        }\n                    }\n                    borrowed_lifetimes.set(&borrow_attribute.path, lifetimes.clone());\n                } else {\n                    borrowed_lifetimes.set(&borrow_attribute.path, borrowable);\n                }\n            }\n        }\n\n        for attr in &field.attrs {\n            if attr.path() != SERDE {\n                continue;\n            }\n\n            if let syn::Meta::List(meta) = &attr.meta {\n                if meta.tokens.is_empty() {\n                    continue;\n                }\n            }\n\n            if let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_multiple_renames(cx, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    for de_value in de {\n                        de_name.set_if_none(Name::from(&de_value));\n                        de_aliases.insert(&meta.path, Name::from(&de_value));\n                    }\n                } else if meta.path == ALIAS {\n                    // #[serde(alias = \"foo\")]\n                    if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {\n                        de_aliases.insert(&meta.path, Name::from(&s));\n                    }\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            default.set(&meta.path, Default::Path(path));\n                        }\n                    } else {\n                        // #[serde(default)]\n                        default.set(&meta.path, Default::Default);\n                    }\n                } else if meta.path == SKIP_SERIALIZING {\n                    // #[serde(skip_serializing)]\n                    skip_serializing.set_true(&meta.path);\n                } else if meta.path == SKIP_DESERIALIZING {\n                    // #[serde(skip_deserializing)]\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP {\n                    // #[serde(skip)]\n                    skip_serializing.set_true(&meta.path);\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_SERIALIZING_IF {\n                    // #[serde(skip_serializing_if = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SKIP_SERIALIZING_IF, &meta)? {\n                        skip_serializing_if.set(&meta.path, path);\n                    }\n                } else if meta.path == SERIALIZE_WITH {\n                    // #[serde(serialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {\n                        serialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == DESERIALIZE_WITH {\n                    // #[serde(deserialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {\n                        deserialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == WITH {\n                    // #[serde(with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {\n                        let mut ser_path = path.clone();\n                        ser_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"serialize\", ser_path.span()).into());\n                        serialize_with.set(&meta.path, ser_path);\n                        let mut de_path = path;\n                        de_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"deserialize\", de_path.span()).into());\n                        deserialize_with.set(&meta.path, de_path);\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == BORROW {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(borrow = \"'a + 'b\")]\n                        let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;\n                        if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field) {\n                            for lifetime in &lifetimes {\n                                if !borrowable.contains(lifetime) {\n                                    let msg = format!(\n                                        \"field `{}` does not have lifetime {}\",\n                                        ident, lifetime,\n                                    );\n                                    cx.error_spanned_by(field, msg);\n                                }\n                            }\n                            borrowed_lifetimes.set(&meta.path, lifetimes);\n                        }\n                    } else {\n                        // #[serde(borrow)]\n                        if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field) {\n                            borrowed_lifetimes.set(&meta.path, borrowable);\n                        }\n                    }\n                } else if meta.path == GETTER {\n                    // #[serde(getter = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, GETTER, &meta)? {\n                        getter.set(&meta.path, path);\n                    }\n                } else if meta.path == FLATTEN {\n                    // #[serde(flatten)]\n                    flatten.set_true(&meta.path);\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde field attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            }) {\n                cx.syn_error(err);\n            }\n        }\n\n        // Is skip_deserializing, initialize the field to Default::default() unless a\n        // different default is specified by `#[serde(default = \"...\")]` on\n        // ourselves or our container (e.g. the struct we are in).\n        if let Default::None = *container_default {\n            if skip_deserializing.0.value.is_some() {\n                default.set_if_none(Default::Default);\n            }\n        }\n\n        let mut borrowed_lifetimes = borrowed_lifetimes.get().unwrap_or_default();\n        if !borrowed_lifetimes.is_empty() {\n            // Cow<str> and Cow<[u8]> never borrow by default:\n            //\n            //     impl<'de, 'a, T: ?Sized> Deserialize<'de> for Cow<'a, T>\n            //\n            // A #[serde(borrow)] attribute enables borrowing that corresponds\n            // roughly to these impls:\n            //\n            //     impl<'de: 'a, 'a> Deserialize<'de> for Cow<'a, str>\n            //     impl<'de: 'a, 'a> Deserialize<'de> for Cow<'a, [u8]>\n            if is_cow(&field.ty, is_str) {\n                let mut path = syn::Path {\n                    leading_colon: None,\n                    segments: Punctuated::new(),\n                };\n                let span = Span::call_site();\n                path.segments.push(Ident::new(\"_serde\", span).into());\n                path.segments.push(Ident::new(\"__private\", span).into());\n                path.segments.push(Ident::new(\"de\", span).into());\n                path.segments\n                    .push(Ident::new(\"borrow_cow_str\", span).into());\n                let expr = syn::ExprPath {\n                    attrs: Vec::new(),\n                    qself: None,\n                    path,\n                };\n                deserialize_with.set_if_none(expr);\n            } else if is_cow(&field.ty, is_slice_u8) {\n                let mut path = syn::Path {\n                    leading_colon: None,\n                    segments: Punctuated::new(),\n                };\n                let span = Span::call_site();\n                path.segments.push(Ident::new(\"_serde\", span).into());\n                path.segments.push(Ident::new(\"__private\", span).into());\n                path.segments.push(Ident::new(\"de\", span).into());\n                path.segments\n                    .push(Ident::new(\"borrow_cow_bytes\", span).into());\n                let expr = syn::ExprPath {\n                    attrs: Vec::new(),\n                    qself: None,\n                    path,\n                };\n                deserialize_with.set_if_none(expr);\n            }\n        } else if is_implicitly_borrowed(&field.ty) {\n            // Types &str and &[u8] are always implicitly borrowed. No need for\n            // a #[serde(borrow)].\n            collect_lifetimes(&field.ty, &mut borrowed_lifetimes);\n        }\n\n        Field {\n            name: MultiName::from_attrs(ident, ser_name, de_name, Some(de_aliases)),\n            skip_serializing: skip_serializing.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing_if: skip_serializing_if.get(),\n            default: default.get().unwrap_or(Default::None),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            borrowed_lifetimes,\n            getter: getter.get(),\n            flatten: flatten.get(),\n            transparent: false,\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::getter":["pub fn getter(&self) -> Option<&syn::ExprPath>{\n        self.getter.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::mark_transparent":["pub fn mark_transparent(&mut self){\n        self.transparent = true;\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::name":["pub fn name(&self) -> &MultiName{\n        &self.name\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::rename_by_rules":["pub fn rename_by_rules(&mut self, rules: RenameAllRules){\n        if !self.name.serialize_renamed {\n            self.name.serialize.value = rules.serialize.apply_to_field(&self.name.serialize.value);\n        }\n        if !self.name.deserialize_renamed {\n            self.name.deserialize.value = rules\n                .deserialize\n                .apply_to_field(&self.name.deserialize.value);\n        }\n        self.name\n            .deserialize_aliases\n            .insert(self.name.deserialize.clone());\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::ser_bound":["pub fn ser_bound(&self) -> Option<&[syn::WherePredicate]>{\n        self.ser_bound.as_ref().map(|vec| &vec[..])\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::serialize_with":["pub fn serialize_with(&self) -> Option<&syn::ExprPath>{\n        self.serialize_with.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::skip_deserializing":["pub fn skip_deserializing(&self) -> bool{\n        self.skip_deserializing\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::skip_serializing":["pub fn skip_serializing(&self) -> bool{\n        self.skip_serializing\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::skip_serializing_if":["pub fn skip_serializing_if(&self) -> Option<&syn::ExprPath>{\n        self.skip_serializing_if.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Field::transparent":["pub fn transparent(&self) -> bool{\n        self.transparent\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Identifier":["/// Whether this enum represents the fields of a struct or the variants of an\n/// enum.\npub enum Identifier {\n    /// It does not.\n    No,\n\n    /// This enum represents the fields of a struct. All of the variants must be\n    /// unit variants, except possibly one which is annotated with\n    /// `#[serde(other)]` and is a newtype variant.\n    Field,\n\n    /// This enum represents the variants of an enum. All of the variants must\n    /// be unit variants.\n    Variant,\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::RenameAllRules":["pub struct RenameAllRules {\n    pub serialize: RenameRule,\n    pub deserialize: RenameRule,\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::RenameAllRules::or":["/// Returns a new `RenameAllRules` with the individual rules of `self` and\n/// `other_rules` joined by `RenameRules::or`.\npub fn or(self, other_rules: Self) -> Self{\n        Self {\n            serialize: self.serialize.or(other_rules.serialize),\n            deserialize: self.deserialize.or(other_rules.deserialize),\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::TagType":["/// Styles of representing an enum.\npub enum TagType {\n    /// The default.\n    ///\n    /// ```json\n    /// {\"variant1\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n    /// ```\n    External,\n\n    /// `#[serde(tag = \"type\")]`\n    ///\n    /// ```json\n    /// {\"type\": \"variant1\", \"key1\": \"value1\", \"key2\": \"value2\"}\n    /// ```\n    Internal { tag: String },\n\n    /// `#[serde(tag = \"t\", content = \"c\")]`\n    ///\n    /// ```json\n    /// {\"t\": \"variant1\", \"c\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n    /// ```\n    Adjacent { tag: String, content: String },\n\n    /// `#[serde(untagged)]`\n    ///\n    /// ```json\n    /// {\"key1\": \"value1\", \"key2\": \"value2\"}\n    /// ```\n    None,\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant":["/// Represents variant attribute information\npub struct Variant {\n    name: MultiName,\n    rename_all_rules: RenameAllRules,\n    ser_bound: Option<Vec<syn::WherePredicate>>,\n    de_bound: Option<Vec<syn::WherePredicate>>,\n    skip_deserializing: bool,\n    skip_serializing: bool,\n    other: bool,\n    serialize_with: Option<syn::ExprPath>,\n    deserialize_with: Option<syn::ExprPath>,\n    borrow: Option<BorrowAttribute>,\n    untagged: bool,\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::aliases":["pub fn aliases(&self) -> &BTreeSet<Name>{\n        self.name.deserialize_aliases()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::de_bound":["pub fn de_bound(&self) -> Option<&[syn::WherePredicate]>{\n        self.de_bound.as_ref().map(|vec| &vec[..])\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::deserialize_with":["pub fn deserialize_with(&self) -> Option<&syn::ExprPath>{\n        self.deserialize_with.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::from_ast":["pub fn from_ast(cx: &Ctxt, variant: &syn::Variant) -> Self{\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut de_aliases = VecAttr::none(cx, RENAME);\n        let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);\n        let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);\n        let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut other = BoolAttr::none(cx, OTHER);\n        let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n        let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n        let mut borrow = Attr::none(cx, BORROW);\n        let mut untagged = BoolAttr::none(cx, UNTAGGED);\n\n        for attr in &variant.attrs {\n            if attr.path() != SERDE {\n                continue;\n            }\n\n            if let syn::Meta::List(meta) = &attr.meta {\n                if meta.tokens.is_empty() {\n                    continue;\n                }\n            }\n\n            if let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_multiple_renames(cx, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    for de_value in de {\n                        de_name.set_if_none(Name::from(&de_value));\n                        de_aliases.insert(&meta.path, Name::from(&de_value));\n                    }\n                } else if meta.path == ALIAS {\n                    // #[serde(alias = \"foo\")]\n                    if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {\n                        de_aliases.insert(&meta.path, Name::from(&s));\n                    }\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == SKIP {\n                    // #[serde(skip)]\n                    skip_serializing.set_true(&meta.path);\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_DESERIALIZING {\n                    // #[serde(skip_deserializing)]\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_SERIALIZING {\n                    // #[serde(skip_serializing)]\n                    skip_serializing.set_true(&meta.path);\n                } else if meta.path == OTHER {\n                    // #[serde(other)]\n                    other.set_true(&meta.path);\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == WITH {\n                    // #[serde(with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {\n                        let mut ser_path = path.clone();\n                        ser_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"serialize\", ser_path.span()).into());\n                        serialize_with.set(&meta.path, ser_path);\n                        let mut de_path = path;\n                        de_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"deserialize\", de_path.span()).into());\n                        deserialize_with.set(&meta.path, de_path);\n                    }\n                } else if meta.path == SERIALIZE_WITH {\n                    // #[serde(serialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {\n                        serialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == DESERIALIZE_WITH {\n                    // #[serde(deserialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {\n                        deserialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == BORROW {\n                    let borrow_attribute = if meta.input.peek(Token![=]) {\n                        // #[serde(borrow = \"'a + 'b\")]\n                        let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: Some(lifetimes),\n                        }\n                    } else {\n                        // #[serde(borrow)]\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: None,\n                        }\n                    };\n                    match &variant.fields {\n                        syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {\n                            borrow.set(&meta.path, borrow_attribute);\n                        }\n                        _ => {\n                            let msg = \"#[serde(borrow)] may only be used on newtype variants\";\n                            cx.error_spanned_by(variant, msg);\n                        }\n                    }\n                } else if meta.path == UNTAGGED {\n                    untagged.set_true(&meta.path);\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde variant attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            }) {\n                cx.syn_error(err);\n            }\n        }\n\n        Variant {\n            name: MultiName::from_attrs(\n                Name::from(&unraw(&variant.ident)),\n                ser_name,\n                de_name,\n                Some(de_aliases),\n            ),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n            untagged: untagged.get(),\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::name":["pub fn name(&self) -> &MultiName{\n        &self.name\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::other":["pub fn other(&self) -> bool{\n        self.other\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::rename_all_rules":["pub fn rename_all_rules(&self) -> RenameAllRules{\n        self.rename_all_rules\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::rename_by_rules":["pub fn rename_by_rules(&mut self, rules: RenameAllRules){\n        if !self.name.serialize_renamed {\n            self.name.serialize.value =\n                rules.serialize.apply_to_variant(&self.name.serialize.value);\n        }\n        if !self.name.deserialize_renamed {\n            self.name.deserialize.value = rules\n                .deserialize\n                .apply_to_variant(&self.name.deserialize.value);\n        }\n        self.name\n            .deserialize_aliases\n            .insert(self.name.deserialize.clone());\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::ser_bound":["pub fn ser_bound(&self) -> Option<&[syn::WherePredicate]>{\n        self.ser_bound.as_ref().map(|vec| &vec[..])\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::serialize_with":["pub fn serialize_with(&self) -> Option<&syn::ExprPath>{\n        self.serialize_with.as_ref()\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::skip_deserializing":["pub fn skip_deserializing(&self) -> bool{\n        self.skip_deserializing\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::skip_serializing":["pub fn skip_serializing(&self) -> bool{\n        self.skip_serializing\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::Variant::untagged":["pub fn untagged(&self) -> bool{\n        self.untagged\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::VecAttr":["pub(crate) struct VecAttr<'c, T> {\n    cx: &'c Ctxt,\n    name: Symbol,\n    first_dup_tokens: TokenStream,\n    values: Vec<T>,\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::VecAttr::<'c, T>::at_most_one":["fn at_most_one(mut self) -> Option<T>{\n        if self.values.len() > 1 {\n            let dup_token = self.first_dup_tokens;\n            let msg = format!(\"duplicate serde attribute `{}`\", self.name);\n            self.cx.error_spanned_by(dup_token, msg);\n            None\n        } else {\n            self.values.pop()\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::VecAttr::<'c, T>::get":["pub(crate) fn get(self) -> Vec<T>{\n        self.values\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::VecAttr::<'c, T>::insert":["fn insert<A: ToTokens>(&mut self, obj: A, value: T){\n        if self.values.len() == 1 {\n            self.first_dup_tokens = obj.into_token_stream();\n        }\n        self.values.push(value);\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::VecAttr::<'c, T>::none":["fn none(cx: &'c Ctxt, name: Symbol) -> Self{\n        VecAttr {\n            cx,\n            name,\n            first_dup_tokens: TokenStream::new(),\n            values: Vec::new(),\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::borrowable_lifetimes":["fn borrowable_lifetimes(\n    cx: &Ctxt,\n    name: &Name,\n    field: &syn::Field,\n) -> Result<BTreeSet<syn::Lifetime>, ()>{\n    let mut lifetimes = BTreeSet::new();\n    collect_lifetimes(&field.ty, &mut lifetimes);\n    if lifetimes.is_empty() {\n        let msg = format!(\"field `{}` has no lifetimes to borrow\", name);\n        cx.error_spanned_by(field, msg);\n        Err(())\n    } else {\n        Ok(lifetimes)\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::collect_lifetimes":["fn collect_lifetimes(ty: &syn::Type, out: &mut BTreeSet<syn::Lifetime>){\n    match ty {\n        #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]\n        syn::Type::Slice(ty) => {\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Array(ty) => {\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Ptr(ty) => {\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Reference(ty) => {\n            out.extend(ty.lifetime.iter().cloned());\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Tuple(ty) => {\n            for elem in &ty.elems {\n                collect_lifetimes(elem, out);\n            }\n        }\n        syn::Type::Path(ty) => {\n            if let Some(qself) = &ty.qself {\n                collect_lifetimes(&qself.ty, out);\n            }\n            for seg in &ty.path.segments {\n                if let syn::PathArguments::AngleBracketed(bracketed) = &seg.arguments {\n                    for arg in &bracketed.args {\n                        match arg {\n                            syn::GenericArgument::Lifetime(lifetime) => {\n                                out.insert(lifetime.clone());\n                            }\n                            syn::GenericArgument::Type(ty) => {\n                                collect_lifetimes(ty, out);\n                            }\n                            syn::GenericArgument::AssocType(binding) => {\n                                collect_lifetimes(&binding.ty, out);\n                            }\n                            syn::GenericArgument::Const(_)\n                            | syn::GenericArgument::AssocConst(_)\n                            | syn::GenericArgument::Constraint(_)\n                            | _ => {}\n                        }\n                    }\n                }\n            }\n        }\n        syn::Type::Paren(ty) => {\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Group(ty) => {\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Macro(ty) => {\n            collect_lifetimes_from_tokens(ty.mac.tokens.clone(), out);\n        }\n        syn::Type::BareFn(_)\n        | syn::Type::Never(_)\n        | syn::Type::TraitObject(_)\n        | syn::Type::ImplTrait(_)\n        | syn::Type::Infer(_)\n        | syn::Type::Verbatim(_) => {}\n\n        _ => {}\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::collect_lifetimes_from_tokens":["fn collect_lifetimes_from_tokens(tokens: TokenStream, out: &mut BTreeSet<syn::Lifetime>){\n    let mut iter = tokens.into_iter();\n    while let Some(tt) = iter.next() {\n        match &tt {\n            TokenTree::Punct(op) if op.as_char() == '\\'' && op.spacing() == Spacing::Joint => {\n                if let Some(TokenTree::Ident(ident)) = iter.next() {\n                    out.insert(syn::Lifetime {\n                        apostrophe: op.span(),\n                        ident,\n                    });\n                }\n            }\n            TokenTree::Group(group) => {\n                let tokens = group.stream();\n                collect_lifetimes_from_tokens(tokens, out);\n            }\n            _ => {}\n        }\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::decide_identifier":["fn decide_identifier(\n    cx: &Ctxt,\n    item: &syn::DeriveInput,\n    field_identifier: BoolAttr,\n    variant_identifier: BoolAttr,\n) -> Identifier{\n    match (\n        &item.data,\n        field_identifier.0.get_with_tokens(),\n        variant_identifier.0.get_with_tokens(),\n    ) {\n        (_, None, None) => Identifier::No,\n        (_, Some((field_identifier_tokens, ())), Some((variant_identifier_tokens, ()))) => {\n            let msg =\n                \"#[serde(field_identifier)] and #[serde(variant_identifier)] cannot both be set\";\n            cx.error_spanned_by(field_identifier_tokens, msg);\n            cx.error_spanned_by(variant_identifier_tokens, msg);\n            Identifier::No\n        }\n        (syn::Data::Enum(_), Some(_), None) => Identifier::Field,\n        (syn::Data::Enum(_), None, Some(_)) => Identifier::Variant,\n        (syn::Data::Struct(syn::DataStruct { struct_token, .. }), Some(_), None) => {\n            let msg = \"#[serde(field_identifier)] can only be used on an enum\";\n            cx.error_spanned_by(struct_token, msg);\n            Identifier::No\n        }\n        (syn::Data::Union(syn::DataUnion { union_token, .. }), Some(_), None) => {\n            let msg = \"#[serde(field_identifier)] can only be used on an enum\";\n            cx.error_spanned_by(union_token, msg);\n            Identifier::No\n        }\n        (syn::Data::Struct(syn::DataStruct { struct_token, .. }), None, Some(_)) => {\n            let msg = \"#[serde(variant_identifier)] can only be used on an enum\";\n            cx.error_spanned_by(struct_token, msg);\n            Identifier::No\n        }\n        (syn::Data::Union(syn::DataUnion { union_token, .. }), None, Some(_)) => {\n            let msg = \"#[serde(variant_identifier)] can only be used on an enum\";\n            cx.error_spanned_by(union_token, msg);\n            Identifier::No\n        }\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::decide_tag":["fn decide_tag(\n    cx: &Ctxt,\n    item: &syn::DeriveInput,\n    untagged: BoolAttr,\n    internal_tag: Attr<String>,\n    content: Attr<String>,\n) -> TagType{\n    match (\n        untagged.0.get_with_tokens(),\n        internal_tag.get_with_tokens(),\n        content.get_with_tokens(),\n    ) {\n        (None, None, None) => TagType::External,\n        (Some(_), None, None) => TagType::None,\n        (None, Some((_, tag)), None) => {\n            // Check that there are no tuple variants.\n            if let syn::Data::Enum(data) = &item.data {\n                for variant in &data.variants {\n                    match &variant.fields {\n                        syn::Fields::Named(_) | syn::Fields::Unit => {}\n                        syn::Fields::Unnamed(fields) => {\n                            if fields.unnamed.len() != 1 {\n                                let msg =\n                                    \"#[serde(tag = \\\"...\\\")] cannot be used with tuple variants\";\n                                cx.error_spanned_by(variant, msg);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            TagType::Internal { tag }\n        }\n        (Some((untagged_tokens, ())), Some((tag_tokens, _)), None) => {\n            let msg = \"enum cannot be both untagged and internally tagged\";\n            cx.error_spanned_by(untagged_tokens, msg);\n            cx.error_spanned_by(tag_tokens, msg);\n            TagType::External // doesn't matter, will error\n        }\n        (None, None, Some((content_tokens, _))) => {\n            let msg = \"#[serde(tag = \\\"...\\\", content = \\\"...\\\")] must be used together\";\n            cx.error_spanned_by(content_tokens, msg);\n            TagType::External\n        }\n        (Some((untagged_tokens, ())), None, Some((content_tokens, _))) => {\n            let msg = \"untagged enum cannot have #[serde(content = \\\"...\\\")]\";\n            cx.error_spanned_by(untagged_tokens, msg);\n            cx.error_spanned_by(content_tokens, msg);\n            TagType::External\n        }\n        (None, Some((_, tag)), Some((_, content))) => TagType::Adjacent { tag, content },\n        (Some((untagged_tokens, ())), Some((tag_tokens, _)), Some((content_tokens, _))) => {\n            let msg = \"untagged enum cannot have #[serde(tag = \\\"...\\\", content = \\\"...\\\")]\";\n            cx.error_spanned_by(untagged_tokens, msg);\n            cx.error_spanned_by(tag_tokens, msg);\n            cx.error_spanned_by(content_tokens, msg);\n            TagType::External\n        }\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::get_lit_str":["fn get_lit_str(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    meta: &ParseNestedMeta,\n) -> syn::Result<Option<syn::LitStr>>{\n    get_lit_str2(cx, attr_name, attr_name, meta)\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::get_lit_str2":["fn get_lit_str2(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    meta_item_name: Symbol,\n    meta: &ParseNestedMeta,\n) -> syn::Result<Option<syn::LitStr>>{\n    let expr: syn::Expr = meta.value()?.parse()?;\n    let mut value = &expr;\n    while let syn::Expr::Group(e) = value {\n        value = &e.expr;\n    }\n    if let syn::Expr::Lit(syn::ExprLit {\n        lit: syn::Lit::Str(lit),\n        ..\n    }) = value\n    {\n        let suffix = lit.suffix();\n        if !suffix.is_empty() {\n            cx.error_spanned_by(\n                lit,\n                format!(\"unexpected suffix `{}` on string literal\", suffix),\n            );\n        }\n        Ok(Some(lit.clone()))\n    } else {\n        cx.error_spanned_by(\n            expr,\n            format!(\n                \"expected serde {} attribute to be a string: `{} = \\\"...\\\"`\",\n                attr_name, meta_item_name\n            ),\n        );\n        Ok(None)\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::get_multiple_renames":["fn get_multiple_renames(\n    cx: &Ctxt,\n    meta: &ParseNestedMeta,\n) -> syn::Result<(Option<syn::LitStr>, Vec<syn::LitStr>)>{\n    let (ser, de) = get_ser_and_de(cx, RENAME, meta, get_lit_str2)?;\n    Ok((ser.at_most_one(), de.get()))\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::get_renames":["fn get_renames(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    meta: &ParseNestedMeta,\n) -> syn::Result<SerAndDe<syn::LitStr>>{\n    let (ser, de) = get_ser_and_de(cx, attr_name, meta, get_lit_str2)?;\n    Ok((ser.at_most_one(), de.at_most_one()))\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::get_ser_and_de":["fn get_ser_and_de<'c, T, F, R>(\n    cx: &'c Ctxt,\n    attr_name: Symbol,\n    meta: &ParseNestedMeta,\n    f: F,\n) -> syn::Result<(VecAttr<'c, T>, VecAttr<'c, T>)>\nwhere\n    T: Clone,\n    F: Fn(&Ctxt, Symbol, Symbol, &ParseNestedMeta) -> syn::Result<R>,\n    R: Into<Option<T>>,{\n    let mut ser_meta = VecAttr::none(cx, attr_name);\n    let mut de_meta = VecAttr::none(cx, attr_name);\n\n    let lookahead = meta.input.lookahead1();\n    if lookahead.peek(Token![=]) {\n        if let Some(both) = f(cx, attr_name, attr_name, meta)?.into() {\n            ser_meta.insert(&meta.path, both.clone());\n            de_meta.insert(&meta.path, both);\n        }\n    } else if lookahead.peek(token::Paren) {\n        meta.parse_nested_meta(|meta| {\n            if meta.path == SERIALIZE {\n                if let Some(v) = f(cx, attr_name, SERIALIZE, &meta)?.into() {\n                    ser_meta.insert(&meta.path, v);\n                }\n            } else if meta.path == DESERIALIZE {\n                if let Some(v) = f(cx, attr_name, DESERIALIZE, &meta)?.into() {\n                    de_meta.insert(&meta.path, v);\n                }\n            } else {\n                return Err(meta.error(format_args!(\n                    \"malformed {0} attribute, expected `{0}(serialize = ..., deserialize = ...)`\",\n                    attr_name,\n                )));\n            }\n            Ok(())\n        })?;\n    } else {\n        return Err(lookahead.error());\n    }\n\n    Ok((ser_meta, de_meta))\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::get_where_predicates":["fn get_where_predicates(\n    cx: &Ctxt,\n    meta: &ParseNestedMeta,\n) -> syn::Result<SerAndDe<Vec<syn::WherePredicate>>>{\n    let (ser, de) = get_ser_and_de(cx, BOUND, meta, parse_lit_into_where)?;\n    Ok((ser.at_most_one(), de.at_most_one()))\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::is_cow":["fn is_cow(ty: &syn::Type, elem: fn(&syn::Type) -> bool) -> bool{\n    let path = match ungroup(ty) {\n        syn::Type::Path(ty) => &ty.path,\n        _ => {\n            return false;\n        }\n    };\n    let seg = match path.segments.last() {\n        Some(seg) => seg,\n        None => {\n            return false;\n        }\n    };\n    let args = match &seg.arguments {\n        syn::PathArguments::AngleBracketed(bracketed) => &bracketed.args,\n        _ => {\n            return false;\n        }\n    };\n    seg.ident == \"Cow\"\n        && args.len() == 2\n        && match (&args[0], &args[1]) {\n            (syn::GenericArgument::Lifetime(_), syn::GenericArgument::Type(arg)) => elem(arg),\n            _ => false,\n        }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::is_implicitly_borrowed":["fn is_implicitly_borrowed(ty: &syn::Type) -> bool{\n    is_implicitly_borrowed_reference(ty) || is_option(ty, is_implicitly_borrowed_reference)\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::is_implicitly_borrowed_reference":["fn is_implicitly_borrowed_reference(ty: &syn::Type) -> bool{\n    is_reference(ty, is_str) || is_reference(ty, is_slice_u8)\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::is_option":["fn is_option(ty: &syn::Type, elem: fn(&syn::Type) -> bool) -> bool{\n    let path = match ungroup(ty) {\n        syn::Type::Path(ty) => &ty.path,\n        _ => {\n            return false;\n        }\n    };\n    let seg = match path.segments.last() {\n        Some(seg) => seg,\n        None => {\n            return false;\n        }\n    };\n    let args = match &seg.arguments {\n        syn::PathArguments::AngleBracketed(bracketed) => &bracketed.args,\n        _ => {\n            return false;\n        }\n    };\n    seg.ident == \"Option\"\n        && args.len() == 1\n        && match &args[0] {\n            syn::GenericArgument::Type(arg) => elem(arg),\n            _ => false,\n        }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::is_primitive_path":["fn is_primitive_path(path: &syn::Path, primitive: &str) -> bool{\n    path.leading_colon.is_none()\n        && path.segments.len() == 1\n        && path.segments[0].ident == primitive\n        && path.segments[0].arguments.is_empty()\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::is_primitive_type":["fn is_primitive_type(ty: &syn::Type, primitive: &str) -> bool{\n    match ungroup(ty) {\n        syn::Type::Path(ty) => ty.qself.is_none() && is_primitive_path(&ty.path, primitive),\n        _ => false,\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::is_reference":["fn is_reference(ty: &syn::Type, elem: fn(&syn::Type) -> bool) -> bool{\n    match ungroup(ty) {\n        syn::Type::Reference(ty) => ty.mutability.is_none() && elem(&ty.elem),\n        _ => false,\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::is_slice_u8":["fn is_slice_u8(ty: &syn::Type) -> bool{\n    match ungroup(ty) {\n        syn::Type::Slice(ty) => is_primitive_type(&ty.elem, \"u8\"),\n        _ => false,\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::is_str":["fn is_str(ty: &syn::Type) -> bool{\n    is_primitive_type(ty, \"str\")\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::parse_lit_into_expr_path":["fn parse_lit_into_expr_path(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    meta: &ParseNestedMeta,\n) -> syn::Result<Option<syn::ExprPath>>{\n    let string = match get_lit_str(cx, attr_name, meta)? {\n        Some(string) => string,\n        None => return Ok(None),\n    };\n\n    Ok(match string.parse() {\n        Ok(expr) => Some(expr),\n        Err(_) => {\n            cx.error_spanned_by(\n                &string,\n                format!(\"failed to parse path: {:?}\", string.value()),\n            );\n            None\n        }\n    })\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::parse_lit_into_lifetimes":["fn parse_lit_into_lifetimes(\n    cx: &Ctxt,\n    meta: &ParseNestedMeta,\n) -> syn::Result<BTreeSet<syn::Lifetime>>{\n    let string = match get_lit_str(cx, BORROW, meta)? {\n        Some(string) => string,\n        None => return Ok(BTreeSet::new()),\n    };\n\n    if let Ok(lifetimes) = string.parse_with(|input: ParseStream| {\n        let mut set = BTreeSet::new();\n        while !input.is_empty() {\n            let lifetime: Lifetime = input.parse()?;\n            if !set.insert(lifetime.clone()) {\n                cx.error_spanned_by(\n                    &string,\n                    format!(\"duplicate borrowed lifetime `{}`\", lifetime),\n                );\n            }\n            if input.is_empty() {\n                break;\n            }\n            input.parse::<Token![+]>()?;\n        }\n        Ok(set)\n    }) {\n        if lifetimes.is_empty() {\n            cx.error_spanned_by(string, \"at least one lifetime must be borrowed\");\n        }\n        return Ok(lifetimes);\n    }\n\n    cx.error_spanned_by(\n        &string,\n        format!(\"failed to parse borrowed lifetimes: {:?}\", string.value()),\n    );\n    Ok(BTreeSet::new())\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::parse_lit_into_path":["fn parse_lit_into_path(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    meta: &ParseNestedMeta,\n) -> syn::Result<Option<syn::Path>>{\n    let string = match get_lit_str(cx, attr_name, meta)? {\n        Some(string) => string,\n        None => return Ok(None),\n    };\n\n    Ok(match string.parse() {\n        Ok(path) => Some(path),\n        Err(_) => {\n            cx.error_spanned_by(\n                &string,\n                format!(\"failed to parse path: {:?}\", string.value()),\n            );\n            None\n        }\n    })\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::parse_lit_into_ty":["fn parse_lit_into_ty(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    meta: &ParseNestedMeta,\n) -> syn::Result<Option<syn::Type>>{\n    let string = match get_lit_str(cx, attr_name, meta)? {\n        Some(string) => string,\n        None => return Ok(None),\n    };\n\n    Ok(match string.parse() {\n        Ok(ty) => Some(ty),\n        Err(_) => {\n            cx.error_spanned_by(\n                &string,\n                format!(\"failed to parse type: {} = {:?}\", attr_name, string.value()),\n            );\n            None\n        }\n    })\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::parse_lit_into_where":["fn parse_lit_into_where(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    meta_item_name: Symbol,\n    meta: &ParseNestedMeta,\n) -> syn::Result<Vec<syn::WherePredicate>>{\n    let string = match get_lit_str2(cx, attr_name, meta_item_name, meta)? {\n        Some(string) => string,\n        None => return Ok(Vec::new()),\n    };\n\n    Ok(\n        match string.parse_with(Punctuated::<syn::WherePredicate, Token![,]>::parse_terminated) {\n            Ok(predicates) => Vec::from_iter(predicates),\n            Err(err) => {\n                cx.error_spanned_by(string, err);\n                Vec::new()\n            }\n        },\n    )\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::attr::unraw":["fn unraw(ident: &Ident) -> Ident{\n    Ident::new(ident.to_string().trim_start_matches(\"r#\"), ident.span())\n}","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))"],"internals::case::ParseError":["pub struct ParseError<'a> {\n    unknown: &'a str,\n}","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))"],"internals::case::RenameRule":["/// The different possible ways to change case of fields in a struct, or variants in an enum.\npub enum RenameRule {\n    /// Don't apply a default rename rule.\n    None,\n    /// Rename direct children to \"lowercase\" style.\n    LowerCase,\n    /// Rename direct children to \"UPPERCASE\" style.\n    UpperCase,\n    /// Rename direct children to \"PascalCase\" style, as typically used for\n    /// enum variants.\n    PascalCase,\n    /// Rename direct children to \"camelCase\" style.\n    CamelCase,\n    /// Rename direct children to \"snake_case\" style, as commonly used for\n    /// fields.\n    SnakeCase,\n    /// Rename direct children to \"SCREAMING_SNAKE_CASE\" style, as commonly\n    /// used for constants.\n    ScreamingSnakeCase,\n    /// Rename direct children to \"kebab-case\" style.\n    KebabCase,\n    /// Rename direct children to \"SCREAMING-KEBAB-CASE\" style.\n    ScreamingKebabCase,\n}","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))"],"internals::case::RenameRule::apply_to_field":["/// Apply a renaming rule to a struct field, returning the version expected in the source.\npub fn apply_to_field(self, field: &str) -> String{\n        match self {\n            None | LowerCase | SnakeCase => field.to_owned(),\n            UpperCase => field.to_ascii_uppercase(),\n            PascalCase => {\n                let mut pascal = String::new();\n                let mut capitalize = true;\n                for ch in field.chars() {\n                    if ch == '_' {\n                        capitalize = true;\n                    } else if capitalize {\n                        pascal.push(ch.to_ascii_uppercase());\n                        capitalize = false;\n                    } else {\n                        pascal.push(ch);\n                    }\n                }\n                pascal\n            }\n            CamelCase => {\n                let pascal = PascalCase.apply_to_field(field);\n                pascal[..1].to_ascii_lowercase() + &pascal[1..]\n            }\n            ScreamingSnakeCase => field.to_ascii_uppercase(),\n            KebabCase => field.replace('_', \"-\"),\n            ScreamingKebabCase => ScreamingSnakeCase.apply_to_field(field).replace('_', \"-\"),\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))"],"internals::case::RenameRule::apply_to_variant":["/// Apply a renaming rule to an enum variant, returning the version expected in the source.\npub fn apply_to_variant(self, variant: &str) -> String{\n        match self {\n            None | PascalCase => variant.to_owned(),\n            LowerCase => variant.to_ascii_lowercase(),\n            UpperCase => variant.to_ascii_uppercase(),\n            CamelCase => variant[..1].to_ascii_lowercase() + &variant[1..],\n            SnakeCase => {\n                let mut snake = String::new();\n                for (i, ch) in variant.char_indices() {\n                    if i > 0 && ch.is_uppercase() {\n                        snake.push('_');\n                    }\n                    snake.push(ch.to_ascii_lowercase());\n                }\n                snake\n            }\n            ScreamingSnakeCase => SnakeCase.apply_to_variant(variant).to_ascii_uppercase(),\n            KebabCase => SnakeCase.apply_to_variant(variant).replace('_', \"-\"),\n            ScreamingKebabCase => ScreamingSnakeCase\n                .apply_to_variant(variant)\n                .replace('_', \"-\"),\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))"],"internals::case::RenameRule::from_str":["pub fn from_str(rename_all_str: &str) -> Result<Self, ParseError>{\n        for (name, rule) in RENAME_RULES {\n            if rename_all_str == *name {\n                return Ok(*rule);\n            }\n        }\n        Err(ParseError {\n            unknown: rename_all_str,\n        })\n    }","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))"],"internals::case::RenameRule::or":["/// Returns the `RenameRule` if it is not `None`, `rule_b` otherwise.\npub fn or(self, rule_b: Self) -> Self{\n        match self {\n            None => rule_b,\n            _ => self,\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))"],"internals::check::allow_transparent":["fn allow_transparent(field: &Field, derive: Derive) -> bool{\n    if let Type::Path(ty) = ungroup(field.ty) {\n        if let Some(seg) = ty.path.segments.last() {\n            if seg.ident == \"PhantomData\" {\n                return false;\n            }\n        }\n    }\n\n    match derive {\n        Derive::Serialize => !field.attrs.skip_serializing(),\n        Derive::Deserialize => !field.attrs.skip_deserializing() && field.attrs.default().is_none(),\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check":["pub fn check(cx: &Ctxt, cont: &mut Container, derive: Derive){\n    check_default_on_tuple(cx, cont);\n    check_remote_generic(cx, cont);\n    check_getter(cx, cont);\n    check_flatten(cx, cont);\n    check_identifier(cx, cont);\n    check_variant_skip_attrs(cx, cont);\n    check_internal_tag_field_name_conflict(cx, cont);\n    check_adjacent_tag_conflict(cx, cont);\n    check_transparent(cx, cont, derive);\n    check_from_and_try_from(cx, cont);\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_adjacent_tag_conflict":["fn check_adjacent_tag_conflict(cx: &Ctxt, cont: &Container){\n    let (type_tag, content_tag) = match cont.attrs.tag() {\n        TagType::Adjacent { tag, content } => (tag, content),\n        TagType::Internal { .. } | TagType::External | TagType::None => return,\n    };\n\n    if type_tag == content_tag {\n        cx.error_spanned_by(\n            cont.original,\n            format!(\n                \"enum tags `{}` for type and content conflict with each other\",\n                type_tag\n            ),\n        );\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_default_on_tuple":["fn check_default_on_tuple(cx: &Ctxt, cont: &Container){\n    if let Default::None = cont.attrs.default() {\n        if let Data::Struct(Style::Tuple, fields) = &cont.data {\n            let mut first_default_index = None;\n            for (i, field) in fields.iter().enumerate() {\n                // Skipped fields automatically get the #[serde(default)]\n                // attribute. We are interested only on non-skipped fields here.\n                if field.attrs.skip_deserializing() {\n                    continue;\n                }\n                if let Default::None = field.attrs.default() {\n                    if let Some(first) = first_default_index {\n                        cx.error_spanned_by(\n                            field.ty,\n                            format!(\"field must have #[serde(default)] because previous field {} has #[serde(default)]\", first),\n                        );\n                    }\n                    continue;\n                }\n                if first_default_index.is_none() {\n                    first_default_index = Some(i);\n                }\n            }\n        }\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_flatten":["fn check_flatten(cx: &Ctxt, cont: &Container){\n    match &cont.data {\n        Data::Enum(variants) => {\n            for variant in variants {\n                for field in &variant.fields {\n                    check_flatten_field(cx, variant.style, field);\n                }\n            }\n        }\n        Data::Struct(style, fields) => {\n            for field in fields {\n                check_flatten_field(cx, *style, field);\n            }\n        }\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_flatten_field":["fn check_flatten_field(cx: &Ctxt, style: Style, field: &Field){\n    if !field.attrs.flatten() {\n        return;\n    }\n    match style {\n        Style::Tuple => {\n            cx.error_spanned_by(\n                field.original,\n                \"#[serde(flatten)] cannot be used on tuple structs\",\n            );\n        }\n        Style::Newtype => {\n            cx.error_spanned_by(\n                field.original,\n                \"#[serde(flatten)] cannot be used on newtype structs\",\n            );\n        }\n        _ => {}\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_from_and_try_from":["fn check_from_and_try_from(cx: &Ctxt, cont: &mut Container){\n    if cont.attrs.type_from().is_some() && cont.attrs.type_try_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(from = \\\"...\\\")] and #[serde(try_from = \\\"...\\\")] conflict with each other\",\n        );\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_getter":["fn check_getter(cx: &Ctxt, cont: &Container){\n    match cont.data {\n        Data::Enum(_) => {\n            if cont.data.has_getter() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(getter = \\\"...\\\")] is not allowed in an enum\",\n                );\n            }\n        }\n        Data::Struct(_, _) => {\n            if cont.data.has_getter() && cont.attrs.remote().is_none() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(getter = \\\"...\\\")] can only be used in structs that have #[serde(remote = \\\"...\\\")]\",\n                );\n            }\n        }\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_identifier":["fn check_identifier(cx: &Ctxt, cont: &Container){\n    let variants = match &cont.data {\n        Data::Enum(variants) => variants,\n        Data::Struct(_, _) => return,\n    };\n\n    for (i, variant) in variants.iter().enumerate() {\n        match (\n            variant.style,\n            cont.attrs.identifier(),\n            variant.attrs.other(),\n            cont.attrs.tag(),\n        ) {\n            // The `other` attribute may not be used in a variant_identifier.\n            (_, Identifier::Variant, true, _) => {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] may not be used on a variant identifier\",\n                );\n            }\n\n            // Variant with `other` attribute cannot appear in untagged enum\n            (_, Identifier::No, true, &TagType::None) => {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] cannot appear on untagged enum\",\n                );\n            }\n\n            // Variant with `other` attribute must be the last one.\n            (Style::Unit, Identifier::Field, true, _) | (Style::Unit, Identifier::No, true, _) => {\n                if i < variants.len() - 1 {\n                    cx.error_spanned_by(\n                        variant.original,\n                        \"#[serde(other)] must be on the last variant\",\n                    );\n                }\n            }\n\n            // Variant with `other` attribute must be a unit variant.\n            (_, Identifier::Field, true, _) | (_, Identifier::No, true, _) => {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] must be on a unit variant\",\n                );\n            }\n\n            // Any sort of variant is allowed if this is not an identifier.\n            (_, Identifier::No, false, _) => {}\n\n            // Unit variant without `other` attribute is always fine.\n            (Style::Unit, _, false, _) => {}\n\n            // The last field is allowed to be a newtype catch-all.\n            (Style::Newtype, Identifier::Field, false, _) => {\n                if i < variants.len() - 1 {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\"`{}` must be the last variant\", variant.ident),\n                    );\n                }\n            }\n\n            (_, Identifier::Field, false, _) => {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(field_identifier)] may only contain unit variants\",\n                );\n            }\n\n            (_, Identifier::Variant, false, _) => {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(variant_identifier)] may only contain unit variants\",\n                );\n            }\n        }\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_internal_tag_field_name_conflict":["fn check_internal_tag_field_name_conflict(cx: &Ctxt, cont: &Container){\n    let variants = match &cont.data {\n        Data::Enum(variants) => variants,\n        Data::Struct(_, _) => return,\n    };\n\n    let tag = match cont.attrs.tag() {\n        TagType::Internal { tag } => tag.as_str(),\n        TagType::External | TagType::Adjacent { .. } | TagType::None => return,\n    };\n\n    let diagnose_conflict = || {\n        cx.error_spanned_by(\n            cont.original,\n            format!(\"variant field name `{}` conflicts with internal tag\", tag),\n        );\n    };\n\n    for variant in variants {\n        match variant.style {\n            Style::Struct => {\n                if variant.attrs.untagged() {\n                    continue;\n                }\n                for field in &variant.fields {\n                    let check_ser =\n                        !(field.attrs.skip_serializing() || variant.attrs.skip_serializing());\n                    let check_de =\n                        !(field.attrs.skip_deserializing() || variant.attrs.skip_deserializing());\n                    let name = field.attrs.name();\n                    let ser_name = name.serialize_name();\n\n                    if check_ser && ser_name.value == tag {\n                        diagnose_conflict();\n                        return;\n                    }\n\n                    for de_name in field.attrs.aliases() {\n                        if check_de && de_name.value == tag {\n                            diagnose_conflict();\n                            return;\n                        }\n                    }\n                }\n            }\n            Style::Unit | Style::Newtype | Style::Tuple => {}\n        }\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_remote_generic":["fn check_remote_generic(cx: &Ctxt, cont: &Container){\n    if let Some(remote) = cont.attrs.remote() {\n        let local_has_generic = !cont.generics.params.is_empty();\n        let remote_has_generic = !remote.segments.last().unwrap().arguments.is_none();\n        if local_has_generic && remote_has_generic {\n            cx.error_spanned_by(remote, \"remove generic parameters from this path\");\n        }\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_transparent":["fn check_transparent(cx: &Ctxt, cont: &mut Container, derive: Derive){\n    if !cont.attrs.transparent() {\n        return;\n    }\n\n    if cont.attrs.type_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(from = \\\"...\\\")]\",\n        );\n    }\n\n    if cont.attrs.type_try_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(try_from = \\\"...\\\")]\",\n        );\n    }\n\n    if cont.attrs.type_into().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(into = \\\"...\\\")]\",\n        );\n    }\n\n    let fields = match &mut cont.data {\n        Data::Enum(_) => {\n            cx.error_spanned_by(\n                cont.original,\n                \"#[serde(transparent)] is not allowed on an enum\",\n            );\n            return;\n        }\n        Data::Struct(Style::Unit, _) => {\n            cx.error_spanned_by(\n                cont.original,\n                \"#[serde(transparent)] is not allowed on a unit struct\",\n            );\n            return;\n        }\n        Data::Struct(_, fields) => fields,\n    };\n\n    let mut transparent_field = None;\n\n    for field in fields {\n        if allow_transparent(field, derive) {\n            if transparent_field.is_some() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires struct to have at most one transparent field\",\n                );\n                return;\n            }\n            transparent_field = Some(field);\n        }\n    }\n\n    match transparent_field {\n        Some(transparent_field) => transparent_field.attrs.mark_transparent(),\n        None => match derive {\n            Derive::Serialize => {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires at least one field that is not skipped\",\n                );\n            }\n            Derive::Deserialize => {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires at least one field that is neither skipped nor has a default\",\n                );\n            }\n        },\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::check_variant_skip_attrs":["fn check_variant_skip_attrs(cx: &Ctxt, cont: &Container){\n    let variants = match &cont.data {\n        Data::Enum(variants) => variants,\n        Data::Struct(_, _) => return,\n    };\n\n    for variant in variants {\n        if variant.attrs.serialize_with().is_some() {\n            if variant.attrs.skip_serializing() {\n                cx.error_spanned_by(\n                    variant.original,\n                    format!(\n                        \"variant `{}` cannot have both #[serde(serialize_with)] and #[serde(skip_serializing)]\",\n                        variant.ident\n                    ),\n                );\n            }\n\n            for field in &variant.fields {\n                let member = member_message(&field.member);\n\n                if field.attrs.skip_serializing() {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(serialize_with)] and a field {} marked with #[serde(skip_serializing)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n\n                if field.attrs.skip_serializing_if().is_some() {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(serialize_with)] and a field {} marked with #[serde(skip_serializing_if)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n            }\n        }\n\n        if variant.attrs.deserialize_with().is_some() {\n            if variant.attrs.skip_deserializing() {\n                cx.error_spanned_by(\n                    variant.original,\n                    format!(\n                        \"variant `{}` cannot have both #[serde(deserialize_with)] and #[serde(skip_deserializing)]\",\n                        variant.ident\n                    ),\n                );\n            }\n\n            for field in &variant.fields {\n                if field.attrs.skip_deserializing() {\n                    let member = member_message(&field.member);\n\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(deserialize_with)] and a field {} marked with #[serde(skip_deserializing)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n            }\n        }\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::check::member_message":["fn member_message(member: &Member) -> String{\n    match member {\n        Member::Named(ident) => format!(\"`{}`\", ident),\n        Member::Unnamed(i) => format!(\"#{}\", i.index),\n    }\n}","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))"],"internals::ctxt::Ctxt":["/// A type to collect errors together and format them.\n///\n/// Dropping this object will cause a panic. It must be consumed using `check`.\n///\n/// References can be shared since this type uses run-time exclusive mut checking.\npub struct Ctxt {\n    // The contents will be set to `None` during checking. This is so that checking can be\n    // enforced.\n    errors: RefCell<Option<Vec<syn::Error>>>,\n}","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))"],"internals::ctxt::Ctxt::check":["/// Consume this object, producing a formatted error string if there are errors.\npub fn check(self) -> syn::Result<()>{\n        let mut errors = self.errors.borrow_mut().take().unwrap().into_iter();\n\n        let mut combined = match errors.next() {\n            Some(first) => first,\n            None => return Ok(()),\n        };\n\n        for rest in errors {\n            combined.combine(rest);\n        }\n\n        Err(combined)\n    }","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))"],"internals::ctxt::Ctxt::error_spanned_by":["/// Add an error to the context object with a tokenenizable object.\n///\n/// The object is used for spanning in error messages.\npub fn error_spanned_by<A: ToTokens, T: Display>(&self, obj: A, msg: T){\n        self.errors\n            .borrow_mut()\n            .as_mut()\n            .unwrap()\n            // Curb monomorphization from generating too many identical methods.\n            .push(syn::Error::new_spanned(obj.into_token_stream(), msg));\n    }","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))"],"internals::ctxt::Ctxt::new":["/// Create a new context object.\n///\n/// This object contains no errors, but will still trigger a panic if it is not `check`ed.\npub fn new() -> Self{\n        Ctxt {\n            errors: RefCell::new(Some(Vec::new())),\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))"],"internals::ctxt::Ctxt::syn_error":["/// Add one of Syn's parse errors.\npub fn syn_error(&self, err: syn::Error){\n        self.errors.borrow_mut().as_mut().unwrap().push(err);\n    }","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))"],"internals::name::MultiName":["pub struct MultiName {\n    pub(crate) serialize: Name,\n    pub(crate) serialize_renamed: bool,\n    pub(crate) deserialize: Name,\n    pub(crate) deserialize_renamed: bool,\n    pub(crate) deserialize_aliases: BTreeSet<Name>,\n}","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"internals::name::MultiName::deserialize_aliases":["pub(crate) fn deserialize_aliases(&self) -> &BTreeSet<Name>{\n        &self.deserialize_aliases\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"internals::name::MultiName::deserialize_name":["/// Return the container name for the container when deserializing.\npub fn deserialize_name(&self) -> &Name{\n        &self.deserialize\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"internals::name::MultiName::from_attrs":["pub(crate) fn from_attrs(\n        source_name: Name,\n        ser_name: Attr<Name>,\n        de_name: Attr<Name>,\n        de_aliases: Option<VecAttr<Name>>,\n    ) -> Self{\n        let mut alias_set = BTreeSet::new();\n        if let Some(de_aliases) = de_aliases {\n            for alias_name in de_aliases.get() {\n                alias_set.insert(alias_name);\n            }\n        }\n\n        let ser_name = ser_name.get();\n        let ser_renamed = ser_name.is_some();\n        let de_name = de_name.get();\n        let de_renamed = de_name.is_some();\n        MultiName {\n            serialize: ser_name.unwrap_or_else(|| source_name.clone()),\n            serialize_renamed: ser_renamed,\n            deserialize: de_name.unwrap_or(source_name),\n            deserialize_renamed: de_renamed,\n            deserialize_aliases: alias_set,\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"internals::name::MultiName::serialize_name":["/// Return the container name for the container when serializing.\npub fn serialize_name(&self) -> &Name{\n        &self.serialize\n    }","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"internals::name::Name":["pub struct Name {\n    pub value: String,\n    pub span: Span,\n}","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))"],"internals::receiver::ReplaceReceiver":["struct ReplaceReceiver<'a>(&'a TypePath);","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::self_to_expr_path":["fn self_to_expr_path(&self, path: &mut Path){\n        let self_ty = self.self_ty(path.segments[0].ident.span());\n        let variant = mem::replace(path, self_ty.path);\n        for segment in &mut path.segments {\n            if let PathArguments::AngleBracketed(bracketed) = &mut segment.arguments {\n                if bracketed.colon2_token.is_none() && !bracketed.args.is_empty() {\n                    bracketed.colon2_token = Some(<Token![::]>::default());\n                }\n            }\n        }\n        if variant.segments.len() > 1 {\n            path.segments.push_punct(<Token![::]>::default());\n            path.segments.extend(variant.segments.into_pairs().skip(1));\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::self_to_qself":["fn self_to_qself(&self, qself: &mut Option<QSelf>, path: &mut Path){\n        if path.leading_colon.is_some() || path.segments[0].ident != \"Self\" {\n            return;\n        }\n\n        if path.segments.len() == 1 {\n            self.self_to_expr_path(path);\n            return;\n        }\n\n        let span = path.segments[0].ident.span();\n        *qself = Some(QSelf {\n            lt_token: Token![<](span),\n            ty: Box::new(Type::Path(self.self_ty(span))),\n            position: 0,\n            as_token: None,\n            gt_token: Token![>](span),\n        });\n\n        path.leading_colon = Some(**path.segments.pairs().next().unwrap().punct().unwrap());\n\n        let segments = mem::take(&mut path.segments);\n        path.segments = segments.into_pairs().skip(1).collect();\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::self_ty":["fn self_ty(&self, span: Span) -> TypePath{\n        let tokens = self.0.to_token_stream();\n        let respanned = respan(tokens, span);\n        syn::parse2(respanned).unwrap()\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_data_mut":["fn visit_data_mut(&mut self, data: &mut Data){\n        match data {\n            Data::Struct(data) => {\n                for field in &mut data.fields {\n                    self.visit_type_mut(&mut field.ty);\n                }\n            }\n            Data::Enum(data) => {\n                for variant in &mut data.variants {\n                    for field in &mut variant.fields {\n                        self.visit_type_mut(&mut field.ty);\n                    }\n                }\n            }\n            Data::Union(_) => {}\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_expr_mut":["fn visit_expr_mut(&mut self, expr: &mut Expr){\n        match expr {\n            Expr::Binary(expr) => {\n                self.visit_expr_mut(&mut expr.left);\n                self.visit_expr_mut(&mut expr.right);\n            }\n            Expr::Call(expr) => {\n                self.visit_expr_mut(&mut expr.func);\n                for arg in &mut expr.args {\n                    self.visit_expr_mut(arg);\n                }\n            }\n            Expr::Cast(expr) => {\n                self.visit_expr_mut(&mut expr.expr);\n                self.visit_type_mut(&mut expr.ty);\n            }\n            Expr::Field(expr) => self.visit_expr_mut(&mut expr.base),\n            Expr::Index(expr) => {\n                self.visit_expr_mut(&mut expr.expr);\n                self.visit_expr_mut(&mut expr.index);\n            }\n            Expr::Paren(expr) => self.visit_expr_mut(&mut expr.expr),\n            Expr::Path(expr) => self.visit_expr_path_mut(expr),\n            Expr::Unary(expr) => self.visit_expr_mut(&mut expr.expr),\n            _ => {}\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_expr_path_mut":["fn visit_expr_path_mut(&mut self, expr: &mut ExprPath){\n        if expr.qself.is_none() {\n            self.self_to_qself(&mut expr.qself, &mut expr.path);\n        }\n        self.visit_expr_path_mut_impl(expr);\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_expr_path_mut_impl":["fn visit_expr_path_mut_impl(&mut self, expr: &mut ExprPath){\n        if let Some(qself) = &mut expr.qself {\n            self.visit_type_mut(&mut qself.ty);\n        }\n        self.visit_path_mut(&mut expr.path);\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_generics_mut":["fn visit_generics_mut(&mut self, generics: &mut Generics){\n        for param in &mut generics.params {\n            match param {\n                GenericParam::Type(param) => {\n                    for bound in &mut param.bounds {\n                        self.visit_type_param_bound_mut(bound);\n                    }\n                }\n                GenericParam::Lifetime(_) | GenericParam::Const(_) => {}\n            }\n        }\n        if let Some(where_clause) = &mut generics.where_clause {\n            for predicate in &mut where_clause.predicates {\n                match predicate {\n                    #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]\n                    WherePredicate::Type(predicate) => {\n                        self.visit_type_mut(&mut predicate.bounded_ty);\n                        for bound in &mut predicate.bounds {\n                            self.visit_type_param_bound_mut(bound);\n                        }\n                    }\n                    WherePredicate::Lifetime(_) => {}\n                    _ => {}\n                }\n            }\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_macro_mut":["fn visit_macro_mut(&mut self, _mac: &mut Macro){}","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_path_arguments_mut":["fn visit_path_arguments_mut(&mut self, arguments: &mut PathArguments){\n        match arguments {\n            PathArguments::None => {}\n            PathArguments::AngleBracketed(arguments) => {\n                for arg in &mut arguments.args {\n                    match arg {\n                        #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]\n                        GenericArgument::Type(arg) => self.visit_type_mut(arg),\n                        GenericArgument::AssocType(arg) => self.visit_type_mut(&mut arg.ty),\n                        GenericArgument::Lifetime(_)\n                        | GenericArgument::Const(_)\n                        | GenericArgument::AssocConst(_)\n                        | GenericArgument::Constraint(_) => {}\n                        _ => {}\n                    }\n                }\n            }\n            PathArguments::Parenthesized(arguments) => {\n                for argument in &mut arguments.inputs {\n                    self.visit_type_mut(argument);\n                }\n                self.visit_return_type_mut(&mut arguments.output);\n            }\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_path_mut":["fn visit_path_mut(&mut self, path: &mut Path){\n        for segment in &mut path.segments {\n            self.visit_path_arguments_mut(&mut segment.arguments);\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_return_type_mut":["fn visit_return_type_mut(&mut self, return_type: &mut ReturnType){\n        match return_type {\n            ReturnType::Default => {}\n            ReturnType::Type(_, output) => self.visit_type_mut(output),\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_type_mut":["fn visit_type_mut(&mut self, ty: &mut Type){\n        let span = if let Type::Path(node) = ty {\n            if node.qself.is_none() && node.path.is_ident(\"Self\") {\n                node.path.segments[0].ident.span()\n            } else {\n                self.visit_type_path_mut(node);\n                return;\n            }\n        } else {\n            self.visit_type_mut_impl(ty);\n            return;\n        };\n        *ty = Type::Path(self.self_ty(span));\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_type_mut_impl":["fn visit_type_mut_impl(&mut self, ty: &mut Type){\n        match ty {\n            #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]\n            Type::Array(ty) => {\n                self.visit_type_mut(&mut ty.elem);\n                self.visit_expr_mut(&mut ty.len);\n            }\n            Type::BareFn(ty) => {\n                for arg in &mut ty.inputs {\n                    self.visit_type_mut(&mut arg.ty);\n                }\n                self.visit_return_type_mut(&mut ty.output);\n            }\n            Type::Group(ty) => self.visit_type_mut(&mut ty.elem),\n            Type::ImplTrait(ty) => {\n                for bound in &mut ty.bounds {\n                    self.visit_type_param_bound_mut(bound);\n                }\n            }\n            Type::Macro(ty) => self.visit_macro_mut(&mut ty.mac),\n            Type::Paren(ty) => self.visit_type_mut(&mut ty.elem),\n            Type::Path(ty) => {\n                if let Some(qself) = &mut ty.qself {\n                    self.visit_type_mut(&mut qself.ty);\n                }\n                self.visit_path_mut(&mut ty.path);\n            }\n            Type::Ptr(ty) => self.visit_type_mut(&mut ty.elem),\n            Type::Reference(ty) => self.visit_type_mut(&mut ty.elem),\n            Type::Slice(ty) => self.visit_type_mut(&mut ty.elem),\n            Type::TraitObject(ty) => {\n                for bound in &mut ty.bounds {\n                    self.visit_type_param_bound_mut(bound);\n                }\n            }\n            Type::Tuple(ty) => {\n                for elem in &mut ty.elems {\n                    self.visit_type_mut(elem);\n                }\n            }\n\n            Type::Infer(_) | Type::Never(_) | Type::Verbatim(_) => {}\n\n            _ => {}\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_type_param_bound_mut":["fn visit_type_param_bound_mut(&mut self, bound: &mut TypeParamBound){\n        match bound {\n            #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]\n            TypeParamBound::Trait(bound) => self.visit_path_mut(&mut bound.path),\n            TypeParamBound::Lifetime(_)\n            | TypeParamBound::PreciseCapture(_)\n            | TypeParamBound::Verbatim(_) => {}\n            _ => {}\n        }\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_type_path_mut":["fn visit_type_path_mut(&mut self, ty: &mut TypePath){\n        if ty.qself.is_none() {\n            self.self_to_qself(&mut ty.qself, &mut ty.path);\n        }\n        self.visit_type_path_mut_impl(ty);\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::ReplaceReceiver::<'_>::visit_type_path_mut_impl":["fn visit_type_path_mut_impl(&mut self, ty: &mut TypePath){\n        if let Some(qself) = &mut ty.qself {\n            self.visit_type_mut(&mut qself.ty);\n        }\n        self.visit_path_mut(&mut ty.path);\n    }","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::receiver::replace_receiver":["pub fn replace_receiver(input: &mut DeriveInput){\n    let self_ty = {\n        let ident = &input.ident;\n        let ty_generics = input.generics.split_for_impl().1;\n        parse_quote!(#ident #ty_generics)\n    };\n    let mut visitor = ReplaceReceiver(&self_ty);\n    visitor.visit_generics_mut(&mut input.generics);\n    visitor.visit_data_mut(&mut input.data);\n}","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))"],"internals::respan::respan":["pub(crate) fn respan(stream: TokenStream, span: Span) -> TokenStream{\n    stream\n        .into_iter()\n        .map(|token| respan_token(token, span))\n        .collect()\n}","Real(LocalPath(\"serde_derive_internals/src/respan.rs\"))"],"internals::respan::respan_token":["fn respan_token(mut token: TokenTree, span: Span) -> TokenTree{\n    if let TokenTree::Group(g) = &mut token {\n        *g = Group::new(g.delimiter(), respan(g.stream(), span));\n    }\n    token.set_span(span);\n    token\n}","Real(LocalPath(\"serde_derive_internals/src/respan.rs\"))"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for &proc_macro2::Ident>::eq":["fn eq(&self, word: &Symbol) -> bool{\n        *self == word.0\n    }","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for &syn::Path>::eq":["fn eq(&self, word: &Symbol) -> bool{\n        self.is_ident(word.0)\n    }","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for proc_macro2::Ident>::eq":["fn eq(&self, word: &Symbol) -> bool{\n        self == word.0\n    }","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for syn::Path>::eq":["fn eq(&self, word: &Symbol) -> bool{\n        self.is_ident(word.0)\n    }","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))"],"internals::symbol::Symbol":["pub struct Symbol(&'static str);","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))"],"internals::ungroup":["pub fn ungroup(mut ty: &Type) -> &Type{\n    while let Type::Group(group) = ty {\n        ty = &group.elem;\n    }\n    ty\n}","Real(LocalPath(\"serde_derive_internals/src/mod.rs\"))"]},"struct_constructor":{"&'^0.Named(DefId(0:619 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::name::'_), \"'_\") internals::name::MultiName":["name"],"&'^0.Named(DefId(0:624 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::default::'_), \"'_\") internals::attr::Default":["default"],"&'^0.Named(DefId(0:625 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::ser_bound::'_), \"'_\") [syn::WherePredicate]":["ser_bound"],"&'^0.Named(DefId(0:626 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::de_bound::'_), \"'_\") [syn::WherePredicate]":["de_bound"],"&'^0.Named(DefId(0:627 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::tag::'_), \"'_\") internals::attr::TagType":["tag"],"&'^0.Named(DefId(0:628 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::type_from::'_), \"'_\") syn::Type":["type_from"],"&'^0.Named(DefId(0:629 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::type_try_from::'_), \"'_\") syn::Type":["type_try_from"],"&'^0.Named(DefId(0:630 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::type_into::'_), \"'_\") syn::Type":["type_into"],"&'^0.Named(DefId(0:631 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::remote::'_), \"'_\") syn::Path":["remote"],"&'^0.Named(DefId(0:634 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::custom_serde_path::'_), \"'_\") syn::Path":["custom_serde_path"],"&'^0.Named(DefId(0:636 ~ serde_derive_internals[9928]::internals::attr::{impl#5}::expecting::'_), \"'_\") str":["expecting"],"&'^0.Named(DefId(0:649 ~ serde_derive_internals[9928]::internals::attr::{impl#6}::name::'_), \"'_\") internals::name::MultiName":["name"],"&'^0.Named(DefId(0:653 ~ serde_derive_internals[9928]::internals::attr::{impl#6}::ser_bound::'_), \"'_\") [syn::WherePredicate]":["ser_bound"],"&'^0.Named(DefId(0:654 ~ serde_derive_internals[9928]::internals::attr::{impl#6}::de_bound::'_), \"'_\") [syn::WherePredicate]":["de_bound"],"&'^0.Named(DefId(0:658 ~ serde_derive_internals[9928]::internals::attr::{impl#6}::serialize_with::'_), \"'_\") syn::ExprPath":["serialize_with"],"&'^0.Named(DefId(0:659 ~ serde_derive_internals[9928]::internals::attr::{impl#6}::deserialize_with::'_), \"'_\") syn::ExprPath":["deserialize_with"],"&'^0.Named(DefId(0:666 ~ serde_derive_internals[9928]::internals::attr::{impl#8}::name::'_), \"'_\") internals::name::MultiName":["name"],"&'^0.Named(DefId(0:671 ~ serde_derive_internals[9928]::internals::attr::{impl#8}::skip_serializing_if::'_), \"'_\") syn::ExprPath":["skip_serializing_if"],"&'^0.Named(DefId(0:672 ~ serde_derive_internals[9928]::internals::attr::{impl#8}::default::'_), \"'_\") internals::attr::Default":["default"],"&'^0.Named(DefId(0:673 ~ serde_derive_internals[9928]::internals::attr::{impl#8}::serialize_with::'_), \"'_\") syn::ExprPath":["serialize_with"],"&'^0.Named(DefId(0:674 ~ serde_derive_internals[9928]::internals::attr::{impl#8}::deserialize_with::'_), \"'_\") syn::ExprPath":["deserialize_with"],"&'^0.Named(DefId(0:675 ~ serde_derive_internals[9928]::internals::attr::{impl#8}::ser_bound::'_), \"'_\") [syn::WherePredicate]":["ser_bound"],"&'^0.Named(DefId(0:676 ~ serde_derive_internals[9928]::internals::attr::{impl#8}::de_bound::'_), \"'_\") [syn::WherePredicate]":["de_bound"],"&'^0.Named(DefId(0:678 ~ serde_derive_internals[9928]::internals::attr::{impl#8}::getter::'_), \"'_\") syn::ExprPath":["getter"],"&'^0.Named(DefId(0:741 ~ serde_derive_internals[9928]::internals::name::{impl#0}::serialize_name::'_), \"'_\") internals::name::Name":["serialize_name"],"&'^0.Named(DefId(0:742 ~ serde_derive_internals[9928]::internals::name::{impl#0}::deserialize_name::'_), \"'_\") internals::name::Name":["deserialize_name"],"(internals::ast::Style, std::vec::Vec<internals::ast::Field<'^0.Named(DefId(0:58 ~ serde_derive_internals[9928]::internals::ast::struct_from_ast::'a), \"'a\")>, std::alloc::Global>)":["struct_from_ast"],"(internals::attr::VecAttr<'^0.Named(DefId(0:275 ~ serde_derive_internals[9928]::internals::attr::get_ser_and_de::'c), \"'c\"), T/#0>, internals::attr::VecAttr<'^0.Named(DefId(0:275 ~ serde_derive_internals[9928]::internals::attr::get_ser_and_de::'c), \"'c\"), T/#0>)":["get_ser_and_de"],"(proc_macro2::TokenStream, T/#1)":["get_with_tokens"],"(std::option::Option<std::vec::Vec<syn::WherePredicate, std::alloc::Global>>, std::option::Option<std::vec::Vec<syn::WherePredicate, std::alloc::Global>>)":["get_where_predicates"],"(std::option::Option<syn::LitStr>, std::option::Option<syn::LitStr>)":["get_renames"],"(std::option::Option<syn::LitStr>, std::vec::Vec<syn::LitStr, std::alloc::Global>)":["get_multiple_renames"],"bool":["allow_transparent","deny_unknown_fields","eq","flatten","get","has_getter","is_cow","is_implicitly_borrowed","is_implicitly_borrowed_reference","is_none","is_option","is_packed","is_primitive_path","is_primitive_type","is_reference","is_slice_u8","is_str","non_exhaustive","other","skip_deserializing","skip_serializing","transparent","untagged"],"internals::Derive":["clone"],"internals::ast::Container":["from_ast"],"internals::ast::Style":["clone"],"internals::attr::Attr":["none"],"internals::attr::BoolAttr":["none"],"internals::attr::Container":["from_ast"],"internals::attr::Field":["from_ast"],"internals::attr::Identifier":["clone","decide_identifier","identifier"],"internals::attr::RenameAllRules":["clone","rename_all_fields_rules","rename_all_rules"],"internals::attr::TagType":["decide_tag"],"internals::attr::Variant":["from_ast"],"internals::attr::VecAttr":["none"],"internals::case::RenameRule":["clone","from_str"],"internals::ctxt::Ctxt":["default","new"],"internals::name::MultiName":["from_attrs"],"internals::name::Name":["clone","from"],"internals::symbol::Symbol":["clone"],"proc_macro2::Ident":["unraw"],"std::borrow::Cow":["serde_path"],"std::boxed::Box":["all_fields"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::collections::BTreeSet":["borrowable_lifetimes","parse_lit_into_lifetimes"],"std::string::String":["apply_to_field","apply_to_variant","member_message"],"std::vec::Vec":["enum_from_ast","fields_from_ast","get","parse_lit_into_where"],"syn::ExprPath":["parse_lit_into_expr_path"],"syn::LitStr":["get_lit_str","get_lit_str2"],"syn::Path":["parse_lit_into_path"],"syn::Type":["parse_lit_into_ty"],"syn::TypePath":["self_ty"]},"struct_to_trait":{"internals::Derive":["std::clone::Clone","std::marker::Copy"],"internals::ast::Style":["std::clone::Clone","std::marker::Copy"],"internals::attr::Identifier":["std::clone::Clone","std::marker::Copy"],"internals::attr::RenameAllRules":["std::clone::Clone","std::marker::Copy"],"internals::case::ParseError":["std::fmt::Display"],"internals::case::RenameRule":["std::clone::Clone","std::cmp::PartialEq","std::marker::Copy","std::marker::StructuralPartialEq"],"internals::ctxt::Ctxt":["std::default::Default","std::ops::Drop"],"internals::name::Name":["quote::ToTokens","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Display"],"internals::symbol::Symbol":["std::clone::Clone","std::fmt::Display","std::marker::Copy"],"proc_macro2::Ident":["std::cmp::PartialEq"],"syn::Path":["std::cmp::PartialEq"]},"targets":{"<internals::case::ParseError<'a> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))","std::fmt::Display"],"<internals::ctxt::Ctxt as std::ops::Drop>::drop":["drop","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))","std::ops::Drop"],"<internals::name::Name as quote::ToTokens>::to_tokens":["to_tokens","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))","quote::ToTokens"],"<internals::name::Name as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))","std::cmp::Ord"],"<internals::name::Name as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))","std::cmp::PartialEq"],"<internals::name::Name as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))","std::cmp::PartialOrd"],"<internals::name::Name as std::convert::From<&proc_macro2::Ident>>::from":["from","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))","std::convert::From"],"<internals::name::Name as std::convert::From<&syn::LitStr>>::from":["from","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))","std::convert::From"],"<internals::name::Name as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))","std::fmt::Display"],"<internals::symbol::Symbol as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))","std::fmt::Display"],"internals::ast::Container::<'a>::from_ast":["from_ast","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))",""],"internals::ast::Data::<'a>::all_fields":["all_fields","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))",""],"internals::ast::Data::<'a>::has_getter":["has_getter","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))",""],"internals::ast::enum_from_ast":["enum_from_ast","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))",""],"internals::ast::fields_from_ast":["fields_from_ast","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))",""],"internals::ast::struct_from_ast":["struct_from_ast","Real(LocalPath(\"serde_derive_internals/src/ast.rs\"))",""],"internals::attr::Attr::<'c, T>::get":["get","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Attr::<'c, T>::get_with_tokens":["get_with_tokens","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Attr::<'c, T>::none":["none","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Attr::<'c, T>::set":["set","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Attr::<'c, T>::set_if_none":["set_if_none","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Attr::<'c, T>::set_opt":["set_opt","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::BoolAttr::<'c>::get":["get","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::BoolAttr::<'c>::none":["none","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::BoolAttr::<'c>::set_true":["set_true","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::custom_serde_path":["custom_serde_path","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::de_bound":["de_bound","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::default":["default","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::deny_unknown_fields":["deny_unknown_fields","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::expecting":["expecting","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::from_ast":["from_ast","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::identifier":["identifier","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::is_packed":["is_packed","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::name":["name","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::non_exhaustive":["non_exhaustive","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::remote":["remote","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::rename_all_fields_rules":["rename_all_fields_rules","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::rename_all_rules":["rename_all_rules","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::ser_bound":["ser_bound","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::serde_path":["serde_path","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::tag":["tag","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::transparent":["transparent","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::type_from":["type_from","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::type_into":["type_into","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Container::type_try_from":["type_try_from","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Default::is_none":["is_none","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::aliases":["aliases","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::borrowed_lifetimes":["borrowed_lifetimes","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::de_bound":["de_bound","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::default":["default","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::deserialize_with":["deserialize_with","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::flatten":["flatten","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::from_ast":["from_ast","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::getter":["getter","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::mark_transparent":["mark_transparent","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::name":["name","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::rename_by_rules":["rename_by_rules","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::ser_bound":["ser_bound","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::serialize_with":["serialize_with","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::skip_deserializing":["skip_deserializing","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::skip_serializing":["skip_serializing","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::skip_serializing_if":["skip_serializing_if","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Field::transparent":["transparent","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::RenameAllRules::or":["or","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::aliases":["aliases","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::de_bound":["de_bound","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::deserialize_with":["deserialize_with","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::from_ast":["from_ast","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::name":["name","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::other":["other","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::rename_all_rules":["rename_all_rules","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::rename_by_rules":["rename_by_rules","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::ser_bound":["ser_bound","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::serialize_with":["serialize_with","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::skip_deserializing":["skip_deserializing","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::skip_serializing":["skip_serializing","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::Variant::untagged":["untagged","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::VecAttr::<'c, T>::at_most_one":["at_most_one","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::VecAttr::<'c, T>::get":["get","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::VecAttr::<'c, T>::insert":["insert","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::VecAttr::<'c, T>::none":["none","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::borrowable_lifetimes":["borrowable_lifetimes","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::collect_lifetimes":["collect_lifetimes","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::collect_lifetimes_from_tokens":["collect_lifetimes_from_tokens","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::decide_identifier":["decide_identifier","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::decide_tag":["decide_tag","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::get_lit_str":["get_lit_str","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::get_lit_str2":["get_lit_str2","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::get_multiple_renames":["get_multiple_renames","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::get_renames":["get_renames","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::get_ser_and_de":["get_ser_and_de","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::get_where_predicates":["get_where_predicates","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::is_cow":["is_cow","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::is_implicitly_borrowed":["is_implicitly_borrowed","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::is_implicitly_borrowed_reference":["is_implicitly_borrowed_reference","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::is_option":["is_option","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::is_primitive_path":["is_primitive_path","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::is_primitive_type":["is_primitive_type","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::is_reference":["is_reference","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::is_slice_u8":["is_slice_u8","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::is_str":["is_str","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::parse_lit_into_expr_path":["parse_lit_into_expr_path","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::parse_lit_into_lifetimes":["parse_lit_into_lifetimes","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::parse_lit_into_path":["parse_lit_into_path","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::parse_lit_into_ty":["parse_lit_into_ty","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::parse_lit_into_where":["parse_lit_into_where","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::attr::unraw":["unraw","Real(LocalPath(\"serde_derive_internals/src/attr.rs\"))",""],"internals::case::RenameRule::apply_to_field":["apply_to_field","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))",""],"internals::case::RenameRule::apply_to_variant":["apply_to_variant","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))",""],"internals::case::RenameRule::from_str":["from_str","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))",""],"internals::case::RenameRule::or":["or","Real(LocalPath(\"serde_derive_internals/src/case.rs\"))",""],"internals::check::allow_transparent":["allow_transparent","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check":["check","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_adjacent_tag_conflict":["check_adjacent_tag_conflict","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_default_on_tuple":["check_default_on_tuple","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_flatten":["check_flatten","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_flatten_field":["check_flatten_field","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_from_and_try_from":["check_from_and_try_from","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_getter":["check_getter","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_identifier":["check_identifier","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_internal_tag_field_name_conflict":["check_internal_tag_field_name_conflict","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_remote_generic":["check_remote_generic","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_transparent":["check_transparent","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::check_variant_skip_attrs":["check_variant_skip_attrs","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::check::member_message":["member_message","Real(LocalPath(\"serde_derive_internals/src/check.rs\"))",""],"internals::ctxt::Ctxt::check":["check","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))",""],"internals::ctxt::Ctxt::error_spanned_by":["error_spanned_by","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))",""],"internals::ctxt::Ctxt::new":["new","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))",""],"internals::ctxt::Ctxt::syn_error":["syn_error","Real(LocalPath(\"serde_derive_internals/src/ctxt.rs\"))",""],"internals::name::MultiName::deserialize_aliases":["deserialize_aliases","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))",""],"internals::name::MultiName::deserialize_name":["deserialize_name","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))",""],"internals::name::MultiName::from_attrs":["from_attrs","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))",""],"internals::name::MultiName::serialize_name":["serialize_name","Real(LocalPath(\"serde_derive_internals/src/name.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::self_to_expr_path":["self_to_expr_path","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::self_to_qself":["self_to_qself","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::self_ty":["self_ty","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_data_mut":["visit_data_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_expr_mut":["visit_expr_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_expr_path_mut":["visit_expr_path_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_expr_path_mut_impl":["visit_expr_path_mut_impl","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_generics_mut":["visit_generics_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_macro_mut":["visit_macro_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_path_arguments_mut":["visit_path_arguments_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_path_mut":["visit_path_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_return_type_mut":["visit_return_type_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_type_mut":["visit_type_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_type_mut_impl":["visit_type_mut_impl","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_type_param_bound_mut":["visit_type_param_bound_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_type_path_mut":["visit_type_path_mut","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::ReplaceReceiver::<'_>::visit_type_path_mut_impl":["visit_type_path_mut_impl","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::receiver::replace_receiver":["replace_receiver","Real(LocalPath(\"serde_derive_internals/src/receiver.rs\"))",""],"internals::respan::respan":["respan","Real(LocalPath(\"serde_derive_internals/src/respan.rs\"))",""],"internals::respan::respan_token":["respan_token","Real(LocalPath(\"serde_derive_internals/src/respan.rs\"))",""],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for &proc_macro2::Ident>::eq":["eq","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))","std::cmp::PartialEq"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for &syn::Path>::eq":["eq","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))","std::cmp::PartialEq"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for proc_macro2::Ident>::eq":["eq","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))","std::cmp::PartialEq"],"internals::symbol::<impl std::cmp::PartialEq<internals::symbol::Symbol> for syn::Path>::eq":["eq","Real(LocalPath(\"serde_derive_internals/src/symbol.rs\"))","std::cmp::PartialEq"],"internals::ungroup":["ungroup","Real(LocalPath(\"serde_derive_internals/src/mod.rs\"))",""]},"trait_to_struct":{"quote::ToTokens":["internals::name::Name"],"std::clone::Clone":["internals::Derive","internals::ast::Style","internals::attr::Identifier","internals::attr::RenameAllRules","internals::case::RenameRule","internals::name::Name","internals::symbol::Symbol"],"std::cmp::Eq":["internals::name::Name"],"std::cmp::Ord":["internals::name::Name"],"std::cmp::PartialEq":["internals::case::RenameRule","internals::name::Name","proc_macro2::Ident","syn::Path"],"std::cmp::PartialOrd":["internals::name::Name"],"std::convert::From":["internals::name::Name"],"std::default::Default":["internals::ctxt::Ctxt"],"std::fmt::Display":["internals::case::ParseError","internals::name::Name","internals::symbol::Symbol"],"std::marker::Copy":["internals::Derive","internals::ast::Style","internals::attr::Identifier","internals::attr::RenameAllRules","internals::case::RenameRule","internals::symbol::Symbol"],"std::marker::StructuralPartialEq":["internals::case::RenameRule"],"std::ops::Drop":["internals::ctxt::Ctxt"]},"type_to_def_path":{"internals::Derive":"internals::Derive","internals::ast::Container<'a>":"internals::ast::Container","internals::ast::Data<'a>":"internals::ast::Data","internals::ast::Field<'a>":"internals::ast::Field","internals::ast::Style":"internals::ast::Style","internals::ast::Variant<'a>":"internals::ast::Variant","internals::attr::Attr<'c, T>":"internals::attr::Attr","internals::attr::BoolAttr<'c>":"internals::attr::BoolAttr","internals::attr::BorrowAttribute":"internals::attr::BorrowAttribute","internals::attr::Container":"internals::attr::Container","internals::attr::Default":"internals::attr::Default","internals::attr::Field":"internals::attr::Field","internals::attr::Identifier":"internals::attr::Identifier","internals::attr::RenameAllRules":"internals::attr::RenameAllRules","internals::attr::TagType":"internals::attr::TagType","internals::attr::Variant":"internals::attr::Variant","internals::attr::VecAttr<'c, T>":"internals::attr::VecAttr","internals::case::ParseError<'a>":"internals::case::ParseError","internals::case::RenameRule":"internals::case::RenameRule","internals::ctxt::Ctxt":"internals::ctxt::Ctxt","internals::name::MultiName":"internals::name::MultiName","internals::name::Name":"internals::name::Name","internals::receiver::ReplaceReceiver<'a>":"internals::receiver::ReplaceReceiver","internals::symbol::Symbol":"internals::symbol::Symbol"}}