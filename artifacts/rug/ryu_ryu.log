ChatCompletion(id='chatcmpl-BclZNlsGDyvorOVkJYTb8vpZNWKFO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::Buffer;\n\n    #[test]\n    fn test_buffer_clone() {\n        let original = Buffer::new();\n        let cloned = original.clone();\n        \n        // Since Buffer is Copy, we can assert they are the same\n        assert_eq!(std::ptr::addr_of!(original), std::ptr::addr_of!(cloned));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579021, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=85, prompt_tokens=932, total_tokens=1017, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZRZuBnaOIe9zNxCBj700Z3u9pW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::Buffer;\n\n    #[test]\n    fn test_buffer_default() {\n        let buffer = Buffer::default();\n        let expected_buffer = Buffer::new();\n        // Since Buffer is Copy, we can compare instances directly\n        assert_eq!(buffer.bytes, expected_buffer.bytes);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579025, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=72, prompt_tokens=919, total_tokens=991, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZVScGDWcNKxYWqlVEDyD0AW33a', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::buffer::Sealed;\n\n    #[test]\n    fn test_format_nonfinite_nan() {\n        let value: f32 = f32::NAN;\n        assert_eq!(value.format_nonfinite(), std::f32::NAN);\n    }\n\n    #[test]\n    fn test_format_nonfinite_neg_infinity() {\n        let value: f32 = f32::NEG_INFINITY;\n        assert_eq!(value.format_nonfinite(), std::f32::NEG_INFINITY);\n    }\n\n    #[test]\n    fn test_format_nonfinite_infinity() {\n        let value: f32 = f32::INFINITY;\n        assert_eq!(value.format_nonfinite(), std::f32::INFINITY);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579029, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=163, prompt_tokens=235, total_tokens=398, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZbNer4WgeHx1jwyuXPzqWv1IVT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use ryu::buffer::Sealed;\n\n    #[test]\n    fn test_is_nonfinite() {\n        assert!(!f32::from_bits(0x3f800000).is_nonfinite()); // 1.0\n        assert!(!f32::from_bits(0x7f800000).is_nonfinite()); // Infinity\n        assert!(f32::from_bits(0x7fc00000).is_nonfinite()); // NaN\n        assert!(f32::from_bits(0x80000000).is_nonfinite()); // -0.0\n        assert!(!f32::from_bits(0x00000000).is_nonfinite()); // 0.0\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579035, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=166, prompt_tokens=183, total_tokens=349, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZfKcKE8yn8mk5zLsiB0GWZ2Ydk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use ryu::buffer::Sealed;\n\n    #[test]\n    fn test_write_to_ryu_buffer() {\n        let mut buffer = [0u8; 32];\n        let f: f32 = 1.0;\n\n        let length = unsafe { f.write_to_ryu_buffer(buffer.as_mut_ptr()) };\n\n        assert!(length > 0);\n        assert_eq!(buffer[..length as usize].to_vec(), b"1.0".to_vec()); // Adjust the expected output as necessary\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579039, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=125, prompt_tokens=176, total_tokens=301, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZk0QVfDCKbzIfzA60Li37RLhjb', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::buffer::Sealed; // Ensure the path is correct according to your module structure\n\n    #[test]\n    fn test_format_nonfinite_nan() {\n        let nan_value = f64::NAN;\n        let result = nan_value.format_nonfinite();\n        assert_eq!(result, "NAN");\n    }\n\n    #[test]\n    fn test_format_nonfinite_negative_infinity() {\n        let neg_infinity_value = f64::NEG_INFINITY;\n        let result = neg_infinity_value.format_nonfinite();\n        assert_eq!(result, "NEG_INFINITY");\n    }\n\n    #[test]\n    fn test_format_nonfinite_infinity() {\n        let infinity_value = f64::INFINITY;\n        let result = infinity_value.format_nonfinite();\n        assert_eq!(result, "INFINITY");\n    }\n\n    #[test]\n    fn test_format_nonfinite_finite() {\n        let finite_value = 42.0;\n        let result = finite_value.format_nonfinite();\n        assert_eq!(result, "NAN");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579044, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=228, prompt_tokens=239, total_tokens=467, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZqHinXxPhEOerxm0XPbMafG8LU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::buffer::Sealed;\n\n    #[test]\n    fn test_is_nonfinite() {\n        assert!(f64::NAN.is_nonfinite());\n        assert!(f64::INFINITY.is_nonfinite());\n        assert!(f64::NEG_INFINITY.is_nonfinite());\n        assert!(!0.0.is_nonfinite());\n        assert!(!1.0.is_nonfinite());\n        assert!(!f64::from_bits(0x7ff8000000000000).is_nonfinite()); // NaN\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579050, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=125, prompt_tokens=186, total_tokens=311, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZvea0WlY2YwXymNplzpRLJwdVo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_write_to_ryu_buffer() {\n        let num: f64 = 3.14;\n        let mut buffer: [u8; 64] = [0; 64];\n\n        let len = unsafe {\n            num.write_to_ryu_buffer(buffer.as_mut_ptr())\n        };\n\n        let result = std::str::from_utf8(&buffer[..len]).unwrap();\n        assert_eq!(result, "3.14"); // Adjust this based on the expected output from the Ryu implementation\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579055, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=134, prompt_tokens=176, total_tokens=310, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcla0mqQuTyF7MfzIt0T90NbYWeHa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use ryu::Buffer;\n    use ryu::Float;\n\n    #[test]\n    fn test_format_finite() {\n        let mut buffer = Buffer::new();\n        let printed = buffer.format(1.234);\n        assert_eq!(printed, "1.234");\n    }\n\n    #[test]\n    fn test_format_nan() {\n        let mut buffer = Buffer::new();\n        let printed = buffer.format(f64::NAN);\n        assert_eq!(printed, "NaN");\n    }\n\n    #[test]\n    fn test_format_infinity() {\n        let mut buffer = Buffer::new();\n        let printed = buffer.format(f64::INFINITY);\n        assert_eq!(printed, "inf");\n    }\n\n    #[test]\n    fn test_format_negative_infinity() {\n        let mut buffer = Buffer::new();\n        let printed = buffer.format(f64::NEG_INFINITY);\n        assert_eq!(printed, "-inf");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579060, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=208, prompt_tokens=1124, total_tokens=1332, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcla7c9erl9BiQfDx46E28wboMJ14', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::buffer::Buffer;\n    use crate::buffer::Float; // Assuming `Float` is implemented for f32 and f64 within the crate.\n\n    #[test]\n    fn test_format_finite_f32() {\n        let mut buffer = Buffer::new();\n        let printed = buffer.format_finite(1.234f32);\n        assert_eq!(printed, "1.234");\n    }\n\n    #[test]\n    fn test_format_finite_f64() {\n        let mut buffer = Buffer::new();\n        let printed = buffer.format_finite(1.23456789f64);\n        assert_eq!(printed, "1.23456789");\n    }\n\n    #[test]\n    fn test_format_finite_negative_number() {\n        let mut buffer = Buffer::new();\n        let printed = buffer.format_finite(-0.001f32);\n        assert_eq!(printed, "-0.001");\n    }\n\n    #[test]\n    fn test_format_finite_large_number() {\n        let mut buffer = Buffer::new();\n        let printed = buffer.format_finite(1234567890.123456f64);\n        assert_eq!(printed, "1234567890.123456");\n    }\n\n    #[test]\n    fn test_format_finite_small_number() {\n        let mut buffer = Buffer::new();\n        let printed = buffer.format_finite(0.000000000001f64);\n        assert_eq!(printed, "1.000000000001e-12");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579067, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=325, prompt_tokens=1215, total_tokens=1540, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaEOXmMnbo1K3AS5ThpPnyeuyxW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::Buffer;\n\n    #[test]\n    fn test_new_buffer() {\n        let buffer = Buffer::new();\n        // Check if the buffer's byte array is initialized (although it contains uninitialized bytes)\n        // We can check if the size of the array is correct\n        assert_eq!(buffer.bytes.len(), 24);\n    }\n\n    #[test]\n    fn test_clone_buffer() {\n        let buffer = Buffer::new();\n        let cloned_buffer = buffer.clone();\n        assert_eq!(buffer.bytes.len(), cloned_buffer.bytes.len());\n    }\n\n    #[test]\n    fn test_default_buffer() {\n        let default_buffer = Buffer::default();\n        assert_eq!(default_buffer.bytes.len(), 24);\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579074, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=159, prompt_tokens=953, total_tokens=1112, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaOZjz7cL6I8nAIaSIwRFsMf7W1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::ceil_log2_pow5;\n\n    #[test]\n    fn test_ceil_log2_pow5() {\n        assert_eq!(ceil_log2_pow5(0), 1);\n        assert_eq!(ceil_log2_pow5(1), 2);\n        assert_eq!(ceil_log2_pow5(2), 3);\n        assert_eq!(ceil_log2_pow5(3), 4);\n        assert_eq!(ceil_log2_pow5(4), 5);\n        assert_eq!(ceil_log2_pow5(5), 6);\n        assert_eq!(ceil_log2_pow5(-1), 1);\n        assert_eq!(ceil_log2_pow5(-2), 1);\n        assert_eq!(ceil_log2_pow5(-3), 1);\n        assert_eq!(ceil_log2_pow5(-10), 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579084, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=189, prompt_tokens=165, total_tokens=354, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaUKK47X1rejCTPtoITkF3R0KOG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::decimal_length9;\n\n    #[test]\n    fn test_decimal_length9() {\n        assert_eq!(decimal_length9(0), 1);\n        assert_eq!(decimal_length9(5), 1);\n        assert_eq!(decimal_length9(9), 1);\n        assert_eq!(decimal_length9(10), 2);\n        assert_eq!(decimal_length9(99), 2);\n        assert_eq!(decimal_length9(100), 3);\n        assert_eq!(decimal_length9(999), 3);\n        assert_eq!(decimal_length9(1000), 4);\n        assert_eq!(decimal_length9(9999), 4);\n        assert_eq!(decimal_length9(10000), 5);\n        assert_eq!(decimal_length9(99999), 5);\n        assert_eq!(decimal_length9(100000), 6);\n        assert_eq!(decimal_length9(999999), 6);\n        assert_eq!(decimal_length9(1000000), 7);\n        assert_eq!(decimal_length9(9999999), 7);\n        assert_eq!(decimal_length9(10000000), 8);\n        assert_eq!(decimal_length9(99999999), 8);\n        assert_eq!(decimal_length9(100000000), 9);\n        assert_eq!(decimal_length9(999999999), 9);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579090, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=299, prompt_tokens=308, total_tokens=607, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaaBSU0VFwOcfA8yIWs6e80EWu6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::common::log10_pow2;\n\n    #[test]\n    fn test_log10_pow2() {\n        assert_eq!(log10_pow2(0), 0);\n        assert_eq!(log10_pow2(1), 4);\n        assert_eq!(log10_pow2(2), 8);\n        assert_eq!(log10_pow2(10), 43);\n        assert_eq!(log10_pow2(1650), 7933);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_log10_pow2_below_min() {\n        log10_pow2(-1);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_log10_pow2_above_max() {\n        log10_pow2(1651);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579096, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=175, prompt_tokens=205, total_tokens=380, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclagW2AGMFNOUkOHn3yLu0B6wGPo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::log10_pow5;\n\n    #[test]\n    fn test_log10_pow5() {\n        // Test minimum boundary\n        assert_eq!(log10_pow5(0), 0);\n        \n        // Test some regular values\n        assert_eq!(log10_pow5(1), 0);\n        assert_eq!(log10_pow5(2), 0);\n        assert_eq!(log10_pow5(3), 1);\n        assert_eq!(log10_pow5(100), 351);\n        assert_eq!(log10_pow5(200), 702);\n        assert_eq!(log10_pow5(250), 887);\n        \n        // Test maximum boundary\n        assert_eq!(log10_pow5(2620), 73292);\n\n        // Test values outside the valid range (should panic)\n        let result = std::panic::catch_unwind(|| log10_pow5(-1));\n        assert!(result.is_err());\n\n        let result = std::panic::catch_unwind(|| log10_pow5(2621));\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579102, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=236, prompt_tokens=206, total_tokens=442, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaoC6qn68s5ZD13juUYhaCBQkIC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::log2_pow5;\n\n    #[test]\n    fn test_log2_pow5() {\n        assert_eq!(log2_pow5(0), 0);\n        assert_eq!(log2_pow5(1), 5);\n        assert_eq!(log2_pow5(2), 10);\n        assert_eq!(log2_pow5(3), 15);\n        assert_eq!(log2_pow5(10), 50);\n        assert_eq!(log2_pow5(100), 503);\n        assert_eq!(log2_pow5(3528), 13898); // maximum valid input\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_log2_pow5_negative_input() {\n        log2_pow5(-1);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_log2_pow5_overflow_input() {\n        log2_pow5(3529);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579110, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=205, prompt_tokens=247, total_tokens=452, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclavBe20gIV0lb5NwfIYrMKzyo4u', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::pow5bits;\n\n    #[test]\n    fn test_pow5bits() {\n        assert_eq!(pow5bits(0), 1);\n        assert_eq!(pow5bits(1), 6);\n        assert_eq!(pow5bits(2), 31);\n        assert_eq!(pow5bits(3), 156);\n        assert_eq!(pow5bits(10), 941);\n        assert_eq!(pow5bits(3528), 1048576);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_pow5bits_negative() {\n        pow5bits(-1);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_pow5bits_too_large() {\n        pow5bits(3529);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579117, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=174, prompt_tokens=243, total_tokens=417, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclb0OGlHreSPCb0X6AmZXJ7Tz4jk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::d2s::{d2d, FloatingDecimal64};\n\n    #[test]\n    fn test_d2d_case1() {\n        let ieee_mantissa = 0x1p52 as u64; // 2^52\n        let ieee_exponent = 1023; // Biased exponent for 1.0\n        let result = d2d(ieee_mantissa, ieee_exponent);\n        assert_eq!(result.mantissa, 1000000000000000000); // 1.0 in decimal\n        assert_eq!(result.exponent, 0);\n    }\n\n    #[test]\n    fn test_d2d_case2() {\n        let ieee_mantissa = 0x3ff0000000000000; // 1.5 in IEEE 754\n        let ieee_exponent = 1023; // Biased exponent for 1.0\n        let result = d2d(ieee_mantissa, ieee_exponent);\n        assert_eq!(result.mantissa, 15); // 1.5 in decimal\n        assert_eq!(result.exponent, 0);\n    }\n\n    #[test]\n    fn test_d2d_case3() {\n        let ieee_mantissa = 0x4000000000000000; // 2.0 in IEEE 754\n        let ieee_exponent = 1023; // Biased exponent for 1.0\n        let result = d2d(ieee_mantissa, ieee_exponent);\n        assert_eq!(result.mantissa, 20); // 2.0 in decimal\n        assert_eq!(result.exponent, 0);\n    }\n\n    #[test]\n    fn test_d2d_case4() {\n        let ieee_mantissa = 0x4080000000000000; // 4.0 in IEEE 754\n        let ieee_exponent = 1024; // Biased exponent for 2.0\n        let result = d2d(ieee_mantissa, ieee_exponent);\n        assert_eq!(result.mantissa, 40); // 4.0 in decimal\n        assert_eq!(result.exponent, 0);\n    }\n\n    #[test]\n    fn test_d2d_case5() {\n        let ieee_mantissa = 0x8000000000000000; // 0.5 in IEEE 754\n        let ieee_exponent = 1022; // Biased exponent for 0.25\n        let result = d2d(ieee_mantissa, ieee_exponent);\n        assert_eq!(result.mantissa, 5); // 0.5 in decimal\n        assert_eq!(result.exponent, -1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579122, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=595, prompt_tokens=2671, total_tokens=3266, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbBgtFtHQbWzhBNSq9OULzgfEgj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::d2s::decimal_length17;\n\n    #[test]\n    fn test_decimal_length17() {\n        assert_eq!(decimal_length17(1), 1);\n        assert_eq!(decimal_length17(9), 1);\n        assert_eq!(decimal_length17(10), 2);\n        assert_eq!(decimal_length17(99), 2);\n        assert_eq!(decimal_length17(100), 3);\n        assert_eq!(decimal_length17(999), 3);\n        assert_eq!(decimal_length17(1000), 4);\n        assert_eq!(decimal_length17(9999), 4);\n        assert_eq!(decimal_length17(10000), 5);\n        assert_eq!(decimal_length17(99999), 5);\n        assert_eq!(decimal_length17(100000), 6);\n        assert_eq!(decimal_length17(999999), 6);\n        assert_eq!(decimal_length17(1000000), 7);\n        assert_eq!(decimal_length17(9999999), 7);\n        assert_eq!(decimal_length17(10000000), 8);\n        assert_eq!(decimal_length17(99999999), 8);\n        assert_eq!(decimal_length17(100000000), 9);\n        assert_eq!(decimal_length17(999999999), 9);\n        assert_eq!(decimal_length17(1000000000), 10);\n        assert_eq!(decimal_length17(9999999999), 10);\n        assert_eq!(decimal_length17(10000000000), 11);\n        assert_eq!(decimal_length17(99999999999), 11);\n        assert_eq!(decimal_length17(100000000000), 12);\n        assert_eq!(decimal_length17(999999999999), 12);\n        assert_eq!(decimal_length17(1000000000000), 13);\n        assert_eq!(decimal_length17(9999999999999), 13);\n        assert_eq!(decimal_length17(10000000000000), 14);\n        assert_eq!(decimal_length17(99999999999999), 14);\n        assert_eq!(decimal_length17(100000000000000), 15);\n        assert_eq!(decimal_length17(999999999999999), 15);\n        assert_eq!(decimal_length17(1000000000000000), 16);\n        assert_eq!(decimal_length17(9999999999999999), 16);\n        assert_eq!(decimal_length17(10000000000000000), 17);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579133, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=542, prompt_tokens=481, total_tokens=1023, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbN3RRD4UDcF4qZaSJQZWLdHXgk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::d2s_intrinsics::div10;\n\n    #[test]\n    fn test_div10() {\n        assert_eq!(div10(10), 1);\n        assert_eq!(div10(25), 2);\n        assert_eq!(div10(100), 10);\n        assert_eq!(div10(1), 0);\n        assert_eq!(div10(0), 0);\n        assert_eq!(div10(99), 9);\n        assert_eq!(div10(1000), 100);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579145, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=123, prompt_tokens=154, total_tokens=277, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbRNKkgZOnqPVVZNJVDvHduWf6k', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::d2s_intrinsics::div100;\n\n    #[test]\n    fn test_div100() {\n        assert_eq!(div100(100), 1);\n        assert_eq!(div100(250), 2);\n        assert_eq!(div100(99), 0);\n        assert_eq!(div100(0), 0);\n        assert_eq!(div100(500), 5);\n        assert_eq!(div100(10000), 100);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579149, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=111, prompt_tokens=154, total_tokens=265, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbVNj2gZ527ROhodI7sD2petUZi', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::d2s_intrinsics::div5;\n\n    #[test]\n    fn test_div5() {\n        assert_eq!(div5(0), 0);\n        assert_eq!(div5(5), 1);\n        assert_eq!(div5(10), 2);\n        assert_eq!(div5(20), 4);\n        assert_eq!(div5(25), 5);\n        assert_eq!(div5(100), 20);\n        assert_eq!(div5(1_000_000), 200_000);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579153, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=128, prompt_tokens=154, total_tokens=282, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclba0d7fbMEOzUPcydK16w6ETN27', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::d2s_intrinsics::mul_shift_64;\n\n    #[test]\n    fn test_mul_shift_64() {\n        // Test case 1\n        let m1: u64 = 2;\n        let mul1 = (3, 1);\n        let j1: u32 = 64;\n        assert_eq!(mul_shift_64(m1, &mul1, j1), 6);\n\n        // Test case 2\n        let m2: u64 = 1;\n        let mul2 = (4, 2);\n        let j2: u32 = 64;\n        assert_eq!(mul_shift_64(m2, &mul2, j2), 4);\n\n        // Test case 3\n        let m3: u64 = 5;\n        let mul3 = (2, 3);\n        let j3: u32 = 64;\n        assert_eq!(mul_shift_64(m3, &mul3, j3), 10);\n\n        // Test case 4\n        let m4: u64 = 10;\n        let mul4 = (1, 1);\n        let j4: u32 = 65;\n        assert_eq!(mul_shift_64(m4, &mul4, j4), 5);\n\n        // Test case 5\n        let m5: u64 = 0;\n        let mul5 = (10, 5);\n        let j5: u32 = 64;\n        assert_eq!(mul_shift_64(m5, &mul5, j5), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579158, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=347, prompt_tokens=225, total_tokens=572, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbmqPfEKhClfLbnivBLT99SQqiB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_mul_shift_all_64() {\n        unsafe {\n            let mul: (u64, u64) = (3, 5);\n            let m: u64 = 2;\n            let j: u32 = 1;\n            let mut vp: u64 = 0;\n            let mut vm: u64 = 0;\n            let mm_shift: u32 = 2;\n\n            let result = mul_shift_all_64(m, &mul, j, &mut vp as *mut u64, &mut vm as *mut u64, mm_shift);\n\n            assert_eq!(vp, 4 * m + 2);\n            assert_eq!(vm, 4 * m - 1 - mm_shift as u64);\n            assert_eq!(result, 4 * m);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579170, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=196, prompt_tokens=265, total_tokens=461, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbruDgBsfmn940COSxTQvlDdUK1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::multiple_of_power_of_2;\n\n    #[test]\n    fn test_multiple_of_power_of_2() {\n        assert!(multiple_of_power_of_2(8, 3));  // 8 is 2^3\n        assert!(multiple_of_power_of_2(16, 4)); // 16 is 2^4\n        assert!(multiple_of_power_of_2(0b11100, 2)); // 28 is divisible by 4\n        assert!(!multiple_of_power_of_2(5, 2)); // 5 is not divisible by 4\n        assert!(!multiple_of_power_of_2(0, 3)); // Invalid case, should panic on debug assert\n    }\n\n    #[test]\n    fn test_multiple_of_power_of_2_edge_cases() {\n        assert!(multiple_of_power_of_2(1024, 10)); // 1024 is 2^10\n        assert!(multiple_of_power_of_2(0b1111111111111111111111111111111111111111111111111111111111111111, 0)); // All bits but the last\n        assert!(multiple_of_power_of_2(2, 1)); // 2 is multiple of 2\n        assert!(multiple_of_power_of_2(4, 2)); // 4 is multiple of 4\n        assert!(multiple_of_power_of_2(64, 6)); // 64 is multiple of 64\n        assert!(!multiple_of_power_of_2(3, 1)); // 3 is not multiple of 2\n        assert!(!multiple_of_power_of_2(62, 5)); // 62 is not multiple of 32\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579175, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=382, prompt_tokens=215, total_tokens=597, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclc5fxheQBOgRAU2rw7RlG9d22Xn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::d2s_intrinsics::multiple_of_power_of_5;\n\n    #[test]\n    fn test_multiple_of_power_of_5() {\n        assert!(multiple_of_power_of_5(25, 2)); // 25 = 5^2\n        assert!(multiple_of_power_of_5(125, 3)); // 125 = 5^3\n        assert!(multiple_of_power_of_5(5, 1)); // 5 = 5^1\n        assert!(!multiple_of_power_of_5(6, 1)); // 6 is not a multiple of 5\n        assert!(multiple_of_power_of_5(0, 0)); // 0 is a multiple of any power\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579189, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=174, prompt_tokens=190, total_tokens=364, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcByJdiGPjj6h0Pisu9I1uZ80oD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::pow5_factor;\n\n    #[test]\n    fn test_pow5_factor() {\n        assert_eq!(pow5_factor(0b1111111111111111111111111111111111111111111111111111111111111111), 0);\n        assert_eq!(pow5_factor(1), 0);\n        assert_eq!(pow5_factor(5), 1);\n        assert_eq!(pow5_factor(25), 2);\n        assert_eq!(pow5_factor(125), 3);\n        assert_eq!(pow5_factor(625), 4);\n        assert_eq!(pow5_factor(3125), 5);\n        assert_eq!(pow5_factor(15625), 6);\n        assert_eq!(pow5_factor(78125), 7);\n        assert_eq!(pow5_factor(390625), 8);\n        assert_eq!(pow5_factor(1953125), 9);\n        assert_eq!(pow5_factor(9765625), 10);\n        assert_eq!(pow5_factor(48828125), 11);\n        assert_eq!(pow5_factor(244140625), 12);\n        assert_eq!(pow5_factor(1220703125), 13);\n        assert_eq!(pow5_factor(6103515625), 14);\n        assert_eq!(pow5_factor(30517578125), 15);\n        assert_eq!(pow5_factor(152587890625), 16);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579195, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=315, prompt_tokens=295, total_tokens=610, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcIX9ibjH3oe9qYJqxFtZ5szw4b', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::f2s::FloatingDecimal32;\n\n    #[test]\n    fn test_f2d_zero() {\n        let result = f2d(0, 0);\n        assert_eq!(result.mantissa, 0);\n        assert_eq!(result.exponent, -45);\n    }\n\n    #[test]\n    fn test_f2d_normal() {\n        let result = f2d(0b11000000000000000000000000000000, 0b10000101);\n        assert_eq!(result.mantissa, 0x3F800000); // Expected mantissa for 1.0\n        assert_eq!(result.exponent, 0); // Expected exponent for 1.0\n    }\n\n    #[test]\n    fn test_f2d_subnormal() {\n        let result = f2d(0b00000000000000000000000000000001, 0);\n        assert_eq!(result.mantissa, 1); // Expected mantissa for the smallest subnormal\n        assert_eq!(result.exponent, -45); // Expected exponent for subnormal\n    }\n\n    #[test]\n    fn test_f2d_large() {\n        let result = f2d(0b01111111100000000000000000000000, 0b11111111); \n        assert_eq!(result.mantissa, 0x7F800000); // Expected mantissa for infinity\n        assert_eq!(result.exponent, 0); // Expected exponent for infinity\n    }\n    \n    #[test]\n    fn test_f2d_denormalized() {\n        let result = f2d(0b00000000010000000000000000000001, 0);\n        assert_eq!(result.mantissa, 1); // Expected mantissa for smallest positive denormalized number\n        assert_eq!(result.exponent, -45); // Expected exponent for denormalized\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579202, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=423, prompt_tokens=1927, total_tokens=2350, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcUWOkh1enczo6ykI11uDiBhkZu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::f2s_intrinsics::mul_pow5_div_pow2;\n\n    #[test]\n    fn test_mul_pow5_div_pow2_small() {\n        #[cfg(feature = "small")]\n        {\n            let m = 10;\n            let i = 2;\n            let j = 1;\n            let result = mul_pow5_div_pow2(m, i, j);\n            // Add expected value based on the small feature logic\n        }\n    }\n\n    #[test]\n    fn test_mul_pow5_div_pow2_not_small() {\n        #[cfg(not(feature = "small"))]\n        {\n            let m = 10;\n            let i = 1;\n            let j = 1;\n            let result = mul_pow5_div_pow2(m, i, j);\n            // Add expected value based on the not small feature logic\n        }\n    }\n\n    #[test]\n    fn test_mul_pow5_div_pow2_boundary() {\n        let m = 10;\n        let i = 0; // boundary case\n        let j = 0; // boundary case\n        let result = mul_pow5_div_pow2(m, i, j);\n        // Add expected value based on the boundary logic\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579214, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=269, prompt_tokens=280, total_tokens=549, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcawtTloIZwfQy0AQfCQM8MvJJF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::f2s_intrinsics::mul_pow5_inv_div_pow2;\n\n    #[test]\n    fn test_mul_pow5_inv_div_pow2_small() {\n        #[cfg(feature = "small")]\n        {\n            let result = mul_pow5_inv_div_pow2(10, 2, 3);\n            assert_eq!(result, expected_value_for_small_feature); // Replace with expected value\n        }\n    }\n\n    #[test]\n    fn test_mul_pow5_inv_div_pow2_large() {\n        #[cfg(not(feature = "small"))]\n        {\n            let result = mul_pow5_inv_div_pow2(10, 2, 3);\n            assert_eq!(result, expected_value_for_large_feature); // Replace with expected value\n        }\n    }\n\n    // Additional tests can be added here for edge cases\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579220, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=186, prompt_tokens=396, total_tokens=582, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcfqgZIqXOVElgX0qHCe4sgOpql', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_mul_shift_32() {\n        assert_eq!(mul_shift_32(1, 1, 33), 1);\n        assert_eq!(mul_shift_32(1, 2, 33), 2);\n        assert_eq!(mul_shift_32(2, 2, 33), 4);\n        assert_eq!(mul_shift_32(0, 1, 33), 0);\n        assert_eq!(mul_shift_32(u32::max_value(), 1, 33), u32::max_value());\n        assert_eq!(mul_shift_32(1, 0x100000000, 65), 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579225, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=161, prompt_tokens=304, total_tokens=465, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcmvtPcGGbDNYwXiZiPtgFKmBPo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::f2s_intrinsics::multiple_of_power_of_2_32;\n\n    #[test]\n    fn test_multiple_of_power_of_2_32() {\n        assert!(multiple_of_power_of_2_32(0b0000_0000_0000_0000_0000_0000_0000_0000, 1));\n        assert!(multiple_of_power_of_2_32(0b0000_0000_0000_0000_0000_0000_0000_1111, 4));\n        assert!(multiple_of_power_of_2_32(0b0000_0000_0000_0000_0000_0000_1111_1111, 8));\n        assert!(!multiple_of_power_of_2_32(0b0000_0000_0000_0000_0000_0001_1111_1111, 7));\n        assert!(multiple_of_power_of_2_32(0b1111_1111_1111_1111_1111_1111_1111_1111, 32));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579232, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=256, prompt_tokens=202, total_tokens=458, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclcs13vDEmYtmcIgaTUO4pvgMoL8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::f2s_intrinsics::multiple_of_power_of_5_32;\n\n    #[test]\n    fn test_multiple_of_power_of_5_32() {\n        assert!(multiple_of_power_of_5_32(25, 2)); // 25 = 5^2, should return true\n        assert!(multiple_of_power_of_5_32(125, 3)); // 125 = 5^3, should return true\n        assert!(multiple_of_power_of_5_32(5, 1)); // 5 = 5^1, should return true\n        assert!(multiple_of_power_of_5_32(1, 0)); // 1 = 5^0, should return true\n        assert!(!multiple_of_power_of_5_32(10, 2)); // 10 = 5^1 * 2^1, should return false\n        assert!(!multiple_of_power_of_5_32(3, 1)); // 3 = not a multiple of 5, should return false\n        assert!(multiple_of_power_of_5_32(0, 0)); // 0 should return true for any p\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579238, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=270, prompt_tokens=181, total_tokens=451, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcyJTpzzRZbsOjFX8OllD2GnpwC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::f2s_intrinsics::pow5factor_32;\n\n    #[test]\n    fn test_pow5factor_32() {\n        assert_eq!(pow5factor_32(0), 0); // This should panic due to debug_assert\n        assert_eq!(pow5factor_32(5), 1);\n        assert_eq!(pow5factor_32(25), 2);\n        assert_eq!(pow5factor_32(125), 3);\n        assert_eq!(pow5factor_32(625), 4);\n        assert_eq!(pow5factor_32(2), 0);\n        assert_eq!(pow5factor_32(100), 2);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_pow5factor_32_zero() {\n        // Testing debug_assert when value is 0\n        pow5factor_32(0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579244, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=201, prompt_tokens=225, total_tokens=426, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcld4xkhZB1d7eUVWRKWxWAZDwz2d', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_write_exponent2_positive() {\n        let mut buffer = [0u8; 3]; // Enough space for digits and sign\n        let result = unsafe {\n            write_exponent2(3, buffer.as_mut_ptr())\n        };\n        assert_eq!(result, 1); // One digit\n        assert_eq!(&buffer[..result], b"3");\n    }\n\n    #[test]\n    fn test_write_exponent2_negative() {\n        let mut buffer = [0u8; 4]; // Enough space for sign and digits\n        let result = unsafe {\n            write_exponent2(-3, buffer.as_mut_ptr())\n        };\n        assert_eq!(result, 2); // One sign and one digit\n        assert_eq!(&buffer[..result], b"-3");\n    }\n\n    #[test]\n    fn test_write_exponent2_zero() {\n        let mut buffer = [0u8; 4]; // Enough space for sign and digits\n        let result = unsafe {\n            write_exponent2(0, buffer.as_mut_ptr())\n        };\n        assert_eq!(result, 1); // One digit\n        assert_eq!(&buffer[..result], b"0");\n    }\n\n    #[test]\n    fn test_write_exponent2_ten() {\n        let mut buffer = [0u8; 4]; // Enough space for sign and digits\n        let result = unsafe {\n            write_exponent2(10, buffer.as_mut_ptr())\n        };\n        assert_eq!(result, 2); // Two digits\n        assert_eq!(&buffer[..result], b"10");\n    }\n\n    #[test]\n    fn test_write_exponent2_ninety_nine() {\n        let mut buffer = [0u8; 4]; // Enough space for sign and digits\n        let result = unsafe {\n            write_exponent2(99, buffer.as_mut_ptr())\n        };\n        assert_eq!(result, 2); // Two digits\n        assert_eq!(&buffer[..result], b"99");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579250, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=450, prompt_tokens=279, total_tokens=729, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldDb3zUQRmxuBuuESp2bZ6eLyz1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_write_exponent3_positive() {\n        let mut buffer = [0u8; 4];\n        let result = unsafe { write_exponent3(123, buffer.as_mut_ptr()) };\n        assert_eq!(result, 3);\n        assert_eq!(&buffer[..3], b"123");\n    }\n\n    #[test]\n    fn test_write_exponent3_negative() {\n        let mut buffer = [0u8; 4];\n        let result = unsafe { write_exponent3(-123, buffer.as_mut_ptr()) };\n        assert_eq!(result, 4);\n        assert_eq!(&buffer[..4], b"-123");\n    }\n\n    #[test]\n    fn test_write_exponent3_single_digit() {\n        let mut buffer = [0u8; 4];\n        let result = unsafe { write_exponent3(7, buffer.as_mut_ptr()) };\n        assert_eq!(result, 1);\n        assert_eq!(&buffer[..1], b"7");\n    }\n\n    #[test]\n    fn test_write_exponent3_double_digits() {\n        let mut buffer = [0u8; 4];\n        let result = unsafe { write_exponent3(45, buffer.as_mut_ptr()) };\n        assert_eq!(result, 2);\n        assert_eq!(&buffer[..2], b"45");\n    }\n\n    #[test]\n    fn test_write_exponent3_large() {\n        let mut buffer = [0u8; 4];\n        let result = unsafe { write_exponent3(999, buffer.as_mut_ptr()) };\n        assert_eq!(result, 3);\n        assert_eq!(&buffer[..3], b"999");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579259, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=374, prompt_tokens=355, total_tokens=729, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldQSNivx0Y0735Lxl8yIxqMYJNx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::{mem::MaybeUninit, slice, str};\n\n    #[test]\n    fn test_format32_positive() {\n        let f = 1.234f32;\n        let mut buffer = [MaybeUninit::<u8>::uninit(); 16];\n        let len = unsafe { format32(f, buffer.as_mut_ptr() as *mut u8) };\n        let slice = unsafe { slice::from_raw_parts(buffer.as_ptr() as *const u8, len) };\n        let print = unsafe { str::from_utf8_unchecked(slice) };\n        assert_eq!(print, "1.234");\n    }\n\n    #[test]\n    fn test_format32_zero() {\n        let f = 0.0f32;\n        let mut buffer = [MaybeUninit::<u8>::uninit(); 16];\n        let len = unsafe { format32(f, buffer.as_mut_ptr() as *mut u8) };\n        let slice = unsafe { slice::from_raw_parts(buffer.as_ptr() as *const u8, len) };\n        let print = unsafe { str::from_utf8_unchecked(slice) };\n        assert_eq!(print, "0.0");\n    }\n\n    #[test]\n    fn test_format32_negative() {\n        let f = -1.234f32;\n        let mut buffer = [MaybeUninit::<u8>::uninit(); 16];\n        let len = unsafe { format32(f, buffer.as_mut_ptr() as *mut u8) };\n        let slice = unsafe { slice::from_raw_parts(buffer.as_ptr() as *const u8, len) };\n        let print = unsafe { str::from_utf8_unchecked(slice) };\n        assert_eq!(print, "-1.234");\n    }\n\n    #[test]\n    fn test_format32_large() {\n        let f = 12345678.9f32;\n        let mut buffer = [MaybeUninit::<u8>::uninit(); 16];\n        let len = unsafe { format32(f, buffer.as_mut_ptr() as *mut u8) };\n        let slice = unsafe { slice::from_raw_parts(buffer.as_ptr() as *const u8, len) };\n        let print = unsafe { str::from_utf8_unchecked(slice) };\n        assert_eq!(print, "12345678.9");\n    }\n\n    #[test]\n    fn test_format32_small() {\n        let f = 0.0001234f32;\n        let mut buffer = [MaybeUninit::<u8>::uninit(); 16];\n        let len = unsafe { format32(f, buffer.as_mut_ptr() as *mut u8) };\n        let slice = unsafe { slice::from_raw_parts(buffer.as_ptr() as *const u8, len) };\n        let print = unsafe { str::from_utf8_unchecked(slice) };\n        assert_eq!(print, "0.0001234");\n    }\n\n    #[test]\n    fn test_format32_edge_case() {\n        let f = 1e30f32;\n        let mut buffer = [MaybeUninit::<u8>::uninit(); 16];\n        let len = unsafe { format32(f, buffer.as_mut_ptr() as *mut u8) };\n        let slice = unsafe { slice::from_raw_parts(buffer.as_ptr() as *const u8, len) };\n        let print = unsafe { str::from_utf8_unchecked(slice) };\n        assert_eq!(print, "1e30");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579272, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=741, prompt_tokens=1215, total_tokens=1956, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldkdUY9rn2S0fAp1BtRAwgCDmaY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::{mem::MaybeUninit, slice, str};\n\n    #[test]\n    fn test_format64_positive() {\n        let f = 1.234f64;\n        unsafe {\n            let mut buffer = [MaybeUninit::<u8>::uninit(); 24];\n            let len = format64(f, buffer.as_mut_ptr() as *mut u8);\n            let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n            let print = str::from_utf8_unchecked(slice);\n            assert_eq!(print, "1.234");\n        }\n    }\n\n    #[test]\n    fn test_format64_negative() {\n        let f = -1.234f64;\n        unsafe {\n            let mut buffer = [MaybeUninit::<u8>::uninit(); 24];\n            let len = format64(f, buffer.as_mut_ptr() as *mut u8);\n            let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n            let print = str::from_utf8_unchecked(slice);\n            assert_eq!(print, "-1.234");\n        }\n    }\n\n    #[test]\n    fn test_format64_zero() {\n        let f = 0.0f64;\n        unsafe {\n            let mut buffer = [MaybeUninit::<u8>::uninit(); 24];\n            let len = format64(f, buffer.as_mut_ptr() as *mut u8);\n            let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n            let print = str::from_utf8_unchecked(slice);\n            assert_eq!(print, "0.0");\n        }\n    }\n\n    #[test]\n    fn test_format64_large_number() {\n        let f = 1234567890.0f64;\n        unsafe {\n            let mut buffer = [MaybeUninit::<u8>::uninit(); 24];\n            let len = format64(f, buffer.as_mut_ptr() as *mut u8);\n            let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n            let print = str::from_utf8_unchecked(slice);\n            assert_eq!(print, "1234567890");\n        }\n    }\n\n    #[test]\n    fn test_format64_small_number() {\n        let f = 0.0001234f64;\n        unsafe {\n            let mut buffer = [MaybeUninit::<u8>::uninit(); 24];\n            let len = format64(f, buffer.as_mut_ptr() as *mut u8);\n            let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n            let print = str::from_utf8_unchecked(slice);\n            assert_eq!(print, "0.0001234");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579292, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=605, prompt_tokens=1225, total_tokens=1830, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldxOgKsqyoB3vRkGZf7U2mgJJJ7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_write_mantissa() {\n        let mut buffer = [0u8; 20];\n        let result_ptr = buffer.as_mut_ptr().offset(buffer.len() as isize);\n        \n        // Test with output = 12345\n        unsafe {\n            write_mantissa(12345, result_ptr);\n        }\n        assert_eq!(&buffer[10..], b"12345\\0");\n\n        // Test with output = 67890\n        unsafe {\n            write_mantissa(67890, result_ptr);\n        }\n        assert_eq!(&buffer[10..], b"67890\\0");\n\n        // Test with output = 0\n        unsafe {\n            write_mantissa(0, result_ptr);\n        }\n        assert_eq!(&buffer[10..], b"0\\0");\n\n        // Test with output = 9999\n        unsafe {\n            write_mantissa(9999, result_ptr);\n        }\n        assert_eq!(&buffer[10..], b"9999\\0");\n\n        // Ensure buffer does not exceed size\n        let result = unsafe { std::str::from_utf8_unchecked(&buffer) };\n        assert_eq!(result.len(), 20);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579305, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=280, prompt_tokens=446, total_tokens=726, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcle3go5vYIzsbVqKEtTGcP2dCQT6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_write_mantissa_long() {\n        let mut buffer = vec![0u8; 16]; // Buffer to hold the result\n        let result_ptr = buffer.as_mut_ptr().add(8); // Pointer to the result buffer\n\n        unsafe {\n            write_mantissa_long(12345678901234567890, result_ptr);\n        }\n\n        // Check the contents of the buffer for expected output\n        let expected_output = "12345678901234567890"; // Adjust this if using a specific output format\n        let result_str = std::str::from_utf8(&buffer[8..]).unwrap();\n        assert_eq!(result_str.trim_start_matches(\'\\0\'), expected_output);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579311, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=174, prompt_tokens=474, total_tokens=648, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
({'dependencies': {'<buffer::Buffer as core::clone::Clone>::clone': ['buffer::Buffer', 'core::marker::Sized', 'core::mem::MaybeUninit'], '<buffer::Buffer as core::default::Default>::default': ['buffer::Buffer', 'core::marker::Sized', 'core::mem::MaybeUninit'], '<f32 as buffer::Sealed>::format_nonfinite': [], '<f32 as buffer::Sealed>::is_nonfinite': [], '<f32 as buffer::Sealed>::write_to_ryu_buffer': [], '<f64 as buffer::Sealed>::format_nonfinite': [], '<f64 as buffer::Sealed>::is_nonfinite': [], '<f64 as buffer::Sealed>::write_to_ryu_buffer': [], 'buffer::Buffer': ['buffer::Buffer', 'core::marker::Sized', 'core::mem::MaybeUninit'], 'buffer::Buffer::format': ['buffer::Buffer', 'buffer::Float', 'core::marker::Sized', 'core::mem::MaybeUninit'], 'buffer::Buffer::format_finite': ['buffer::Buffer', 'buffer::Float', 'core::marker::Sized', 'core::mem::MaybeUninit'], 'buffer::Buffer::new': ['buffer::Buffer', 'core::marker::Sized', 'core::mem::MaybeUninit'], 'buffer::Sealed::format_nonfinite': [], 'buffer::Sealed::is_nonfinite': [], 'buffer::Sealed::write_to_ryu_buffer': [], 'common::ceil_log2_pow5': [], 'common::decimal_length9': [], 'common::log10_pow2': [], 'common::log10_pow5': [], 'common::log2_pow5': [], 'common::pow5bits': [], 'd2s::FloatingDecimal64': ['d2s::FloatingDecimal64'], 'd2s::d2d': ['d2s::FloatingDecimal64'], 'd2s::decimal_length17': [], 'd2s_intrinsics::div10': [], 'd2s_intrinsics::div100': [], 'd2s_intrinsics::div5': [], 'd2s_intrinsics::mul_shift_64': [], 'd2s_intrinsics::mul_shift_all_64': [], 'd2s_intrinsics::multiple_of_power_of_2': [], 'd2s_intrinsics::multiple_of_power_of_5': [], 'd2s_intrinsics::pow5_factor': [], 'f2s::FloatingDecimal32': ['f2s::FloatingDecimal32'], 'f2s::f2d': ['f2s::FloatingDecimal32'], 'f2s_intrinsics::mul_pow5_div_pow2': [], 'f2s_intrinsics::mul_pow5_inv_div_pow2': [], 'f2s_intrinsics::mul_shift_32': [], 'f2s_intrinsics::multiple_of_power_of_2_32': [], 'f2s_intrinsics::multiple_of_power_of_5_32': [], 'f2s_intrinsics::pow5factor_32': [], 'pretty::exponent::write_exponent2': [], 'pretty::exponent::write_exponent3': [], 'pretty::format32': [], 'pretty::format64': [], 'pretty::mantissa::write_mantissa': [], 'pretty::mantissa::write_mantissa_long': []}, 'glob_path_import': {}, 'self_to_fn': {'buffer::Buffer': ['impl Buffer {\n    /// This is a cheap operation; you don\'t need to worry about reusing buffers\n    /// for efficiency.\n    #[inline]\n    #[cfg_attr(feature = "no-panic", no_panic)]\n    pub fn new() -> Self {\n        let bytes = [MaybeUninit::<u8>::uninit(); 24];\n        Buffer { bytes }\n    }\n\n    /// Print a floating point number into this buffer and return a reference to\n    /// its string representation within the buffer.\n    ///\n    /// # Special cases\n    ///\n    /// This function formats NaN as the string "NaN", positive infinity as\n    /// "inf", and negative infinity as "-inf" to match std::fmt.\n    ///\n    /// If your input is known to be finite, you may get better performance by\n    /// calling the `format_finite` method instead of `format` to avoid the\n    /// checks for special cases.\n    #[cfg_attr(feature = "no-panic", inline)]\n    #[cfg_attr(feature = "no-panic", no_panic)]\n    pub fn format<F: Float>(&mut self, f: F) -> &str {\n        if f.is_nonfinite() {\n            f.format_nonfinite()\n        } else {\n            self.format_finite(f)\n        }\n    }\n\n    /// Print a floating point number into this buffer and return a reference to\n    /// its string representation within the buffer.\n    ///\n    /// # Special cases\n    ///\n    /// This function **does not** check for NaN or infinity. If the input\n    /// number is not a finite float, the printed representation will be some\n    /// correctly formatted but unspecified numerical value.\n    ///\n    /// Please check [`is_finite`] yourself before calling this function, or\n    /// check [`is_nan`] and [`is_infinite`] and handle those cases yourself.\n    ///\n    /// [`is_finite`]: f64::is_finite\n    /// [`is_nan`]: f64::is_nan\n    /// [`is_infinite`]: f64::is_infinite\n    #[inline]\n    #[cfg_attr(feature = "no-panic", no_panic)]\n    pub fn format_finite<F: Float>(&mut self, f: F) -> &str {\n        unsafe {\n            let n = f.write_to_ryu_buffer(self.bytes.as_mut_ptr() as *mut u8);\n            debug_assert!(n <= self.bytes.len());\n            let slice = slice::from_raw_parts(self.bytes.as_ptr() as *const u8, n);\n            str::from_utf8_unchecked(slice)\n        }\n    }\n}', 'impl Clone for Buffer {\n    #[inline]\n    #[allow(clippy::non_canonical_clone_impl)] // false positive https://github.com/rust-lang/rust-clippy/issues/11072\n    fn clone(&self) -> Self {\n        Buffer::new()\n    }\n}', 'impl Copy for Buffer {}', 'impl Default for Buffer {\n    #[inline]\n    #[cfg_attr(feature = "no-panic", no_panic)]\n    fn default() -> Self {\n        Buffer::new()\n    }\n}']}, 'single_path_import': {'buffer::Buffer': 'Buffer', 'buffer::Float': 'Float', 'd2s_full_table::DOUBLE_POW5_INV_SPLIT': 'd2s::DOUBLE_POW5_INV_SPLIT', 'd2s_full_table::DOUBLE_POW5_SPLIT': 'd2s::DOUBLE_POW5_SPLIT', 'f2s_intrinsics::FLOAT_POW5_BITCOUNT': 'f2s::FLOAT_POW5_BITCOUNT', 'f2s_intrinsics::FLOAT_POW5_INV_BITCOUNT': 'f2s::FLOAT_POW5_INV_BITCOUNT', 'pretty::format32': 'raw::format32', 'pretty::format64': 'raw::format64'}, 'srcs': {'<buffer::Buffer as core::clone::Clone>::clone': ['#[inline]\n#[allow(clippy::non_canonical_clone_impl)]\nfn clone(&self) -> Self{\n        Buffer::new()\n    }', 'Real(LocalPath("src/buffer/mod.rs"))'], '<buffer::Buffer as core::default::Default>::default': ['#[inline]\nfn default() -> Self{\n        Buffer::new()\n    }', 'Real(LocalPath("src/buffer/mod.rs"))'], '<f32 as buffer::Sealed>::format_nonfinite': ["#[cold]\nfn format_nonfinite(self) -> &'static str{\n        const MANTISSA_MASK: u32 = 0x007fffff;\n        const SIGN_MASK: u32 = 0x80000000;\n        let bits = self.to_bits();\n        if bits & MANTISSA_MASK != 0 {\n            NAN\n        } else if bits & SIGN_MASK != 0 {\n            NEG_INFINITY\n        } else {\n            INFINITY\n        }\n    }", 'Real(LocalPath("src/buffer/mod.rs"))'], '<f32 as buffer::Sealed>::is_nonfinite': ['#[inline]\nfn is_nonfinite(self) -> bool{\n        const EXP_MASK: u32 = 0x7f800000;\n        let bits = self.to_bits();\n        bits & EXP_MASK == EXP_MASK\n    }', 'Real(LocalPath("src/buffer/mod.rs"))'], '<f32 as buffer::Sealed>::write_to_ryu_buffer': ['#[inline]\nunsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize{\n        raw::format32(self, result)\n    }', 'Real(LocalPath("src/buffer/mod.rs"))'], '<f64 as buffer::Sealed>::format_nonfinite': ["#[cold]\nfn format_nonfinite(self) -> &'static str{\n        const MANTISSA_MASK: u64 = 0x000fffffffffffff;\n        const SIGN_MASK: u64 = 0x8000000000000000;\n        let bits = self.to_bits();\n        if bits & MANTISSA_MASK != 0 {\n            NAN\n        } else if bits & SIGN_MASK != 0 {\n            NEG_INFINITY\n        } else {\n            INFINITY\n        }\n    }", 'Real(LocalPath("src/buffer/mod.rs"))'], '<f64 as buffer::Sealed>::is_nonfinite': ['#[inline]\nfn is_nonfinite(self) -> bool{\n        const EXP_MASK: u64 = 0x7ff0000000000000;\n        let bits = self.to_bits();\n        bits & EXP_MASK == EXP_MASK\n    }', 'Real(LocalPath("src/buffer/mod.rs"))'], '<f64 as buffer::Sealed>::write_to_ryu_buffer': ['#[inline]\nunsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize{\n        raw::format64(self, result)\n    }', 'Real(LocalPath("src/buffer/mod.rs"))'], 'buffer::Buffer': ['/// Safe API for formatting floating point numbers to text.\n///\n/// ## Example\n///\n/// ```\n/// let mut buffer = ryu::Buffer::new();\n/// let printed = buffer.format_finite(1.234);\n/// assert_eq!(printed, "1.234");\n/// ```\npub struct Buffer {\n    bytes: [MaybeUninit<u8>; 24],\n}', 'Real(LocalPath("src/buffer/mod.rs"))'], 'buffer::Buffer::format': ['/// Print a floating point number into this buffer and return a reference to\n/// its string representation within the buffer.\n///\n/// # Special cases\n///\n/// This function formats NaN as the string "NaN", positive infinity as\n/// "inf", and negative infinity as "-inf" to match std::fmt.\n///\n/// If your input is known to be finite, you may get better performance by\n/// calling the `format_finite` method instead of `format` to avoid the\n/// checks for special cases.\npub fn format<F: Float>(&mut self, f: F) -> &str{\n        if f.is_nonfinite() {\n            f.format_nonfinite()\n        } else {\n            self.format_finite(f)\n        }\n    }', 'Real(LocalPath("src/buffer/mod.rs"))'], 'buffer::Buffer::format_finite': ['/// Print a floating point number into this buffer and return a reference to\n/// its string representation within the buffer.\n///\n/// # Special cases\n///\n/// This function **does not** check for NaN or infinity. If the input\n/// number is not a finite float, the printed representation will be some\n/// correctly formatted but unspecified numerical value.\n///\n/// Please check [`is_finite`] yourself before calling this function, or\n/// check [`is_nan`] and [`is_infinite`] and handle those cases yourself.\n///\n/// [`is_finite`]: f64::is_finite\n/// [`is_nan`]: f64::is_nan\n/// [`is_infinite`]: f64::is_infinite\n#[inline]\npub fn format_finite<F: Float>(&mut self, f: F) -> &str{\n        unsafe {\n            let n = f.write_to_ryu_buffer(self.bytes.as_mut_ptr() as *mut u8);\n            debug_assert!(n <= self.bytes.len());\n            let slice = slice::from_raw_parts(self.bytes.as_ptr() as *const u8, n);\n            str::from_utf8_unchecked(slice)\n        }\n    }', 'Real(LocalPath("src/buffer/mod.rs"))'], 'buffer::Buffer::new': ["/// This is a cheap operation; you don't need to worry about reusing buffers\n/// for efficiency.\n#[inline]\npub fn new() -> Self{\n        let bytes = [MaybeUninit::<u8>::uninit(); 24];\n        Buffer { bytes }\n    }", 'Real(LocalPath("src/buffer/mod.rs"))'], 'buffer::Float': ['/// A floating point number, f32 or f64, that can be written into a\n/// [`ryu::Buffer`][Buffer].\n///\n/// This trait is sealed and cannot be implemented for types outside of the\n/// `ryu` crate.\npub trait Float: Sealed {}', 'Real(LocalPath("src/buffer/mod.rs"))'], 'buffer::Sealed': ["pub trait Sealed: Copy {\n    fn is_nonfinite(self) -> bool;\n    fn format_nonfinite(self) -> &'static str;\n    unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize;\n}", 'Real(LocalPath("src/buffer/mod.rs"))'], 'common::ceil_log2_pow5': ['#[allow(dead_code)]\npub fn ceil_log2_pow5(e: i32) -> i32{\n    log2_pow5(e) + 1\n}', 'Real(LocalPath("src/common.rs"))'], 'common::decimal_length9': ['pub fn decimal_length9(v: u32) -> u32{\n    // Function precondition: v is not a 10-digit number.\n    // (f2s: 9 digits are sufficient for round-tripping.)\n    debug_assert!(v < 1000000000);\n\n    if v >= 100000000 {\n        9\n    } else if v >= 10000000 {\n        8\n    } else if v >= 1000000 {\n        7\n    } else if v >= 100000 {\n        6\n    } else if v >= 10000 {\n        5\n    } else if v >= 1000 {\n        4\n    } else if v >= 100 {\n        3\n    } else if v >= 10 {\n        2\n    } else {\n        1\n    }\n}', 'Real(LocalPath("src/common.rs"))'], 'common::log10_pow2': ['pub fn log10_pow2(e: i32) -> u32{\n    // The first value this approximation fails for is 2^1651 which is just greater than 10^297.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 1650);\n    (e as u32 * 78913) >> 18\n}', 'Real(LocalPath("src/common.rs"))'], 'common::log10_pow5': ['pub fn log10_pow5(e: i32) -> u32{\n    // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 2620);\n    (e as u32 * 732923) >> 20\n}', 'Real(LocalPath("src/common.rs"))'], 'common::log2_pow5': ['#[allow(dead_code)]\npub fn log2_pow5(e: i32) -> i32{\n    // This approximation works up to the point that the multiplication\n    // overflows at e = 3529. If the multiplication were done in 64 bits, it\n    // would fail at 5^4004 which is just greater than 2^9297.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 3528);\n    ((e as u32 * 1217359) >> 19) as i32\n}', 'Real(LocalPath("src/common.rs"))'], 'common::pow5bits': ['pub fn pow5bits(e: i32) -> i32{\n    // This approximation works up to the point that the multiplication\n    // overflows at e = 3529. If the multiplication were done in 64 bits, it\n    // would fail at 5^4004 which is just greater than 2^9297.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 3528);\n    (((e as u32 * 1217359) >> 19) + 1) as i32\n}', 'Real(LocalPath("src/common.rs"))'], 'd2s::FloatingDecimal64': ["pub struct FloatingDecimal64 {\n    pub mantissa: u64,\n    // Decimal exponent's range is -324 to 308\n    // inclusive, and can fit in i16 if needed.\n    pub exponent: i32,\n}", 'Real(LocalPath("src/d2s.rs"))'], 'd2s::d2d': ['pub fn d2d(ieee_mantissa: u64, ieee_exponent: u32) -> FloatingDecimal64{\n    let (e2, m2) = if ieee_exponent == 0 {\n        (\n            // We subtract 2 so that the bounds computation has 2 additional bits.\n            1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n            ieee_mantissa,\n        )\n    } else {\n        (\n            ieee_exponent as i32 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n            (1u64 << DOUBLE_MANTISSA_BITS) | ieee_mantissa,\n        )\n    };\n    let even = (m2 & 1) == 0;\n    let accept_bounds = even;\n\n    // Step 2: Determine the interval of valid decimal representations.\n    let mv = 4 * m2;\n    // Implicit bool -> int conversion. True is 1, false is 0.\n    let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n    // We would compute mp and mm like this:\n    // uint64_t mp = 4 * m2 + 2;\n    // uint64_t mm = mv - 1 - mm_shift;\n\n    // Step 3: Convert to a decimal power base using 128-bit arithmetic.\n    let mut vr: u64;\n    let mut vp: u64;\n    let mut vm: u64;\n    let mut vp_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let mut vm_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let e10: i32;\n    let mut vm_is_trailing_zeros = false;\n    let mut vr_is_trailing_zeros = false;\n    if e2 >= 0 {\n        // I tried special-casing q == 0, but there was no effect on performance.\n        // This expression is slightly faster than max(0, log10_pow2(e2) - 1).\n        let q = log10_pow2(e2) - (e2 > 3) as u32;\n        e10 = q as i32;\n        let k = DOUBLE_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n        let i = -e2 + q as i32 + k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = "small")]\n                &compute_inv_pow5(q),\n                #[cfg(not(feature = "small"))]\n                {\n                    debug_assert!(q < DOUBLE_POW5_INV_SPLIT.len() as u32);\n                    DOUBLE_POW5_INV_SPLIT.get_unchecked(q as usize)\n                },\n                i as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 21 {\n            // This should use q <= 22, but I think 21 is also safe. Smaller values\n            // may still be safe, but it\'s more difficult to reason about them.\n            // Only one of mp, mv, and mm can be a multiple of 5, if any.\n            let mv_mod5 = (mv as u32).wrapping_sub(5u32.wrapping_mul(div5(mv) as u32));\n            if mv_mod5 == 0 {\n                vr_is_trailing_zeros = multiple_of_power_of_5(mv, q);\n            } else if accept_bounds {\n                // Same as min(e2 + (~mm & 1), pow5_factor(mm)) >= q\n                // <=> e2 + (~mm & 1) >= q && pow5_factor(mm) >= q\n                // <=> true && pow5_factor(mm) >= q, since e2 >= q.\n                vm_is_trailing_zeros = multiple_of_power_of_5(mv - 1 - mm_shift as u64, q);\n            } else {\n                // Same as min(e2 + 1, pow5_factor(mp)) >= q.\n                vp -= multiple_of_power_of_5(mv + 2, q) as u64;\n            }\n        }\n    } else {\n        // This expression is slightly faster than max(0, log10_pow5(-e2) - 1).\n        let q = log10_pow5(-e2) - (-e2 > 1) as u32;\n        e10 = q as i32 + e2;\n        let i = -e2 - q as i32;\n        let k = pow5bits(i) - DOUBLE_POW5_BITCOUNT;\n        let j = q as i32 - k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = "small")]\n                &compute_pow5(i as u32),\n                #[cfg(not(feature = "small"))]\n                {\n                    debug_assert!(i < DOUBLE_POW5_SPLIT.len() as i32);\n                    DOUBLE_POW5_SPLIT.get_unchecked(i as usize)\n                },\n                j as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 1 {\n            // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.\n            // mv = 4 * m2, so it always has at least two trailing 0 bits.\n            vr_is_trailing_zeros = true;\n            if accept_bounds {\n                // mm = mv - 1 - mm_shift, so it has 1 trailing 0 bit iff mm_shift == 1.\n                vm_is_trailing_zeros = mm_shift == 1;\n            } else {\n                // mp = mv + 2, so it always has at least one trailing 0 bit.\n                vp -= 1;\n            }\n        } else if q < 63 {\n            // TODO(ulfjack): Use a tighter bound here.\n            // We want to know if the full product has at least q trailing zeros.\n            // We need to compute min(p2(mv), p5(mv) - e2) >= q\n            // <=> p2(mv) >= q && p5(mv) - e2 >= q\n            // <=> p2(mv) >= q (because -e2 >= q)\n            vr_is_trailing_zeros = multiple_of_power_of_2(mv, q);\n        }\n    }\n\n    // Step 4: Find the shortest decimal representation in the interval of valid representations.\n    let mut removed = 0i32;\n    let mut last_removed_digit = 0u8;\n    // On average, we remove ~2 digits.\n    let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n        // General case, which happens rarely (~0.7%).\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            vm_is_trailing_zeros &= vm_mod10 == 0;\n            vr_is_trailing_zeros &= last_removed_digit == 0;\n            last_removed_digit = vr_mod10 as u8;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        if vm_is_trailing_zeros {\n            loop {\n                let vm_div10 = div10(vm);\n                let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n                if vm_mod10 != 0 {\n                    break;\n                }\n                let vp_div10 = div10(vp);\n                let vr_div10 = div10(vr);\n                let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n                vr_is_trailing_zeros &= last_removed_digit == 0;\n                last_removed_digit = vr_mod10 as u8;\n                vr = vr_div10;\n                vp = vp_div10;\n                vm = vm_div10;\n                removed += 1;\n            }\n        }\n        if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n            // Round even if the exact number is .....50..0.\n            last_removed_digit = 4;\n        }\n        // We need to take vr + 1 if vr is outside bounds or we need to round up.\n        vr + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5)\n            as u64\n    } else {\n        // Specialized for the common case (~99.3%). Percentages below are relative to this.\n        let mut round_up = false;\n        let vp_div100 = div100(vp);\n        let vm_div100 = div100(vm);\n        // Optimization: remove two digits at a time (~86.2%).\n        if vp_div100 > vm_div100 {\n            let vr_div100 = div100(vr);\n            let vr_mod100 = (vr as u32).wrapping_sub(100u32.wrapping_mul(vr_div100 as u32));\n            round_up = vr_mod100 >= 50;\n            vr = vr_div100;\n            vp = vp_div100;\n            vm = vm_div100;\n            removed += 2;\n        }\n        // Loop iterations below (approximately), without optimization above:\n        // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%\n        // Loop iterations below (approximately), with optimization above:\n        // 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            round_up = vr_mod10 >= 5;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        // We need to take vr + 1 if vr is outside bounds or we need to round up.\n        vr + (vr == vm || round_up) as u64\n    };\n    let exp = e10 + removed;\n\n    FloatingDecimal64 {\n        exponent: exp,\n        mantissa: output,\n    }\n}', 'Real(LocalPath("src/d2s.rs"))'], 'd2s::decimal_length17': ['pub fn decimal_length17(v: u64) -> u32{\n    // This is slightly faster than a loop.\n    // The average output length is 16.38 digits, so we check high-to-low.\n    // Function precondition: v is not an 18, 19, or 20-digit number.\n    // (17 digits are sufficient for round-tripping.)\n    debug_assert!(v < 100000000000000000);\n\n    if v >= 10000000000000000 {\n        17\n    } else if v >= 1000000000000000 {\n        16\n    } else if v >= 100000000000000 {\n        15\n    } else if v >= 10000000000000 {\n        14\n    } else if v >= 1000000000000 {\n        13\n    } else if v >= 100000000000 {\n        12\n    } else if v >= 10000000000 {\n        11\n    } else if v >= 1000000000 {\n        10\n    } else if v >= 100000000 {\n        9\n    } else if v >= 10000000 {\n        8\n    } else if v >= 1000000 {\n        7\n    } else if v >= 100000 {\n        6\n    } else if v >= 10000 {\n        5\n    } else if v >= 1000 {\n        4\n    } else if v >= 100 {\n        3\n    } else if v >= 10 {\n        2\n    } else {\n        1\n    }\n}', 'Real(LocalPath("src/d2s.rs"))'], 'd2s_intrinsics::div10': ['pub fn div10(x: u64) -> u64{\n    x / 10\n}', 'Real(LocalPath("src/d2s_intrinsics.rs"))'], 'd2s_intrinsics::div100': ['pub fn div100(x: u64) -> u64{\n    x / 100\n}', 'Real(LocalPath("src/d2s_intrinsics.rs"))'], 'd2s_intrinsics::div5': ['pub fn div5(x: u64) -> u64{\n    x / 5\n}', 'Real(LocalPath("src/d2s_intrinsics.rs"))'], 'd2s_intrinsics::mul_shift_64': ['pub fn mul_shift_64(m: u64, mul: &(u64, u64), j: u32) -> u64{\n    let b0 = m as u128 * mul.0 as u128;\n    let b2 = m as u128 * mul.1 as u128;\n    (((b0 >> 64) + b2) >> (j - 64)) as u64\n}', 'Real(LocalPath("src/d2s_intrinsics.rs"))'], 'd2s_intrinsics::mul_shift_all_64': ['pub unsafe fn mul_shift_all_64(\n    m: u64,\n    mul: &(u64, u64),\n    j: u32,\n    vp: *mut u64,\n    vm: *mut u64,\n    mm_shift: u32,\n) -> u64{\n    ptr::write(vp, mul_shift_64(4 * m + 2, mul, j));\n    ptr::write(vm, mul_shift_64(4 * m - 1 - mm_shift as u64, mul, j));\n    mul_shift_64(4 * m, mul, j)\n}', 'Real(LocalPath("src/d2s_intrinsics.rs"))'], 'd2s_intrinsics::multiple_of_power_of_2': ["pub fn multiple_of_power_of_2(value: u64, p: u32) -> bool{\n    debug_assert!(value != 0);\n    debug_assert!(p < 64);\n    // __builtin_ctzll doesn't appear to be faster here.\n    (value & ((1u64 << p) - 1)) == 0\n}", 'Real(LocalPath("src/d2s_intrinsics.rs"))'], 'd2s_intrinsics::multiple_of_power_of_5': ['pub fn multiple_of_power_of_5(value: u64, p: u32) -> bool{\n    // I tried a case distinction on p, but there was no performance difference.\n    pow5_factor(value) >= p\n}', 'Real(LocalPath("src/d2s_intrinsics.rs"))'], 'd2s_intrinsics::pow5_factor': ['pub(crate) fn pow5_factor(mut value: u64) -> u32{\n    const M_INV_5: u64 = 14757395258967641293; // 5 * m_inv_5 = 1 (mod 2^64)\n    const N_DIV_5: u64 = 3689348814741910323; // #{ n | n = 0 (mod 2^64) } = 2^64 / 5\n    let mut count = 0u32;\n    loop {\n        debug_assert!(value != 0);\n        value = value.wrapping_mul(M_INV_5);\n        if value > N_DIV_5 {\n            break;\n        }\n        count += 1;\n    }\n    count\n}', 'Real(LocalPath("src/d2s_intrinsics.rs"))'], 'f2s::FloatingDecimal32': ["pub struct FloatingDecimal32 {\n    pub mantissa: u32,\n    // Decimal exponent's range is -45 to 38\n    // inclusive, and can fit in i16 if needed.\n    pub exponent: i32,\n}", 'Real(LocalPath("src/f2s.rs"))'], 'f2s::f2d': ["pub fn f2d(ieee_mantissa: u32, ieee_exponent: u32) -> FloatingDecimal32{\n    let (e2, m2) = if ieee_exponent == 0 {\n        (\n            // We subtract 2 so that the bounds computation has 2 additional bits.\n            1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS as i32 - 2,\n            ieee_mantissa,\n        )\n    } else {\n        (\n            ieee_exponent as i32 - FLOAT_BIAS - FLOAT_MANTISSA_BITS as i32 - 2,\n            (1u32 << FLOAT_MANTISSA_BITS) | ieee_mantissa,\n        )\n    };\n    let even = (m2 & 1) == 0;\n    let accept_bounds = even;\n\n    // Step 2: Determine the interval of valid decimal representations.\n    let mv = 4 * m2;\n    let mp = 4 * m2 + 2;\n    // Implicit bool -> int conversion. True is 1, false is 0.\n    let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n    let mm = 4 * m2 - 1 - mm_shift;\n\n    // Step 3: Convert to a decimal power base using 64-bit arithmetic.\n    let mut vr: u32;\n    let mut vp: u32;\n    let mut vm: u32;\n    let e10: i32;\n    let mut vm_is_trailing_zeros = false;\n    let mut vr_is_trailing_zeros = false;\n    let mut last_removed_digit = 0u8;\n    if e2 >= 0 {\n        let q = log10_pow2(e2);\n        e10 = q as i32;\n        let k = FLOAT_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n        let i = -e2 + q as i32 + k;\n        vr = mul_pow5_inv_div_pow2(mv, q, i);\n        vp = mul_pow5_inv_div_pow2(mp, q, i);\n        vm = mul_pow5_inv_div_pow2(mm, q, i);\n        if q != 0 && (vp - 1) / 10 <= vm / 10 {\n            // We need to know one removed digit even if we are not going to loop below. We could use\n            // q = X - 1 above, except that would require 33 bits for the result, and we've found that\n            // 32-bit arithmetic is faster even on 64-bit machines.\n            let l = FLOAT_POW5_INV_BITCOUNT + pow5bits(q as i32 - 1) - 1;\n            last_removed_digit =\n                (mul_pow5_inv_div_pow2(mv, q - 1, -e2 + q as i32 - 1 + l) % 10) as u8;\n        }\n        if q <= 9 {\n            // The largest power of 5 that fits in 24 bits is 5^10, but q <= 9 seems to be safe as well.\n            // Only one of mp, mv, and mm can be a multiple of 5, if any.\n            if mv % 5 == 0 {\n                vr_is_trailing_zeros = multiple_of_power_of_5_32(mv, q);\n            } else if accept_bounds {\n                vm_is_trailing_zeros = multiple_of_power_of_5_32(mm, q);\n            } else {\n                vp -= multiple_of_power_of_5_32(mp, q) as u32;\n            }\n        }\n    } else {\n        let q = log10_pow5(-e2);\n        e10 = q as i32 + e2;\n        let i = -e2 - q as i32;\n        let k = pow5bits(i) - FLOAT_POW5_BITCOUNT;\n        let mut j = q as i32 - k;\n        vr = mul_pow5_div_pow2(mv, i as u32, j);\n        vp = mul_pow5_div_pow2(mp, i as u32, j);\n        vm = mul_pow5_div_pow2(mm, i as u32, j);\n        if q != 0 && (vp - 1) / 10 <= vm / 10 {\n            j = q as i32 - 1 - (pow5bits(i + 1) - FLOAT_POW5_BITCOUNT);\n            last_removed_digit = (mul_pow5_div_pow2(mv, (i + 1) as u32, j) % 10) as u8;\n        }\n        if q <= 1 {\n            // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.\n            // mv = 4 * m2, so it always has at least two trailing 0 bits.\n            vr_is_trailing_zeros = true;\n            if accept_bounds {\n                // mm = mv - 1 - mm_shift, so it has 1 trailing 0 bit iff mm_shift == 1.\n                vm_is_trailing_zeros = mm_shift == 1;\n            } else {\n                // mp = mv + 2, so it always has at least one trailing 0 bit.\n                vp -= 1;\n            }\n        } else if q < 31 {\n            // TODO(ulfjack): Use a tighter bound here.\n            vr_is_trailing_zeros = multiple_of_power_of_2_32(mv, q - 1);\n        }\n    }\n\n    // Step 4: Find the shortest decimal representation in the interval of valid representations.\n    let mut removed = 0i32;\n    let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n        // General case, which happens rarely (~4.0%).\n        while vp / 10 > vm / 10 {\n            vm_is_trailing_zeros &= vm - (vm / 10) * 10 == 0;\n            vr_is_trailing_zeros &= last_removed_digit == 0;\n            last_removed_digit = (vr % 10) as u8;\n            vr /= 10;\n            vp /= 10;\n            vm /= 10;\n            removed += 1;\n        }\n        if vm_is_trailing_zeros {\n            while vm % 10 == 0 {\n                vr_is_trailing_zeros &= last_removed_digit == 0;\n                last_removed_digit = (vr % 10) as u8;\n                vr /= 10;\n                vp /= 10;\n                vm /= 10;\n                removed += 1;\n            }\n        }\n        if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n            // Round even if the exact number is .....50..0.\n            last_removed_digit = 4;\n        }\n        // We need to take vr + 1 if vr is outside bounds or we need to round up.\n        vr + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5)\n            as u32\n    } else {\n        // Specialized for the common case (~96.0%). Percentages below are relative to this.\n        // Loop iterations below (approximately):\n        // 0: 13.6%, 1: 70.7%, 2: 14.1%, 3: 1.39%, 4: 0.14%, 5+: 0.01%\n        while vp / 10 > vm / 10 {\n            last_removed_digit = (vr % 10) as u8;\n            vr /= 10;\n            vp /= 10;\n            vm /= 10;\n            removed += 1;\n        }\n        // We need to take vr + 1 if vr is outside bounds or we need to round up.\n        vr + (vr == vm || last_removed_digit >= 5) as u32\n    };\n    let exp = e10 + removed;\n\n    FloatingDecimal32 {\n        exponent: exp,\n        mantissa: output,\n    }\n}", 'Real(LocalPath("src/f2s.rs"))'], 'f2s_intrinsics::mul_pow5_div_pow2': ['pub fn mul_pow5_div_pow2(m: u32, i: u32, j: i32) -> u32{\n    #[cfg(feature = "small")]\n    {\n        let pow5 = unsafe { d2s::compute_pow5(i) };\n        mul_shift_32(m, pow5.1, j)\n    }\n\n    #[cfg(not(feature = "small"))]\n    {\n        debug_assert!(i < d2s::DOUBLE_POW5_SPLIT.len() as u32);\n        unsafe { mul_shift_32(m, d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1, j) }\n    }\n}', 'Real(LocalPath("src/f2s_intrinsics.rs"))'], 'f2s_intrinsics::mul_pow5_inv_div_pow2': ['pub fn mul_pow5_inv_div_pow2(m: u32, q: u32, j: i32) -> u32{\n    #[cfg(feature = "small")]\n    {\n        // The inverse multipliers are defined as [2^x / 5^y] + 1; the upper 64\n        // bits from the double lookup table are the correct bits for [2^x /\n        // 5^y], so we have to add 1 here. Note that we rely on the fact that\n        // the added 1 that\'s already stored in the table never overflows into\n        // the upper 64 bits.\n        let pow5 = unsafe { d2s::compute_inv_pow5(q) };\n        mul_shift_32(m, pow5.1 + 1, j)\n    }\n\n    #[cfg(not(feature = "small"))]\n    {\n        debug_assert!(q < d2s::DOUBLE_POW5_INV_SPLIT.len() as u32);\n        unsafe {\n            mul_shift_32(\n                m,\n                d2s::DOUBLE_POW5_INV_SPLIT.get_unchecked(q as usize).1 + 1,\n                j,\n            )\n        }\n    }\n}', 'Real(LocalPath("src/f2s_intrinsics.rs"))'], 'f2s_intrinsics::mul_shift_32': ['fn mul_shift_32(m: u32, factor: u64, shift: i32) -> u32{\n    debug_assert!(shift > 32);\n\n    // The casts here help MSVC to avoid calls to the __allmul library\n    // function.\n    let factor_lo = factor as u32;\n    let factor_hi = (factor >> 32) as u32;\n    let bits0 = m as u64 * factor_lo as u64;\n    let bits1 = m as u64 * factor_hi as u64;\n\n    let sum = (bits0 >> 32) + bits1;\n    let shifted_sum = sum >> (shift - 32);\n    debug_assert!(shifted_sum <= u32::max_value() as u64);\n    shifted_sum as u32\n}', 'Real(LocalPath("src/f2s_intrinsics.rs"))'], 'f2s_intrinsics::multiple_of_power_of_2_32': ["pub fn multiple_of_power_of_2_32(value: u32, p: u32) -> bool{\n    // __builtin_ctz doesn't appear to be faster here.\n    (value & ((1u32 << p) - 1)) == 0\n}", 'Real(LocalPath("src/f2s_intrinsics.rs"))'], 'f2s_intrinsics::multiple_of_power_of_5_32': ['pub fn multiple_of_power_of_5_32(value: u32, p: u32) -> bool{\n    pow5factor_32(value) >= p\n}', 'Real(LocalPath("src/f2s_intrinsics.rs"))'], 'f2s_intrinsics::pow5factor_32': ['fn pow5factor_32(mut value: u32) -> u32{\n    let mut count = 0u32;\n    loop {\n        debug_assert!(value != 0);\n        let q = value / 5;\n        let r = value % 5;\n        if r != 0 {\n            break;\n        }\n        value = q;\n        count += 1;\n    }\n    count\n}', 'Real(LocalPath("src/f2s_intrinsics.rs"))'], 'pretty::exponent::write_exponent2': ["pub unsafe fn write_exponent2(mut k: isize, mut result: *mut u8) -> usize{\n    let sign = k < 0;\n    if sign {\n        *result = b'-';\n        result = result.offset(1);\n        k = -k;\n    }\n\n    debug_assert!(k < 100);\n    if k >= 10 {\n        let d = DIGIT_TABLE.as_ptr().offset(k * 2);\n        ptr::copy_nonoverlapping(d, result, 2);\n        sign as usize + 2\n    } else {\n        *result = b'0' + k as u8;\n        sign as usize + 1\n    }\n}", 'Real(LocalPath("src/pretty/exponent.rs"))'], 'pretty::exponent::write_exponent3': ["pub unsafe fn write_exponent3(mut k: isize, mut result: *mut u8) -> usize{\n    let sign = k < 0;\n    if sign {\n        *result = b'-';\n        result = result.offset(1);\n        k = -k;\n    }\n\n    debug_assert!(k < 1000);\n    if k >= 100 {\n        *result = b'0' + (k / 100) as u8;\n        k %= 100;\n        let d = DIGIT_TABLE.as_ptr().offset(k * 2);\n        ptr::copy_nonoverlapping(d, result.offset(1), 2);\n        sign as usize + 3\n    } else if k >= 10 {\n        let d = DIGIT_TABLE.as_ptr().offset(k * 2);\n        ptr::copy_nonoverlapping(d, result, 2);\n        sign as usize + 2\n    } else {\n        *result = b'0' + k as u8;\n        sign as usize + 1\n    }\n}", 'Real(LocalPath("src/pretty/exponent.rs"))'], 'pretty::format32': ['/// Print f32 to the given buffer and return number of bytes written.\n///\n/// At most 16 bytes will be written.\n///\n/// ## Special cases\n///\n/// This function **does not** check for NaN or infinity. If the input\n/// number is not a finite float, the printed representation will be some\n/// correctly formatted but unspecified numerical value.\n///\n/// Please check [`is_finite`] yourself before calling this function, or\n/// check [`is_nan`] and [`is_infinite`] and handle those cases yourself.\n///\n/// [`is_finite`]: f32::is_finite\n/// [`is_nan`]: f32::is_nan\n/// [`is_infinite`]: f32::is_infinite\n///\n/// ## Safety\n///\n/// The `result` pointer argument must point to sufficiently many writable bytes\n/// to hold Ry\'s representation of `f`.\n///\n/// ## Example\n///\n/// ```\n/// use std::{mem::MaybeUninit, slice, str};\n///\n/// let f = 1.234f32;\n///\n/// unsafe {\n///     let mut buffer = [MaybeUninit::<u8>::uninit(); 16];\n///     let len = ryu::raw::format32(f, buffer.as_mut_ptr() as *mut u8);\n///     let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n///     let print = str::from_utf8_unchecked(slice);\n///     assert_eq!(print, "1.234");\n/// }\n/// ```\n#[must_use]\npub unsafe fn format32(f: f32, result: *mut u8) -> usize{\n    let bits = f.to_bits();\n    let sign = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS)) & 1) != 0;\n    let ieee_mantissa = bits & ((1u32 << FLOAT_MANTISSA_BITS) - 1);\n    let ieee_exponent = (bits >> FLOAT_MANTISSA_BITS) & ((1u32 << FLOAT_EXPONENT_BITS) - 1);\n\n    let mut index = 0isize;\n    if sign {\n        *result = b\'-\';\n        index += 1;\n    }\n\n    if ieee_exponent == 0 && ieee_mantissa == 0 {\n        ptr::copy_nonoverlapping(b"0.0".as_ptr(), result.offset(index), 3);\n        return sign as usize + 3;\n    }\n\n    let v = f2d(ieee_mantissa, ieee_exponent);\n\n    let length = common::decimal_length9(v.mantissa) as isize;\n    let k = v.exponent as isize;\n    let kk = length + k; // 10^(kk-1) <= v < 10^kk\n    debug_assert!(k >= -45);\n\n    if 0 <= k && kk <= 13 {\n        // 1234e7 -> 12340000000.0\n        write_mantissa(v.mantissa, result.offset(index + length));\n        for i in length..kk {\n            *result.offset(index + i) = b\'0\';\n        }\n        *result.offset(index + kk) = b\'.\';\n        *result.offset(index + kk + 1) = b\'0\';\n        index as usize + kk as usize + 2\n    } else if 0 < kk && kk <= 13 {\n        // 1234e-2 -> 12.34\n        write_mantissa(v.mantissa, result.offset(index + length + 1));\n        ptr::copy(result.offset(index + 1), result.offset(index), kk as usize);\n        *result.offset(index + kk) = b\'.\';\n        index as usize + length as usize + 1\n    } else if -6 < kk && kk <= 0 {\n        // 1234e-6 -> 0.001234\n        *result.offset(index) = b\'0\';\n        *result.offset(index + 1) = b\'.\';\n        let offset = 2 - kk;\n        for i in 2..offset {\n            *result.offset(index + i) = b\'0\';\n        }\n        write_mantissa(v.mantissa, result.offset(index + length + offset));\n        index as usize + length as usize + offset as usize\n    } else if length == 1 {\n        // 1e30\n        *result.offset(index) = b\'0\' + v.mantissa as u8;\n        *result.offset(index + 1) = b\'e\';\n        index as usize + 2 + write_exponent2(kk - 1, result.offset(index + 2))\n    } else {\n        // 1234e30 -> 1.234e33\n        write_mantissa(v.mantissa, result.offset(index + length + 1));\n        *result.offset(index) = *result.offset(index + 1);\n        *result.offset(index + 1) = b\'.\';\n        *result.offset(index + length + 1) = b\'e\';\n        index as usize\n            + length as usize\n            + 2\n            + write_exponent2(kk - 1, result.offset(index + length + 2))\n    }\n}', 'Real(LocalPath("src/pretty/mod.rs"))'], 'pretty::format64': ['/// Print f64 to the given buffer and return number of bytes written.\n///\n/// At most 24 bytes will be written.\n///\n/// ## Special cases\n///\n/// This function **does not** check for NaN or infinity. If the input\n/// number is not a finite float, the printed representation will be some\n/// correctly formatted but unspecified numerical value.\n///\n/// Please check [`is_finite`] yourself before calling this function, or\n/// check [`is_nan`] and [`is_infinite`] and handle those cases yourself.\n///\n/// [`is_finite`]: f64::is_finite\n/// [`is_nan`]: f64::is_nan\n/// [`is_infinite`]: f64::is_infinite\n///\n/// ## Safety\n///\n/// The `result` pointer argument must point to sufficiently many writable bytes\n/// to hold Ry\'s representation of `f`.\n///\n/// ## Example\n///\n/// ```\n/// use std::{mem::MaybeUninit, slice, str};\n///\n/// let f = 1.234f64;\n///\n/// unsafe {\n///     let mut buffer = [MaybeUninit::<u8>::uninit(); 24];\n///     let len = ryu::raw::format64(f, buffer.as_mut_ptr() as *mut u8);\n///     let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n///     let print = str::from_utf8_unchecked(slice);\n///     assert_eq!(print, "1.234");\n/// }\n/// ```\n#[must_use]\npub unsafe fn format64(f: f64, result: *mut u8) -> usize{\n    let bits = f.to_bits();\n    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;\n    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);\n    let ieee_exponent =\n        (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);\n\n    let mut index = 0isize;\n    if sign {\n        *result = b\'-\';\n        index += 1;\n    }\n\n    if ieee_exponent == 0 && ieee_mantissa == 0 {\n        ptr::copy_nonoverlapping(b"0.0".as_ptr(), result.offset(index), 3);\n        return sign as usize + 3;\n    }\n\n    let v = d2d(ieee_mantissa, ieee_exponent);\n\n    let length = d2s::decimal_length17(v.mantissa) as isize;\n    let k = v.exponent as isize;\n    let kk = length + k; // 10^(kk-1) <= v < 10^kk\n    debug_assert!(k >= -324);\n\n    if 0 <= k && kk <= 16 {\n        // 1234e7 -> 12340000000.0\n        write_mantissa_long(v.mantissa, result.offset(index + length));\n        for i in length..kk {\n            *result.offset(index + i) = b\'0\';\n        }\n        *result.offset(index + kk) = b\'.\';\n        *result.offset(index + kk + 1) = b\'0\';\n        index as usize + kk as usize + 2\n    } else if 0 < kk && kk <= 16 {\n        // 1234e-2 -> 12.34\n        write_mantissa_long(v.mantissa, result.offset(index + length + 1));\n        ptr::copy(result.offset(index + 1), result.offset(index), kk as usize);\n        *result.offset(index + kk) = b\'.\';\n        index as usize + length as usize + 1\n    } else if -5 < kk && kk <= 0 {\n        // 1234e-6 -> 0.001234\n        *result.offset(index) = b\'0\';\n        *result.offset(index + 1) = b\'.\';\n        let offset = 2 - kk;\n        for i in 2..offset {\n            *result.offset(index + i) = b\'0\';\n        }\n        write_mantissa_long(v.mantissa, result.offset(index + length + offset));\n        index as usize + length as usize + offset as usize\n    } else if length == 1 {\n        // 1e30\n        *result.offset(index) = b\'0\' + v.mantissa as u8;\n        *result.offset(index + 1) = b\'e\';\n        index as usize + 2 + write_exponent3(kk - 1, result.offset(index + 2))\n    } else {\n        // 1234e30 -> 1.234e33\n        write_mantissa_long(v.mantissa, result.offset(index + length + 1));\n        *result.offset(index) = *result.offset(index + 1);\n        *result.offset(index + 1) = b\'.\';\n        *result.offset(index + length + 1) = b\'e\';\n        index as usize\n            + length as usize\n            + 2\n            + write_exponent3(kk - 1, result.offset(index + length + 2))\n    }\n}', 'Real(LocalPath("src/pretty/mod.rs"))'], 'pretty::mantissa::write_mantissa': ["pub unsafe fn write_mantissa(mut output: u32, mut result: *mut u8){\n    while output >= 10_000 {\n        let c = output - 10_000 * (output / 10_000);\n        output /= 10_000;\n        let c0 = (c % 100) << 1;\n        let c1 = (c / 100) << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c0 as isize),\n            result.offset(-2),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c1 as isize),\n            result.offset(-4),\n            2,\n        );\n        result = result.offset(-4);\n    }\n    if output >= 100 {\n        let c = (output % 100) << 1;\n        output /= 100;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c as isize),\n            result.offset(-2),\n            2,\n        );\n        result = result.offset(-2);\n    }\n    if output >= 10 {\n        let c = output << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c as isize),\n            result.offset(-2),\n            2,\n        );\n    } else {\n        *result.offset(-1) = b'0' + output as u8;\n    }\n}", 'Real(LocalPath("src/pretty/mantissa.rs"))'], 'pretty::mantissa::write_mantissa_long': ['pub unsafe fn write_mantissa_long(mut output: u64, mut result: *mut u8){\n    if (output >> 32) != 0 {\n        // One expensive 64-bit division.\n        let mut output2 = (output - 100_000_000 * (output / 100_000_000)) as u32;\n        output /= 100_000_000;\n\n        let c = output2 % 10_000;\n        output2 /= 10_000;\n        let d = output2 % 10_000;\n        let c0 = (c % 100) << 1;\n        let c1 = (c / 100) << 1;\n        let d0 = (d % 100) << 1;\n        let d1 = (d / 100) << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c0 as isize),\n            result.offset(-2),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c1 as isize),\n            result.offset(-4),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(d0 as isize),\n            result.offset(-6),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(d1 as isize),\n            result.offset(-8),\n            2,\n        );\n        result = result.offset(-8);\n    }\n    write_mantissa(output as u32, result);\n}', 'Real(LocalPath("src/pretty/mantissa.rs"))']}, 'struct_constructor': {'&\'^0.Named(DefId(0:169 ~ ryu[da7a]::buffer::{impl#0}::format::\'_), "\'_") str': ['format'], '&\'^0.Named(DefId(0:170 ~ ryu[da7a]::buffer::{impl#0}::format_finite::\'_), "\'_") str': ['format_finite'], "&'static str": ['format_nonfinite'], 'bool': ['is_nonfinite', 'multiple_of_power_of_2', 'multiple_of_power_of_2_32', 'multiple_of_power_of_5', 'multiple_of_power_of_5_32'], 'buffer::Buffer': ['clone', 'default', 'new'], 'd2s::FloatingDecimal64': ['d2d'], 'f2s::FloatingDecimal32': ['f2d'], 'u32': ['decimal_length17', 'log10_pow2', 'log10_pow5', 'pow5_factor'], 'usize': ['format32', 'format64', 'write_exponent2', 'write_exponent3', 'write_to_ryu_buffer']}, 'struct_to_trait': {'buffer::Buffer': ['core::clone::Clone', 'core::default::Default', 'core::marker::Copy']}, 'targets': {'<buffer::Buffer as core::clone::Clone>::clone': ['clone', 'Real(LocalPath("src/buffer/mod.rs"))', 'core::clone::Clone'], '<buffer::Buffer as core::default::Default>::default': ['default', 'Real(LocalPath("src/buffer/mod.rs"))', 'core::default::Default'], '<f32 as buffer::Sealed>::format_nonfinite': ['format_nonfinite', 'Real(LocalPath("src/buffer/mod.rs"))', 'buffer::Sealed'], '<f32 as buffer::Sealed>::is_nonfinite': ['is_nonfinite', 'Real(LocalPath("src/buffer/mod.rs"))', 'buffer::Sealed'], '<f32 as buffer::Sealed>::write_to_ryu_buffer': ['write_to_ryu_buffer', 'Real(LocalPath("src/buffer/mod.rs"))', 'buffer::Sealed'], '<f64 as buffer::Sealed>::format_nonfinite': ['format_nonfinite', 'Real(LocalPath("src/buffer/mod.rs"))', 'buffer::Sealed'], '<f64 as buffer::Sealed>::is_nonfinite': ['is_nonfinite', 'Real(LocalPath("src/buffer/mod.rs"))', 'buffer::Sealed'], '<f64 as buffer::Sealed>::write_to_ryu_buffer': ['write_to_ryu_buffer', 'Real(LocalPath("src/buffer/mod.rs"))', 'buffer::Sealed'], 'buffer::Buffer::format': ['format', 'Real(LocalPath("src/buffer/mod.rs"))', ''], 'buffer::Buffer::format_finite': ['format_finite', 'Real(LocalPath("src/buffer/mod.rs"))', ''], 'buffer::Buffer::new': ['new', 'Real(LocalPath("src/buffer/mod.rs"))', ''], 'common::ceil_log2_pow5': ['ceil_log2_pow5', 'Real(LocalPath("src/common.rs"))', ''], 'common::decimal_length9': ['decimal_length9', 'Real(LocalPath("src/common.rs"))', ''], 'common::log10_pow2': ['log10_pow2', 'Real(LocalPath("src/common.rs"))', ''], 'common::log10_pow5': ['log10_pow5', 'Real(LocalPath("src/common.rs"))', ''], 'common::log2_pow5': ['log2_pow5', 'Real(LocalPath("src/common.rs"))', ''], 'common::pow5bits': ['pow5bits', 'Real(LocalPath("src/common.rs"))', ''], 'd2s::d2d': ['d2d', 'Real(LocalPath("src/d2s.rs"))', ''], 'd2s::decimal_length17': ['decimal_length17', 'Real(LocalPath("src/d2s.rs"))', ''], 'd2s_intrinsics::div10': ['div10', 'Real(LocalPath("src/d2s_intrinsics.rs"))', ''], 'd2s_intrinsics::div100': ['div100', 'Real(LocalPath("src/d2s_intrinsics.rs"))', ''], 'd2s_intrinsics::div5': ['div5', 'Real(LocalPath("src/d2s_intrinsics.rs"))', ''], 'd2s_intrinsics::mul_shift_64': ['mul_shift_64', 'Real(LocalPath("src/d2s_intrinsics.rs"))', ''], 'd2s_intrinsics::mul_shift_all_64': ['mul_shift_all_64', 'Real(LocalPath("src/d2s_intrinsics.rs"))', ''], 'd2s_intrinsics::multiple_of_power_of_2': ['multiple_of_power_of_2', 'Real(LocalPath("src/d2s_intrinsics.rs"))', ''], 'd2s_intrinsics::multiple_of_power_of_5': ['multiple_of_power_of_5', 'Real(LocalPath("src/d2s_intrinsics.rs"))', ''], 'd2s_intrinsics::pow5_factor': ['pow5_factor', 'Real(LocalPath("src/d2s_intrinsics.rs"))', ''], 'f2s::f2d': ['f2d', 'Real(LocalPath("src/f2s.rs"))', ''], 'f2s_intrinsics::mul_pow5_div_pow2': ['mul_pow5_div_pow2', 'Real(LocalPath("src/f2s_intrinsics.rs"))', ''], 'f2s_intrinsics::mul_pow5_inv_div_pow2': ['mul_pow5_inv_div_pow2', 'Real(LocalPath("src/f2s_intrinsics.rs"))', ''], 'f2s_intrinsics::mul_shift_32': ['mul_shift_32', 'Real(LocalPath("src/f2s_intrinsics.rs"))', ''], 'f2s_intrinsics::multiple_of_power_of_2_32': ['multiple_of_power_of_2_32', 'Real(LocalPath("src/f2s_intrinsics.rs"))', ''], 'f2s_intrinsics::multiple_of_power_of_5_32': ['multiple_of_power_of_5_32', 'Real(LocalPath("src/f2s_intrinsics.rs"))', ''], 'f2s_intrinsics::pow5factor_32': ['pow5factor_32', 'Real(LocalPath("src/f2s_intrinsics.rs"))', ''], 'pretty::exponent::write_exponent2': ['write_exponent2', 'Real(LocalPath("src/pretty/exponent.rs"))', ''], 'pretty::exponent::write_exponent3': ['write_exponent3', 'Real(LocalPath("src/pretty/exponent.rs"))', ''], 'pretty::format32': ['format32', 'Real(LocalPath("src/pretty/mod.rs"))', ''], 'pretty::format64': ['format64', 'Real(LocalPath("src/pretty/mod.rs"))', ''], 'pretty::mantissa::write_mantissa': ['write_mantissa', 'Real(LocalPath("src/pretty/mantissa.rs"))', ''], 'pretty::mantissa::write_mantissa_long': ['write_mantissa_long', 'Real(LocalPath("src/pretty/mantissa.rs"))', '']}, 'trait_to_struct': {'core::clone::Clone': ['buffer::Buffer'], 'core::default::Default': ['buffer::Buffer'], 'core::marker::Copy': ['buffer::Buffer']}, 'type_to_def_path': {'buffer::Buffer': 'buffer::Buffer', 'd2s::FloatingDecimal64': 'd2s::FloatingDecimal64', 'f2s::FloatingDecimal32': 'f2s::FloatingDecimal32'}}, 'ryu', 'ryu') finished, time: 297.7120039120782s
