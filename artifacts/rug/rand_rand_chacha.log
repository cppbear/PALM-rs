ChatCompletion(id='chatcmpl-BclZMG7BXt4TTjJ7134iQIef0wkWI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::chacha::Array64;\n\n    #[test]\n    fn test_clone() {\n        // Setup\n        let original = Array64([1u8; 64]); // Array filled with 1s\n        let cloned = original.clone();\n\n        // Assert that the original and cloned contents are the same\n        assert_eq!(original.as_ref(), cloned.as_ref());\n\n        // Assert that the original and cloned are different instances\n        assert!(!std::ptr::eq(&original, &cloned));\n    }\n\n    #[test]\n    fn test_clone_with_default() {\n        // Setup\n        let original = Array64::<u8>::default(); // Array with default values (0s)\n        let cloned = original.clone();\n\n        // Assert that the original and cloned contents are the same\n        assert_eq!(original.as_ref(), cloned.as_ref());\n\n        // Assert that the original and cloned are different instances\n        assert!(!std::ptr::eq(&original, &cloned));\n    }\n\n    #[test]\n    fn test_clone_empty() {\n        // Setup\n        let original = Array64::<u8>([0; 64]); // Array filled with 0s\n        let cloned = original.clone();\n\n        // Assert that the original and cloned contents are the same\n        assert_eq!(original.as_ref(), cloned.as_ref());\n\n        // Assert that the original and cloned are different instances\n        assert!(!std::ptr::eq(&original, &cloned));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579020, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=326, prompt_tokens=733, total_tokens=1059, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZWOkiIKsI9NaA1Qhbhp85FEiDs', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::chacha::Array64;\n\n    #[test]\n    fn test_as_mut() {\n        let mut array = Array64([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64]);\n        \n        let slice: &mut [i32] = array.as_mut();\n        slice[0] = 42;\n\n        assert_eq!(array.0[0], 42);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579030, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=276, prompt_tokens=728, total_tokens=1004, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZdWdQflV8cxy7ytvHmesYWWq7x', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::chacha::Array64;\n\n    #[test]\n    fn test_as_ref() {\n        let array = Array64([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n                             17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\n                             29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n                             41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,\n                             53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64]);\n        let slice: &[i32] = array.as_ref();\n        assert_eq!(slice.len(), 64);\n        assert_eq!(slice[0], 1);\n        assert_eq!(slice[63], 64);\n    }\n\n    #[test]\n    fn test_as_ref_empty() {\n        let array: Array64<u8> = Array64([0; 64]);\n        let slice: &[u8] = array.as_ref();\n        assert_eq!(slice.len(), 64);\n        assert!(slice.iter().all(|&x| x == 0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579037, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=359, prompt_tokens=724, total_tokens=1083, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZm0pIS35MSsQRH5h4GUz5ICrbL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::default::Default;\n\n    #[test]\n    fn test_array64_default() {\n        let array: Array64<u32> = Default::default();\n        let expected = Array64([0u32; 64]);\n        assert_eq!(array.as_ref(), expected.as_ref());\n\n        let array_f64: Array64<f64> = Default::default();\n        let expected_f64 = Array64([0.0; 64]);\n        assert_eq!(array_f64.as_ref(), expected_f64.as_ref());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579046, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=126, prompt_tokens=982, total_tokens=1108, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZrq0saBVkTMzaXPeIESfnP1pWf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_from_seed() {\n        let seed: [u8; 32] = [0; 32]; // Example seed for testing\n        let rng = chacha::ChaCha12Core::from_seed(seed);\n        \n        // Assert properties of the rng, such as it being initialized\n        assert_eq!(rng.state.get_seed(), seed);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579051, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=105, prompt_tokens=872, total_tokens=977, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZveS414eWY9rBc1P2ChgFDsaY0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n    use rand_chacha::ChaCha12Core;\n\n    #[test]\n    fn test_generate() {\n        let seed: [u8; 32] = [0u8; 32];\n        let mut rng = ChaCha12Core::from_seed(seed);\n        let mut results = [0u32; 64]; // Adjust size if necessary\n        rng.generate(&mut results);\n        \n        // Asserts to validate the randomness or the generated results\n        assert!(!results.is_empty());\n        // Additional assertions can be made based on expected output\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579055, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=143, prompt_tokens=863, total_tokens=1006, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZzhEpsBq2PFmFFR8Z8GUtJIIdM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha12Rng, SeedableRng};\n\n    #[test]\n    fn test_fill_bytes() {\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let mut rng = ChaCha12Rng::from_seed(seed);\n        \n        let mut buffer = [0u8; 16]; // Buffer to fill\n        rng.fill_bytes(&mut buffer);\n\n        // Ensure buffer is filled with non-zero values\n        assert!(buffer.iter().any(|&b| b != 0), "Buffer should be filled with non-zero values");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579059, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=147, prompt_tokens=2643, total_tokens=2790, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcla4a9grWrekFRFWSqADuj10VBQK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha12Rng;\n\n    #[test]\n    fn test_next_u32() {\n        let seed: [u8; 32] = rand::random();\n        let mut rng = ChaCha12Rng::from_seed(seed);\n\n        let first_value = rng.next_u32();\n        let second_value = rng.next_u32();\n\n        assert_ne!(first_value, second_value, "next_u32 should produce different values on subsequent calls");\n    }\n\n    #[test]\n    fn test_next_u32_bounds() {\n        let seed: [u8; 32] = rand::random();\n        let mut rng = ChaCha12Rng::from_seed(seed);\n\n        let value = rng.next_u32();\n\n        assert!(value <= u32::MAX, "next_u32 should return a value within the bounds of u32");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579064, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=195, prompt_tokens=2642, total_tokens=2837, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcla9IZlfM4DPFkusdyItytWKamrf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use rand_chacha::ChaCha12Rng;\n    use rand_core::RngCore;\n\n    #[test]\n    fn test_next_u64() {\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let mut rng = ChaCha12Rng::from_seed(seed);\n        \n        let random_value = rng.next_u64();\n        \n        // Check that the result is a valid u64\n        assert!(random_value <= u64::MAX);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579069, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=119, prompt_tokens=2642, total_tokens=2761, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaEOIubDl3S8gHCOuKHtw19shIt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha12Rng;\n\n    #[test]\n    fn test_from_seed() {\n        let seed: [u8; 32] = [0u8; 32];\n        let rng = ChaCha12Rng::from_seed(seed);\n        let expected_seed = [0u8; 32];\n        \n        // Test that the RNG can produce a seed\n        assert_eq!(rng.get_seed(), expected_seed);\n        \n        // Test the RNG can generate numbers\n        let number = rng.next_u32();\n        assert!(number != 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579074, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=138, prompt_tokens=2662, total_tokens=2800, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaLB6nYU2weiX42KOwX0IiAYm8X', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha12Rng, SeedableRng};\n\n    #[test]\n    fn test_rng_equality() {\n        let seed: [u8; 32] = [0; 32];\n        let rng1 = ChaCha12Rng::from_seed(seed);\n        let rng2 = ChaCha12Rng::from_seed(seed);\n\n        assert!(rng1 == rng2);\n    }\n\n    #[test]\n    fn test_rng_inequality() {\n        let seed1: [u8; 32] = [1; 32];\n        let seed2: [u8; 32] = [2; 32];\n        let rng1 = ChaCha12Rng::from_seed(seed1);\n        let rng2 = ChaCha12Rng::from_seed(seed2);\n\n        assert!(rng1 != rng2);\n    }\n\n    #[test]\n    fn test_rng_equality_after_modification() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng1 = ChaCha12Rng::from_seed(seed);\n        let mut rng2 = ChaCha12Rng::from_seed(seed);\n\n        rng1.next_u32(); // Modify rng1\n        assert!(rng1 != rng2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579081, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=286, prompt_tokens=2668, total_tokens=2954, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaSciUmZYIA96VJ3CZyRJ3zhiIB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_from_cha_cha_12_core() {\n        let seed: [u8; 32] = [0u8; 32]; // Replace with a test seed if needed\n        let core = chacha::ChaCha12Core::from_seed(seed);\n        let rng: chacha::ChaCha12Rng = chacha::ChaCha12Rng::from(core);\n        \n        assert_eq!(rng.get_seed(), seed);\n    }\n\n    #[test]\n    fn test_from_with_different_seed() {\n        let seed1: [u8; 32] = [1u8; 32];\n        let seed2: [u8; 32] = [2u8; 32];\n        let core1 = chacha::ChaCha12Core::from_seed(seed1);\n        let core2 = chacha::ChaCha12Core::from_seed(seed2);\n\n        let rng1: chacha::ChaCha12Rng = chacha::ChaCha12Rng::from(core1);\n        let rng2: chacha::ChaCha12Rng = chacha::ChaCha12Rng::from(core2);\n\n        assert_ne!(rng1.get_seed(), rng2.get_seed());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579088, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=288, prompt_tokens=2654, total_tokens=2942, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaeALpcmbf4AuiszBb4VbbsqBGM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha20Core;\n\n    #[test]\n    fn test_from_seed() {\n        let seed: [u8; 32] = [\n            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n        ];\n        \n        let rng = ChaCha20Core::from_seed(seed);\n        \n        // Check if the rng state is correctly initialized\n        assert_eq!(rng.state.get_seed(), seed);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579100, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=268, prompt_tokens=872, total_tokens=1140, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclamEhJfvKMZtacyPiuzUN6wOySu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha20Core;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_generate() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha20Core::from_seed(seed);\n        let mut results = [0u32; 64];\n        \n        rng.generate(&mut results.into());\n        \n        // Check that results are populated\n        assert!(!results.iter().all(|&x| x == 0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579108, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=129, prompt_tokens=863, total_tokens=992, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclar280yu5irsbLwaGIiqSY9LXU9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha20Rng;\n\n    #[test]\n    fn test_fill_bytes() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha20Rng::from_seed(seed);\n        let mut bytes = [0; 16];\n\n        rng.fill_bytes(&mut bytes);\n\n        assert_ne!(bytes, [0; 16], "The filled bytes should not be all zeros.");\n    }\n\n    #[test]\n    fn test_fill_bytes_multiple() {\n        let seed: [u8; 32] = [1; 32];\n        let mut rng = ChaCha20Rng::from_seed(seed);\n        let mut bytes1 = [0; 16];\n        let mut bytes2 = [0; 16];\n\n        rng.fill_bytes(&mut bytes1);\n        rng.fill_bytes(&mut bytes2);\n\n        assert_ne!(bytes1, bytes2, "The filled bytes should not be the same for different calls.");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579113, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=227, prompt_tokens=2643, total_tokens=2870, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclazrOC2mUxObS8qRMj7Iq43iT5Z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_next_u32() {\n        let seed: [u8; 32] = [0; 32]; // Using a fixed seed for determinism\n        let mut rng = ChaCha20Rng::from_seed(seed);\n\n        let value1 = rng.next_u32();\n        let value2 = rng.next_u32();\n\n        // Ensure we get different values on consecutive calls\n        assert_ne!(value1, value2);\n\n        // Verify that values are within the proper range\n        assert!(value1 <= u32::MAX);\n        assert!(value2 <= u32::MAX);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579121, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=156, prompt_tokens=2642, total_tokens=2798, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclb4UI30tRzhwFj4xrINdiuA55hG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha20Rng;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_next_u64() {\n        // Arrange\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let mut rng = ChaCha20Rng::from_seed(seed);\n        \n        // Act\n        let value = rng.next_u64();\n        \n        // Assert\n        assert!(value != 0); // Assert that the value is not zero, indicating randomness\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579126, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=132, prompt_tokens=2642, total_tokens=2774, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbAmZr2C0EETOE2ABQdROJt4iYn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha20Rng;\n\n    #[test]\n    fn test_from_seed() {\n        let seed: [u8; 32] = [0; 32];\n        let rng = ChaCha20Rng::from_seed(seed);\n        \n        assert_eq!(rng.get_seed(), seed);\n    }\n\n    #[test]\n    fn test_from_seed_non_zero() {\n        let seed: [u8; 32] = [1; 32];\n        let rng = ChaCha20Rng::from_seed(seed);\n        \n        assert_eq!(rng.get_seed(), seed);\n    }\n\n    #[test]\n    fn test_from_seed_different_seeds() {\n        let seed1: [u8; 32] = [0; 32];\n        let seed2: [u8; 32] = [1; 32];\n        let rng1 = ChaCha20Rng::from_seed(seed1);\n        let rng2 = ChaCha20Rng::from_seed(seed2);\n\n        assert_ne!(rng1.get_seed(), rng2.get_seed());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579132, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=243, prompt_tokens=2662, total_tokens=2905, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbGHBjKxrEx0vepa92Id6Bqvuo2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha20Rng;\n\n    #[test]\n    fn test_eq_identical() {\n        let seed: [u8; 32] = [0u8; 32];\n        let rng1 = ChaCha20Rng::from_seed(seed);\n        let rng2 = ChaCha20Rng::from_seed(seed);\n        assert!(rng1.eq(&rng2));\n    }\n\n    #[test]\n    fn test_eq_different() {\n        let seed1: [u8; 32] = [0u8; 32];\n        let seed2: [u8; 32] = [1u8; 32];\n        let rng1 = ChaCha20Rng::from_seed(seed1);\n        let rng2 = ChaCha20Rng::from_seed(seed2);\n        assert!(!rng1.eq(&rng2));\n    }\n\n    #[test]\n    fn test_eq_different_states() {\n        let seed: [u8; 32] = [0u8; 32];\n        let mut rng1 = ChaCha20Rng::from_seed(seed);\n        let mut rng2 = ChaCha20Rng::from_seed(seed);\n        rng1.next_u32(); // Advance rng1\n        assert!(!rng1.eq(&rng2));\n    }\n\n    #[test]\n    fn test_eq_reflexivity() {\n        let seed: [u8; 32] = [0u8; 32];\n        let rng = ChaCha20Rng::from_seed(seed);\n        assert!(rng.eq(&rng));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579138, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=348, prompt_tokens=2668, total_tokens=3016, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbSg3TRXXAwKlimVfytWDDnMbe1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha20Core, ChaCha20Rng};\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_from_cha_cha_core() {\n        let seed: [u8; 32] = [0; 32];\n        let core = ChaCha20Core::from_seed(seed);\n        let rng: ChaCha20Rng = ChaCha20Rng::from(core);\n        \n        // Ensuring rng is initialized correctly\n        let random_value = rng.next_u32();\n        assert!(random_value != 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579150, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=139, prompt_tokens=2974, total_tokens=3113, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbXUJbXo1Q7u4pfUBoNV8yHvEAa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_from_seed() {\n        let seed: [u8; 32] = [1; 32]; // Example seed\n        let rng = chacha::ChaCha8Core::from_seed(seed);\n        \n        // Validate that the RNG is created and has the expected properties\n        assert_eq!(rng.state.get_seed(), seed);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579155, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=103, prompt_tokens=872, total_tokens=975, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbbesC2o8IMQwFWkMFG178QPFqU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_generate() {\n        let seed: [u8; 32] = [0u8; 32];\n        let mut rng = cha::ChaCha8Core::from_seed(seed);\n        let mut results: [u32; 64] = [0; 64];\n        \n        rng.generate(&mut results);\n\n        // Verify that the results are populated\n        assert!(!results.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579159, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=118, prompt_tokens=863, total_tokens=981, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclbg0ZSFgvCdR875AnYGyqV44oXC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha8Rng, SeedableRng};\n\n    #[test]\n    fn test_fill_bytes() {\n        let seed: [u8; 32] = [0; 32]; // Seed with zeros for reproducibility\n        let mut rng = ChaCha8Rng::from_seed(seed);\n        let mut bytes = [0u8; 16]; // A buffer of 16 bytes\n        rng.fill_bytes(&mut bytes);\n        \n        // Assert that bytes are filled with non-zero values\n        assert!(bytes.iter().any(|&b| b != 0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579164, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=145, prompt_tokens=2643, total_tokens=2788, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclblqpD0xnaLtJJDU40pgIq9OVUQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha8Rng, SeedableRng};\n\n    #[test]\n    fn test_next_u32() {\n        // Setup with a known seed\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha8Rng::from_seed(seed);\n\n        // Generate a known value\n        let value = rng.next_u32();\n\n        // Expected value can be derived from known output; adjust as necessary\n        let expected_value: u32 = 0; // Replace with actual expected output for seed [0; 32]\n        \n        assert_eq!(value, expected_value);\n    }\n\n    #[test]\n    fn test_next_u32_generates_different_values() {\n        let seed: [u8; 32] = [1; 32];\n        let mut rng1 = ChaCha8Rng::from_seed(seed);\n        let mut rng2 = ChaCha8Rng::from_seed(seed);\n\n        let value1 = rng1.next_u32();\n        let value2 = rng2.next_u32();\n\n        assert_eq!(value1, value2);\n\n        // Generate another value to check they are different\n        let value1_next = rng1.next_u32();\n        assert_ne!(value1, value1_next);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579169, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=289, prompt_tokens=2642, total_tokens=2931, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclbvaz9Sc6I8w5nIRnVkRJiCUeWd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha8Rng;\n\n    #[test]\n    fn test_next_u64() {\n        let seed: [u8; 32] = [0u8; 32];\n        let mut rng = ChaCha8Rng::from_seed(seed);\n        \n        let value = rng.next_u64();\n        \n        assert!(value <= u64::MAX);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579179, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=98, prompt_tokens=2642, total_tokens=2740, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclc1lGYkotGQpXj5j19SYA6WMQsT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha8Rng;\n\n    #[test]\n    fn test_from_seed() {\n        let seed: [u8; 32] = [0; 32];\n        let rng = ChaCha8Rng::from_seed(seed);\n\n        // Ensure that the RNG can produce values\n        let first_value = rng.next_u32();\n        let second_value = rng.next_u32();\n        \n        assert_ne!(first_value, second_value, "RNG should produce different values for different calls");\n\n        // Ensure that the RNG can be created with the same seed\n        let rng2 = ChaCha8Rng::from_seed(seed);\n        assert_eq!(rng.next_u32(), rng2.next_u32(), "RNG should produce the same value for the same seed");\n\n        // Ensure that different seeds produce different RNGs\n        let different_seed: [u8; 32] = [1; 32];\n        let rng3 = ChaCha8Rng::from_seed(different_seed);\n        assert_ne!(rng.next_u32(), rng3.next_u32(), "Different seeds should produce different RNGs");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579185, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=253, prompt_tokens=2662, total_tokens=2915, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclc9jCtBuguASLTnp4ZdoIrJyzwK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha8Rng, ChaCha12Core, SeedableRng};\n\n    #[test]\n    fn test_eq_identical() {\n        let seed: [u8; 32] = [0; 32];\n        let rng1 = ChaCha8Rng::from_seed(seed);\n        let rng2 = ChaCha8Rng::from_seed(seed);\n        assert!(rng1.eq(&rng2));\n    }\n\n    #[test]\n    fn test_eq_different() {\n        let seed1: [u8; 32] = [1; 32];\n        let seed2: [u8; 32] = [2; 32];\n        let rng1 = ChaCha8Rng::from_seed(seed1);\n        let rng2 = ChaCha8Rng::from_seed(seed2);\n        assert!(!rng1.eq(&rng2));\n    }\n\n    #[test]\n    fn test_eq_different_state() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng1 = ChaCha8Rng::from_seed(seed);\n        let mut rng2 = ChaCha8Rng::from_seed(seed);\n        \n        rng1.next_u32(); // Advance state\n        assert!(!rng1.eq(&rng2));\n    }\n\n    #[test]\n    fn test_eq_structural() {\n        let seed: [u8; 32] = [0; 32];\n        let rng1 = ChaCha8Rng::from_seed(seed);\n        let rng2 = rng1.clone(); // Clone to get equivalent state\n        assert!(rng1.eq(&rng2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579193, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=366, prompt_tokens=2668, total_tokens=3034, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcHX0XYXRWsVFzhLTA5NqPhYOYm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha8Core, ChaCha8Rng};\n\n    #[test]\n    fn test_from_cha_cha8_core() {\n        // Arrange\n        let seed: [u8; 32] = [0; 32]; // Replace with an actual seed if needed\n        let core = ChaCha8Core::from_seed(seed);\n\n        // Act\n        let rng: ChaCha8Rng = ChaCha8Rng::from(core);\n\n        // Assert\n        assert_eq!(rng.get_seed(), seed);\n    }\n\n    #[test]\n    fn test_from_cha_cha12_core() {\n        // Arrange\n        let seed: [u8; 32] = [0; 32]; // Replace with an actual seed if needed\n        let core = ChaCha12Core::from_seed(seed);\n\n        // Act\n        let rng: ChaCha8Rng = ChaCha8Rng::from(core);\n\n        // Assert\n        assert_eq!(rng.get_seed(), seed);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579201, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=231, prompt_tokens=2974, total_tokens=3205, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcRsxC5m7aRpByRonuiCEoGeHED', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha12Rng, ChaCha12Core}; // Adjust the import paths as necessary\n\n    #[test]\n    fn test_from() {\n        // Arrange\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let mut rng = ChaCha12Rng::from_seed(seed);\n        let expected_seed = rng.get_seed();\n        let expected_stream = rng.get_stream();\n        let expected_word_pos = rng.get_word_pos();\n\n        // Act\n        let result: ChaCha12Rng = ChaCha12Rng::from(&rng);\n\n        // Assert\n        assert_eq!(expected_seed, result.get_seed());\n        assert_eq!(expected_stream, result.get_stream());\n        assert_eq!(expected_word_pos, result.get_word_pos());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579211, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=186, prompt_tokens=2878, total_tokens=3064, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcYwhFF8HXrb9qlhwIqMaDvEfSt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha20Rng; // adjust the path if necessary\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_from_chacha20rng() {\n        // Create an instance of ChaCha20Rng\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha20Rng::from_seed(seed);\n\n        // Get the seed, stream, and word_pos\n        let seed_from_rng = rng.get_seed();\n        let stream_from_rng = rng.get_stream();\n        let word_pos_from_rng = rng.get_word_pos();\n\n        // Convert ChaCha20Rng to abstract ChaCha20Rng\n        let abstract_rng: abstract20::ChaCha20Rng = (&rng).into();\n\n        // Verify the values\n        assert_eq!(abstract_rng.seed, seed_from_rng);\n        assert_eq!(abstract_rng.stream, stream_from_rng);\n        assert_eq!(abstract_rng.word_pos, word_pos_from_rng);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579218, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=229, prompt_tokens=2878, total_tokens=3107, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcefBkfZtKoGry2ua0FNBhrQmWd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha8Rng;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_from_cha_cha8_rng() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha8Rng::from_seed(seed);\n        rng.set_stream(5);\n        rng.set_word_pos(10);\n\n        let cha_cha8_rng: abstract8::ChaCha8Rng = ChaCha8Rng::from(&rng);\n\n        assert_eq!(cha_cha8_rng.get_seed(), seed);\n        assert_eq!(cha_cha8_rng.get_stream(), 5);\n        assert_eq!(cha_cha8_rng.get_word_pos(), 10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579224, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=176, prompt_tokens=2878, total_tokens=3054, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclckXbmvLaBG6YghLq1rWWaekiTj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n    use rand_chacha::ChaCha12Rng;\n\n    #[test]\n    fn test_get_seed() {\n        let seed: [u8; 32] = [0u8; 32];\n        let rng = ChaCha12Rng::from_seed(seed);\n        let retrieved_seed = rng.get_seed();\n        assert_eq!(retrieved_seed, seed);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579230, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=104, prompt_tokens=2643, total_tokens=2747, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcpyVhtELtfZLvLXbPJ4uU4ciCW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_get_stream() {\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let rng = ChaCha12Rng::from_seed(seed);\n        let stream_number = rng.get_stream();\n        assert_eq!(stream_number, 0); // The initial stream number should be 0\n    }\n\n    #[test]\n    fn test_set_stream() {\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let mut rng = ChaCha12Rng::from_seed(seed);\n        rng.set_stream(42);\n        let stream_number = rng.get_stream();\n        assert_eq!(stream_number, 42); // The stream number should be set to 42\n    }\n\n    #[test]\n    fn test_get_stream_multiple() {\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let mut rng = ChaCha12Rng::from_seed(seed);\n        rng.set_stream(135);\n        assert_eq!(rng.get_stream(), 135); // Ensure stream number is correctly set\n        rng.set_stream(256);\n        assert_eq!(rng.get_stream(), 256); // Ensure stream number is correctly set again\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579235, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=295, prompt_tokens=2639, total_tokens=2934, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcwQwZiYufRODcza0vrz9I4Y0Fl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha12Rng, rand_core::SeedableRng};\n\n    #[test]\n    fn test_get_word_pos() {\n        // Arrange\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha12Rng::from_seed(seed);\n        \n        // Act\n        let word_pos = rng.get_word_pos();\n        \n        // Assert\n        assert_eq!(word_pos, 0); // Adjust the expected value based on the initial state of the RNG\n    }\n\n    #[test]\n    fn test_get_word_pos_after_generation() {\n        // Arrange\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha12Rng::from_seed(seed);\n        let initial_pos = rng.get_word_pos();\n        \n        // Generate some random numbers to change the state\n        rng.next_u32();\n        \n        // Act\n        let new_pos = rng.get_word_pos();\n        \n        // Assert\n        assert!(new_pos > initial_pos);\n    }\n\n    #[test]\n    fn test_get_word_pos_with_different_seeds() {\n        // Arrange\n        let seed1: [u8; 32] = [1; 32];\n        let seed2: [u8; 32] = [2; 32];\n        \n        let mut rng1 = ChaCha12Rng::from_seed(seed1);\n        let mut rng2 = ChaCha12Rng::from_seed(seed2);\n        \n        // Act\n        let pos1 = rng1.get_word_pos();\n        let pos2 = rng2.get_word_pos();\n        \n        // Assert\n        assert_ne!(pos1, pos2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579242, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=379, prompt_tokens=2878, total_tokens=3257, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcld8kLapTHdvs6DJLOLqJvE9uleY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_set_stream() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha12Rng::from_seed(seed);\n\n        let initial_stream = rng.get_stream();\n        let new_stream: u64 = 42;\n\n        rng.set_stream(new_stream);\n        let updated_stream = rng.get_stream();\n\n        assert_ne!(initial_stream, updated_stream);\n        assert_eq!(updated_stream, new_stream);\n    }\n\n    #[test]\n    fn test_set_stream_no_change() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha12Rng::from_seed(seed);\n\n        let initial_stream = rng.get_stream();\n        rng.set_stream(initial_stream);\n        let updated_stream = rng.get_stream();\n\n        assert_eq!(updated_stream, initial_stream);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579254, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=211, prompt_tokens=2808, total_tokens=3019, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldGMUx6lGbTJiDKbGAjOJ9B2wtY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_set_word_pos() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha12Rng::from_seed(seed);\n        \n        // Setting a known position\n        let word_pos: u128 = 100;\n\n        // Before setting position, get the current position\n        let initial_pos = rng.get_word_pos();\n        \n        // Set new word position\n        rng.set_word_pos(word_pos);\n        \n        // Check if the new position reflects the expected value\n        let new_pos = rng.get_word_pos();\n        assert_eq!(new_pos, word_pos);\n        \n        // Ensure the position has actually changed\n        assert_ne!(initial_pos, new_pos);\n    }\n\n    #[test]\n    fn test_set_word_pos_large_value() {\n        let seed: [u8; 32] = [1; 32];\n        let mut rng = ChaCha12Rng::from_seed(seed);\n        \n        // Setting a word position that is significantly larger than the maximum block\n        let word_pos: u128 = u128::MAX;\n\n        // Set new word position\n        rng.set_word_pos(word_pos);\n        \n        // Check if the new position reflects the expected value\n        let new_pos = rng.get_word_pos();\n        assert_eq!(new_pos, word_pos);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579262, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=308, prompt_tokens=2748, total_tokens=3056, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldO100nT7bOdMTYhBULVr3PB2lt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha20Rng, SeedableRng};\n\n    #[test]\n    fn test_get_seed() {\n        // Arrange\n        let seed: [u8; 32] = [\n            0u8, 1, 2, 3, 4, 5, 6, 7, \n            8, 9, 10, 11, 12, 13, 14, 15, \n            16, 17, 18, 19, 20, 21, 22, 23, \n            24, 25, 26, 27, 28, 29, 30, 31\n        ];\n        let rng = ChaCha20Rng::from_seed(seed);\n\n        // Act\n        let retrieved_seed = rng.get_seed();\n\n        // Assert\n        assert_eq!(retrieved_seed, seed);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579270, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=211, prompt_tokens=2643, total_tokens=2854, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldWsF0mW0sv8rLCiVjgMBHgPOkT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha20Rng;\n\n    #[test]\n    fn test_get_stream() {\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let mut rng = ChaCha20Rng::from_seed(seed);\n        \n        // Initially, the stream number should be 0\n        assert_eq!(rng.get_stream(), 0);\n        \n        // Set the stream number to a known value\n        let stream_value: u64 = 42;\n        rng.set_stream(stream_value);\n        \n        // Verify the stream number\n        assert_eq!(rng.get_stream(), stream_value);\n        \n        // Set the stream number to another value\n        let another_stream_value: u64 = 100;\n        rng.set_stream(another_stream_value);\n        \n        // Verify the stream number\n        assert_eq!(rng.get_stream(), another_stream_value);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579278, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=203, prompt_tokens=2639, total_tokens=2842, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldgfcP5phzlsqb0X8w8wjKPpwPc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_get_word_pos() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha20Rng::from_seed(seed);\n        \n        // Set some known word position\n        let test_position: u128 = 12; // Example position\n        rng.set_word_pos(test_position);\n        \n        // Get the current word position\n        let pos = rng.get_word_pos();\n        \n        // Calculate expected position\n        let expected_position = (rng.rng.core.state.get_block_pos() - 4).wrapping_add(test_position / 64) * 64 + (test_position % 64);\n        \n        // Ensure the calculated position matches the expected position\n        assert_eq!(pos, expected_position);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579288, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=190, prompt_tokens=2878, total_tokens=3068, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcldm0r6iT5KgpbKbOrObcDyGb201', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha20Rng, SeedableRng};\n\n    #[test]\n    fn test_set_stream() {\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let mut rng = ChaCha20Rng::from_seed(seed);\n\n        // Initially, the stream should be 0\n        assert_eq!(rng.get_stream(), 0);\n\n        // Set the stream to a new value\n        let new_stream = 42;\n        rng.set_stream(new_stream);\n\n        // The new stream value should now be reflected\n        assert_eq!(rng.get_stream(), new_stream);\n        \n        // Set the stream to another value\n        let another_stream = 12345;\n        rng.set_stream(another_stream);\n        \n        // Ensure the stream value has updated again\n        assert_eq!(rng.get_stream(), another_stream);\n    }\n\n    #[test]\n    fn test_set_stream_with_large_stream_value() {\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let mut rng = ChaCha20Rng::from_seed(seed);\n\n        // Set stream to a large value\n        let large_stream = u64::MAX; // maximum value for u64\n        rng.set_stream(large_stream);\n\n        // Check if the stream is correctly set to the large value\n        assert_eq!(rng.get_stream(), large_stream);\n    }\n\n    #[test]\n    fn test_set_stream_not_equal_after_set() {\n        let seed: [u8; 32] = [0; 32]; // Example seed\n        let mut rng = ChaCha20Rng::from_seed(seed);\n        \n        let stream1 = 10;\n        let stream2 = 20;\n        \n        rng.set_stream(stream1);\n        assert_ne!(rng.get_stream(), stream2);\n        \n        rng.set_stream(stream2);\n        assert_eq!(rng.get_stream(), stream2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579294, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=423, prompt_tokens=2808, total_tokens=3231, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcldyf0HzT8iK0MBObxXUHVQh6hqL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_set_word_pos() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha20Rng::from_seed(seed);\n\n        // Setting position to 0\n        rng.set_word_pos(0);\n        assert_eq!(rng.get_word_pos(), 0);\n\n        // Setting position to a positive word offset\n        let offset: u128 = 10; // arbitrary offset\n        rng.set_word_pos(offset);\n        assert_eq!(rng.get_word_pos(), offset);\n\n        // Setting position to a very large word offset\n        let large_offset: u128 = u128::MAX; // maximum offset\n        rng.set_word_pos(large_offset);\n        assert_eq!(rng.get_word_pos(), large_offset);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579306, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=192, prompt_tokens=2748, total_tokens=2940, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcle3xnl5BBN84EmdRnAIyjlHKEky', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha8Rng;\n\n    #[test]\n    fn test_get_seed() {\n        let seed: [u8; 32] = [0; 32]; // Test seed\n        let mut rng = ChaCha8Rng::from_seed(seed);\n        \n        // Ensure that the seed retrieved via get_seed matches the original seed\n        let retrieved_seed = rng.get_seed();\n        assert_eq!(retrieved_seed, seed);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579311, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=113, prompt_tokens=2643, total_tokens=2756, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcle7q82Dhx34htEtg4L0mC0vmuKT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust based on your module structure.\n    use rand_chacha::ChaCha8Rng;\n\n    #[test]\n    fn test_get_stream() {\n        let seed: [u8; 32] = [0; 32];\n        let rng = ChaCha8Rng::from_seed(seed);\n        let stream_number = rng.get_stream();\n        assert_eq!(stream_number, 0); // Assuming initial stream number is 0\n    }\n\n    #[test]\n    fn test_get_stream_after_setting_stream() {\n        let seed: [u8; 32] = [0; 32];\n        let mut rng = ChaCha8Rng::from_seed(seed);\n        rng.set_stream(42); // Setting stream number to 42\n        let stream_number = rng.get_stream();\n        assert_eq!(stream_number, 42);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579315, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=193, prompt_tokens=2639, total_tokens=2832, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcleDuJZUAjNGvXaAyWmTbSmbzy0p', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_get_word_pos() {\n        let seed: [u8; 32] = [0u8; 32];\n        let mut rng = ChaCha8Rng::from_seed(seed);\n        rng.set_word_pos(100);\n        let pos = rng.get_word_pos();\n        assert_eq!(pos, 100);\n        \n        rng.set_word_pos(0);\n        let pos_zero = rng.get_word_pos();\n        assert_eq!(pos_zero, 0);\n        \n        rng.set_word_pos(16);\n        let pos_sixteen = rng.get_word_pos();\n        assert_eq!(pos_sixteen, 16);\n        \n        rng.set_word_pos(256);\n        let pos_two_fifty_six = rng.get_word_pos();\n        assert_eq!(pos_two_fifty_six, 256);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579321, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=200, prompt_tokens=2878, total_tokens=3078, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcleIdqD20CsJAhPLDyDAKzuUebff', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha8Rng;\n    \n    #[test]\n    fn test_set_stream() {\n        // Create a new ChaCha8Rng instance with a known seed\n        let seed: [u8; 32] = [0u8; 32];\n        let mut rng = ChaCha8Rng::from_seed(seed);\n\n        // Set a specific stream\n        let stream_id: u64 = 10;\n        rng.set_stream(stream_id);\n\n        // Verify if the stream has been set correctly\n        assert_eq!(rng.get_stream(), stream_id);\n    }\n\n    #[test]\n    fn test_set_stream_sequential() {\n        let seed: [u8; 32] = [0u8; 32];\n        let mut rng = ChaCha8Rng::from_seed(seed);\n\n        // Set a stream, generate a number, then change stream\n        rng.set_stream(0);\n        let first_output = rng.next_u32();\n\n        rng.set_stream(1);\n        let second_output = rng.next_u32();\n\n        // Verify that the outputs are different with different streams\n        assert_ne!(first_output, second_output);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579326, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=260, prompt_tokens=2808, total_tokens=3068, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclePDBTt0uK3m036UzTYi0oReyXm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::ChaCha8Rng;\n\n    #[test]\n    fn test_set_word_pos() {\n        let seed = [0u8; 32];\n        let mut rng = ChaCha8Rng::from_seed(seed);\n\n        let initial_pos = rng.get_word_pos();\n        let new_pos = initial_pos + 16; // Move 16 words ahead\n\n        rng.set_word_pos(new_pos);\n        let current_pos = rng.get_word_pos();\n\n        assert_eq!(current_pos, new_pos);\n    }\n\n    #[test]\n    fn test_set_word_pos_zero() {\n        let seed = [0u8; 32];\n        let mut rng = ChaCha8Rng::from_seed(seed);\n\n        rng.set_word_pos(0);\n        let current_pos = rng.get_word_pos();\n\n        assert_eq!(current_pos, 0);\n    }\n\n    #[test]\n    fn test_set_word_pos_large_value() {\n        let seed = [0u8; 32];\n        let mut rng = ChaCha8Rng::from_seed(seed);\n\n        let max_word_pos = u128::MAX;\n        rng.set_word_pos(max_word_pos);\n        let current_pos = rng.get_word_pos();\n\n        assert_eq!(current_pos, max_word_pos % u128::from(BLOCK_WORDS));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579333, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=288, prompt_tokens=2748, total_tokens=3036, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcleY5ABekd0ZQ9G3pNLdeB299tpJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n    use rand_chacha::{ChaCha12Rng, abstract12::ChaCha12Rng as AbstractChaCha12Rng};\n\n    #[test]\n    fn test_from_cha_cha12_rng() {\n        // Given\n        let seed: [u8; 32] = [0; 32];\n        let mut original_rng = ChaCha12Rng::from_seed(seed);\n        original_rng.set_stream(1);\n        original_rng.set_word_pos(100);\n\n        // When\n        let abstract_rng: AbstractChaCha12Rng = AbstractChaCha12Rng::from(&original_rng);\n\n        // Then\n        assert_eq!(abstract_rng.get_seed(), seed);\n        assert_eq!(abstract_rng.get_stream(), 1);\n        assert_eq!(abstract_rng.get_word_pos(), 100);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579342, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=195, prompt_tokens=2897, total_tokens=3092, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcleeE9TgsizhaCmB1ECyG5KSRhrV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::SeedableRng;\n\n    #[test]\n    fn test_from() {\n        // Create a seed and stream for the Abstract ChaCha20Rng\n        let seed: [u8; 32] = [0u8; 32];\n        let stream: u64 = 42;\n        let word_pos: u128 = 0;\n\n        // Initialize the Abstract ChaCha20Rng\n        let abstract_rng = chacha::abstract20::ChaCha20Rng {\n            seed,\n            stream,\n            word_pos,\n        };\n\n        // Convert Abstract ChaCha20Rng to ChaCha20Rng\n        let cha_cha_rng: chacha::ChaCha20Rng = chacha::ChaCha20Rng::from(&abstract_rng);\n\n        // Check if the seed and stream match after conversion\n        assert_eq!(cha_cha_rng.get_seed(), abstract_rng.get_seed());\n        assert_eq!(cha_cha_rng.get_stream(), abstract_rng.get_stream());\n        assert_eq!(cha_cha_rng.get_word_pos(), abstract_rng.get_word_pos());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579348, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=243, prompt_tokens=2897, total_tokens=3140, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclekGfsOcTRYJ0vyP3huzeZjkMF9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{ChaCha8Rng, ChaCha12Core, SeedableRng};\n\n    #[test]\n    fn test_from_cha_cha_8_rng() {\n        let seed: [u8; 32] = [0; 32];\n        let original_rng = ChaCha8Rng::from_seed(seed);\n        \n        let cha_cha_12_rng: ChaCha12Core = ChaCha12Core::from(&original_rng);\n        \n        assert_eq!(cha_cha_12_rng.get_seed(), original_rng.get_seed());\n        assert_eq!(cha_cha_12_rng.get_stream(), original_rng.get_stream());\n        assert_eq!(cha_cha_12_rng.get_word_pos(), original_rng.get_word_pos());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579354, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=172, prompt_tokens=2897, total_tokens=3069, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclesiNITDrxdmefsLQHvwXdQtcWk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::guts::ChaCha;\n\n    #[test]\n    fn test_get_block_pos() {\n        let key = [0u8; 32];\n        let nonce = [0u8; 12]; // Adjust nonce length if needed\n        let mut cha_cha = ChaCha::new(&key, &nonce);\n        \n        // Initially, set a block position\n        cha_cha.set_block_pos(10);\n        \n        // Retrieve the block position\n        let block_pos = cha_cha.get_block_pos();\n        \n        // Assert the block position is as set\n        assert_eq!(block_pos, 10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579362, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=151, prompt_tokens=528, total_tokens=679, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclewK8Tbkd5EbZlJ7sezsB47H9Ar', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::guts::ChaCha;\n\n    #[test]\n    fn test_get_nonce() {\n        let key = [0u8; 32];\n        let nonce = [0u8; 12];\n        let mut chacha = ChaCha::new(&key, &nonce);\n\n        // Set nonce to a known value to test\n        let expected_nonce: u64 = 42;\n        chacha.set_nonce(expected_nonce);\n\n        // Retrieve the nonce using get_nonce\n        let actual_nonce = chacha.get_nonce();\n\n        // Assert that the retrieved nonce matches the expected value\n        assert_eq!(actual_nonce, expected_nonce);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579366, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=152, prompt_tokens=526, total_tokens=678, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclf1CvjBHDCfQWAN2bvVlynTIoRq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::guts::ChaCha;\n\n    #[test]\n    fn test_get_seed() {\n        let key: [u8; 32] = [0; 32];\n        let nonce: &[u8] = &[0; 12];\n        let chacha = ChaCha::new(&key, nonce);\n        let seed = chacha.get_seed();\n        \n        // Ensure the seed is the expected size\n        assert_eq!(seed.len(), 32);\n        \n        // This is a placeholder for a real test; replace with actual seed validation if available\n        assert_ne!(seed, [0; 32]); // Assuming we expect a non-zero seed\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579371, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=157, prompt_tokens=525, total_tokens=682, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclf7ixNIntjiR8xYKe4e9Y9V4qDy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::guts::ChaCha;\n\n    #[test]\n    fn test_new() {\n        let key: [u8; 32] = [0; 32];\n        let nonce: &[u8] = b"nonce";\n        let chacha_instance = ChaCha::new(&key, nonce);\n        \n        // Assuming you have a way to validate the internal state\n        assert_eq!(chacha_instance.get_seed(), key);\n        assert_eq!(chacha_instance.get_nonce(), 0); // Assuming nonce is initialized to 0\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579377, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=132, prompt_tokens=531, total_tokens=663, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfC7F3scwtAuvliS4k8T7rf90kO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::guts::ChaCha;\n\n    #[test]\n    fn test_refill4() {\n        let key: [u8; 32] = [0; 32];\n        let nonce: &[u8] = &[0; 12];\n        let mut chacha = ChaCha::new(&key, nonce);\n        let mut output: [u32; 4] = [0; 4];\n        let drounds: u32 = 20;\n\n        chacha.refill4(drounds, &mut output);\n\n        // Add assertions to verify the state of output\n        assert_eq!(output.len(), 4);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579382, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=156, prompt_tokens=557, total_tokens=713, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfHTxmVHecEA2EvpCykVgnMy17e', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::guts::ChaCha;\n\n    #[test]\n    fn test_set_block_pos() {\n        // Initialize with a sample key and nonce\n        let key = [0u8; 32];\n        let nonce = [0u8; 12];\n        let mut chacha = ChaCha::new(&key, &nonce);\n\n        // Set a block position\n        let block_pos: u64 = 12345;\n        chacha.set_block_pos(block_pos);\n\n        // Assert that the block position has been set correctly\n        assert_eq!(chacha.get_block_pos(), block_pos);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579387, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=143, prompt_tokens=532, total_tokens=675, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfMhFVxWbkZSC6mXCwyuGZ3vumW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::guts::ChaCha;\n\n    #[test]\n    fn test_set_nonce() {\n        let key = [0u8; 32];\n        let nonce = [0u8; 8];\n        let mut chacha = ChaCha::new(&key, &nonce);\n        \n        // Set nonce to a specific value\n        let value: u64 = 42;\n        chacha.set_nonce(value);\n        \n        // Check if the nonce is set correctly\n        assert_eq!(chacha.get_nonce(), value);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579392, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=130, prompt_tokens=530, total_tokens=660, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfSMvOwOf32iOMh1LEKIZft7Zmf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::guts;\n\n    struct MockMachine;\n\n    impl guts::Machine for MockMachine {\n        type u32x4 = [u32; 4];\n        type u64x2 = [u64; 2];\n\n        fn unpack(&self, value: [u64; 2]) -> Self::u32x4 {\n            [value[0] as u32, value[1] as u32, 0, 0] // Mock implementation for testing\n        }\n\n        fn vec(&self, input: [u64; 2]) -> Self::u64x2 {\n            input // Return input directly as mock behavior\n        }\n\n        fn into(self) -> [u64; 2] {\n            [0, 0] // Mock implementation\n        }\n    }\n\n    #[test]\n    fn test_add_pos() {\n        let mock_machine = MockMachine;\n        let d = mock_machine.vec([1, 2]);\n        let i = 5;\n\n        let result = guts::add_pos(mock_machine, d, i);\n        assert_eq!(result, [1 + 5, 2, 0, 0]); // Expected output based on mock implementation\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579398, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=271, prompt_tokens=220, total_tokens=491, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfZ4HqJ3iEqPhuOsxSSc5YpzlSg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::guts::{d0123, Machine, vec128_storage};\n\n    struct MockMachine;\n\n    impl Machine for MockMachine {\n        type u32x4x4 = [[u32; 4]; 4];\n        type u64x2 = [u64; 2];\n        type u64x2x4 = [[u64; 2]; 4];\n\n        fn unpack(&self, d: vec128_storage) -> Self::u64x2 {\n            // Mock unpacking logic\n        }\n\n        fn vec(&self, lanes: [u64; 2]) -> Self::u64x2 {\n            lanes\n        }\n    }\n\n    #[test]\n    fn test_d0123() {\n        let m = MockMachine;\n        let d = vec128_storage::default(); // Replace with valid initialization\n        let result = d0123(m, d);\n        \n        // Add assertions to verify the behavior of d0123\n        assert_eq!(result, expected_result); // Replace expected_result with actual expected value\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579405, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=238, prompt_tokens=278, total_tokens=516, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclffvIlgdfFD2iSZWrNDHvaQ2iln', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::guts::{diagonalize, State};\n\n    #[derive(Clone)]\n    struct MockLaneWords4([u32; 4]);\n\n    impl MockLaneWords4 {\n        fn new(arr: [u32; 4]) -> Self {\n            MockLaneWords4(arr)\n        }\n    }\n\n    impl LaneWords4 for MockLaneWords4 {\n        fn shuffle_lane_words3012(self) -> Self {\n            MockLaneWords4([self.0[3], self.0[0], self.0[1], self.0[2]])\n        }\n\n        fn shuffle_lane_words2301(self) -> Self {\n            MockLaneWords4([self.0[2], self.0[3], self.0[0], self.0[1]])\n        }\n\n        fn shuffle_lane_words1230(self) -> Self {\n            MockLaneWords4([self.0[1], self.0[2], self.0[3], self.0[0]])\n        }\n    }\n\n    #[test]\n    fn test_diagonalize() {\n        let state = State {\n            a: MockLaneWords4::new([1, 2, 3, 4]),\n            b: MockLaneWords4::new([5, 6, 7, 8]),\n            c: MockLaneWords4::new([9, 10, 11, 12]),\n            d: MockLaneWords4::new([13, 14, 15, 16]),\n        };\n\n        let result = diagonalize(state.clone());\n\n        assert_ne!(result.b, state.b);\n        assert_ne!(result.c, state.c);\n        assert_ne!(result.d, state.d);\n        assert_eq!(result.a, state.a); // a should remain unchanged\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579411, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=388, prompt_tokens=279, total_tokens=667, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfoKqBTet3aM7bXhltoFQO2gWUB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_read_u32le() {\n        let input: &[u8] = &[1, 2, 3, 4];\n        let result = read_u32le(input);\n        assert_eq!(result, 0x04030201);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_read_u32le_panic_on_short_input() {\n        let input: &[u8] = &[1, 2, 3];\n        read_u32le(input);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_read_u32le_panic_on_long_input() {\n        let input: &[u8] = &[1, 2, 3, 4, 5];\n        read_u32le(input);\n    }\n\n    #[test]\n    fn test_read_u32le_edge_case() {\n        let input: &[u8] = &[0, 0, 0, 0];\n        let result = read_u32le(input);\n        assert_eq!(result, 0x00000000);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579420, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=244, prompt_tokens=213, total_tokens=457, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfubCZru4lvtSwut8pp8SiQqQdI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::{guts::{ChaCha, refill_wide_impl}, Machine}; // Update the import as needed\n    use rand_chacha::guts::vec128_storage; // Update the import as needed\n    \n    struct DummyMachine; // Dummy machine to implement the Machine trait\n    \n    impl Machine for DummyMachine {\n        type u32x4x4 = DummyU32x4x4;\n\n        fn vec(&self, lanes: [u32; 4]) -> Self::u32x4x4 {\n            Self::u32x4x4::from_lanes(lanes)\n        }\n\n        fn unpack(&self, value: vec128_storage) -> u32 {\n            // Implement as needed for your tests\n        }\n\n        fn to_scalars(&self, value: Self::u32x4x4) -> [u32; 4] {\n            // Implement as needed for your tests\n        }\n    }\n\n    struct DummyU32x4x4; // Dummy struct for the example\n    \n    impl DummyU32x4x4 {\n        fn from_lanes(lanes: [u32; 4]) -> Self {\n            // Create DummyU32x4x4 from lanes\n        }\n        // Implement necessary operations\n    }\n\n    #[test]\n    fn test_refill_wide_impl() {\n        let mut state = ChaCha::new(&[0u8; 32], &[0u8; 8]);\n        let mut output: [u32; BUFSZ] = [0; BUFSZ];\n        let drounds = 20;\n\n        refill_wide_impl(DummyMachine, &mut state, drounds, &mut output);\n\n        // Assert output values and the state as needed\n        // For example:\n        // assert_eq!(output, expected_output);\n        // assert_eq!(state.get_block_pos(), expected_block_pos);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579426, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=412, prompt_tokens=979, total_tokens=1391, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclg4oLy26HYCih4DsWajD7ZfTzFs', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::guts::State;\n\n    struct TestArithOps;\n    struct TestBitOps32;\n\n    impl ArithOps for TestArithOps {\n        // Implement necessary arithmetic operations\n    }\n\n    impl BitOps32 for TestBitOps32 {\n        // Implement necessary bit operations\n    }\n\n    #[test]\n    fn test_round() {\n        let initial_state = State {\n            a: TestArithOps,\n            b: TestArithOps,\n            c: TestArithOps,\n            d: TestArithOps,\n        };\n\n        let result = round(initial_state.clone());\n\n        // Add assertions to check if the result matches the expected values\n        assert_eq!(result.a, /* expected value */);\n        assert_eq!(result.b, /* expected value */);\n        assert_eq!(result.c, /* expected value */);\n        assert_eq!(result.d, /* expected value */);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579436, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=205, prompt_tokens=338, total_tokens=543, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclgCZIiQdSUukjd7Bd7miIj5pRya', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_chacha::guts::{State, LaneWords4};\n\n    struct TestLaneWords4([u32; 4]);\n\n    impl LaneWords4 for TestLaneWords4 {}\n\n    #[test]\n    fn test_undiagonalize() {\n        let initial_state = State {\n            a: TestLaneWords4([1, 2, 3, 4]),\n            b: TestLaneWords4([5, 6, 7, 8]),\n            c: TestLaneWords4([9, 10, 11, 12]),\n            d: TestLaneWords4([13, 14, 15, 16]),\n        };\n\n        let result_state = undiagonalize(initial_state.clone());\n\n        assert_ne!(result_state.b, initial_state.b);\n        assert_ne!(result_state.c, initial_state.c);\n        assert_ne!(result_state.d, initial_state.d);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579444, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=204, prompt_tokens=281, total_tokens=485, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
({'dependencies': {'<chacha::Array64<T> as std::clone::Clone>::clone': ['chacha::Array64', 'std::marker::Sized'], '<chacha::Array64<T> as std::convert::AsMut<[T]>>::as_mut': ['chacha::Array64', 'std::marker::Sized'], '<chacha::Array64<T> as std::convert::AsRef<[T]>>::as_ref': ['chacha::Array64', 'std::marker::Sized'], '<chacha::Array64<T> as std::default::Default>::default': ['chacha::Array64', 'std::marker::Sized'], '<chacha::Array64<T> as std::fmt::Debug>::fmt': ['chacha::Array64', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<chacha::ChaCha12Core as rand_core::SeedableRng>::from_seed': ['chacha::ChaCha12Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha12Core as rand_core::block::BlockRngCore>::generate': ['chacha::ChaCha12Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha12Core as std::clone::Clone>::clone': ['chacha::ChaCha12Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha12Core as std::cmp::Eq>::assert_receiver_is_total_eq': ['chacha::ChaCha12Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha12Core as std::cmp::PartialEq>::eq': ['chacha::ChaCha12Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha12Core as std::fmt::Debug>::fmt': ['chacha::ChaCha12Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<chacha::ChaCha12Rng as rand_core::RngCore>::fill_bytes': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha12Rng as rand_core::RngCore>::next_u32': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha12Rng as rand_core::RngCore>::next_u64': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha12Rng as rand_core::SeedableRng>::from_seed': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha12Rng as std::clone::Clone>::clone': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha12Rng as std::cmp::PartialEq>::eq': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha12Rng as std::convert::From<chacha::ChaCha12Core>>::from': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha12Rng as std::fmt::Debug>::fmt': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<chacha::ChaCha20Core as rand_core::SeedableRng>::from_seed': ['chacha::ChaCha20Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha20Core as rand_core::block::BlockRngCore>::generate': ['chacha::ChaCha20Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha20Core as std::clone::Clone>::clone': ['chacha::ChaCha20Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha20Core as std::cmp::Eq>::assert_receiver_is_total_eq': ['chacha::ChaCha20Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha20Core as std::cmp::PartialEq>::eq': ['chacha::ChaCha20Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha20Core as std::fmt::Debug>::fmt': ['chacha::ChaCha20Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<chacha::ChaCha20Rng as rand_core::RngCore>::fill_bytes': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha20Rng as rand_core::RngCore>::next_u32': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha20Rng as rand_core::RngCore>::next_u64': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha20Rng as rand_core::SeedableRng>::from_seed': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha20Rng as std::clone::Clone>::clone': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha20Rng as std::cmp::PartialEq>::eq': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha20Rng as std::convert::From<chacha::ChaCha20Core>>::from': ['chacha::ChaCha12Core', 'chacha::ChaCha20Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha20Rng as std::fmt::Debug>::fmt': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<chacha::ChaCha8Core as rand_core::SeedableRng>::from_seed': ['chacha::ChaCha8Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha8Core as rand_core::block::BlockRngCore>::generate': ['chacha::ChaCha8Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha8Core as std::clone::Clone>::clone': ['chacha::ChaCha8Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha8Core as std::cmp::Eq>::assert_receiver_is_total_eq': ['chacha::ChaCha8Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha8Core as std::cmp::PartialEq>::eq': ['chacha::ChaCha8Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], '<chacha::ChaCha8Core as std::fmt::Debug>::fmt': ['chacha::ChaCha8Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<chacha::ChaCha8Rng as rand_core::RngCore>::fill_bytes': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha8Rng as rand_core::RngCore>::next_u32': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha8Rng as rand_core::RngCore>::next_u64': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha8Rng as rand_core::SeedableRng>::from_seed': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha8Rng as std::clone::Clone>::clone': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha8Rng as std::cmp::PartialEq>::eq': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha8Rng as std::convert::From<chacha::ChaCha8Core>>::from': ['chacha::ChaCha12Core', 'chacha::ChaCha8Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::ChaCha8Rng as std::fmt::Debug>::fmt': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<chacha::abstract12::ChaCha12Rng as std::cmp::Eq>::assert_receiver_is_total_eq': ['chacha::abstract12::ChaCha12Rng'], '<chacha::abstract12::ChaCha12Rng as std::cmp::PartialEq>::eq': ['chacha::abstract12::ChaCha12Rng'], '<chacha::abstract12::ChaCha12Rng as std::convert::From<&chacha::ChaCha12Rng>>::from': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'chacha::abstract12::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::abstract12::ChaCha12Rng as std::fmt::Debug>::fmt': ['chacha::abstract12::ChaCha12Rng', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<chacha::abstract20::ChaCha20Rng as std::cmp::Eq>::assert_receiver_is_total_eq': ['chacha::abstract20::ChaCha20Rng'], '<chacha::abstract20::ChaCha20Rng as std::cmp::PartialEq>::eq': ['chacha::abstract20::ChaCha20Rng'], '<chacha::abstract20::ChaCha20Rng as std::convert::From<&chacha::ChaCha20Rng>>::from': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'chacha::abstract20::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::abstract20::ChaCha20Rng as std::fmt::Debug>::fmt': ['chacha::abstract20::ChaCha20Rng', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<chacha::abstract8::ChaCha8Rng as std::cmp::Eq>::assert_receiver_is_total_eq': ['chacha::abstract8::ChaCha8Rng'], '<chacha::abstract8::ChaCha8Rng as std::cmp::PartialEq>::eq': ['chacha::abstract8::ChaCha8Rng'], '<chacha::abstract8::ChaCha8Rng as std::convert::From<&chacha::ChaCha8Rng>>::from': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'chacha::abstract8::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], '<chacha::abstract8::ChaCha8Rng as std::fmt::Debug>::fmt': ['chacha::abstract8::ChaCha8Rng', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<guts::ChaCha as std::clone::Clone>::clone': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], '<guts::ChaCha as std::cmp::Eq>::assert_receiver_is_total_eq': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], '<guts::ChaCha as std::cmp::PartialEq>::eq': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], '<guts::State<V> as std::clone::Clone>::clone': ['guts::State', 'std::marker::Sized'], 'chacha::Array64': ['chacha::Array64', 'std::marker::Sized'], 'chacha::ChaCha12Core': ['chacha::ChaCha12Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], 'chacha::ChaCha12Rng': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha12Rng::get_seed': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha12Rng::get_stream': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha12Rng::get_word_pos': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha12Rng::set_stream': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha12Rng::set_word_pos': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha20Core': ['chacha::ChaCha20Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], 'chacha::ChaCha20Rng': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha20Rng::get_seed': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha20Rng::get_stream': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha20Rng::get_word_pos': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha20Rng::set_stream': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha20Rng::set_word_pos': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha8Core': ['chacha::ChaCha8Core', 'guts::ChaCha', 'ppv_lite86::vec128_storage'], 'chacha::ChaCha8Rng': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha8Rng::get_seed': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha8Rng::get_stream': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha8Rng::get_word_pos': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha8Rng::set_stream': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::ChaCha8Rng::set_word_pos': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::abstract12::<impl std::convert::From<&chacha::abstract12::ChaCha12Rng> for chacha::ChaCha12Rng>::from': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'chacha::abstract12::ChaCha12Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::abstract12::ChaCha12Rng': ['chacha::abstract12::ChaCha12Rng'], 'chacha::abstract20::<impl std::convert::From<&chacha::abstract20::ChaCha20Rng> for chacha::ChaCha20Rng>::from': ['chacha::ChaCha12Core', 'chacha::ChaCha20Rng', 'chacha::abstract20::ChaCha20Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::abstract20::ChaCha20Rng': ['chacha::abstract20::ChaCha20Rng'], 'chacha::abstract8::<impl std::convert::From<&chacha::abstract8::ChaCha8Rng> for chacha::ChaCha8Rng>::from': ['chacha::ChaCha12Core', 'chacha::ChaCha8Rng', 'chacha::abstract8::ChaCha8Rng', 'guts::ChaCha', 'ppv_lite86::vec128_storage', 'rand_core::block::BlockRng', 'rand_core::block::BlockRngCore', 'std::marker::Sized'], 'chacha::abstract8::ChaCha8Rng': ['chacha::abstract8::ChaCha8Rng'], 'guts::ChaCha': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::ChaCha::get_block_pos': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::ChaCha::get_nonce': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::ChaCha::get_seed': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::ChaCha::new': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::ChaCha::refill4': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::ChaCha::set_block_pos': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::ChaCha::set_nonce': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::State': ['guts::State', 'std::marker::Sized'], 'guts::add_pos': ['ppv_lite86::Machine', 'std::marker::Sized'], 'guts::d0123': ['ppv_lite86::Machine', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::diagonalize': ['guts::State', 'ppv_lite86::LaneWords4', 'std::marker::Sized'], 'guts::get_seed': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::get_seed::fn_impl': ['guts::ChaCha', 'ppv_lite86::Machine', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::get_seed::impl_avx': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::get_seed::impl_sse2': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::get_stream_param': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::get_stream_param::fn_impl': ['guts::ChaCha', 'ppv_lite86::Machine', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::get_stream_param::impl_avx': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::get_stream_param::impl_sse2': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::init_chacha': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::init_chacha::fn_impl': ['guts::ChaCha', 'ppv_lite86::Machine', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::init_chacha::impl_avx': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::init_chacha::impl_sse2': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::init_chacha_x': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::init_chacha_x::fn_impl': ['guts::ChaCha', 'ppv_lite86::Machine', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::init_chacha_x::impl_avx': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::init_chacha_x::impl_sse2': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::read_u32le': [], 'guts::refill_narrow_rounds': ['guts::ChaCha', 'guts::State', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::refill_narrow_rounds::fn_impl': ['guts::ChaCha', 'guts::State', 'ppv_lite86::Machine', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::refill_narrow_rounds::impl_avx': ['guts::ChaCha', 'guts::State', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::refill_narrow_rounds::impl_avx2': ['guts::ChaCha', 'guts::State', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::refill_narrow_rounds::impl_sse2': ['guts::ChaCha', 'guts::State', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::refill_narrow_rounds::impl_sse41': ['guts::ChaCha', 'guts::State', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::refill_narrow_rounds::impl_ssse3': ['guts::ChaCha', 'guts::State', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::refill_wide': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::refill_wide::fn_impl': ['guts::ChaCha', 'ppv_lite86::Machine', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::refill_wide::impl_avx': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::refill_wide::impl_avx2': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::refill_wide::impl_sse2': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::refill_wide::impl_sse41': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::refill_wide::impl_ssse3': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::refill_wide_impl': ['guts::ChaCha', 'ppv_lite86::Machine', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::round': ['guts::State', 'ppv_lite86::ArithOps', 'ppv_lite86::BitOps32', 'std::marker::Sized'], 'guts::set_stream_param': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::set_stream_param::fn_impl': ['guts::ChaCha', 'ppv_lite86::Machine', 'ppv_lite86::vec128_storage', 'std::marker::Sized'], 'guts::set_stream_param::impl_avx': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::set_stream_param::impl_sse2': ['guts::ChaCha', 'ppv_lite86::vec128_storage'], 'guts::undiagonalize': ['guts::State', 'ppv_lite86::LaneWords4', 'std::marker::Sized']}, 'glob_path_import': {}, 'self_to_fn': {'chacha::Array64': ['impl<T> AsMut<[T]> for Array64<T> {\n    fn as_mut(&mut self) -> &mut [T] {\n        &mut self.0\n    }\n}', 'impl<T> AsRef<[T]> for Array64<T> {\n    fn as_ref(&self) -> &[T] {\n        &self.0\n    }\n}', 'impl<T> Clone for Array64<T>\nwhere\n    T: Copy + Default,\n{\n    fn clone(&self) -> Self {\n        let mut new = Self::default();\n        new.0.copy_from_slice(&self.0);\n        new\n    }\n}', 'impl<T> Default for Array64<T>\nwhere\n    T: Default,\n{\n    #[rustfmt::skip]\n    fn default() -> Self {\n        Self([\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n        ])\n    }\n}', 'impl<T> fmt::Debug for Array64<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, "Array64 {{}}")\n    }\n}'], 'chacha::ChaCha12Core': ['Clone', 'Eq', 'PartialEq', 'impl BlockRngCore for $ChaChaXCore {\n            type Item = u32;\n            type Results = Array64<u32>;\n\n            #[inline]\n            fn generate(&mut self, r: &mut Self::Results) {\n                self.state.refill4($rounds, &mut r.0);\n            }\n        }', 'impl CryptoBlockRng for $ChaChaXCore {}', 'impl SeedableRng for $ChaChaXCore {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }\n        }', 'impl fmt::Debug for $ChaChaXCore {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                write!(f, "ChaChaXCore {{}}")\n            }\n        }'], 'chacha::ChaCha12Rng': ['Clone', 'Debug', 'impl $ChaChaXRng {\n            // The buffer is a 4-block window, i.e. it is always at a block-aligned position in the\n            // stream but if the stream has been sought it may not be self-aligned.\n\n            /// Get the offset from the start of the stream, in 32-bit words.\n            ///\n            /// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n            /// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n            /// not supported, hence the result can simply be multiplied by 4 to get a\n            /// byte-offset.\n            #[inline]\n            pub fn get_word_pos(&self) -> u128 {\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }\n\n            /// Set the offset from the start of the stream, in 32-bit words.\n            ///\n            /// As with `get_word_pos`, we use a 68-bit number. Since the generator\n            /// simply cycles at the end of its period (1 ZiB), we ignore the upper\n            /// 60 bits.\n            #[inline]\n            pub fn set_word_pos(&mut self, word_offset: u128) {\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }\n\n            /// Set the stream number.\n            ///\n            /// This is initialized to zero; 2<sup>64</sup> unique streams of output\n            /// are available per seed/key.\n            ///\n            /// Note that in order to reproduce ChaCha output with a specific 64-bit\n            /// nonce, one can convert that nonce to a `u64` in little-endian fashion\n            /// and pass to this function. In theory a 96-bit nonce can be used by\n            /// passing the last 64-bits to this function and using the first 32-bits as\n            /// the most significant half of the 64-bit counter (which may be set\n            /// indirectly via `set_word_pos`), but this is not directly supported.\n            #[inline]\n            pub fn set_stream(&mut self, stream: u64) {\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }\n\n            /// Get the stream number.\n            #[inline]\n            pub fn get_stream(&self) -> u64 {\n                self.rng.core.state.get_nonce()\n            }\n\n            /// Get the seed.\n            #[inline]\n            pub fn get_seed(&self) -> [u8; 32] {\n                self.rng.core.state.get_seed()\n            }\n        }', 'impl CryptoRng for $ChaChaXRng {}', 'impl Eq for $ChaChaXRng {}', 'impl From<$ChaChaXCore> for $ChaChaXRng {\n            fn from(core: $ChaChaXCore) -> Self {\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }', 'impl From<&$ChaChaXRng> for super::$ChaChaXRng {\n                // Construct one of the possible concrete RNGs realizing an abstract state.\n                fn from(a: &$ChaChaXRng) -> Self {\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }\n            }', 'impl PartialEq<$ChaChaXRng> for $ChaChaXRng {\n            fn eq(&self, rhs: &$ChaChaXRng) -> bool {\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }\n        }', 'impl RngCore for $ChaChaXRng {\n            #[inline]\n            fn next_u32(&mut self) -> u32 {\n                self.rng.next_u32()\n            }\n\n            #[inline]\n            fn next_u64(&mut self) -> u64 {\n                self.rng.next_u64()\n            }\n\n            #[inline]\n            fn fill_bytes(&mut self, bytes: &mut [u8]) {\n                self.rng.fill_bytes(bytes)\n            }\n        }', 'impl SeedableRng for $ChaChaXRng {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }'], 'chacha::ChaCha20Core': ['Clone', 'Eq', 'PartialEq', 'impl BlockRngCore for $ChaChaXCore {\n            type Item = u32;\n            type Results = Array64<u32>;\n\n            #[inline]\n            fn generate(&mut self, r: &mut Self::Results) {\n                self.state.refill4($rounds, &mut r.0);\n            }\n        }', 'impl CryptoBlockRng for $ChaChaXCore {}', 'impl SeedableRng for $ChaChaXCore {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }\n        }', 'impl fmt::Debug for $ChaChaXCore {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                write!(f, "ChaChaXCore {{}}")\n            }\n        }'], 'chacha::ChaCha20Rng': ['Clone', 'Debug', 'impl $ChaChaXRng {\n            // The buffer is a 4-block window, i.e. it is always at a block-aligned position in the\n            // stream but if the stream has been sought it may not be self-aligned.\n\n            /// Get the offset from the start of the stream, in 32-bit words.\n            ///\n            /// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n            /// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n            /// not supported, hence the result can simply be multiplied by 4 to get a\n            /// byte-offset.\n            #[inline]\n            pub fn get_word_pos(&self) -> u128 {\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }\n\n            /// Set the offset from the start of the stream, in 32-bit words.\n            ///\n            /// As with `get_word_pos`, we use a 68-bit number. Since the generator\n            /// simply cycles at the end of its period (1 ZiB), we ignore the upper\n            /// 60 bits.\n            #[inline]\n            pub fn set_word_pos(&mut self, word_offset: u128) {\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }\n\n            /// Set the stream number.\n            ///\n            /// This is initialized to zero; 2<sup>64</sup> unique streams of output\n            /// are available per seed/key.\n            ///\n            /// Note that in order to reproduce ChaCha output with a specific 64-bit\n            /// nonce, one can convert that nonce to a `u64` in little-endian fashion\n            /// and pass to this function. In theory a 96-bit nonce can be used by\n            /// passing the last 64-bits to this function and using the first 32-bits as\n            /// the most significant half of the 64-bit counter (which may be set\n            /// indirectly via `set_word_pos`), but this is not directly supported.\n            #[inline]\n            pub fn set_stream(&mut self, stream: u64) {\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }\n\n            /// Get the stream number.\n            #[inline]\n            pub fn get_stream(&self) -> u64 {\n                self.rng.core.state.get_nonce()\n            }\n\n            /// Get the seed.\n            #[inline]\n            pub fn get_seed(&self) -> [u8; 32] {\n                self.rng.core.state.get_seed()\n            }\n        }', 'impl CryptoRng for $ChaChaXRng {}', 'impl Eq for $ChaChaXRng {}', 'impl From<$ChaChaXCore> for $ChaChaXRng {\n            fn from(core: $ChaChaXCore) -> Self {\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }', 'impl From<&$ChaChaXRng> for super::$ChaChaXRng {\n                // Construct one of the possible concrete RNGs realizing an abstract state.\n                fn from(a: &$ChaChaXRng) -> Self {\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }\n            }', 'impl PartialEq<$ChaChaXRng> for $ChaChaXRng {\n            fn eq(&self, rhs: &$ChaChaXRng) -> bool {\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }\n        }', 'impl RngCore for $ChaChaXRng {\n            #[inline]\n            fn next_u32(&mut self) -> u32 {\n                self.rng.next_u32()\n            }\n\n            #[inline]\n            fn next_u64(&mut self) -> u64 {\n                self.rng.next_u64()\n            }\n\n            #[inline]\n            fn fill_bytes(&mut self, bytes: &mut [u8]) {\n                self.rng.fill_bytes(bytes)\n            }\n        }', 'impl SeedableRng for $ChaChaXRng {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }'], 'chacha::ChaCha8Core': ['Clone', 'Eq', 'PartialEq', 'impl BlockRngCore for $ChaChaXCore {\n            type Item = u32;\n            type Results = Array64<u32>;\n\n            #[inline]\n            fn generate(&mut self, r: &mut Self::Results) {\n                self.state.refill4($rounds, &mut r.0);\n            }\n        }', 'impl CryptoBlockRng for $ChaChaXCore {}', 'impl SeedableRng for $ChaChaXCore {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }\n        }', 'impl fmt::Debug for $ChaChaXCore {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                write!(f, "ChaChaXCore {{}}")\n            }\n        }'], 'chacha::ChaCha8Rng': ['Clone', 'Debug', 'impl $ChaChaXRng {\n            // The buffer is a 4-block window, i.e. it is always at a block-aligned position in the\n            // stream but if the stream has been sought it may not be self-aligned.\n\n            /// Get the offset from the start of the stream, in 32-bit words.\n            ///\n            /// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n            /// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n            /// not supported, hence the result can simply be multiplied by 4 to get a\n            /// byte-offset.\n            #[inline]\n            pub fn get_word_pos(&self) -> u128 {\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }\n\n            /// Set the offset from the start of the stream, in 32-bit words.\n            ///\n            /// As with `get_word_pos`, we use a 68-bit number. Since the generator\n            /// simply cycles at the end of its period (1 ZiB), we ignore the upper\n            /// 60 bits.\n            #[inline]\n            pub fn set_word_pos(&mut self, word_offset: u128) {\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }\n\n            /// Set the stream number.\n            ///\n            /// This is initialized to zero; 2<sup>64</sup> unique streams of output\n            /// are available per seed/key.\n            ///\n            /// Note that in order to reproduce ChaCha output with a specific 64-bit\n            /// nonce, one can convert that nonce to a `u64` in little-endian fashion\n            /// and pass to this function. In theory a 96-bit nonce can be used by\n            /// passing the last 64-bits to this function and using the first 32-bits as\n            /// the most significant half of the 64-bit counter (which may be set\n            /// indirectly via `set_word_pos`), but this is not directly supported.\n            #[inline]\n            pub fn set_stream(&mut self, stream: u64) {\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }\n\n            /// Get the stream number.\n            #[inline]\n            pub fn get_stream(&self) -> u64 {\n                self.rng.core.state.get_nonce()\n            }\n\n            /// Get the seed.\n            #[inline]\n            pub fn get_seed(&self) -> [u8; 32] {\n                self.rng.core.state.get_seed()\n            }\n        }', 'impl CryptoRng for $ChaChaXRng {}', 'impl Eq for $ChaChaXRng {}', 'impl From<$ChaChaXCore> for $ChaChaXRng {\n            fn from(core: $ChaChaXCore) -> Self {\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }', 'impl From<&$ChaChaXRng> for super::$ChaChaXRng {\n                // Construct one of the possible concrete RNGs realizing an abstract state.\n                fn from(a: &$ChaChaXRng) -> Self {\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }\n            }', 'impl PartialEq<$ChaChaXRng> for $ChaChaXRng {\n            fn eq(&self, rhs: &$ChaChaXRng) -> bool {\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }\n        }', 'impl RngCore for $ChaChaXRng {\n            #[inline]\n            fn next_u32(&mut self) -> u32 {\n                self.rng.next_u32()\n            }\n\n            #[inline]\n            fn next_u64(&mut self) -> u64 {\n                self.rng.next_u64()\n            }\n\n            #[inline]\n            fn fill_bytes(&mut self, bytes: &mut [u8]) {\n                self.rng.fill_bytes(bytes)\n            }\n        }', 'impl SeedableRng for $ChaChaXRng {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }'], 'chacha::abstract12::ChaCha12Rng': ['Debug', 'Eq', 'PartialEq', 'impl From<&super::$ChaChaXRng> for $ChaChaXRng {\n                // Forget all information about the input except what is necessary to determine the\n                // outputs of any sequence of pub API calls.\n                fn from(r: &super::$ChaChaXRng) -> Self {\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }\n            }'], 'chacha::abstract20::ChaCha20Rng': ['Debug', 'Eq', 'PartialEq', 'impl From<&super::$ChaChaXRng> for $ChaChaXRng {\n                // Forget all information about the input except what is necessary to determine the\n                // outputs of any sequence of pub API calls.\n                fn from(r: &super::$ChaChaXRng) -> Self {\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }\n            }'], 'chacha::abstract8::ChaCha8Rng': ['Debug', 'Eq', 'PartialEq', 'impl From<&super::$ChaChaXRng> for $ChaChaXRng {\n                // Forget all information about the input except what is necessary to determine the\n                // outputs of any sequence of pub API calls.\n                fn from(r: &super::$ChaChaXRng) -> Self {\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }\n            }'], 'guts::ChaCha': ['Clone', 'Eq', 'PartialEq', 'impl ChaCha {\n    #[inline(always)]\n    pub fn new(key: &[u8; 32], nonce: &[u8]) -> Self {\n        init_chacha(key, nonce)\n    }\n\n    /// Produce 4 blocks of output, advancing the state\n    #[inline(always)]\n    pub fn refill4(&mut self, drounds: u32, out: &mut [u32; BUFSZ]) {\n        refill_wide(self, drounds, out)\n    }\n\n    #[inline(always)]\n    pub fn set_block_pos(&mut self, value: u64) {\n        set_stream_param(self, STREAM_PARAM_BLOCK, value)\n    }\n\n    #[inline(always)]\n    pub fn get_block_pos(&self) -> u64 {\n        get_stream_param(self, STREAM_PARAM_BLOCK)\n    }\n\n    #[inline(always)]\n    pub fn set_nonce(&mut self, value: u64) {\n        set_stream_param(self, STREAM_PARAM_NONCE, value)\n    }\n\n    #[inline(always)]\n    pub fn get_nonce(&self) -> u64 {\n        get_stream_param(self, STREAM_PARAM_NONCE)\n    }\n\n    #[inline(always)]\n    pub fn get_seed(&self) -> [u8; 32] {\n        get_seed(self)\n    }\n}'], 'guts::State': ['Clone']}, 'single_path_import': {'chacha::ChaCha12Core': 'ChaCha12Core', 'chacha::ChaCha12Rng': 'ChaCha12Rng', 'chacha::ChaCha20Core': 'ChaCha20Core', 'chacha::ChaCha20Rng': 'ChaCha20Rng', 'chacha::ChaCha8Core': 'ChaCha8Core', 'chacha::ChaCha8Rng': 'ChaCha8Rng', 'ppv_lite86::Machine': 'guts::Machine', 'rand_core': 'rand_core'}, 'srcs': {'<chacha::Array64<T> as std::clone::Clone>::clone': ['fn clone(&self) -> Self{\n        let mut new = Self::default();\n        new.0.copy_from_slice(&self.0);\n        new\n    }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::Array64<T> as std::convert::AsMut<[T]>>::as_mut': ['fn as_mut(&mut self) -> &mut [T]{\n        &mut self.0\n    }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::Array64<T> as std::convert::AsRef<[T]>>::as_ref': ['fn as_ref(&self) -> &[T]{\n        &self.0\n    }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::Array64<T> as std::default::Default>::default': ['#[rustfmt::skip]\nfn default() -> Self{\n        Self([\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n        ])\n    }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::Array64<T> as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, "Array64 {{}}")\n    }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha12Core as rand_core::SeedableRng>::from_seed': ['#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha12Core as rand_core::block::BlockRngCore>::generate': ['#[inline]\nfn generate(&mut self, r: &mut Self::Results){\n                self.state.refill4($rounds, &mut r.0);\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha12Core as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n                write!(f, "ChaChaXCore {{}}")\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha12Rng as rand_core::RngCore>::fill_bytes': ['#[inline]\nfn fill_bytes(&mut self, bytes: &mut [u8]){\n                self.rng.fill_bytes(bytes)\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha12Rng as rand_core::RngCore>::next_u32': ['#[inline]\nfn next_u32(&mut self) -> u32{\n                self.rng.next_u32()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha12Rng as rand_core::RngCore>::next_u64': ['#[inline]\nfn next_u64(&mut self) -> u64{\n                self.rng.next_u64()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha12Rng as rand_core::SeedableRng>::from_seed': ['#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha12Rng as std::cmp::PartialEq>::eq': ['fn eq(&self, rhs: &$ChaChaXRng) -> bool{\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha12Rng as std::convert::From<chacha::ChaCha12Core>>::from': ['fn from(core: $ChaChaXCore) -> Self{\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha20Core as rand_core::SeedableRng>::from_seed': ['#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha20Core as rand_core::block::BlockRngCore>::generate': ['#[inline]\nfn generate(&mut self, r: &mut Self::Results){\n                self.state.refill4($rounds, &mut r.0);\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha20Core as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n                write!(f, "ChaChaXCore {{}}")\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha20Rng as rand_core::RngCore>::fill_bytes': ['#[inline]\nfn fill_bytes(&mut self, bytes: &mut [u8]){\n                self.rng.fill_bytes(bytes)\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha20Rng as rand_core::RngCore>::next_u32': ['#[inline]\nfn next_u32(&mut self) -> u32{\n                self.rng.next_u32()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha20Rng as rand_core::RngCore>::next_u64': ['#[inline]\nfn next_u64(&mut self) -> u64{\n                self.rng.next_u64()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha20Rng as rand_core::SeedableRng>::from_seed': ['#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha20Rng as std::cmp::PartialEq>::eq': ['fn eq(&self, rhs: &$ChaChaXRng) -> bool{\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha20Rng as std::convert::From<chacha::ChaCha20Core>>::from': ['fn from(core: $ChaChaXCore) -> Self{\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha8Core as rand_core::SeedableRng>::from_seed': ['#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha8Core as rand_core::block::BlockRngCore>::generate': ['#[inline]\nfn generate(&mut self, r: &mut Self::Results){\n                self.state.refill4($rounds, &mut r.0);\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha8Core as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n                write!(f, "ChaChaXCore {{}}")\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha8Rng as rand_core::RngCore>::fill_bytes': ['#[inline]\nfn fill_bytes(&mut self, bytes: &mut [u8]){\n                self.rng.fill_bytes(bytes)\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha8Rng as rand_core::RngCore>::next_u32': ['#[inline]\nfn next_u32(&mut self) -> u32{\n                self.rng.next_u32()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha8Rng as rand_core::RngCore>::next_u64': ['#[inline]\nfn next_u64(&mut self) -> u64{\n                self.rng.next_u64()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha8Rng as rand_core::SeedableRng>::from_seed': ['#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha8Rng as std::cmp::PartialEq>::eq': ['fn eq(&self, rhs: &$ChaChaXRng) -> bool{\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::ChaCha8Rng as std::convert::From<chacha::ChaCha8Core>>::from': ['fn from(core: $ChaChaXCore) -> Self{\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::abstract12::ChaCha12Rng as std::convert::From<&chacha::ChaCha12Rng>>::from': ['fn from(r: &super::$ChaChaXRng) -> Self{\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::abstract20::ChaCha20Rng as std::convert::From<&chacha::ChaCha20Rng>>::from': ['fn from(r: &super::$ChaChaXRng) -> Self{\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], '<chacha::abstract8::ChaCha8Rng as std::convert::From<&chacha::ChaCha8Rng>>::from': ['fn from(r: &super::$ChaChaXRng) -> Self{\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::Array64': ['#[repr(transparent)]\npub struct Array64<T>([T; 64]);', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha12Core': ['#[doc=$doc]\npub struct $ChaChaXCore {\n            state: ChaCha,\n        }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha12Rng': ['/// A cryptographically secure random number generator that uses the ChaCha algorithm.\n///\n/// ChaCha is a stream cipher designed by Daniel J. Bernstein[^1], that we use as an RNG. It is\n/// an improved variant of the Salsa20 cipher family, which was selected as one of the "stream\n/// ciphers suitable for widespread adoption" by eSTREAM[^2].\n///\n/// ChaCha uses add-rotate-xor (ARX) operations as its basis. These are safe against timing\n/// attacks, although that is mostly a concern for ciphers and not for RNGs. We provide a SIMD\n/// implementation to support high throughput on a variety of common hardware platforms.\n///\n/// With the ChaCha algorithm it is possible to choose the number of rounds the core algorithm\n/// should run. The number of rounds is a tradeoff between performance and security, where 8\n/// rounds is the minimum potentially secure configuration, and 20 rounds is widely used as a\n/// conservative choice.\n///\n/// We use a 64-bit counter and 64-bit stream identifier as in Bernstein\'s implementation[^1]\n/// except that we use a stream identifier in place of a nonce. A 64-bit counter over 64-byte\n/// (16 word) blocks allows 1 ZiB of output before cycling, and the stream identifier allows\n/// 2<sup>64</sup> unique streams of output per seed. Both counter and stream are initialized\n/// to zero but may be set via the `set_word_pos` and `set_stream` methods.\n///\n/// The word layout is:\n///\n/// ```text\n/// constant  constant  constant  constant\n/// seed      seed      seed      seed\n/// seed      seed      seed      seed\n/// counter   counter   stream_id stream_id\n/// ```\n///\n/// This implementation uses an output buffer of sixteen `u32` words, and uses\n/// [`BlockRng`] to implement the [`RngCore`] methods.\n///\n/// [^1]: D. J. Bernstein, [*ChaCha, a variant of Salsa20*](\n///       https://cr.yp.to/chacha.html)\n///\n/// [^2]: [eSTREAM: the ECRYPT Stream Cipher Project](\n///       http://www.ecrypt.eu.org/stream/)\npub struct $ChaChaXRng {\n            rng: BlockRng<$ChaChaXCore>,\n        }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha12Rng::get_seed': ['/// Get the seed.\n#[inline]\npub fn get_seed(&self) -> [u8; 32]{\n                self.rng.core.state.get_seed()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha12Rng::get_stream': ['/// Get the stream number.\n#[inline]\npub fn get_stream(&self) -> u64{\n                self.rng.core.state.get_nonce()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha12Rng::get_word_pos': ['/// Get the offset from the start of the stream, in 32-bit words.\n///\n/// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n/// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n/// not supported, hence the result can simply be multiplied by 4 to get a\n/// byte-offset.\n#[inline]\npub fn get_word_pos(&self) -> u128{\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha12Rng::set_stream': ['/// Set the stream number.\n///\n/// This is initialized to zero; 2<sup>64</sup> unique streams of output\n/// are available per seed/key.\n///\n/// Note that in order to reproduce ChaCha output with a specific 64-bit\n/// nonce, one can convert that nonce to a `u64` in little-endian fashion\n/// and pass to this function. In theory a 96-bit nonce can be used by\n/// passing the last 64-bits to this function and using the first 32-bits as\n/// the most significant half of the 64-bit counter (which may be set\n/// indirectly via `set_word_pos`), but this is not directly supported.\n#[inline]\npub fn set_stream(&mut self, stream: u64){\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha12Rng::set_word_pos': ['/// Set the offset from the start of the stream, in 32-bit words.\n///\n/// As with `get_word_pos`, we use a 68-bit number. Since the generator\n/// simply cycles at the end of its period (1 ZiB), we ignore the upper\n/// 60 bits.\n#[inline]\npub fn set_word_pos(&mut self, word_offset: u128){\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha20Core': ['#[doc=$doc]\npub struct $ChaChaXCore {\n            state: ChaCha,\n        }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha20Rng': ['/// A cryptographically secure random number generator that uses the ChaCha algorithm.\n///\n/// ChaCha is a stream cipher designed by Daniel J. Bernstein[^1], that we use as an RNG. It is\n/// an improved variant of the Salsa20 cipher family, which was selected as one of the "stream\n/// ciphers suitable for widespread adoption" by eSTREAM[^2].\n///\n/// ChaCha uses add-rotate-xor (ARX) operations as its basis. These are safe against timing\n/// attacks, although that is mostly a concern for ciphers and not for RNGs. We provide a SIMD\n/// implementation to support high throughput on a variety of common hardware platforms.\n///\n/// With the ChaCha algorithm it is possible to choose the number of rounds the core algorithm\n/// should run. The number of rounds is a tradeoff between performance and security, where 8\n/// rounds is the minimum potentially secure configuration, and 20 rounds is widely used as a\n/// conservative choice.\n///\n/// We use a 64-bit counter and 64-bit stream identifier as in Bernstein\'s implementation[^1]\n/// except that we use a stream identifier in place of a nonce. A 64-bit counter over 64-byte\n/// (16 word) blocks allows 1 ZiB of output before cycling, and the stream identifier allows\n/// 2<sup>64</sup> unique streams of output per seed. Both counter and stream are initialized\n/// to zero but may be set via the `set_word_pos` and `set_stream` methods.\n///\n/// The word layout is:\n///\n/// ```text\n/// constant  constant  constant  constant\n/// seed      seed      seed      seed\n/// seed      seed      seed      seed\n/// counter   counter   stream_id stream_id\n/// ```\n///\n/// This implementation uses an output buffer of sixteen `u32` words, and uses\n/// [`BlockRng`] to implement the [`RngCore`] methods.\n///\n/// [^1]: D. J. Bernstein, [*ChaCha, a variant of Salsa20*](\n///       https://cr.yp.to/chacha.html)\n///\n/// [^2]: [eSTREAM: the ECRYPT Stream Cipher Project](\n///       http://www.ecrypt.eu.org/stream/)\npub struct $ChaChaXRng {\n            rng: BlockRng<$ChaChaXCore>,\n        }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha20Rng::get_seed': ['/// Get the seed.\n#[inline]\npub fn get_seed(&self) -> [u8; 32]{\n                self.rng.core.state.get_seed()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha20Rng::get_stream': ['/// Get the stream number.\n#[inline]\npub fn get_stream(&self) -> u64{\n                self.rng.core.state.get_nonce()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha20Rng::get_word_pos': ['/// Get the offset from the start of the stream, in 32-bit words.\n///\n/// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n/// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n/// not supported, hence the result can simply be multiplied by 4 to get a\n/// byte-offset.\n#[inline]\npub fn get_word_pos(&self) -> u128{\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha20Rng::set_stream': ['/// Set the stream number.\n///\n/// This is initialized to zero; 2<sup>64</sup> unique streams of output\n/// are available per seed/key.\n///\n/// Note that in order to reproduce ChaCha output with a specific 64-bit\n/// nonce, one can convert that nonce to a `u64` in little-endian fashion\n/// and pass to this function. In theory a 96-bit nonce can be used by\n/// passing the last 64-bits to this function and using the first 32-bits as\n/// the most significant half of the 64-bit counter (which may be set\n/// indirectly via `set_word_pos`), but this is not directly supported.\n#[inline]\npub fn set_stream(&mut self, stream: u64){\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha20Rng::set_word_pos': ['/// Set the offset from the start of the stream, in 32-bit words.\n///\n/// As with `get_word_pos`, we use a 68-bit number. Since the generator\n/// simply cycles at the end of its period (1 ZiB), we ignore the upper\n/// 60 bits.\n#[inline]\npub fn set_word_pos(&mut self, word_offset: u128){\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha8Core': ['#[doc=$doc]\npub struct $ChaChaXCore {\n            state: ChaCha,\n        }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha8Rng': ['/// A cryptographically secure random number generator that uses the ChaCha algorithm.\n///\n/// ChaCha is a stream cipher designed by Daniel J. Bernstein[^1], that we use as an RNG. It is\n/// an improved variant of the Salsa20 cipher family, which was selected as one of the "stream\n/// ciphers suitable for widespread adoption" by eSTREAM[^2].\n///\n/// ChaCha uses add-rotate-xor (ARX) operations as its basis. These are safe against timing\n/// attacks, although that is mostly a concern for ciphers and not for RNGs. We provide a SIMD\n/// implementation to support high throughput on a variety of common hardware platforms.\n///\n/// With the ChaCha algorithm it is possible to choose the number of rounds the core algorithm\n/// should run. The number of rounds is a tradeoff between performance and security, where 8\n/// rounds is the minimum potentially secure configuration, and 20 rounds is widely used as a\n/// conservative choice.\n///\n/// We use a 64-bit counter and 64-bit stream identifier as in Bernstein\'s implementation[^1]\n/// except that we use a stream identifier in place of a nonce. A 64-bit counter over 64-byte\n/// (16 word) blocks allows 1 ZiB of output before cycling, and the stream identifier allows\n/// 2<sup>64</sup> unique streams of output per seed. Both counter and stream are initialized\n/// to zero but may be set via the `set_word_pos` and `set_stream` methods.\n///\n/// The word layout is:\n///\n/// ```text\n/// constant  constant  constant  constant\n/// seed      seed      seed      seed\n/// seed      seed      seed      seed\n/// counter   counter   stream_id stream_id\n/// ```\n///\n/// This implementation uses an output buffer of sixteen `u32` words, and uses\n/// [`BlockRng`] to implement the [`RngCore`] methods.\n///\n/// [^1]: D. J. Bernstein, [*ChaCha, a variant of Salsa20*](\n///       https://cr.yp.to/chacha.html)\n///\n/// [^2]: [eSTREAM: the ECRYPT Stream Cipher Project](\n///       http://www.ecrypt.eu.org/stream/)\npub struct $ChaChaXRng {\n            rng: BlockRng<$ChaChaXCore>,\n        }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha8Rng::get_seed': ['/// Get the seed.\n#[inline]\npub fn get_seed(&self) -> [u8; 32]{\n                self.rng.core.state.get_seed()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha8Rng::get_stream': ['/// Get the stream number.\n#[inline]\npub fn get_stream(&self) -> u64{\n                self.rng.core.state.get_nonce()\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha8Rng::get_word_pos': ['/// Get the offset from the start of the stream, in 32-bit words.\n///\n/// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n/// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n/// not supported, hence the result can simply be multiplied by 4 to get a\n/// byte-offset.\n#[inline]\npub fn get_word_pos(&self) -> u128{\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha8Rng::set_stream': ['/// Set the stream number.\n///\n/// This is initialized to zero; 2<sup>64</sup> unique streams of output\n/// are available per seed/key.\n///\n/// Note that in order to reproduce ChaCha output with a specific 64-bit\n/// nonce, one can convert that nonce to a `u64` in little-endian fashion\n/// and pass to this function. In theory a 96-bit nonce can be used by\n/// passing the last 64-bits to this function and using the first 32-bits as\n/// the most significant half of the 64-bit counter (which may be set\n/// indirectly via `set_word_pos`), but this is not directly supported.\n#[inline]\npub fn set_stream(&mut self, stream: u64){\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::ChaCha8Rng::set_word_pos': ['/// Set the offset from the start of the stream, in 32-bit words.\n///\n/// As with `get_word_pos`, we use a 68-bit number. Since the generator\n/// simply cycles at the end of its period (1 ZiB), we ignore the upper\n/// 60 bits.\n#[inline]\npub fn set_word_pos(&mut self, word_offset: u128){\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::abstract12::<impl std::convert::From<&chacha::abstract12::ChaCha12Rng> for chacha::ChaCha12Rng>::from': ['fn from(a: &$ChaChaXRng) -> Self{\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::abstract12::ChaCha12Rng': ['pub(crate) struct $ChaChaXRng {\n                seed: [u8; 32],\n                stream: u64,\n                word_pos: u128,\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::abstract20::<impl std::convert::From<&chacha::abstract20::ChaCha20Rng> for chacha::ChaCha20Rng>::from': ['fn from(a: &$ChaChaXRng) -> Self{\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::abstract20::ChaCha20Rng': ['pub(crate) struct $ChaChaXRng {\n                seed: [u8; 32],\n                stream: u64,\n                word_pos: u128,\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::abstract8::<impl std::convert::From<&chacha::abstract8::ChaCha8Rng> for chacha::ChaCha8Rng>::from': ['fn from(a: &$ChaChaXRng) -> Self{\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'chacha::abstract8::ChaCha8Rng': ['pub(crate) struct $ChaChaXRng {\n                seed: [u8; 32],\n                stream: u64,\n                word_pos: u128,\n            }', 'Real(LocalPath("rand_chacha/src/chacha.rs"))'], 'guts::ChaCha': ['pub struct ChaCha {\n    pub(crate) b: vec128_storage,\n    pub(crate) c: vec128_storage,\n    pub(crate) d: vec128_storage,\n}', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::ChaCha::get_block_pos': ['#[inline(always)]\npub fn get_block_pos(&self) -> u64{\n        get_stream_param(self, STREAM_PARAM_BLOCK)\n    }', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::ChaCha::get_nonce': ['#[inline(always)]\npub fn get_nonce(&self) -> u64{\n        get_stream_param(self, STREAM_PARAM_NONCE)\n    }', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::ChaCha::get_seed': ['#[inline(always)]\npub fn get_seed(&self) -> [u8; 32]{\n        get_seed(self)\n    }', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::ChaCha::new': ['#[inline(always)]\npub fn new(key: &[u8; 32], nonce: &[u8]) -> Self{\n        init_chacha(key, nonce)\n    }', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::ChaCha::refill4': ['/// Produce 4 blocks of output, advancing the state\n#[inline(always)]\npub fn refill4(&mut self, drounds: u32, out: &mut [u32; BUFSZ]){\n        refill_wide(self, drounds, out)\n    }', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::ChaCha::set_block_pos': ['#[inline(always)]\npub fn set_block_pos(&mut self, value: u64){\n        set_stream_param(self, STREAM_PARAM_BLOCK, value)\n    }', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::ChaCha::set_nonce': ['#[inline(always)]\npub fn set_nonce(&mut self, value: u64){\n        set_stream_param(self, STREAM_PARAM_NONCE, value)\n    }', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::State': ['pub struct State<V> {\n    pub(crate) a: V,\n    pub(crate) b: V,\n    pub(crate) c: V,\n    pub(crate) d: V,\n}', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::add_pos': ['#[inline(always)]\n#[cfg(target_endian = "little")]\nfn add_pos<Mach: Machine>(m: Mach, d: Mach::u32x4, i: u64) -> Mach::u32x4{\n    let d0: Mach::u64x2 = m.unpack(d.into());\n    let incr = m.vec([i, 0]);\n    m.unpack((d0 + incr).into())\n}', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::d0123': ['#[inline(always)]\n#[cfg(target_endian = "little")]\nfn d0123<Mach: Machine>(m: Mach, d: vec128_storage) -> Mach::u32x4x4{\n    let d0: Mach::u64x2 = m.unpack(d);\n    let incr =\n        Mach::u64x2x4::from_lanes([m.vec([0, 0]), m.vec([1, 0]), m.vec([2, 0]), m.vec([3, 0])]);\n    m.unpack((Mach::u64x2x4::from_lanes([d0, d0, d0, d0]) + incr).into())\n}', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::diagonalize': ['#[inline(always)]\npub(crate) fn diagonalize<V: LaneWords4>(mut x: State<V>) -> State<V>{\n    x.b = x.b.shuffle_lane_words3012();\n    x.c = x.c.shuffle_lane_words2301();\n    x.d = x.d.shuffle_lane_words1230();\n    x\n}', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::get_seed': ['#[cfg(feature = "std")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = "avx")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }\n            #[target_feature(enable = "sse2")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!("avx") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!("sse2") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::get_seed::fn_impl': ['#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let b: Mach::u32x4 = m.unpack(state.b);\n        let c: Mach::u32x4 = m.unpack(state.c);\n        let mut key = [0u8; 32];\n        b.write_le(&mut key[..16]);\n        c.write_le(&mut key[16..]);\n        key\n    }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::get_seed::impl_avx': ['#[target_feature(enable = "avx")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::get_seed::impl_sse2': ['#[target_feature(enable = "sse2")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::get_stream_param': ['#[cfg(feature = "std")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = "avx")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }\n            #[target_feature(enable = "sse2")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!("avx") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!("sse2") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::get_stream_param::fn_impl': ['#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let d: Mach::u32x4 = m.unpack(state.d);\n        ((d.extract((param << 1) | 1) as u64) << 32) | d.extract(param << 1) as u64\n    }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::get_stream_param::impl_avx': ['#[target_feature(enable = "avx")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::get_stream_param::impl_sse2': ['#[target_feature(enable = "sse2")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::init_chacha': ['#[cfg(feature = "std")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = "avx")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }\n            #[target_feature(enable = "sse2")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!("avx") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!("sse2") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::init_chacha::fn_impl': ['#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let ctr_nonce = [\n            0,\n            if nonce.len() == 12 {\n                read_u32le(&nonce[0..4])\n            } else {\n                0\n            },\n            read_u32le(&nonce[nonce.len() - 8..nonce.len() - 4]),\n            read_u32le(&nonce[nonce.len() - 4..]),\n        ];\n        let key0: Mach::u32x4 = m.read_le(&key[..16]);\n        let key1: Mach::u32x4 = m.read_le(&key[16..]);\n        ChaCha {\n            b: key0.into(),\n            c: key1.into(),\n            d: ctr_nonce.into(),\n        }\n    }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::init_chacha::impl_avx': ['#[target_feature(enable = "avx")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::init_chacha::impl_sse2': ['#[target_feature(enable = "sse2")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::init_chacha_x': ['#[cfg(feature = "std")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = "avx")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }\n            #[target_feature(enable = "sse2")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!("avx") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!("sse2") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::init_chacha_x::fn_impl': ['#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let key0: Mach::u32x4 = m.read_le(&key[..16]);\n        let key1: Mach::u32x4 = m.read_le(&key[16..]);\n        let nonce0: Mach::u32x4 = m.read_le(&nonce[..16]);\n        let mut state = ChaCha {\n            b: key0.into(),\n            c: key1.into(),\n            d: nonce0.into(),\n        };\n        let x = refill_narrow_rounds(&mut state, rounds);\n        let ctr_nonce1 = [0, 0, read_u32le(&nonce[16..20]), read_u32le(&nonce[20..24])];\n        state.b = x.a;\n        state.c = x.d;\n        state.d = ctr_nonce1.into();\n        state\n    }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::init_chacha_x::impl_avx': ['#[target_feature(enable = "avx")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::init_chacha_x::impl_sse2': ['#[target_feature(enable = "sse2")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::read_u32le': ['fn read_u32le(xs: &[u8]) -> u32{\n    assert_eq!(xs.len(), 4);\n    u32::from(xs[0]) | (u32::from(xs[1]) << 8) | (u32::from(xs[2]) << 16) | (u32::from(xs[3]) << 24)\n}', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::refill_narrow_rounds': ['#[cfg(feature = "std")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = "avx2")]\n            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {\n                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }\n            #[target_feature(enable = "avx")]\n            #[target_feature(enable = "sse4.1")]\n            #[target_feature(enable = "ssse3")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }\n            #[target_feature(enable = "sse4.1")]\n            #[target_feature(enable = "ssse3")]\n            unsafe fn impl_sse41($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)\n            }\n            #[target_feature(enable = "ssse3")]\n            unsafe fn impl_ssse3($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)\n            }\n            #[target_feature(enable = "sse2")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!("avx2") {\n                    impl_avx2($($arg),*)\n                } else if is_x86_feature_detected!("avx") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!("sse4.1") {\n                    impl_sse41($($arg),*)\n                } else if is_x86_feature_detected!("ssse3") {\n                    impl_ssse3($($arg),*)\n                } else if is_x86_feature_detected!("sse2") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_narrow_rounds::fn_impl': ['#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let k: Mach::u32x4 = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);\n        let mut x = State {\n            a: k,\n            b: m.unpack(state.b),\n            c: m.unpack(state.c),\n            d: m.unpack(state.d),\n        };\n        for _ in 0..drounds {\n            x = round(x);\n            x = undiagonalize(round(diagonalize(x)));\n        }\n        State {\n            a: x.a.into(),\n            b: x.b.into(),\n            c: x.c.into(),\n            d: x.d.into(),\n        }\n    }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_narrow_rounds::impl_avx': ['#[target_feature(enable = "avx")]\n#[target_feature(enable = "sse4.1")]\n#[target_feature(enable = "ssse3")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_narrow_rounds::impl_avx2': ['#[target_feature(enable = "avx2")]\nunsafe fn impl_avx2($($arg: $argty),*) -> $ret{\n                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_narrow_rounds::impl_sse2': ['#[target_feature(enable = "sse2")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_narrow_rounds::impl_sse41': ['#[target_feature(enable = "sse4.1")]\n#[target_feature(enable = "ssse3")]\nunsafe fn impl_sse41($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_narrow_rounds::impl_ssse3': ['#[target_feature(enable = "ssse3")]\nunsafe fn impl_ssse3($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_wide': ['#[cfg(feature = "std")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = "avx2")]\n            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {\n                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }\n            #[target_feature(enable = "avx")]\n            #[target_feature(enable = "sse4.1")]\n            #[target_feature(enable = "ssse3")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }\n            #[target_feature(enable = "sse4.1")]\n            #[target_feature(enable = "ssse3")]\n            unsafe fn impl_sse41($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)\n            }\n            #[target_feature(enable = "ssse3")]\n            unsafe fn impl_ssse3($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)\n            }\n            #[target_feature(enable = "sse2")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!("avx2") {\n                    impl_avx2($($arg),*)\n                } else if is_x86_feature_detected!("avx") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!("sse4.1") {\n                    impl_sse41($($arg),*)\n                } else if is_x86_feature_detected!("ssse3") {\n                    impl_ssse3($($arg),*)\n                } else if is_x86_feature_detected!("sse2") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_wide::fn_impl': ['#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        refill_wide_impl(m, state, drounds, out);\n    }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_wide::impl_avx': ['#[target_feature(enable = "avx")]\n#[target_feature(enable = "sse4.1")]\n#[target_feature(enable = "ssse3")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_wide::impl_avx2': ['#[target_feature(enable = "avx2")]\nunsafe fn impl_avx2($($arg: $argty),*) -> $ret{\n                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_wide::impl_sse2': ['#[target_feature(enable = "sse2")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_wide::impl_sse41': ['#[target_feature(enable = "sse4.1")]\n#[target_feature(enable = "ssse3")]\nunsafe fn impl_sse41($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_wide::impl_ssse3': ['#[target_feature(enable = "ssse3")]\nunsafe fn impl_ssse3($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::refill_wide_impl': ['#[allow(clippy::many_single_char_names)]\n#[inline(always)]\nfn refill_wide_impl<Mach: Machine>(\n    m: Mach,\n    state: &mut ChaCha,\n    drounds: u32,\n    out: &mut [u32; BUFSZ],\n){\n    let k = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);\n    let b = m.unpack(state.b);\n    let c = m.unpack(state.c);\n    let mut x = State {\n        a: Mach::u32x4x4::from_lanes([k, k, k, k]),\n        b: Mach::u32x4x4::from_lanes([b, b, b, b]),\n        c: Mach::u32x4x4::from_lanes([c, c, c, c]),\n        d: d0123(m, state.d),\n    };\n    for _ in 0..drounds {\n        x = round(x);\n        x = undiagonalize(round(diagonalize(x)));\n    }\n    let kk = Mach::u32x4x4::from_lanes([k, k, k, k]);\n    let sb = m.unpack(state.b);\n    let sb = Mach::u32x4x4::from_lanes([sb, sb, sb, sb]);\n    let sc = m.unpack(state.c);\n    let sc = Mach::u32x4x4::from_lanes([sc, sc, sc, sc]);\n    let sd = d0123(m, state.d);\n    let results = Mach::u32x4x4::transpose4(x.a + kk, x.b + sb, x.c + sc, x.d + sd);\n    out[0..16].copy_from_slice(&results.0.to_scalars());\n    out[16..32].copy_from_slice(&results.1.to_scalars());\n    out[32..48].copy_from_slice(&results.2.to_scalars());\n    out[48..64].copy_from_slice(&results.3.to_scalars());\n    state.d = add_pos(m, sd.to_lanes()[0], 4).into();\n}', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::round': ['#[inline(always)]\npub(crate) fn round<V: ArithOps + BitOps32>(mut x: State<V>) -> State<V>{\n    x.a += x.b;\n    x.d = (x.d ^ x.a).rotate_each_word_right16();\n    x.c += x.d;\n    x.b = (x.b ^ x.c).rotate_each_word_right20();\n    x.a += x.b;\n    x.d = (x.d ^ x.a).rotate_each_word_right24();\n    x.c += x.d;\n    x.b = (x.b ^ x.c).rotate_each_word_right25();\n    x\n}', 'Real(LocalPath("rand_chacha/src/guts.rs"))'], 'guts::set_stream_param': ['#[cfg(feature = "std")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = "avx")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }\n            #[target_feature(enable = "sse2")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!("avx") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!("sse2") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::set_stream_param::fn_impl': ['#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let d: Mach::u32x4 = m.unpack(state.d);\n        state.d = d\n            .insert((value >> 32) as u32, (param << 1) | 1)\n            .insert(value as u32, param << 1)\n            .into();\n    }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::set_stream_param::impl_avx': ['#[target_feature(enable = "avx")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::set_stream_param::impl_sse2': ['#[target_feature(enable = "sse2")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))'], 'guts::undiagonalize': ['#[inline(always)]\npub(crate) fn undiagonalize<V: LaneWords4>(mut x: State<V>) -> State<V>{\n    x.b = x.b.shuffle_lane_words1230();\n    x.c = x.c.shuffle_lane_words2301();\n    x.d = x.d.shuffle_lane_words3012();\n    x\n}', 'Real(LocalPath("rand_chacha/src/guts.rs"))']}, 'struct_constructor': {'&\'^0.Named(DefId(0:379 ~ rand_chacha[133f]::chacha::{impl#1}::as_ref::\'_), "\'_") [T/#0]': ['as_ref'], '&\'^0.Named(DefId(0:380 ~ rand_chacha[133f]::chacha::{impl#2}::as_mut::\'_), "\'_") mut [T/#0]': ['as_mut'], 'Alias(Projection, AliasTy { args: [Mach/#0], def_id: DefId(21:282 ~ ppv_lite86[e7d0]::types::Machine::u32x4x4) })': ['d0123'], '[u8; 32_usize]': ['fn_impl', 'get_seed', 'impl_avx', 'impl_sse2'], 'bool': ['eq'], 'chacha::Array64': ['clone', 'default'], 'chacha::ChaCha12Core': ['clone', 'from_seed'], 'chacha::ChaCha12Rng': ['clone', 'from', 'from_seed'], 'chacha::ChaCha20Core': ['clone', 'from_seed'], 'chacha::ChaCha20Rng': ['clone', 'from', 'from_seed'], 'chacha::ChaCha8Core': ['clone', 'from_seed'], 'chacha::ChaCha8Rng': ['clone', 'from', 'from_seed'], 'chacha::abstract12::ChaCha12Rng': ['from'], 'chacha::abstract20::ChaCha20Rng': ['from'], 'chacha::abstract8::ChaCha8Rng': ['from'], 'guts::ChaCha': ['clone', 'fn_impl', 'impl_avx', 'impl_sse2', 'init_chacha', 'init_chacha_x', 'new'], 'guts::State': ['clone', 'fn_impl', 'impl_avx', 'impl_avx2', 'impl_sse2', 'impl_sse41', 'impl_ssse3', 'refill_narrow_rounds'], 'u128': ['get_word_pos'], 'u32': ['next_u32', 'read_u32le'], 'u64': ['fn_impl', 'get_block_pos', 'get_nonce', 'get_stream', 'get_stream_param', 'impl_avx', 'impl_sse2', 'next_u64']}, 'struct_to_trait': {'chacha::Array64': ['std::clone::Clone', 'std::convert::AsMut', 'std::convert::AsRef', 'std::default::Default', 'std::fmt::Debug'], 'chacha::ChaCha12Core': ['rand_core::SeedableRng', 'rand_core::block::BlockRngCore', 'rand_core::block::CryptoBlockRng', 'std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::marker::StructuralPartialEq'], 'chacha::ChaCha12Rng': ['rand_core::CryptoRng', 'rand_core::RngCore', 'rand_core::SeedableRng', 'std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::From', 'std::fmt::Debug'], 'chacha::ChaCha20Core': ['rand_core::SeedableRng', 'rand_core::block::BlockRngCore', 'rand_core::block::CryptoBlockRng', 'std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::marker::StructuralPartialEq'], 'chacha::ChaCha20Rng': ['rand_core::CryptoRng', 'rand_core::RngCore', 'rand_core::SeedableRng', 'std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::From', 'std::fmt::Debug'], 'chacha::ChaCha8Core': ['rand_core::SeedableRng', 'rand_core::block::BlockRngCore', 'rand_core::block::CryptoBlockRng', 'std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::marker::StructuralPartialEq'], 'chacha::ChaCha8Rng': ['rand_core::CryptoRng', 'rand_core::RngCore', 'rand_core::SeedableRng', 'std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::From', 'std::fmt::Debug'], 'chacha::abstract12::ChaCha12Rng': ['std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::From', 'std::fmt::Debug', 'std::marker::StructuralPartialEq'], 'chacha::abstract20::ChaCha20Rng': ['std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::From', 'std::fmt::Debug', 'std::marker::StructuralPartialEq'], 'chacha::abstract8::ChaCha8Rng': ['std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::From', 'std::fmt::Debug', 'std::marker::StructuralPartialEq'], 'guts::ChaCha': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::marker::StructuralPartialEq'], 'guts::State': ['std::clone::Clone']}, 'targets': {'<chacha::Array64<T> as std::clone::Clone>::clone': ['clone', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::clone::Clone'], '<chacha::Array64<T> as std::convert::AsMut<[T]>>::as_mut': ['as_mut', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::AsMut'], '<chacha::Array64<T> as std::convert::AsRef<[T]>>::as_ref': ['as_ref', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::AsRef'], '<chacha::Array64<T> as std::default::Default>::default': ['default', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::default::Default'], '<chacha::Array64<T> as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::fmt::Debug'], '<chacha::ChaCha12Core as rand_core::SeedableRng>::from_seed': ['from_seed', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::SeedableRng'], '<chacha::ChaCha12Core as rand_core::block::BlockRngCore>::generate': ['generate', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::block::BlockRngCore'], '<chacha::ChaCha12Core as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::fmt::Debug'], '<chacha::ChaCha12Rng as rand_core::RngCore>::fill_bytes': ['fill_bytes', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::RngCore'], '<chacha::ChaCha12Rng as rand_core::RngCore>::next_u32': ['next_u32', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::RngCore'], '<chacha::ChaCha12Rng as rand_core::RngCore>::next_u64': ['next_u64', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::RngCore'], '<chacha::ChaCha12Rng as rand_core::SeedableRng>::from_seed': ['from_seed', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::SeedableRng'], '<chacha::ChaCha12Rng as std::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::cmp::PartialEq'], '<chacha::ChaCha12Rng as std::convert::From<chacha::ChaCha12Core>>::from': ['from', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::From'], '<chacha::ChaCha20Core as rand_core::SeedableRng>::from_seed': ['from_seed', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::SeedableRng'], '<chacha::ChaCha20Core as rand_core::block::BlockRngCore>::generate': ['generate', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::block::BlockRngCore'], '<chacha::ChaCha20Core as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::fmt::Debug'], '<chacha::ChaCha20Rng as rand_core::RngCore>::fill_bytes': ['fill_bytes', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::RngCore'], '<chacha::ChaCha20Rng as rand_core::RngCore>::next_u32': ['next_u32', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::RngCore'], '<chacha::ChaCha20Rng as rand_core::RngCore>::next_u64': ['next_u64', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::RngCore'], '<chacha::ChaCha20Rng as rand_core::SeedableRng>::from_seed': ['from_seed', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::SeedableRng'], '<chacha::ChaCha20Rng as std::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::cmp::PartialEq'], '<chacha::ChaCha20Rng as std::convert::From<chacha::ChaCha20Core>>::from': ['from', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::From'], '<chacha::ChaCha8Core as rand_core::SeedableRng>::from_seed': ['from_seed', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::SeedableRng'], '<chacha::ChaCha8Core as rand_core::block::BlockRngCore>::generate': ['generate', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::block::BlockRngCore'], '<chacha::ChaCha8Core as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::fmt::Debug'], '<chacha::ChaCha8Rng as rand_core::RngCore>::fill_bytes': ['fill_bytes', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::RngCore'], '<chacha::ChaCha8Rng as rand_core::RngCore>::next_u32': ['next_u32', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::RngCore'], '<chacha::ChaCha8Rng as rand_core::RngCore>::next_u64': ['next_u64', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::RngCore'], '<chacha::ChaCha8Rng as rand_core::SeedableRng>::from_seed': ['from_seed', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'rand_core::SeedableRng'], '<chacha::ChaCha8Rng as std::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::cmp::PartialEq'], '<chacha::ChaCha8Rng as std::convert::From<chacha::ChaCha8Core>>::from': ['from', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::From'], '<chacha::abstract12::ChaCha12Rng as std::convert::From<&chacha::ChaCha12Rng>>::from': ['from', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::From'], '<chacha::abstract20::ChaCha20Rng as std::convert::From<&chacha::ChaCha20Rng>>::from': ['from', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::From'], '<chacha::abstract8::ChaCha8Rng as std::convert::From<&chacha::ChaCha8Rng>>::from': ['from', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::From'], 'chacha::ChaCha12Rng::get_seed': ['get_seed', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha12Rng::get_stream': ['get_stream', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha12Rng::get_word_pos': ['get_word_pos', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha12Rng::set_stream': ['set_stream', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha12Rng::set_word_pos': ['set_word_pos', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha20Rng::get_seed': ['get_seed', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha20Rng::get_stream': ['get_stream', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha20Rng::get_word_pos': ['get_word_pos', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha20Rng::set_stream': ['set_stream', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha20Rng::set_word_pos': ['set_word_pos', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha8Rng::get_seed': ['get_seed', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha8Rng::get_stream': ['get_stream', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha8Rng::get_word_pos': ['get_word_pos', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha8Rng::set_stream': ['set_stream', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::ChaCha8Rng::set_word_pos': ['set_word_pos', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', ''], 'chacha::abstract12::<impl std::convert::From<&chacha::abstract12::ChaCha12Rng> for chacha::ChaCha12Rng>::from': ['from', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::From'], 'chacha::abstract20::<impl std::convert::From<&chacha::abstract20::ChaCha20Rng> for chacha::ChaCha20Rng>::from': ['from', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::From'], 'chacha::abstract8::<impl std::convert::From<&chacha::abstract8::ChaCha8Rng> for chacha::ChaCha8Rng>::from': ['from', 'Real(LocalPath("rand_chacha/src/chacha.rs"))', 'std::convert::From'], 'guts::ChaCha::get_block_pos': ['get_block_pos', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::ChaCha::get_nonce': ['get_nonce', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::ChaCha::get_seed': ['get_seed', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::ChaCha::new': ['new', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::ChaCha::refill4': ['refill4', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::ChaCha::set_block_pos': ['set_block_pos', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::ChaCha::set_nonce': ['set_nonce', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::add_pos': ['add_pos', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::d0123': ['d0123', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::diagonalize': ['diagonalize', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::get_seed': ['get_seed', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::get_seed::fn_impl': ['fn_impl', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::get_seed::impl_avx': ['impl_avx', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::get_seed::impl_sse2': ['impl_sse2', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::get_stream_param': ['get_stream_param', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::get_stream_param::fn_impl': ['fn_impl', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::get_stream_param::impl_avx': ['impl_avx', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::get_stream_param::impl_sse2': ['impl_sse2', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::init_chacha': ['init_chacha', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::init_chacha::fn_impl': ['fn_impl', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::init_chacha::impl_avx': ['impl_avx', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::init_chacha::impl_sse2': ['impl_sse2', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::init_chacha_x': ['init_chacha_x', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::init_chacha_x::fn_impl': ['fn_impl', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::init_chacha_x::impl_avx': ['impl_avx', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::init_chacha_x::impl_sse2': ['impl_sse2', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::read_u32le': ['read_u32le', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::refill_narrow_rounds': ['refill_narrow_rounds', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_narrow_rounds::fn_impl': ['fn_impl', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_narrow_rounds::impl_avx': ['impl_avx', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_narrow_rounds::impl_avx2': ['impl_avx2', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_narrow_rounds::impl_sse2': ['impl_sse2', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_narrow_rounds::impl_sse41': ['impl_sse41', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_narrow_rounds::impl_ssse3': ['impl_ssse3', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_wide': ['refill_wide', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_wide::fn_impl': ['fn_impl', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_wide::impl_avx': ['impl_avx', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_wide::impl_avx2': ['impl_avx2', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_wide::impl_sse2': ['impl_sse2', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_wide::impl_sse41': ['impl_sse41', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_wide::impl_ssse3': ['impl_ssse3', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::refill_wide_impl': ['refill_wide_impl', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::round': ['round', 'Real(LocalPath("rand_chacha/src/guts.rs"))', ''], 'guts::set_stream_param': ['set_stream_param', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::set_stream_param::fn_impl': ['fn_impl', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::set_stream_param::impl_avx': ['impl_avx', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::set_stream_param::impl_sse2': ['impl_sse2', 'Real(LocalPath("/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs"))', ''], 'guts::undiagonalize': ['undiagonalize', 'Real(LocalPath("rand_chacha/src/guts.rs"))', '']}, 'trait_to_struct': {'rand_core::CryptoRng': ['chacha::ChaCha12Rng', 'chacha::ChaCha20Rng', 'chacha::ChaCha8Rng'], 'rand_core::RngCore': ['chacha::ChaCha12Rng', 'chacha::ChaCha20Rng', 'chacha::ChaCha8Rng'], 'rand_core::SeedableRng': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'chacha::ChaCha20Core', 'chacha::ChaCha20Rng', 'chacha::ChaCha8Core', 'chacha::ChaCha8Rng'], 'rand_core::block::BlockRngCore': ['chacha::ChaCha12Core', 'chacha::ChaCha20Core', 'chacha::ChaCha8Core'], 'rand_core::block::CryptoBlockRng': ['chacha::ChaCha12Core', 'chacha::ChaCha20Core', 'chacha::ChaCha8Core'], 'std::clone::Clone': ['chacha::Array64', 'chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'chacha::ChaCha20Core', 'chacha::ChaCha20Rng', 'chacha::ChaCha8Core', 'chacha::ChaCha8Rng', 'guts::ChaCha', 'guts::State'], 'std::cmp::Eq': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'chacha::ChaCha20Core', 'chacha::ChaCha20Rng', 'chacha::ChaCha8Core', 'chacha::ChaCha8Rng', 'chacha::abstract12::ChaCha12Rng', 'chacha::abstract20::ChaCha20Rng', 'chacha::abstract8::ChaCha8Rng', 'guts::ChaCha'], 'std::cmp::PartialEq': ['chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'chacha::ChaCha20Core', 'chacha::ChaCha20Rng', 'chacha::ChaCha8Core', 'chacha::ChaCha8Rng', 'chacha::abstract12::ChaCha12Rng', 'chacha::abstract20::ChaCha20Rng', 'chacha::abstract8::ChaCha8Rng', 'guts::ChaCha'], 'std::convert::AsMut': ['chacha::Array64'], 'std::convert::AsRef': ['chacha::Array64'], 'std::convert::From': ['chacha::ChaCha12Rng', 'chacha::ChaCha20Rng', 'chacha::ChaCha8Rng', 'chacha::abstract12::ChaCha12Rng', 'chacha::abstract20::ChaCha20Rng', 'chacha::abstract8::ChaCha8Rng'], 'std::default::Default': ['chacha::Array64'], 'std::fmt::Debug': ['chacha::Array64', 'chacha::ChaCha12Core', 'chacha::ChaCha12Rng', 'chacha::ChaCha20Core', 'chacha::ChaCha20Rng', 'chacha::ChaCha8Core', 'chacha::ChaCha8Rng', 'chacha::abstract12::ChaCha12Rng', 'chacha::abstract20::ChaCha20Rng', 'chacha::abstract8::ChaCha8Rng'], 'std::marker::StructuralPartialEq': ['chacha::ChaCha12Core', 'chacha::ChaCha20Core', 'chacha::ChaCha8Core', 'chacha::abstract12::ChaCha12Rng', 'chacha::abstract20::ChaCha20Rng', 'chacha::abstract8::ChaCha8Rng', 'guts::ChaCha']}, 'type_to_def_path': {'chacha::Array64<T>': 'chacha::Array64', 'chacha::ChaCha12Core': 'chacha::ChaCha12Core', 'chacha::ChaCha12Rng': 'chacha::ChaCha12Rng', 'chacha::ChaCha20Core': 'chacha::ChaCha20Core', 'chacha::ChaCha20Rng': 'chacha::ChaCha20Rng', 'chacha::ChaCha8Core': 'chacha::ChaCha8Core', 'chacha::ChaCha8Rng': 'chacha::ChaCha8Rng', 'chacha::abstract12::ChaCha12Rng': 'chacha::abstract12::ChaCha12Rng', 'chacha::abstract20::ChaCha20Rng': 'chacha::abstract20::ChaCha20Rng', 'chacha::abstract8::ChaCha8Rng': 'chacha::abstract8::ChaCha8Rng', 'guts::ChaCha': 'guts::ChaCha', 'guts::State<V>': 'guts::State'}}, 'rand', 'rand_chacha') finished, time: 429.4618959099753s
